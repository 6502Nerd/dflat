AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank0.s --------------------------------

-------------------------------- Symbol Table --------------------------------

              Symbol   Value        Decimal

                 ACR : $000b             11   *
              AM_ABS : $0001              1   *
           AM_ABSIND : $000a             10   *
          AM_ABSINDX : $000b             11   *
             AM_ABSX : $0002              2   *
             AM_ABSY : $0003              3   *
              AM_ACC : $000d             13   *
              AM_DIR : $0010             16   *
              AM_IMM : $000c             12   *
              AM_IMP : $000d             13   *
             AM_NONE : $0000              0   *
              AM_REL : $000f             15   *
               AM_ZP : $0004              4   *
            AM_ZPIND : $0007              7   *
           AM_ZPINDX : $0008              8   *
           AM_ZPINDY : $0009              9   *
              AM_ZPX : $0005              5   *
              AM_ZPY : $0006              6   *
            asm_init : $ffcd          65485
               BANK0 : $0001              1
             bcd_str : $c3a5          50085
          bcd_to_str : $c398          50072
      bin_to_bcd_bit : $c37a          50042
              buf_ef : $003a             58
              buf_hi : $0038             56
              buf_lo : $0037             55
              buf_sz : $0039             57
     CMD_ERR_NOERROR : $0000              0   *
    CMD_ERR_NOTFOUND : $0001              1   *
        CMD_ERR_PARM : $0002              2   *
         CMD_ERR_VAL : $0003              3   *
           CRSR_DOWN : $000a             10   *
           CRSR_LEFT : $0008              8   *
          CRSR_RIGHT : $0009              9   *
             CRSR_UP : $000b             11   *
           CTRL_CAPS : $0014             20   *
        call_irq_brk : $c0da          49370
     call_irq_master : $c0d7          49367
   call_irq_usercia0 : $c0dd          49373
       cmd_check_cmd : $d2aa          53930
         cmd_check_d : $d2bd          53949
         cmd_check_s : $d2c4          53956
         cmd_dumpmem : $d2f7          54007
    cmd_dumpmemASCII : $d31d          54045
      cmd_dumpmemFin : $d352          54098
   cmd_dumpmem_ascii : $d32f          54063
   cmd_dumpmem_block : $d2fd          54013
    cmd_dumpmem_byte : $d30e          54030
  cmd_dump_skip_ctrl : $d339          54073
   cmd_dump_skip_del : $d33e          54078
           cmd_error : $d2b2          53938
       cmd_find_parm : $d3a1          54177
              cmd_hi : $0093            147   *
          cmd_incmem : $d359          54105
              cmd_lo : $0092            146   *
   cmd_next_parm_err : $d3ad          54189
       cmd_not_found : $d2cb          53963
           cmd_parse : $d2bc          53948
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank0.s --------------------------------

      cmd_parse_byte : $d372          54130
  cmd_parse_byte_err : $d38c          54156
 cmd_parse_byte_errp : $d38b          54155
 cmd_parse_next_parm : $d3a0          54176
      cmd_parse_word : $d38e          54158
            cmd_peek : $d360          54112
            cmd_poke : $d369          54121
           cmd_ready : $d296          53910
          cmd_setmem : $d2d1          53969
     cmd_setmem_byte : $d2d6          53974
      cmd_setmem_err : $d2f5          54005
        cmd_word_err : $d39e          54174
        command_line : $d292          53906
       con_bin_digit : $c254          49748
        con_bin_done : $c26a          49770
         con_bin_err : $c274          49780
         con_bin_jmp : $c1f1          49649
        con_bin_to_a : $c24c          49740
    con_bin_to_a_int : $c250          49744
         con_dec_jmp : $c1e5          49637
        con_dec_to_a : $c276          49782
    con_dec_to_a_int : $c27a          49786
       con_hex_digit : $c215          49685
        con_hex_done : $c242          49730
         con_hex_err : $c240          49728
         con_hex_jmp : $c1eb          49643
  con_hex_skip_x_f_1 : $c222          49698
        con_hex_to_a : $c20d          49677
    con_hex_to_a_int : $c211          49681
           con_n_err : $c1f4          49652
       con_n_not_dec : $c1e8          49640
       con_n_not_hex : $c1ee          49646
          con_n_to_a : $c1d4          49620
   con_n_to_a_detect : $c1f6          49654
                DDRA : $0003              3   *
                DDRB : $0002              2   *
         DFERR_ABORT : $0012             18   *
         DFERR_BREAK : $000d             13   *
           DFERR_DIM : $0003              3   *
         DFERR_FNAME : $000b             11   *
     DFERR_IMMEDIATE : $0007              7   *
       DFERR_NEXTFOR : $000a             10   *
        DFERR_NODATA : $000e             14   *
          DFERR_NOIF : $0009              9   *
        DFERR_NOLINE : $0010             16   *
         DFERR_NOORG : $0014             20   *
        DFERR_NOPROC : $0005              5   *
            DFERR_OK : $0000              0   *
      DFERR_PROCPARM : $0006              6   *
      DFERR_QUANTITY : $0013             19   *
        DFERR_RETURN : $0011             17   *
       DFERR_STRLONG : $000c             12   *
        DFERR_SYNTAX : $0001              1   *
      DFERR_TYPEMISM : $0002              2   *
    DFERR_UNCLOSEDIF : $0008              8   *
         DFERR_UNTIL : $0004              4   *
          DFERR_WEND : $000f             15   *
          DFRT_ABORT : $0089            137   *
            DFRT_ASM : $0097            151   *
           DFRT_DATA : $0096            150   *
            DFRT_DEF : $0086            134   *
           DFRT_ELSE : $0093            147   *
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank0.s --------------------------------

         DFRT_ELSEIF : $0095            149   *
         DFRT_ENDDEF : $0087            135   *
          DFRT_ENDIF : $0094            148   *
            DFRT_FOR : $008e            142   *
             DFRT_IF : $0092            146   *
           DFRT_NEXT : $008f            143   *
         DFRT_REPEAT : $008c            140   *
         DFRT_RETURN : $0088            136   *
           DFRT_WEND : $0091            145   *
          DFRT_WHILE : $0090            144   *
            DFST_INT : $0001              1   *
            DFST_STR : $0080            128   *
            DFTK_BYT : $0020             32   *
         DFTK_BYTBIN : $0007              7   *
         DFTK_BYTDEC : $0005              5   *
         DFTK_BYTHEX : $0006              6   *
            DFTK_CHR : $0000              0   *
            DFTK_EOL : $0000              0   *
         DFTK_ESCVAL : $0020             32   *
            DFTK_FLT : $0080            128   *
             DFTK_FN : $0002              2   *
            DFTK_INT : $0010             16   *
         DFTK_INTBIN : $000b             11   *
         DFTK_INTDEC : $0009              9   *
         DFTK_INTHEX : $000a             10   *
             DFTK_KW : $0001              1   *
         DFTK_LINLEN : $0000              0   *
         DFTK_LINNUM : $0001              1   *
             DFTK_OP : $0008              8   *
          DFTK_OPMSK : $0007              7   *
           DFTK_PROC : $0012             18   *
          DFTK_RESVC : $000c             12   *
          DFTK_RESVD : $000d             13   *
          DFTK_RESVE : $000e             14   *
          DFTK_RESVF : $000f             15   *
          DFTK_RESV1 : $0001              1   *
          DFTK_RESV2 : $0002              2   *
          DFTK_RESV3 : $0003              3   *
          DFTK_RESV4 : $0004              4   *
          DFTK_RESV8 : $0008              8   *
          DFTK_RTMSK : $00f8            248   *
          DFTK_STEND : $001f             31   *
            DFTK_STR : $0040             64   *
         DFTK_STRLIT : $0010             16   *
          DFTK_STROP : $0004              4   *
          DFTK_TOKEN : $0080            128   *
            DFTK_VAR : $0011             17   *
        DFTK_VARPARM : $0026             38   *
          DFVVT_ARRY : $0080            128   *
           DFVVT_BYT : $0002              2   *
          DFVVT_DIM1 : $0003              3   *
          DFVVT_DIM2 : $0004              4   *
           DFVVT_FLT : $0008              8   *
            DFVVT_HI : $0002              2   *
           DFVVT_INT : $0001              1   *
            DFVVT_LO : $0001              1   *
          DFVVT_PROC : $0040             64   *
           DFVVT_STR : $0004              4   *
            DFVVT_SZ : $0008              8   *
          DFVVT_TYPE : $0000              0   *
           DF_MEMTOP : $9800          38912   *
        DF_PROGSTART : $0713           1811   *
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank0.s --------------------------------

          dflat_zp_e : $00a9            169
          dflat_zp_s : $0059             89
     dflat_zp_save_e : $009f            159
     dflat_zp_save_s : $0059             89
          df_asmadmd : $009a            154
           df_asmlen : $009e            158
         df_asmopcde : $009b            155
         df_asmoprnd : $009c            156
           df_asmopt : $0099            153
            df_asmpc : $0097            151
  df_asm_altaddrmode : $fd7c          64892
       df_asm_length : $fd6b          64875
    df_asm_tokensyms : $fd8d          64909
            df_brkpc : $0060             96
           df_brkval : $0062             98
         df_checkkey : $0059             89
         df_checkmsk : $005a             90
            df_clear : $f777          63351
          df_currdat : $0092            146
          df_currlin : $0084            132
         df_curstidx : $007e            126
           df_datoff : $0094            148
           df_eolidx : $007c            124
           df_exeoff : $0086            134
           df_ifnest : $0091            145
            df_immed : $005c             92
             df_init : $f769          63337
          df_initrun : $dff9          57337
       df_lexer_line : $d96c          55660
  df_lexer_skip_lnum : $d98d          55693
          df_linbuff : $0400           1024
          df_lineidx : $0090            144
          df_lineptr : $008e            142
           df_linoff : $007a            122
           df_memtop : $0611           1553
          df_msg_acc : $f94b          63819
           df_msg_pc : $f947          63815
         df_msg_xreg : $f94e          63822
         df_msg_yreg : $f951          63825
          df_nextlin : $0087            135
        df_next_done : $e9e6          59878
         df_nxtstidx : $007d            125
     df_ost_peekType : $f73c          63292
       df_ost_popInt : $f742          63298
     df_ost_popParmX : $f721          63265
       df_ost_popPtr : $f74c          63308
       df_ost_popStr : $f747          63303
      df_ost_pushInt : $f70a          63242
     df_ost_pushIntA : $f70f          63247
    df_ost_pushParmX : $f6f4          63220
      df_ost_pushPtr : $f71c          63260
      df_ost_pushStr : $f717          63255
          df_parmtop : $0075            117
               df_pc : $005e             94
    df_pg_check_line : $de8e          56974
df_pg_check_next_line : $de77          56951
df_pg_copyinputtolinbuff : $df44          57156
  df_pg_delete_block : $df04          57092
   df_pg_delete_byte : $df08          57096
df_pg_delete_next_byte : $df2b          57131
         df_pg_dflat : $df4e          57166
          df_pg_done : $df8d          57229
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank0.s --------------------------------

     df_pg_find_line : $de6b          56939
    df_pg_getcommand : $df64          57188
     df_pg_inputline : $df3b          57147
  df_pg_inputline_ok : $df44          57156
 df_pg_insertlinbyte : $dfe9          57321
    df_pg_insertline : $dfca          57290
  df_pg_insert_block : $dec8          57032
   df_pg_insert_byte : $ded4          57044
df_pg_insert_next_byte : $def4          57076
   df_pg_line_number : $dfaa          57258
       df_pg_nothing : $dfa9          57257
        df_pg_prompt : $df59          57177
    df_pg_prompt_msg : $dff2          57330
 df_pg_skip_del_line : $dfc0          57280
      df_pg_tokenise : $df8f          57231
           df_prgend : $0065            101
          df_prgstrt : $0063             99
         df_procargs : $008a            138
          df_procloc : $008b            139
         df_procmode : $0089            137
          df_procptr : $008c            140
df_pr_line_gt_target : $de83          56963
     df_pr_line_next : $deb6          57014
  df_pr_line_nomatch : $dea8          57000
              df_raw : $0400           1024
              df_rnd : $0095            149
     df_rst_peekByte : $f6d2          63186
      df_rst_popByte : $f6c9          63177
      df_rst_popWord : $f6e6          63206
     df_rst_pushByte : $f6c0          63168
     df_rst_pushWord : $f6d8          63192
          df_rtspace : $0500           1280
           df_rtstck : $0500           1280
           df_rtstop : $0074            116
         df_rt_abort : $f516          62742
           df_rt_add : $e64d          58957
         df_rt_aequb : $e729          59177
      df_rt_aequbFin : $e733          59187
           df_rt_and : $e6fc          59132
  df_rt_array_exists : $e2f0          58096
     df_rt_arry_parm : $e1f4          57844
    df_rt_arry_parm2 : $e1fb          57851
df_rt_arry_parm2_arry2 : $e213          57875
df_rt_arry_parm2_skiparry2 : $e21a          57882
df_rt_arry_parm2_term : $e203          57859
           df_rt_asc : $f4eb          62699
           df_rt_asl : $e6d6          59094
        df_rt_aslbit : $e6dc          59100
       df_rt_asldone : $e6e6          59110
    df_rt_asm_ABSREL : $fcbc          64700
    df_rt_asm_AM_ABS : $fcd3          64723
   df_rt_asm_AM_ABSX : $fce0          64736
   df_rt_asm_AM_ABSY : $fcce          64718
    df_rt_asm_AM_IMM : $fce5          64741
    df_rt_asm_AM_IMP : $fcb7          64695
df_rt_asm_AM_INDIRECT : $fcef          64751
    df_rt_asm_AM_REL : $fcdd          64733
  df_rt_asm_AM_ZPIND : $fd15          64789
df_rt_asm_AM_ZPINDORY : $fd05          64773
  df_rt_asm_addrmode : $fc9b          64667
  df_rt_asm_assemble : $fa50          64080
df_rt_asm_assemble_done : $fa64          64100
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank0.s --------------------------------

 df_rt_asm_check_alt : $fb64          64356
   df_rt_asm_command : $fa65          64101
      df_rt_asm_data : $fac7          64199
 df_rt_asm_data_done : $fb05          64261
 df_rt_asm_data_next : $fafb          64251
df_rt_asm_data_write : $fb06          64262
df_rt_asm_data_write_err : $fb35          64309
df_rt_asm_data_write_hi : $fb20          64288
df_rt_asm_data_write_skip1 : $fb09          64265
df_rt_asm_data_write_skip2 : $fb24          64292
        df_rt_asm_db : $fab7          64183
  df_rt_asm_db_start : $fac1          64193
df_rt_asm_decode_token : $f079          61561
df_rt_asm_decode_token_done : $f0d5          61653
df_rt_asm_decode_token_found : $f090          61584
df_rt_asm_decode_token_keyword : $f097          61591
df_rt_asm_decode_token_ws : $f080          61568
       df_rt_asm_dir : $fa77          64119
  df_rt_asm_do_label : $fa61          64097
        df_rt_asm_ds : $fb37          64311
        df_rt_asm_dw : $fabd          64189
    df_rt_asm_encode : $fb9d          64413
df_rt_asm_encode_print : $fc07          64519
df_rt_asm_encode_relfar : $fbd5          64469
df_rt_asm_encode_relpos : $fbd1          64465
df_rt_asm_encode_skiprel : $fbd9          64473
df_rt_asm_encode_writebyte : $fbf5          64501
df_rt_asm_encode_writeword : $fbfd          64509
df_rt_asm_find_addr_mode : $fd23          64803
df_rt_asm_find_addr_mode_err : $fd38          64824
df_rt_asm_find_addr_mode_loop : $fd29          64809
df_rt_asm_get_operand : $fd18          64792
     df_rt_asm_label : $fa89          64137
      df_rt_asm_mnem : $fb55          64341
  df_rt_asm_mnem_chk : $fb78          64376
 df_rt_asm_mnem_done : $fb86          64390
  df_rt_asm_mnem_err : $fb9b          64411
  df_rt_asm_mnem_try : $fb5b          64347
       df_rt_asm_opt : $faaf          64175
       df_rt_asm_org : $fa9c          64156
   df_rt_asm_printCH : $fc75          64629
   df_rt_asm_printCR : $fc6b          64619
 df_rt_asm_printline : $fc83          64643
  df_rt_asm_printOPC : $fc3a          64570
  df_rt_asm_printOPR : $fc50          64592
df_rt_asm_printOPR_1 : $fc65          64613
   df_rt_asm_printPC : $fc29          64553
  df_rt_asm_printSPC : $fc46          64582
df_rt_asm_print_mmen : $fc19          64537
 df_rt_asm_print_rts : $fc28          64552
df_rt_asm_skip_to_sym : $fd3b          64827
df_rt_asm_skip_to_sym_done : $fd6a          64874
df_rt_asm_skip_to_sym_end : $fd59          64857
df_rt_asm_skip_to_sym_next : $fd4a          64842
    df_rt_asm_string : $fade          64222
 df_rt_asm_string_ch : $fae5          64229
  df_rt_asm_tokenjmp : $ffc3          65475
        df_rt_assign : $ed5d          60765
    df_rt_assign_str : $ed6a          60778
         df_rt_asubb : $e734          59188
      df_rt_asubbFin : $e741          59201
   df_rt_binlen_skip : $f2eb          62187
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank0.s --------------------------------

         df_rt_bload : $f1e6          61926
    df_rt_bload_addr : $f209          61961
         df_rt_bsave : $f219          61977
   df_rt_bsave_parms : $f2c9          62153
         df_rt_bsuba : $e742          59202
      df_rt_bsubaFin : $e74f          59215
          df_rt_call : $f3f0          62448
       df_rt_calljsr : $f401          62465
     df_rt_check_pos : $e9d9          59865
   df_rt_check_while : $e87c          59516
           df_rt_chr : $f444          62532
        df_rt_circle : $ec91          60561
           df_rt_cls : $ebe1          60385
         df_rt_comeq : $e7aa          59306
         df_rt_comgt : $e7a1          59297
        df_rt_comgte : $e7bc          59324
         df_rt_comlt : $e798          59288
        df_rt_comlte : $e7b3          59315
       df_rt_comment : $ed6e          60782
         df_rt_comne : $e7c5          59333
       df_rt_copyStr : $e1af          57775
    df_rt_copyStr_ch : $e1b1          57777
  df_rt_copyStr_done : $e1ba          57786
       df_rt_copy_fn : $f17b          61819
        df_rt_cursor : $ec58          60504
          df_rt_data : $ed6e          60782
 df_rt_datastatement : $ea47          59975
   df_rt_datlinstart : $ea3f          59967
    df_rt_datnextlin : $ea4d          59981
      df_rt_datumerr : $ea77          60023
    df_rt_dec_binlen : $f2e5          62181
          df_rt_deek : $f307          62215
           df_rt_def : $f5f7          62967
  df_rt_def_find_var : $f603          62979
   df_rt_def_got_var : $f617          62999
df_rt_def_got_varparm : $f614          62996
df_rt_def_initialise_parm : $f656          63062
  df_rt_def_load_var : $f635          63029
df_rt_def_load_var_done : $f672          63090
df_rt_def_load_var_int : $f664          63076
df_rt_def_load_var_int_skip : $f667          63079
 df_rt_def_parm_done : $f62d          63021
           df_rt_dim : $eb58          60248
     df_rt_dim2_mul2 : $ebbf          60351
       df_rt_dim2_nz : $ebaa          60330
     df_rt_dim_alloc : $eb99          60313
      df_rt_dim_done : $ebde          60382
       df_rt_dim_err : $ebdf          60383
   df_rt_dim_findesc : $eb5b          60251
 df_rt_dim_next_byte : $ebd9          60377
           df_rt_div : $e694          59028
      df_rt_doassign : $ed60          60768
          df_rt_doke : $f0d6          61654
       df_rt_dosound : $f11b          61723
       df_rt_do_else : $e94a          59722
       df_rt_elapsed : $f3d5          62421
          df_rt_else : $e8f8          59640
        df_rt_elseif : $e8f8          59640
        df_rt_enddef : $f679          63097
         df_rt_endif : $e8f3          59635
           df_rt_eor : $e71a          59162
           df_rt_eos : $ed70          60784
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank0.s --------------------------------

      df_rt_eos_true : $ed82          60802
            df_rt_eq : $e784          59268
        df_rt_escjmp : $e620          58912
      df_rt_eval_byt : $e30b          58123
   df_rt_eval_bytbin : $e1c8          57800
   df_rt_eval_bytdec : $e1c8          57800
   df_rt_eval_bythex : $e1c8          57800
      df_rt_eval_chr : $e1c8          57800
      df_rt_eval_esc : $e0f4          57588
  df_rt_eval_esc_tab : $e103          57603
   df_rt_eval_intbin : $e1c8          57800
   df_rt_eval_intdec : $e1c8          57800
   df_rt_eval_inthex : $e1c8          57800
     df_rt_eval_lvar : $e258          57944
   df_rt_eval_lvskip : $e232          57906
     df_rt_eval_proc : $e31d          58141
 df_rt_eval_proc_err : $e32a          58154
      df_rt_eval_ptr : $e316          58134
 df_rt_eval_reserved : $e1d4          57812
   df_rt_eval_strlit : $e1d6          57814
df_rt_eval_strlit_ch : $e1ea          57834
df_rt_eval_strlit_done : $e1f1          57841
      df_rt_eval_var : $e21f          57887
df_rt_eval_var_dim2adj : $e2a2          58018
df_rt_eval_var_dim2adjx : $e2ac          58028
df_rt_eval_var_dim2adjy : $e2a7          58023
df_rt_eval_var_do_arry : $e273          57971
df_rt_eval_var_nomult : $e2c5          58053
df_rt_eval_var_notarry : $e248          57928
 df_rt_eval_var_push : $e2df          58079
df_rt_eval_var_simple : $e265          57957
  df_rt_eval_var_str : $e315          58133
   df_rt_exec_ctrl_c : $e464          58468
   df_rt_exec_ctrl_z : $e468          58472
      df_rt_exec_end : $e462          58466
 df_rt_exec_find_tok : $e410          58384
df_rt_exec_found_tok : $e415          58389
 df_rt_exec_init_ptr : $e409          58377
     df_rt_exec_jump : $e46a          58474
   df_rt_exec_no_key : $e43b          58427
     df_rt_exec_proc : $f554          62804
     df_rt_exec_stat : $e403          58371
         df_rt_false : $e756          59222
  df_rt_file_cleanup : $f1a5          61861
     df_rt_file_errc : $f18f          61839
 df_rt_findelseendif : $e8bb          59579
    df_rt_findescval : $e521          58657
df_rt_findescval_loop : $e524          58660
      df_rt_findproc : $e4d9          58585
  df_rt_findproc_cmd : $e4eb          58603
  df_rt_findproc_err : $e51f          58655
df_rt_findproc_nextstat : $e50b          58635
      df_rt_findwend : $e849          59465
    df_rt_fname_case : $f17d          61821
           df_rt_for : $e94e          59726
 df_rt_generate_lvar : $ed3a          60730
           df_rt_get : $f3a1          62369
  df_rt_getbin_parms : $f2a8          62120
df_rt_getbin_parms_loop : $f2aa          62122
     df_rt_getdatatk : $ea5d          59997
       df_rt_getlvar : $e53b          58683
       df_rt_getnval : $e066          57446
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank0.s --------------------------------

      df_rt_get2Ints : $e32c          58156
      df_rt_get2Strs : $e33b          58171
      df_rt_get_push : $f3b4          62388
     df_rt_get_pushp : $f3b3          62387
      df_rt_get_sync : $f3a8          62376
            df_rt_gt : $e770          59248
           df_rt_gte : $e77a          59258
      df_rt_gte_calc : $e77d          59261
           df_rt_hex : $f45a          62554
         df_rt_himem : $ec5e          60510
         df_rt_hires : $ec6e          60526
            df_rt_if : $e90a          59658
         df_rt_ifcmd : $e8be          59582
        df_rt_ifelse : $e8dc          59612
        df_rt_ifeval : $e90c          59660
  df_rt_ifskipelseif : $e8d3          59603
       df_rt_if_done : $e94d          59725
      df_rt_if_found : $e8e9          59625
      df_rt_if_match : $e8b3          59571
       df_rt_if_stat : $e89d          59549
   df_rt_if_stat_err : $e8b1          59569
     df_rt_init_done : $e065          57445
 df_rt_init_filename : $f16f          61807
 df_rt_init_stat_ptr : $e3ee          58350
      df_rt_init_vvt : $e022          57378
 df_rt_init_vvt_skip : $e056          57430
 df_rt_init_vvt_slot : $e02c          57388
df_rt_init_vvt_slot_undim : $e038          57400
           df_rt_ink : $ec77          60535
         df_rt_input : $eaec          60140
     df_rt_input_err : $eb26          60198
     df_rt_input_num : $eb0f          60175
     df_rt_input_str : $eb07          60167
    df_rt_ldtokenise : $f1ce          61902
          df_rt_left : $f48d          62605
           df_rt_len : $f4dd          62685
          df_rt_line : $eca3          60579
          df_rt_list : $ee6f          61039
  df_rt_listcheckvnt : $edd5          60885
   df_rt_listgotnext : $ee04          60932
   df_rt_listnextvnt : $edfd          60925
   df_rt_listpn_done : $ee16          60950
       df_rt_listprg : $ee96          61078
    df_rt_listprgend : $ee9e          61086
      df_rt_listproc : $ee17          60951
    df_rt_listprocch : $ede1          60897
    df_rt_listproccr : $eded          60909
 df_rt_listprocnames : $edc9          60873
 df_rt_listprocpause : $edf3          60915
    df_rt_listp_copy : $ee1e          60958
    df_rt_listp_done : $ee63          61027
 df_rt_listp_findcmd : $ee49          61001
 df_rt_listp_findend : $ee42          60994
df_rt_listp_notfound : $ee6d          61037
      df_rt_listwait : $edfa          60922
      df_rt_list_all : $ee82          61058
 df_rt_list_all_line : $eee7          61159
   df_rt_list_decode : $eef3          61171
df_rt_list_decode_esc : $ef26          61222
df_rt_list_decode_token : $f03a          61498
df_rt_list_decode_token_normal : $f041          61505
   df_rt_list_donvvt : $f012          61458
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank0.s --------------------------------

df_rt_list_do_decode_tkn : $f048          61512
   df_rt_list_escval : $ef03          61187
  df_rt_list_findvvt : $efd3          61395
df_rt_list_find_asm_sym : $f0a2          61602
 df_rt_list_find_sym : $f051          61521
   df_rt_list_gotvvt : $f002          61442
df_rt_list_gotvvtend : $efec          61420
df_rt_list_got_asm_sym : $f0c3          61635
df_rt_list_got_last_sym : $f063          61539
  df_rt_list_got_sym : $f067          61543
     df_rt_list_line : $eea4          61092
df_rt_list_line_cont : $eebe          61118
 df_rt_list_line_fin : $eee4          61156
df_rt_list_line_only : $eeea          61162
df_rt_list_line_only_fin : $ef25          61221
    df_rt_list_linno : $ee89          61065
   df_rt_list_linnum : $f02d          61485
  df_rt_list_nexttok : $ef0c          61196
df_rt_list_next_asm_ch : $f0a8          61608
  df_rt_list_next_ch : $f057          61527
df_rt_list_next_line : $eec5          61125
    df_rt_list_pause : $eeb3          61107
  df_rt_list_synckey : $eeaf          61103
    df_rt_list_token : $ef09          61193
   df_rt_list_vvtend : $efdf          61407
          df_rt_load : $f28c          62092
       df_rt_loadbin : $f2b5          62133
  df_rt_loadbin_byte : $f2b7          62135
   df_rt_loadbin_inc : $f2c1          62145
      df_rt_loadline : $f1b4          61876
         df_rt_local : $eb28          60200
    df_rt_local_done : $eb54          60244
 df_rt_local_findesc : $eb2f          60207
           df_rt_lsr : $e6e9          59113
        df_rt_lsrbit : $e6ef          59119
       df_rt_lsrdone : $e6f9          59129
       df_rt_lst_bin : $ef95          61333
       df_rt_lst_bit : $ef9f          61343
 df_rt_lst_bit_skip0 : $efa9          61353
    df_rt_lst_bytbin : $ef87          61319
    df_rt_lst_bythex : $ef62          61282
       df_rt_lst_chr : $ef45          61253
   df_rt_lst_hex_pre : $ef58          61272
    df_rt_lst_intbin : $ef90          61328
    df_rt_lst_intdec : $efb3          61363
    df_rt_lst_inthex : $ef75          61301
    df_rt_lst_lo_hex : $ef65          61285
      df_rt_lst_proc : $efbe          61374
  df_rt_lst_reserved : $ef44          61252
    df_rt_lst_strlit : $f013          61459
  df_rt_lst_strlitch : $f01a          61466
 df_rt_lst_strlitdon : $f025          61477
       df_rt_lst_var : $efbe          61374
            df_rt_lt : $e75c          59228
           df_rt_lte : $e766          59238
      df_rt_lte_calc : $e769          59241
           df_rt_mem : $f349          62281
      df_rt_mem_calc : $f38c          62348
      df_rt_mem_free : $f356          62294
       df_rt_mem_prg : $f369          62313
       df_rt_mem_var : $f37c          62332
           df_rt_mid : $f4bd          62653
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank0.s --------------------------------

           df_rt_mod : $e6b5          59061
       df_rt_monitor : $e81d          59421
          df_rt_mult : $e673          58995
         df_rt_music : $f12b          61739
       df_rt_nassign : $ed1d          60701
            df_rt_ne : $e78e          59278
         df_rt_neval : $e06c          57452
    df_rt_neval_done : $e0ba          57530
   df_rt_neval_donow : $e0d2          57554
     df_rt_neval_esc : $e099          57497
df_rt_neval_nextbyte : $e0ef          57583
    df_rt_neval_optk : $e06f          57455
 df_rt_neval_process : $e0b1          57521
  df_rt_neval_pushOp : $e0e4          57572
      df_rt_neval_tk : $e09f          57503
   df_rt_neval_tk_fn : $e0ea          57578
   df_rt_neval_tk_op : $e0bc          57532
  df_rt_neval_tk_opp : $e0bb          57531
           df_rt_new : $e821          59425
          df_rt_next : $e98c          59788
     df_rt_nextdatum : $ea2f          59951
      df_rt_nextstat : $e482          58498
   df_rt_nextstat_dn : $e4ac          58540
  df_rt_nextstat_err : $e4a8          58536
   df_rt_nextstat_ln : $e497          58519
    df_rt_next_check : $e9dc          59868
      df_rt_next_err : $e9e9          59881
      df_rt_noif_err : $e908          59656
df_rt_openforbinload : $f1dd          61917
df_rt_openforbinsave : $f1d4          61908
            df_rt_or : $e70b          59147
         df_rt_paper : $ec7d          60541
    df_rt_parm_2ints : $e34a          58186
    df_rt_parm_3ints : $e361          58209
    df_rt_parm_4ints : $e384          58244
    df_rt_parm_5ints : $e3b3          58291
    df_rt_parse_file : $f186          61830
          df_rt_peek : $f30a          62218
         df_rt_pixel : $f3c6          62406
       df_rt_pixmode : $ec71          60529
          df_rt_play : $f140          61760
          df_rt_plot : $ebe4          60388
       df_rt_plotstr : $ec17          60439
     df_rt_plotstrch : $ec28          60456
   df_rt_plotstrdone : $ec57          60503
    df_rt_plot_h_int : $ec0e          60430
    df_rt_plot_h_str : $ec45          60485
         df_rt_point : $ec87          60551
          df_rt_poke : $f0e5          61669
      df_rt_pop_stat : $e4c0          58560
   df_rt_pop_stat_go : $e557          58711
         df_rt_print : $ecdc          60636
       df_rt_printat : $ecd2          60626
       df_rt_println : $ed15          60693
    df_rt_print_done : $ed12          60690
  df_rt_print_gotstr : $ed06          60678
     df_rt_print_num : $ea13          59923
     df_rt_print_str : $ea1a          59930
  df_rt_print_string : $ed0c          60684
  df_rt_print_str_ch : $ea23          59939
df_rt_print_str_done : $ea2e          59950
      df_rt_print_ws : $ecdf          60639
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank0.s --------------------------------

          df_rt_proc : $f59e          62878
     df_rt_proc_addr : $f5c8          62920
    df_rt_proc_local : $f6ac          63148
df_rt_proc_local_load : $f6b3          63155
  df_rt_proc_parmerr : $f5f5          62965
df_rt_proc_parm_done : $f5e5          62949
df_rt_proc_parm_none : $f5e6          62950
df_rt_proc_push_parm : $f5d1          62929
df_rt_proc_unloadvar : $f68b          63115
df_rt_proc_unload_done : $f6ab          63147
  df_rt_proc_unlocal : $f685          63109
     df_rt_push_stat : $e4b4          58548
     df_rt_putintres : $e646          58950
          df_rt_read : $ead0          60112
      df_rt_readbyte : $f30b          62219
 df_rt_readbyte_skip : $f322          62242
     df_rt_readdatum : $ea79          60025
     df_rt_read_done : $eae9          60137
 df_rt_read_find_var : $ead2          60114
         df_rt_renum : $ed84          60804
      df_rt_renum_do : $ed98          60824
    df_rt_renum_next : $edb7          60855
      df_rt_renum_ok : $ed94          60820
  df_rt_renum_update : $ed9f          60831
        df_rt_repeat : $e9eb          59883
         df_rt_reset : $f2f2          62194
        df_rt_return : $f67e          63102
         df_rt_right : $f4a0          62624
           df_rt_rnd : $f325          62245
     df_rt_rnd_noeor : $f33b          62267
       df_rt_rnd_set : $f342          62274
           df_rt_run : $ed6f          60783
     df_rt_run_token : $e473          58483
          df_rt_sadd : $ea12          59922
       df_rt_sassign : $ed34          60724
          df_rt_save : $f23a          62010
       df_rt_savebin : $f2c7          62151
  df_rt_savebin_byte : $f2d5          62165
   df_rt_savebin_inc : $f2df          62175
          df_rt_scrn : $f3b7          62391
           df_rt_seq : $e7f9          59385
         df_rt_seval : $e129          57641
    df_rt_seval_copy : $e185          57733
    df_rt_seval_done : $e1ab          57771
     df_rt_seval_esc : $e153          57683
df_rt_seval_esc_proc : $e1a4          57764
df_rt_seval_esc_strlit : $e19e          57758
 df_rt_seval_esc_var : $e181          57729
df_rt_seval_nextbyte : $e1a6          57766
    df_rt_seval_optk : $e137          57655
      df_rt_seval_tk : $e161          57697
   df_rt_seval_tk_fn : $e17a          57722
   df_rt_seval_tk_op : $e176          57718
           df_rt_sgt : $e7f0          59376
          df_rt_sgte : $e7db          59355
df_rt_skipinitdataptr : $ea67          60007
 df_rt_skipnestendif : $e8e6          59622
    df_rt_skipnestif : $e8d9          59609
       df_rt_skip_ws : $e52e          58670
  df_rt_skip_ws_loop : $e531          58673
           df_rt_slt : $e7e9          59369
          df_rt_slte : $e7ce          59342
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank0.s --------------------------------

    df_rt_snd_common : $f0ef          61679
           df_rt_sne : $e7e2          59362
         df_rt_sound : $f118          61720
df_rt_sound_env_skip : $f115          61717
   df_rt_sound_noise : $f122          61730
       df_rt_sprchar : $f518          62744
        df_rt_sprhit : $f540          62784
df_rt_sprhit_inactive : $f54e          62798
       df_rt_sprinit : $f537          62775
      df_rt_sprmulti : $f53a          62778
        df_rt_sprpos : $f522          62754
        df_rt_sprupd : $f52e          62766
         df_rt_stick : $f399          62361
 df_rt_strlen_common : $f404          62468
  df_rt_strlen_count : $f40a          62474
      df_rt_str_comp : $e800          59392
 df_rt_str_comp_byte : $e805          59397
   df_rt_str_comp_eq : $e81a          59418
df_rt_str_comp_false : $e7d5          59349
   df_rt_str_comp_gt : $e817          59415
   df_rt_str_comp_lt : $e814          59412
 df_rt_str_comp_true : $e7d8          59352
    df_rt_str_cpy_ch : $f424          62500
   df_rt_str_extract : $f411          62481
           df_rt_sub : $e660          58976
          df_rt_sval : $e12d          57645
          df_rt_text : $ec6b          60523
         df_rt_tload : $f1ac          61868
      df_rt_tokenjmp : $e560          58720
          df_rt_true : $e750          59216
         df_rt_tsave : $f191          61841
df_rt_unexpected_end : $e466          58470
         df_rt_until : $e9f3          59891
df_rt_untilnext_done : $ea08          59912
     df_rt_until_err : $ea10          59920
           df_rt_val : $f4fe          62718
       df_rt_val_err : $f514          62740
          df_rt_wait : $ecb9          60601
  df_rt_wait_counter : $ecbd          60605
   df_rt_wait_skiphi : $ecc9          60617
     df_rt_wait_tick : $ecbf          60607
          df_rt_wend : $e887          59527
      df_rt_wend_end : $e885          59525
      df_rt_wend_err : $e89b          59547
         df_rt_while : $e824          59428
     df_rt_while_cmd : $e85a          59482
    df_rt_while_done : $e834          59444
         df_sevalptr : $0078            120
    df_show_err_done : $f8f7          63735
     df_show_err_fin : $f8d6          63702
    df_show_err_find : $f881          63617
   df_show_err_found : $f89d          63645
  df_show_err_linnum : $f8bd          63677
    df_show_err_skip : $f889          63625
               df_sp : $005d             93
          df_starend : $0072            114
         df_starstrt : $0070            112
          df_strbuff : $0076            118
           df_stridx : $0077            119
      df_str_src_end : $f439          62521
        df_st_malloc : $f751          63313
df_st_typemismatcherr : $f73a          63290
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank0.s --------------------------------

           df_symini : $0082            130
           df_symoff : $0081            129
           df_symtab : $007f            127
         df_tk_abort : $de47          56903
           df_tk_add : $de47          56903
           df_tk_and : $de47          56903
           df_tk_asc : $de19          56857
           df_tk_asl : $de47          56903
 df_tk_asm_addr_mode : $f9e9          63977
df_tk_asm_addr_mode_ok : $fa1e          64030
df_tk_asm_addr_mode_1 : $f9fe          63998
df_tk_asm_addr_mode_2 : $fa08          64008
df_tk_asm_checknexttok : $f991          63889
df_tk_asm_checktokch : $f993          63891
        df_tk_asm_db : $ddb6          56758
        df_tk_asm_ds : $de49          56905
        df_tk_asm_dw : $ddb6          56758
df_tk_asm_exec_parser : $f9da          63962
df_tk_asm_foundsymend : $f9b9          63929
  df_tk_asm_matchtok : $f983          63875
  df_tk_asm_mnemonic : $f977          63863
       df_tk_asm_opt : $de49          56905
       df_tk_asm_org : $de49          56905
df_tk_asm_parse_command : $f954          63828
df_tk_asm_parse_command_err : $f976          63862
df_tk_asm_parse_command_symbol : $f97d          63869
  df_tk_asm_symfound : $f9cc          63948
df_tk_asm_symnextentry : $f9aa          63914
df_tk_asm_symnomatch : $f9a8          63912
  df_tk_asm_tokenjmp : $ffb9          65465
        df_tk_assign : $dd4e          56654
         df_tk_bload : $de4d          56909
          df_tk_body : $d995          55701
         df_tk_bsave : $de56          56918
          df_tk_call : $de39          56889
      df_tk_callproc : $de0e          56846
          df_tk_char : $d783          55171
      df_tk_char_err : $d79f          55199
         df_tk_chdir : $de49          56905
  df_tk_checknexttok : $da13          55827
    df_tk_checktokch : $da30          55856
           df_tk_chr : $de19          56857
        df_tk_circle : $de56          56918
     df_tk_closebrkt : $de1c          56860
           df_tk_cls : $de47          56903
        df_tk_colour : $de56          56918
       df_tk_comment : $dd56          56662
  df_tk_comment_done : $dd61          56673
         df_tk_const : $d7c3          55235
     df_tk_const_err : $d7e3          55267
df_tk_const_try_char : $d7dc          55260
 df_tk_const_try_num : $d7d2          55250
 df_tk_const_try_str : $d7d5          55253
        df_tk_cursor : $de49          56905
          df_tk_data : $ddb6          56758
          df_tk_deek : $de19          56857
           df_tk_def : $ddef          56815
           df_tk_del : $de49          56905
           df_tk_dim : $ddcd          56781
           df_tk_dir : $de47          56903
           df_tk_div : $de47          56903
          df_tk_doke : $de4d          56909
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank0.s --------------------------------

          df_tk_done : $d9bc          55740
       df_tk_elapsed : $de22          56866
          df_tk_else : $de47          56903
        df_tk_elseif : $de49          56905
        df_tk_enddef : $de47          56903
         df_tk_endif : $de47          56903
           df_tk_eor : $de47          56903
           df_tk_eos : $d940          55616
            df_tk_eq : $de47          56903
         df_tk_error : $dd4c          56652
      df_tk_errortab : $f7ae          63406
   df_tk_error_atpos : $f855          63573
   df_tk_error_error : $f85b          63579
  df_tk_error_inline : $f84b          63563
   df_tk_exec_parser : $d9d7          55767
        df_tk_expect : $d718          55064
     df_tk_expecterr : $d726          55078
  df_tk_expecttokret : $d734          55092
    df_tk_expect_tok : $d728          55080
df_tk_expect_tok_err : $d735          55093
df_tk_expect_tok_fatal : $d73b          55099
    df_tk_expression : $d927          55591
           df_tk_for : $ddf5          56821
      df_tk_for_done : $de0c          56844
   df_tk_foundsymend : $da5f          55903
           df_tk_get : $de19          56857
       df_tk_get_buf : $d694          54932
  df_tk_get_buf_null : $d69e          54942
            df_tk_gt : $de47          56903
           df_tk_gte : $de47          56903
         df_tk_hchar : $de56          56918
           df_tk_hex : $de19          56857
         df_tk_himem : $de49          56905
         df_tk_hires : $de47          56903
            df_tk_if : $de49          56905
           df_tk_imm : $fa20          64032
      df_tk_indirect : $fa25          64037
 df_tk_indirect_done : $fa4e          64078
    df_tk_indirect_y : $fa3b          64059
           df_tk_ink : $de49          56905
         df_tk_input : $ddc4          56772
       df_tk_isalpha : $d6d2          54994
    df_tk_isalphanum : $d6e2          55010
 df_tk_isalpha_false : $d6df          55007
         df_tk_isbin : $d6b3          54963
    df_tk_isbin_true : $d6bc          54972
       df_tk_isdigit : $d6a8          54952
 df_tk_isdigit_false : $d6b1          54961
         df_tk_isEOS : $d937          55607
         df_tk_ishex : $d6bd          54973
   df_tk_ishex_false : $d6cf          54991
   df_tk_ishex_truep : $d6cd          54989
        df_tk_isproc : $d6ec          55020
   df_tk_isproc_true : $d6f2          55026
          df_tk_isws : $d711          55057
    df_tk_isws_false : $d716          55062
          df_tk_left : $de2d          56877
           df_tk_len : $de19          56857
          df_tk_line : $de5f          56927
       df_tk_linenum : $d9e6          55782
    df_tk_line_empty : $d9d3          55763
          df_tk_list : $dd87          56711
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank0.s --------------------------------

df_tk_listp_procname : $dd63          56675
df_tk_listp_procname_ch : $dd72          56690
df_tk_listp_procname_err : $dd85          56709
df_tk_listp_procname_ok : $dd83          56707
     df_tk_list_done : $dda8          56744
     df_tk_list_line : $dd9b          56731
    df_tk_list_procs : $dd94          56724
          df_tk_load : $de49          56905
         df_tk_local : $ddde          56798
      df_tk_localvar : $d819          55321
 df_tk_localvar_cont : $d81f          55327
           df_tk_lsr : $de47          56903
            df_tk_lt : $de47          56903
           df_tk_lte : $de47          56903
      df_tk_matchtok : $da06          55814
df_tk_matchtok_skip_op : $da2c          55852
           df_tk_mem : $de19          56857
           df_tk_mid : $de33          56883
           df_tk_mod : $de47          56903
       df_tk_monitor : $de47          56903
          df_tk_mult : $de47          56903
         df_tk_music : $de5f          56927
         df_tk_narry : $d8a5          55461
     df_tk_narry_end : $d8b2          55474
         df_tk_nbrkt : $d8b8          55480
            df_tk_ne : $de47          56903
           df_tk_new : $de47          56903
          df_tk_next : $de47          56903
           df_tk_nop : $d910          55568
     df_tk_nop_false : $d925          55589
         df_tk_nterm : $d8c7          55495
    df_tk_nterm_cont : $d8d0          55504
     df_tk_nterm_err : $d90e          55566
    df_tk_nterm_proc : $d8c1          55489
   df_tk_nterm_tryfn : $d8de          55518
df_tk_nterm_try_const : $d908          55560
df_tk_nterm_try_proc : $d8f4          55540
 df_tk_nterm_try_var : $d900          55552
           df_tk_num : $d73d          55101
       df_tk_num_bin : $d76e          55150
       df_tk_num_err : $d781          55169
    df_tk_num_hexbin : $d75e          55134
   df_tk_num_makeint : $d769          55145
       df_tk_num_put : $d772          55154
            df_tk_or : $de47          56903
         df_tk_paper : $de49          56905
          df_tk_parm : $d807          55303
 df_tk_parm_skip_var : $d814          55316
    df_tk_parseerror : $d9d5          55765
 df_tk_parse_ass_err : $dd4c          56652
 df_tk_parse_command : $d954          55636
df_tk_parse_command_done : $d96a          55658
df_tk_parse_command_err : $d96b          55659
df_tk_parse_user_proc : $d949          55625
          df_tk_peek : $de19          56857
      df_tk_peek_buf : $d68e          54926
         df_tk_pixel : $de2d          56877
       df_tk_pixmode : $de49          56905
          df_tk_play : $de5f          56927
          df_tk_plot : $de56          56918
         df_tk_point : $de4d          56909
          df_tk_poke : $de4d          56909
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank0.s --------------------------------

     df_tk_preassign : $dd33          56627
         df_tk_print : $ddb6          56758
       df_tk_printat : $ddaa          56746
       df_tk_println : $ddb6          56758
    df_tk_print_done : $ddc2          56770
          df_tk_proc : $d831          55345
     df_tk_proc_call : $d86d          55405
    df_tk_proc_comma : $d887          55431
      df_tk_proc_err : $d8a3          55459
     df_tk_proc_errp : $d8a2          55458
   df_tk_proc_noparm : $d890          55440
    df_tk_proc_parms : $d860          55392
df_tk_proc_skip_args : $d8a0          55456
df_tk_proc_skip_call : $d876          55414
       df_tk_put_tok : $d69f          54943
          df_tk_read : $ddcd          56781
         df_tk_renum : $de56          56918
        df_tk_repeat : $de47          56903
         df_tk_reset : $de10          56848
        df_tk_return : $de49          56905
         df_tk_right : $de2d          56877
           df_tk_rnd : $de19          56857
           df_tk_run : $de47          56903
          df_tk_save : $de49          56905
          df_tk_scrn : $de2d          56877
        df_tk_setvdp : $de4d          56909
       df_tk_skip_ws : $d6f3          55027
         df_tk_sound : $de56          56918
       df_tk_sprchar : $de4d          56909
        df_tk_sprhit : $de19          56857
       df_tk_sprinit : $de47          56903
     df_tk_spritepos : $de56          56918
      df_tk_sprmulti : $de4d          56909
        df_tk_sprpos : $de56          56918
        df_tk_sprupd : $de47          56903
         df_tk_stick : $de1c          56860
           df_tk_str : $d7a1          55201
      df_tk_strip_ws : $d704          55044
        df_tk_str_ch : $d7a9          55209
       df_tk_str_don : $d7ba          55226
       df_tk_str_err : $d7c1          55233
           df_tk_sub : $de47          56903
      df_tk_sws_done : $d710          55056
     df_tk_sws_loop1 : $d704          55044
      df_tk_symfound : $da70          55920
df_tk_symfound_final : $da80          55936
  df_tk_symnextentry : $da50          55888
    df_tk_symnomatch : $da4e          55886
   df_tk_symnomatchp : $da4d          55885
          df_tk_text : $de47          56903
         df_tk_tload : $de49          56905
      df_tk_tokenjmp : $dc13          56339
     df_tk_tokentype : $dcd3          56531
df_tk_tok_expression : $d931          55601
    df_tk_try_assign : $d9b7          55735
   df_tk_try_command : $d9b0          55728
     df_tk_try_digit : $d6e8          55016
         df_tk_tsave : $de49          56905
         df_tk_until : $de49          56905
           df_tk_val : $de19          56857
           df_tk_var : $d7e5          55269
        df_tk_var_ck : $d7fb          55291
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank0.s --------------------------------

      df_tk_var_cont : $d7eb          55275
    df_tk_var_noarry : $d805          55301
         df_tk_vpeek : $de19          56857
          df_tk_wait : $de49          56905
          df_tk_wend : $de47          56903
         df_tk_while : $de49          56905
       df_tk_ws_done : $d703          55043
      df_tk_ws_loop1 : $d6f3          55027
        df_tk_2parms : $de4d          56909
        df_tk_3parms : $de56          56918
        df_tk_4parms : $de5f          56927
          df_tmpptra : $009f            159
          df_tmpptrb : $00a1            161
          df_tmpptrc : $00a3            163
          df_tmpptrd : $00a5            165
          df_tmpptre : $00a7            167
              df_tok : $0480           1152
          df_tokbuff : $0480           1152
        df_tokensyms : $da88          55944
           df_tokoff : $007b            123
       df_trap_error : $f862          63586
  df_trap_go_monitor : $f87c          63612
     df_trap_monitor : $f900          63744
      df_trap_normal : $f87f          63615
           df_varcnt : $006f            111
      df_var_analyse : $d5b3          54707
df_var_analyse_chk_arry : $d60b          54795
df_var_analyse_chk_dollar : $d5fc          54780
df_var_analyse_chk_post : $d5eb          54763
  df_var_analyse_err : $d5e1          54753
df_var_analyse_fatal_err : $d5e9          54761
   df_var_analyse_ok : $d651          54865
   df_var_check_type : $d51e          54558
         df_var_find : $d4e2          54498
   df_var_findcreate : $d625          54821
df_var_findcreate_copy : $d675          54901
df_var_findcreate_create : $d63e          54846
df_var_findcreate_err : $d64f          54863
df_var_findcreate_errp : $d64e          54862
df_var_findcreate_found : $d637          54839
  df_var_find_no_vnt : $d54a          54602
    df_var_find_true : $d550          54608
df_var_initialise_var : $d65e          54878
 df_var_insert_space : $d558          54616
    df_var_match_vnt : $d4f2          54514
 df_var_match_vnt_do : $d4fe          54526
df_var_match_vnt_sym : $d502          54530
    df_var_move_byte : $d57b          54651
 df_var_move_byte_do : $d587          54663
df_var_move_byte_fin : $d598          54680
     df_var_not_arry : $d61c          54812
     df_var_not_proc : $d5c5          54725
df_var_type_countlen : $d5c8          54728
df_var_type_countlen_alphanum : $d5d8          54744
df_var_type_countlen_done : $d5dd          54749
df_var_vnt_entry_end : $d535          54581
df_var_vnt_sym_nomatch : $d528          54568
     df_var_zero_vnt : $d66a          54890
           df_vntend : $0069            105
          df_vntstrt : $0067            103
           df_vvtend : $006d            109
          df_vvtstrt : $006b            107
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank0.s --------------------------------

               errno : $005b             91
 fd_cload_getname_pc : $c583          50563
 fd_csave_getname_pc : $c5d8          50648
     fd_getname_addr : $0400           1024
               grc_d : $0041             65   *
               grc_r : $003d             61   *
               grc_x : $003e             62   *
              grc_x0 : $003b             59   *
               grc_y : $0040             64   *
              grc_y0 : $003c             60   *
              grl_dx : $003f             63   *
              grl_dy : $0040             64   *
               grl_p : $0049             73   *
            grl_sinx : $0048             72   *
            grl_siny : $004b             75   *
            grl_xyyx : $0041             65   *
              grl_x0 : $003b             59   *
              grl_x1 : $003d             61   *
              grl_y0 : $003c             60   *
              grl_y1 : $003e             62   *
             grl_2dx : $0042             66   *
            grl_2dxy : $0046             70   *
             grl_2dy : $0044             68   *
             gr_char : $0003              3
  gr_check_font_copy : $cc5a          52314
gr_check_font_copy_done : $cc71          52337
           gr_circle : $d02d          53293
      gr_circle_done : $d06a          53354
    gr_circle_d_lte0 : $d05d          53341
      gr_circle_plot : $d03a          53306
    gr_circle_points : $d06b          53355
              gr_cls : $cd53          52563
          gr_cls_col : $cd73          52595
          gr_cls_row : $cd5f          52575
    gr_cls_skip_marg : $cd6f          52591
        gr_copy_byte : $cc31          52273
         gr_copy_mem : $cc27          52263
         gr_cur_down : $cea2          52898
         gr_cur_left : $ce83          52867
          gr_cur_ptr : $000d             13
        gr_cur_right : $ce71          52849
  gr_cur_skip_at_bot : $ceae          52910
 gr_cur_skip_at_left : $ce92          52882
   gr_cur_skip_at_tl : $ce96          52886
  gr_cur_skip_at_top : $cea1          52897
           gr_cur_up : $ce97          52887
            gr_cur_x : $000b             11
            gr_cur_y : $000c             12
              gr_del : $ceaf          52911
         gr_geom_tmp : $0014             20
              gr_get : $cdbe          52670
       gr_getXY_base : $cd9b          52635
          gr_get_key : $ceb8          52920
        gr_get_key_2 : $cebc          52924
            gr_hchar : $cf56          53078
   gr_hchar_copyline : $cfac          53164
gr_hchar_copyline_nx : $cfe9          53225
 gr_hchar_copyline_0 : $cfd4          53204
 gr_hchar_copyline_2 : $cfc4          53188
    gr_hchar_getfont : $cf87          53127
       gr_hchar_mask : $cf7f          53119
    gr_hchar_rot1bit : $cf91          53137
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank0.s --------------------------------

gr_hchar_rot1bit_bcc : $cf9c          53148
 gr_hchar_rot1bit_nx : $cfa1          53153
         gr_hi_start : $0001              1
             gr_init : $cc41          52289
        gr_init_font : $cc11          52241
        gr_init_geom : $cc72          52338
   gr_init_geom_done : $cc81          52353
       gr_init_hires : $ccd4          52436
gr_init_hires_tables : $cd0d          52493
  gr_init_screen_txt : $ccbb          52411
     gr_init_tab_col : $cd3b          52539
gr_init_tab_col_skip : $cd4d          52557
     gr_init_tab_row : $cd17          52503
              gr_ink : $0011             17
    gr_key_check_key : $cec8          52936
      gr_key_got_key : $cedf          52959
       gr_key_no_key : $ceea          52970
    gr_key_skip_copy : $ced0          52944
      gr_key_tidy_up : $cee1          52961
             gr_line : $d0e4          53476
        gr_line_done : $d1af          53679
       gr_line_neg_p : $d19f          53663
       gr_line_pixel : $d168          53608
 gr_line_skip_dx_neg : $d0f3          53491
 gr_line_skip_dy_neg : $d100          53504
   gr_line_skip_left : $d130          53552
gr_line_skip_xy_swap : $d120          53536
   gr_line_skip_y_up : $d138          53560
     gr_line_yx_skip : $d174          53620
           gr_margin : $0013             19
             gr_mode : $0000              0
           gr_new_ln : $ce58          52824
       gr_nl_skip_nl : $ce6d          52845
       gr_no_special : $cf23          53027
      gr_offset_40hi : $d1cc          53708
      gr_offset_40lo : $d1b0          53680
            gr_paper : $0012             18
            gr_pitch : $0010             16
            gr_pixel : $d00f          53263
          gr_pixmode : $000f             15
             gr_plot : $cdab          52651
            gr_point : $d017          53271
        gr_point_eor : $d028          53288
       gr_point_plot : $d01a          53274
      gr_point_setup : $cffc          53244
      gr_point_write : $d02a          53290
        gr_printable : $cf24          53028
        gr_print_msg : $cf41          53057
   gr_print_msg_done : $cf51          53073
   gr_print_msg_loop : $cf47          53063
  gr_process_special : $cf08          53000
              gr_put : $cdb3          52659
         gr_put_byte : $ceee          52974
     gr_put_byte_low : $cf00          52992
           gr_screen : $0016             22
         gr_scrngeom : $0011             17
    gr_scrngeom_base : $cc82          52354
   gr_scrngeom_hires : $cca2          52386
    gr_scrngeom_text : $cc8f          52367
      gr_scroll_char : $ce16          52758
    gr_scroll_cpy_ln : $ce13          52755
  gr_scroll_erase_ln : $ce4e          52814
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank0.s --------------------------------

      gr_scroll_marg : $ce4a          52810
   gr_scroll_routine : $ce61          52833
        gr_scroll_up : $cdf7          52727
          gr_set_cur : $cdc4          52676
     gr_set_cur_init : $cdc5          52677
     gr_set_cur_skip : $cdd7          52695
       gr_special_ch : $cf2b          53035
    gr_special_fn_hi : $cf3a          53050
    gr_special_fn_lo : $cf33          53043
     gr_special_loop : $cf0c          53004
         gr_spr_char : $d261          53857
         gr_spr_draw : $d23d          53821
    gr_spr_draw_loop : $d23f          53823
    gr_spr_draw_next : $d24c          53836
        gr_spr_erase : $d1f6          53750
     gr_spr_erase_do : $d1ff          53759
   gr_spr_erase_loop : $d1f8          53752
   gr_spr_erase_next : $d205          53765
          gr_spr_hit : $d267          53863
         gr_spr_init : $d1e8          53736
    gr_spr_init_loop : $d1ea          53738
   gr_spr_multi_loop : $d282          53890
    gr_spr_multi_pos : $d27e          53886
          gr_spr_new : $d209          53769
     gr_spr_new_loop : $d20b          53771
     gr_spr_new_next : $d239          53817
      gr_spr_new_pos : $d212          53778
          gr_spr_pos : $d271          53873
          gr_spr_put : $d250          53840
           gr_text_h : $000a             10
        gr_text_size : $0007              7
       gr_text_start : $0005              5
           gr_text_w : $0009              9
              HICHAR : $9800          38912   *
              HISCRN : $a000          40960   *
              HITEXT : $bf68          49000   *
          hex_to_bcd : $c35a          50010
 hex_to_bcd_skip_neg : $c36d          50029
           hires_col : $9d90          40336   *
          hires_mask : $9e80          40576   *
        hires_row_hi : $9cc8          40136   *
       hires_row_low : $9c00          39936   *
                 IER : $000e             14   *
                 IFR : $000d             13   *
             IFR_CA1 : $0002              2   *
             IFR_CA2 : $0001              1   *
             IFR_CB1 : $0010             16   *
                IO_0 : $0300            768   *
       inc_kb_timers : $c157          49495
            infinity : $c060          49248
                init : $c4ce          50382
            init_irq : $c0be          49342
       init_keyboard : $c75e          51038
            init_ram : $c4fa          50426
       init_ram_fill : $c506          50438
       init_ram_skip : $c50a          50442
          init_ram_1 : $c502          50434
            init_snd : $d3ca          54218
       init_snd_regs : $d3cc          54220
       init_tape_tab : $c546          50502
           init_via0 : $c51c          50460
      init_via0_done : $c52e          50478
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank0.s --------------------------------

      init_via0_loop : $c51e          50462
       init_via0_tab : $c52f          50479
      init_via0_tape : $c518          50456
              init_2 : $c4d3          50387
             int_add : $d3fe          54270
             int_div : $d47f          54399
       int_div_cycle : $d4b1          54449
      int_div_noflip : $d4e1          54497
        int_div_skip : $d4cb          54475
   int_div_skip_negA : $d496          54422
   int_div_skip_negB : $d4a9          54441
       int_fast_mult : $d42b          54315
 int_fast_mult_cycle : $d43b          54331
  int_fast_mult_next : $d44c          54348
            int_mult : $d454          54356
      int_mult_cycle : $d464          54372
       int_mult_next : $d477          54391
             int_sub : $d40c          54284
             int_swp : $d41a          54298
         int_vdp_fin : $c14c          49484
     int_vdp_handler : $c131          49457
    io_active_device : $c424          50212
          io_address : $0300            768
            io_block : $0601           1537
            io_close : $c454          50260
          io_close_f : $0008              8
        io_copy_data : $c42b          50219
          io_default : $0600           1536
           io_delete : $c457          50263
            io_del_f : $000a             10
          io_devices : $c4ae          50350
          io_device0 : $c4ae          50350
          io_device1 : $c4be          50366
          io_do_echo : $c477          50295
             io_ext1 : $000c             12
             io_ext2 : $000e             14
         io_get_byte : $0000              0
           io_get_ch : $c448          50248
    io_get_line_byte : $c464          50276
    io_get_line_done : $c491          50321
             io_init : $c419          50201
          io_null_op : $c4ac          50348
        io_open_ext1 : $c45a          50266
        io_open_ext2 : $c45d          50269
           io_open_r : $0004              4
        io_open_read : $c44e          50254
           io_open_w : $0006              6
       io_open_write : $c451          50257
       io_print_done : $c4aa          50346
       io_print_line : $c499          50329
  io_print_line_byte : $c4a0          50336
         io_put_byte : $0002              2
           io_put_ch : $c44b          50251
        io_read_line : $c460          50272
      io_set_default : $c421          50209
        io_skip_echo : $c47a          50298
     io_skip_special : $c485          50309
           io_struct : $0010             16
                 irq : $c0e2          49378
             irq_brk : $c104          49412
             irq_fin : $c0fe          49406
           KB_CAPSLK : $0001              1   *
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank0.s --------------------------------

         KB_DEBOUNCE : $0002              2   *
          KB_REP_DEL : $0014             20   *
          KB_REP_TIM : $0003              3   *
            KB_SENSE : $0008              8   *
          kb_any_key : $c790          51088
     kb_any_key_none : $c7a8          51112
  kb_any_key_pressed : $c7aa          51114
      kb_any_key_row : $c799          51097
              kb_brk : $c864          51300
     kb_check_matrix : $c7b3          51123
             kb_code : $0029             41
         kb_col_mask : $c904          51460
              kb_deb : $002b             43
          kb_deb_tim : $002c             44
        kb_do_repeat : $c84a          51274
          kb_get_key : $c866          51302
          kb_get_try : $c86a          51306
    kb_handle_repeat : $c854          51284
        kb_in_repeat : $c860          51296
             kb_last : $0028             40
              kb_raw : $0027             39
         kb_rdel_tim : $002f             47
         kb_read_got : $c7dc          51164
     kb_read_noshift : $c81a          51226
     kb_read_nothing : $c7d8          51160
         kb_read_raw : $c7ac          51116
   kb_read_raw_force : $c7b1          51121
              kb_rep : $002d             45
          kb_rep_tim : $002e             46
      kb_scan_decode : $c7f3          51187
     kb_scan_got_key : $c87b          51323
         kb_scan_key : $c7e2          51170
        kb_scan_wait : $c7f1          51185
        kb_skip_col4 : $c7de          51166
        kb_skip_ctrl : $c834          51252
             kb_stat : $002a             42
            kb_stick : $c76f          51055
       kb_stick_mask : $c90c          51468
        kb_stick_pos : $c77b          51067
      kb_table_shift : $c8c4          51396
        kb_table_std : $c884          51332
         kernel_init : $c4dc          50396
         kernel_test : $c4e5          50405
                main : $c04b          49227
           mem_start : $0713           1811
        mod_sz_asm_e : $ffd6          65494
        mod_sz_asm_s : $f954          63828
       mod_sz_bios_e : $d3fe          54270
       mod_sz_bios_s : $c000          49152
        mod_sz_cia_e : $c555          50517
        mod_sz_cia_s : $c518          50456
      mod_sz_dflat_e : $f7ae          63406
      mod_sz_dflat_s : $d4e2          54498
      mod_sz_graph_e : $d292          53906
      mod_sz_graph_s : $c911          51473
         mod_sz_io_e : $c4ce          50382
         mod_sz_io_s : $c419          50201
     mod_sz_kernel_e : $c518          50456
     mod_sz_kernel_s : $c000          49152
   mod_sz_language_e : $ffd6          65494
   mod_sz_language_s : $d3fe          54270
       mod_sz_proc_e : $f6c0          63168
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank0.s --------------------------------

       mod_sz_proc_s : $f554          62804
   mod_sz_progedit_e : $dff9          57337
   mod_sz_progedit_s : $de6b          56939
      mod_sz_rtasm_e : $fd6b          64875
      mod_sz_rtasm_s : $fa50          64080
     mod_sz_rtsubs_e : $f554          62804
     mod_sz_rtsubs_s : $e646          58950
    mod_sz_runtime_e : $f6c0          63168
    mod_sz_runtime_s : $dff9          57337
      mod_sz_sound_e : $d3fe          54270
      mod_sz_sound_s : $d3b3          54195
     mod_sz_sprite_e : $d292          53906
     mod_sz_sprite_s : $d1e8          53736
      mod_sz_tkasm_e : $fa50          64080
      mod_sz_tkasm_s : $f954          63828
   mod_sz_tokenise_e : $de6b          56939
   mod_sz_tokenise_s : $d68e          54926
    mod_sz_toksubs_e : $de6b          56939
    mod_sz_toksubs_s : $dd33          56627
        mod_sz_var_e : $d68e          54926
        mod_sz_var_s : $d4e2          54498
          msg_errmsg : $d3b0          54192
     msg_hello_world : $c066          49254
           msg_ready : $d3ae          54190
             NUM_ANY : $0000              0   *
             NUM_BIN : $0003              3   *
             NUM_DEC : $0001              1   *
             NUM_HEX : $0002              2   *
                 nmi : $c517          50455
        null_handler : $c0e1          49377
            null_irq : $c0e0          49376
               num_a : $003b             59
               num_b : $003f             63
             num_buf : $004b             75
             num_tmp : $0047             71
               num_x : $0043             67
             out_bcd : $c3c7          50119
       out_bcd_digit : $c3cf          50127
         out_bcd_fin : $c3f0          50160
        out_bcd_next : $c3e1          50145
       out_bcd_print : $c3dd          50141
                 PCR : $000c             12   *
                 PRA : $0001              1   *
                PRAH : $000f             15   *
                 PRB : $0000              0   *
        print_a_to_d : $c3f6          50166
print_a_to_d_skip_neg : $c40f          50191
           SND_ADBUS : $030f            783   *
        SND_DESELECT : $00dd            221   *
            SND_MODE : $030c            780   *
       SND_REG_CHAPH : $0001              1   *
       SND_REG_CHAPL : $0000              0   *
      SND_REG_CHAVOL : $0008              8   *
       SND_REG_CHBPH : $0003              3   *
       SND_REG_CHBPL : $0002              2   *
      SND_REG_CHBVOL : $000a             10   *
       SND_REG_CHCPH : $0005              5   *
       SND_REG_CHCPL : $0004              4   *
        SND_REG_CHNP : $0006              6   *
         SND_REG_CTL : $0007              7   *
      SND_REG_ENVCYC : $000d             13   *
       SND_REG_ENVPH : $000c             12   *
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank0.s --------------------------------

       SND_REG_ENVPL : $000b             11   *
         SND_REG_IOA : $000e             14   *
         SND_REG_IOB : $000f             15   *
         SND_SELREAD : $00df            223   *
      SND_SELSETADDR : $00ff            255   *
        SND_SELWRITE : $00fd            253   *
                  SR : $000a             10   *
               SWBRK : <macro>
             scratch : $0613           1555
          skip_a_f_1 : $c195          49557
          skip_a_f_2 : $c1a4          49572
         skip_kb_deb : $c15d          49501
         skip_kb_rep : $c163          49507
          skip_x_f_1 : $c1b1          49585
          skip_x_f_2 : $c1c6          49606
             snd_get : $c024          49188
        snd_get_note : $d3b3          54195
    snd_get_note_oct : $d3be          54206
        snd_init_tab : $d3d6          54230
       snd_music_tab : $d3e6          54246
       snd_note_done : $d3c7          54215
             snd_set : $c000          49152
        spr_baseadrh : $b4e0          46304   *
        spr_baseadrl : $b4c0          46272   *
            spr_bgnd : $b4a0          46240   *
             spr_chr : $b480          46208   *
            spr_curX : $b400          46080   *
            spr_curY : $b440          46144   *
            spr_newX : $b420          46112   *
            spr_newY : $b460          46176   *
          str_a_to_x : $c189          49545
   str_d_digits_done : $c2c8          49864
         str_d_error : $c2e5          49893
      str_d_find_end : $c283          49795
     str_d_found_end : $c290          49808
        str_d_powers : $c2e7          49895
 str_d_process_digit : $c29e          49822
      str_d_skip_neg : $c2df          49887
          str_x_to_a : $c1a6          49574
      str_x_to_a_err : $c1d2          49618
     str_x_to_a_errl : $c1d1          49617
           TAPE_RATE : $00d0            208   *
            TEXTCHAR : $b400          46080   *
            TEXTSCRN : $bb80          48000   *
         TIMER1_RATE : $4e20          20000   *
                T1CH : $0005              5   *
                T1CL : $0004              4   *
                T1LH : $0007              7   *
                T1LL : $0006              6   *
                T2CH : $0009              9   *
                T2CL : $0008              8   *
             tmp_ahi : $0031             49
             tmp_alo : $0030             48
           tmp_bank1 : $0000              0
           tmp_bank2 : $0001              1
             tmp_bhi : $0033             51
             tmp_blo : $0032             50
             tmp_chi : $0035             53
             tmp_clo : $0034             52
               tmp_d : $0036             54
            tp_back4 : $c566          50534
            tp_block : $0053             83
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank0.s --------------------------------

        tp_block_gap : $c690          50832
      tp_block_gap_1 : $c694          50836
              tp_buf : $0200            512
            tp_close : $c5b6          50614
   tp_close_no_flush : $c5bf          50623
            tp_delay : $0057             87
             tp_flag : $0056             86
        tp_get_block : $c710          50960
  tp_get_block_bytes : $c721          50977
         tp_get_byte : $c6f3          50931
     tp_get_byte_buf : $c700          50944
        tp_get_fname : $c59c          50588
  tp_get_fname_start : $c58d          50573
       tp_get_header : $c596          50582
              tp_idx : $0055             85
             tp_init : $c56b          50539
         tp_io_error : $c75c          51036
       tp_open_bread : $c583          50563
      tp_open_bwrite : $c5ce          50638
      tp_open_common : $c573          50547
         tp_open_msg : $c555          50517
        tp_open_read : $c583          50563
       tp_open_write : $c5d4          50644
 tp_open_write_start : $c5d8          50648
      tp_print_block : $c670          50800
        tp_put_block : $c64c          50764
  tp_put_block_bytes : $c662          50786
         tp_put_byte : $c61a          50714
    tp_put_byte_done : $c63d          50749
        tp_put_delay : $c644          50756
         tp_read_bit : $c743          51011
     tp_read_bit_cb1 : $c747          51015
        tp_read_byte : $c72f          50991
   tp_read_byte_bits : $c73b          51003
     tp_read_byte_st : $c72f          50991
         tp_save_msg : $c55e          50526
        tp_write_bit : $c6be          50878
   tp_write_bit_chk1 : $c6cf          50895
   tp_write_bit_chk2 : $c6e7          50919
     tp_write_bit_t1 : $c6de          50910
       tp_write_byte : $c69b          50843
   tp_write_byte_bit : $c6a7          50855
tp_write_byte_nodelay : $c6bc          50876
      tp_write_fname : $c60c          50700
     tp_write_header : $c603          50691
     tt_csave_end_pc : $c5cc          50636
   tt_getsync_end_pc : $c5b5          50613
  tt_getsync_loop_pc : $c747          51015
       tt_getsync_pc : $c5b5          50613
   tt_putbyte_end_pc : $c6bd          50877
       tt_putbyte_pc : $c69b          50843
  tt_readbyte_end_pc : $c742          51010
      tt_readbyte_pc : $c72f          50991
tt_writeleader_end_pc : $c5f4          50676
   tt_writeleader_pc : $c5f4          50676
     twos_complement : $c34b          49995
twos_complement_skip_X : $c359          50009
             UTF_ACK : $0001              1   *
             UTF_BEL : $0007              7   *
             UTF_BRK : $001a             26   *
              UTF_CR : $000d             13   *
             UTF_DEL : $007f            127   *
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank0.s --------------------------------

             UTF_ETX : $0003              3   *
              UTF_FF : $000c             12   *
         UTF_SPECIAL : $0020             32   *
       update_timers : $c14d          49485
          utilPrintA : $c174          49524
       utilPrintCRLF : $c16c          49516
        utilPrintSPC : $c164          49508
           VDP_FLASH : $0010             16   *
           vdp_blank : $0010             16
             vdp_cnt : $0008              8
          vdp_cnt_hi : $0009              9
         vdp_cnt_hi2 : $000a             10
          vdp_curcnt : $000c             12
          vdp_curoff : $000d             13
         vdp_curstat : $000e             14
          vdp_curtim : $000b             11
          vdp_curval : $000f             15
  vdp_fill_vram_loop : $ccf5          52469
 vdp_fill_vram_noinc : $ccfd          52477
            vdp_font : $c911          51473
          vdp_font_a : $ca19          51737
             vec_brk : $0004              4
             vec_irq : $0002              2
        vec_usercia0 : $0006              6
             ztmp_24 : $003b             59
          _adcZPWord : <macro>
          _addZPWord : <macro>
           _code_end : $ffd6          65494
         _code_start : $c000          49152
          _cpu_stack : $0100            256
          _cpyZPWord : <macro>
              _debug : <macro>
          _decZPWord : <macro>
      _end_zero_page : $00a9            169
          _incZPWord : <macro>
       _mod_sz_cmd_e : $d3b3          54195
       _mod_sz_cmd_s : $d292          53906
       _PushFalseJmp : <macro>
        _PushTrueJmp : <macro>
             _printA : <macro>
             _printC : <macro>
            _printCA : <macro>
          _printCRLF : <macro>
            _println : <macro>
        _println_low : <macro>
          _printmsgA : <macro>
            _pullAXY : <macro>
            _pushAXY : <macro>
            _sendcmd : <macro>
          _subZPWord : <macro>
            __6502__ : $0001              1

1639 labels used

15555 lines read, no errors in pass 1.
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank0.s --------------------------------

c000 =                       	org 0xc000
c000 :                       mod_sz_bios_s
                             	include "kernel\kernel.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	Lol, I thought this would become more sophisti
                             ;*	hence the name 'kernel'. But no, it just initi
                             ;*	memory, VIA, sound and screen, before passing 
                             ;*	to main.
                             ;*	References to banks etc. are from ported code 
                             ;*	did do more stuff, namely helping with ROM ban
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc\includes.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  and ACIA registers.
                             ;*	Of course the Oric doesn't have a VDP or an AC
                             ;*	so this file could be optimised.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x04000 and decodes up to
                             ;* eight IO addresses, at 0x0080 intervals
                             ;* All eight are not used at the present time:
                             ;* - 0 : VIA 1 (Keyboard)
                             ;* - 1 : VIA 2 (Sound and SD card interface)
                             ;* - 2 : VDP (Video)
                             ;* - 3 : ACIA (Serial)
0300 =                       IO_0		= 0x0300
                             
0010 =                       VDP_FLASH	= 16				;* 32/50 second flash
                             
4e20 =                       TIMER1_RATE	= 1000000 / 50		;* 50 times per secon
00d0 =                       TAPE_RATE	= 0xd0				;* Assumed required FM freque
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank0.s --------------------------------

0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
0010 =                       IFR_CB1		= 0x10
                             
                             ;* AY-3-8910 definitions
                             ;* The sound chip is accessed through VIA 2
030f =                       SND_ADBUS	= IO_0+PRAH
030c =                       SND_MODE	= IO_0+PCR
                             
                             ; Values for the PCR register - always enable CB1
00df =                       SND_SELREAD			= 0b11011111
00fd =                       SND_SELWRITE		= 0b11111101
00ff =                       SND_SELSETADDR		= 0b11111111
00dd =                       SND_DESELECT		= 0b11011101
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             
                             ;* Port B
0008 =                       KB_SENSE	= 0x08			; Input - Bit 3 port A
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
                             
0003 =                       KB_REP_TIM	= 3 			; Number of VB periods for the 
0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0002 =                       KB_DEBOUNCE	= 2				; Number of VB periods before 
                             
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0014 =                       CTRL_CAPS	= 0x14			; CTRL-T to toggle caps
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank0.s --------------------------------

0001 =                       UTF_ACK		= 0x01			; Used for the CTRL-A copy in t
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	sta tmp_d
                             	txa
                             	pha
                             	tya
                             	pha
                             	lda tmp_d
                             	endm
                             
                             _pullAXY macro
                             	pla
                             	tay
                             	pla
                             	tax
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank0.s --------------------------------

                             _printmsgA macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	_pullAXY
                             	endm
                             
                             _printA macro
                             	_pushAXY
                             	jsr str_a_to_x
                             	jsr io_put_ch
                             	txa
                             	jsr io_put_ch
                             	_pullAXY
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr io_put_ch
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWord macro wordp
                             	pha
                             	sec
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank0.s --------------------------------

                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPWord macro worda,const
                             	clc
                             	lda worda
                             	adc #const
                             	sta worda
                             	lda worda+1
                             	adc #0
                             	sta worda+1
                             	endm
                             	
                             _debug macro ch
                             	pha
                             	lda #ch
                             	sta 48000
                             	pla
                             	endm
                             	
                             
                             
                             	include "inc\graph.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank0.s --------------------------------

                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*	This was needed in the previous code due to 32
                             ;*	byte width screens, but Oric only  has 40, so 
                             ;*	could be optimised a little.
                             ;*
                             ;************************************************
                             
                             ; Important screen addresses for the Oric ULA
bb80 =                       TEXTSCRN	=	0xbb80
b400 =                       TEXTCHAR	=	0xb400
a000 =                       HISCRN		=	0xa000
9800 =                       HICHAR		=	0x9800
bf68 =                       HITEXT		=	0xbf68
                             
0000 =                       	struct gr_screen
0000 =                       	db gr_mode					; Text or Hires mode
0001 =                       	dw gr_hi_start				; Address fo hires screen
0003 =                       	dw gr_char					; Start address of charset
0005 =                       	dw gr_text_start			; Start of text memory
0007 =                       	dw gr_text_size				; Number of bytes screen occu
0009 =                       	db gr_text_w				; Number of columns
000a =                       	db gr_text_h				; Number of rows
000b =                       	db gr_cur_x					; Current X position of cursor
000c =                       	db gr_cur_y					; Current Y position of cursor
000d =                       	dw gr_cur_ptr				; VDP address of cursor
000f =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
0010 =                       	db gr_pitch					; Pixel pitch for char plotting
0011 =                       	db gr_ink					; Ink colour
0012 =                       	db gr_paper					; Paper colour
0013 =                       	db gr_margin				; Left margin
0014 =                       	dw gr_geom_tmp				; One word of temp storage for
                             	end struct
                             	
                             ; Sprite data stored in free 256 in font space
b400 =                       spr_curX	= TEXTCHAR			; Sprite current X pos
b420 =                       spr_newX	= TEXTCHAR+32		; Sprite new X pos
b440 =                       spr_curY	= TEXTCHAR+64		; Sprite current Y pos
b460 =                       spr_newY	= TEXTCHAR+96		; Sprite new Y pos
b480 =                       spr_chr		= TEXTCHAR+128		; Sprite character
b4a0 =                       spr_bgnd	= TEXTCHAR+160		; Background character u
b4c0 =                       spr_baseadrl= TEXTCHAR+192		; Y low address of sp
b4e0 =                       spr_baseadrh= TEXTCHAR+224		; Y high address of s
                             
                             ; Tables stored in alternate character set area
                             ; only used for high-resolution screen handling
9c00 =                       hires_row_low	=	HICHAR+0x400		; Low byte of row p
9cc8 =                       hires_row_hi	=	hires_row_low+200	; High byte of r
9d90 =                       hires_col		=	hires_row_hi+200	; Pixel to byte col
9e80 =                       hires_mask		=	hires_col+240		; Pixel column to pi
                             
                             
                             	include "io\io.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank0.s --------------------------------

                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*	Some over-engineering here for future possibil
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0713 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank0.s --------------------------------

                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank0.s --------------------------------

0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "kernel\zeropage.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank0.s --------------------------------

                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple uses across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       vec_irq		 ds	2		; Master IRQ handler
0004 =                       vec_brk		 ds	2		; Master BRK handler
0006 =                       vec_usercia0 ds	2		; Where to jump for CIA0 inter
                             
                             ; VDP parameters
0008 =                       vdp_cnt		ds	1		; VDP interrupt counter
0009 =                       vdp_cnt_hi 	ds	1		; VDP counter high
000a =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000b =                       vdp_curtim	ds	1		; Cursor blink speed
000c =                       vdp_curcnt	ds	1		; Cursor blink countdown
000d =                       vdp_curoff	ds	1		; Cursor off (0 = On)
000e =                       vdp_curstat	ds	1		; Cursor status
000f =                       vdp_curval	ds	1		; Cursor value on screen
0010 =                       vdp_blank	ds	1		; Screen blank value normally 32
                             
                             ; Screen geometry
0011 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0027 =                       kb_raw  	ds	1		; Raw keyboard code
0028 =                       kb_last		ds	1		; Code of last key
0029 =                       kb_code 	ds	1		; Converted keyboard code
002a =                       kb_stat		ds	1		; Keyboard status for caps and shi
002b =                       kb_deb		ds	1		; Debounce timer
002c =                       kb_deb_tim  ds	1		; Default debounce delay
002d =                       kb_rep		ds	1		; Keyboard repeat speed timer
002e =                       kb_rep_tim 	ds	1		; Default repeat speed
002f =                       kb_rdel_tim	ds	1		; Default repeat delay (until s
                             
0030 =                       tmp_alo 	ds	1		; VDP addresses lo
0031 =                       tmp_ahi 	ds	1		; VDP addresses hi
0032 =                       tmp_blo 	ds	1		; Temp address lo
0033 =                       tmp_bhi		ds	1		; Temp address hi
0034 =                       tmp_clo		ds	1		; Temp address lo
0035 =                       tmp_chi		ds	1		; Temp address hi
0036 =                       tmp_d		ds	1		; Temp storage d
                             
                             ; Raw input/output parameters
0037 =                       buf_lo		ds	1		; Line buffer address low
0038 =                       buf_hi		ds	1		; Line buffer address high
0039 =                       buf_sz		ds	1		; Buffer size
003a =                       buf_ef		ds	1		; End file / line marker
                             
                             
                             ; ** Integer function storage **
003b =                       ztmp_24					; Start of 24 byte scratch area (all 
003b =                       num_a		ds	4		; 4 byte primary accumulator
003f =                       num_b		ds	4		; 4 byte secondary accumulator
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank0.s --------------------------------

0043 =                       num_x		ds	4		; 4 byte x register
0047 =                       num_tmp		ds	4		; 4 byte temp space
004b =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ; ** Tape function storage **
0053 =                       tp_block	ds	2		; Block number (int)
0055 =                       tp_idx		ds	1		; Current buffer index
0056 =                       tp_flag		ds	1		; zero = closed, 1=read, 2=write
0057 =                       tp_delay	ds	2		; Interblock delay
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
0059 =                       dflat_zp_s
0059 =                       dflat_zp_save_s			; ZP save dflat from here
0059 =                       df_checkkey	ds	1		; Key check interval counter
005a =                       df_checkmsk	ds	1		; Mask for check key
005b =                       errno		ds	1		; General error condition status
005c =                       df_immed	ds	1		; Immediate mode (0 = not immediat
005d =                       df_sp		ds	1		; Stack pointer after error to resto
005e =                       df_pc		ds	2		; PC after error to return to
0060 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
0062 =                       df_brkval	ds	1		; Byte after BRK instruction
0063 =                       df_prgstrt	ds	2		; Start of program code
0065 =                       df_prgend	ds	2		; End of program code
0067 =                       df_vntstrt	ds	2		; Variable name table start
0069 =                       df_vntend	ds	2		; Variable name table end
006b =                       df_vvtstrt	ds	2		; Variable value table start
006d =                       df_vvtend	ds	2		; Variable value table end
006f =                       df_varcnt	ds	1		; Variable counter
0070 =                       df_starstrt	ds	2		; String and array table start
0072 =                       df_starend	ds	2		; String and array table end
0074 =                       df_rtstop	ds	1		; Runtime stack pointer
0075 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
0076 =                       df_strbuff	ds	1		; String expression buffer
0077 =                       df_stridx	ds	1		; Top of string buffer (grows dow
0078 =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
007a =                       df_linoff	ds	1		; Offset in to line buffer
007b =                       df_tokoff	ds	1		; Offset in to tokenised buffer
007c =                       df_eolidx	ds	1		; End of line index (i.e length)
007d =                       df_nxtstidx	ds	1		; Offset to the next statement 
007e =                       df_curstidx	ds	1		; Offset to the start of curren
007f =                       df_symtab	ds	2		; Pointer to next free symtab ent
0081 =                       df_symoff	ds	1		; Offset in to token table
0082 =                       df_symini	ds	2		; Start of symtab
0084 =                       df_currlin	ds	2		; Execution current line pointer
0086 =                       df_exeoff	ds	1		; Execution line buffer offset
0087 =                       df_nextlin	ds	2		; Next line to execute
0089 =                       df_procmode	ds	1		; Only used during tokenisation
008a =                       df_procargs	ds	1		; Only used during tokenisation
008b =                       df_procloc	ds	1		; Counts the number of local par
008c =                       df_procptr	ds	2		; Pointer to proc vvt slot
008e =                       df_lineptr	ds	2		; Pointer to line during searche
0090 =                       df_lineidx	ds	1		; Pointer to line index during s
0091 =                       df_ifnest	ds	1		; Global nested if counter
0092 =                       df_currdat	ds	2		; Data current line pointer
0094 =                       df_datoff	ds	1		; Data line buffer offset
0095 =                       df_rnd		ds	2		; Random number seed
                             
0097 =                       df_asmpc	ds	2		; Assembler program counter
0099 =                       df_asmopt	ds	1		; Assembler current option
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank0.s --------------------------------

009a =                       df_asmadmd	ds	1		; Addressing mode
009b =                       df_asmopcde	ds	1		; Current opcode
009c =                       df_asmoprnd	ds	2		; Current operand
009e =                       df_asmlen	ds	1		; Instruction length
                             
009f =                       dflat_zp_save_e			; Save up to this place
                             
                             ; Temp space for dflat
009f =                       df_tmpptra	ds	2		; Temp pointer a
00a1 =                       df_tmpptrb	ds	2		; Temp pointer b
00a3 =                       df_tmpptrc	ds	2		; Temp pointer c
00a5 =                       df_tmpptrd	ds	2		; Temp pointer d
00a7 =                       df_tmpptre	ds	2		; Temp pointer e
                             
00a9 =                       dflat_zp_e
                             
                             
                             ;***** END OF ZERO PAGE *****
00a9 =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 is tape buffer *****
0200 =                       	org 0x0200
0200 =                       tp_buf		ds	256		; Serial input / output line buff
                             
                             ;***** 3 is IO *****
0300 =                       	org 0x0300			; IO mapped to Page 3 on Oric
0300 =                       io_address	ds	256
                             
0400 =                       	org 0x0400			; Page 4 = dflat space
0400 =                       fd_getname_addr			; ** FOR ORICUTRON EMULATOR **
0400 =                       df_linbuff
0400 =                       df_raw		ds	128		; untokenised input line
0480 =                       df_tokbuff
0480 =                       df_tok		ds 	128		; tokenised output line
                             
0500 =                       	org 0x0500			; Page 5 = fixed space for interpre
0500 =                       df_rtstck				; operator stack grow up, runtime gr
0500 =                       df_rtspace	ds	256
                             
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Acticve IO device settings
0600 =                       io_default	ds	1		; The default device number
0601 =                       io_block	ds	io_struct
                             
                             
                             ; Dflat top of memory+1 - initialised at boot tim
0611 =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
0613 =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0713 =                       mem_start
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank0.s --------------------------------

                             	include "dflat\dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0713 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank0.s --------------------------------

                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank0.s --------------------------------

0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank0.s --------------------------------

0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors are at these addresses
fffa : 17c5                  	fcw nmi				; 0xfffa : NMI Vector
fffc : cec4                  	fcw init			; 0xfffc : Reset Vector
fffe : d7c0                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             	
                             	; ROM code
                             	code				;  
c000 =                       	org 0xc000			; Start of ROM
                             
c000 :                       _code_start
                             	; Restore current bank always at address c001
c000 :                       mod_sz_kernel_s
                             
                             ;* Include all core code in the right order
                             	include "kernel\snd-low.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*	Routines to access the AY-3-8912, which is don
                             ;*	lines of the VIA - CB2 and CA2 for chip select
                             ;*	Port A for data interface. This makes accessin
                             ;*	8912 a bit slow..
                             ;*
                             ;* 	CB2		CA2		Function		CB2=BDIR, CA2=BC1
                             ;*	0		0		Not selected
                             ;*	0		1		Read register in to Port A
                             ;*	1		0		Write register from Port A
                             ;*	1		1		Select register # from Port A
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_set
                             ;* Set AY register X to value A
                             ;* Input : X = Reg no, A = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c000 :                       snd_set
c000 : 48               [ 3] 	pha
                             
c001 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c003 : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c006 : 8e0f03           [ 4] 	stx SND_ADBUS			; Put reg # on Port A (sound bus
                             
c009 : a9ff             [ 2] 	lda #SND_SELSETADDR		; Get ready to select the r
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank0.s --------------------------------

c00b : 8d0c03           [ 4] 	sta SND_MODE			; Latch the reg # on Port A
                             
c00e : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c010 : 8d0c03           [ 4] 	sta SND_MODE
                             
c013 : 68               [ 4] 	pla						; Get value
c014 : 48               [ 3] 	pha						; but don't lose it
c015 : 8d0f03           [ 4] 	sta SND_ADBUS			; Put reg value on Port A (sound
c018 : a9fd             [ 2] 	lda #SND_SELWRITE		; Select mode for writing dat
c01a : 8d0c03           [ 4] 	sta SND_MODE			; Latch reg value on Port A
                             	
c01d : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c01f : 8d0c03           [ 4] 	sta SND_MODE
                             
c022 : 68               [ 4] 	pla
                             	
c023 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X value
                             ;* Input : X = Reg no
                             ;* Output : A = Value
                             ;* Regs affected : None
                             ;****************************************
c024 :                       snd_get
                             
c024 : a9ff             [ 2] 	lda #0xff				; Set Port A to output
c026 : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c029 : 8e0f03           [ 4] 	stx SND_ADBUS			; Put X on the sound bus (X = re
                             
c02c : a9ff             [ 2] 	lda #SND_SELSETADDR		; Get ready to select the r
c02e : 8d0c03           [ 4] 	sta SND_MODE			; Latch the reg # on Port A
                             
c031 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c033 : 8d0c03           [ 4] 	sta SND_MODE
                             
c036 : a900             [ 2] 	lda #0x00				; Set Port A to input
c038 : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c03b : a9df             [ 2] 	lda #SND_SELREAD		; Select mode for reading data
c03d : 8d0c03           [ 4] 	sta SND_MODE			; Set read mode on AY
                             
c040 : ad0f03           [ 4] 	lda SND_ADBUS			; Get value in to Y from Port A
c043 : 48               [ 3] 	pha						; Save it to stack
                             	
c044 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c046 : 8d0c03           [ 4] 	sta SND_MODE
                             
c049 : 68               [ 4] 	pla						; Get the value off stack
                             	
c04a : 60               [ 6] 	rts
                             
                             
                             	include "kernel\main.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank0.s --------------------------------

                             ;*  credit of original my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
c04b :                       main
                             	_println msg_hello_world
                             
                             
                             	
c060 :                       infinity
c060 : 204edf           [ 6] 	jsr df_pg_dflat
c063 : 4c60c0           [ 3] 	jmp infinity
                             
c066 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel\build.s"
c066 : 4f726963206466..       db "Oric dflat custom ROM\r" 
c07c : 42792040363530..       db "By @6502Nerd (Dolo Miah)\r" 
c095 : 4275696c64203a..       db "Build : 0.11 [BETA]\r" 
c0a9 : 436f7079726967..       db "Copyright (c) 2020\r\r",0 
                             
                             
                             	include "kernel\irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler
                             ;*	There is only one regular interrupt source whi
                             ;*	T1 timeout on a 50Hz cycle, whose main job is 
                             ;*	flash the cursor and decrement some timers.
                             ;*	But there are handlers for BRK, user and VIA s
                             ;*	By default the user and VIA do nothing, but ca
                             ;*	redirected to user routines.
                             ;*
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c0be :                       init_irq
                             	; Core IRQ handler
c0be : a9e2             [ 2] 	lda #lo(irq)
c0c0 : 8502             [ 3] 	sta vec_irq
c0c2 : a9c0             [ 2] 	lda #hi(irq)
c0c4 : 8503             [ 3] 	sta vec_irq+1
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank0.s --------------------------------

                             	
                             	; Core BRK handler
c0c6 : a904             [ 2] 	lda #lo(irq_brk)
c0c8 : 8504             [ 3] 	sta vec_brk
c0ca : a9c1             [ 2] 	lda #hi(irq_brk)
c0cc : 8505             [ 3] 	sta vec_brk+1
                             
                             	; User handlers VIA0 interrupts
c0ce : a9e1             [ 2] 	lda #lo(null_handler)
c0d0 : 8506             [ 3] 	sta vec_usercia0
c0d2 : a9c0             [ 2] 	lda #hi(null_handler)
c0d4 : 8507             [ 3] 	sta vec_usercia0+1
                             
c0d6 : 60               [ 6] 	rts
                             
                             
                             ;* Calls the master IRQ handler - from the ROM
c0d7 :                       call_irq_master
c0d7 : 6c0200           [ 6] 	jmp (vec_irq)
                             	
                             ;* Calls the BRK handler
c0da :                       call_irq_brk
c0da : 6c0400           [ 6] 	jmp (vec_brk)
                             
                             ;* Call the user CIA0 handler
c0dd :                       call_irq_usercia0
c0dd : 6c0600           [ 6] 	jmp (vec_usercia0)
                             
                             ;* null interrupt
c0e0 :                       null_irq
c0e0 : 40               [ 6] 	rti
                             
                             ;* null handler
c0e1 :                       null_handler
c0e1 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c0e2 :                       irq
                             	; Don't use _pushAXY as it uses a temp location!
c0e2 : 48               [ 3] 	pha
c0e3 : 8a               [ 2] 	txa
c0e4 : 48               [ 3] 	pha
c0e5 : 98               [ 2] 	tya
c0e6 : 48               [ 3] 	pha
                             
c0e7 : d8               [ 2] 	cld						; Just in case!
c0e8 : 18               [ 2] 	clc						; Standard behaviour
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c0e9 : ba               [ 2] 	tsx
c0ea : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c0ed : 2910             [ 2] 	and #0x10
c0ef : d0e9             [ 3] 	bne call_irq_brk
                             	
                             	;* Primary interrupt is timer 1
c0f1 : ad0d03           [ 4] 	lda IO_0 + IFR
c0f4 : 2940             [ 2] 	and #0x40				; Bit 6 = Timer 1 interrupt
c0f6 : f006             [ 3] 	beq irq_fin				; If nothing then end
                             
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank0.s --------------------------------

                             	; Service the timer 1 interrupt
c0f8 : 8d0d03           [ 4] 	sta IO_0 + IFR			; Clear the interrupt
c0fb : 2031c1           [ 6] 	jsr int_vdp_handler
                             
c0fe :                       irq_fin
                             	_pullAXY
                             
c103 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c104 :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c104 : 38               [ 2] 	sec
c105 : bd0501           [ 4] 	lda 0x0105,x
c108 : e902             [ 2] 	sbc #2
c10a : 8560             [ 3] 	sta df_brkpc
c10c : bd0601           [ 4] 	lda 0x0106,x
c10f : e900             [ 2] 	sbc #0
c111 : 8561             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c113 : a001             [ 2] 	ldy #1
c115 : b160             [ 5] 	lda (df_brkpc),y
c117 : 8562             [ 3] 	sta df_brkval
c119 : 855b             [ 3] 	sta errno
                             	; now update the return address
c11b : a55e             [ 3] 	lda df_pc
c11d : 9d0501           [ 5] 	sta 0x105,x
c120 : a55f             [ 3] 	lda df_pc+1
c122 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c12a : 853b             [ 3] 	sta num_a
c12c : 863c             [ 3] 	stx num_a+1
c12e : 843d             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c130 : 40               [ 6] 	rti
                             	
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c131 :                       int_vdp_handler
c131 : 204dc1           [ 6] 	jsr update_timers	; If it is then update system 
c134 : a50d             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c136 : d014             [ 3] 	bne int_vdp_fin		; Skip if disabled
                             
c138 : c60c             [ 5] 	dec vdp_curcnt		; Decrement countdown
c13a : d010             [ 3] 	bne int_vdp_fin		; If not expired, do nothing
c13c : a50b             [ 3] 	lda vdp_curtim		; Reset cursor countdown
c13e : 850c             [ 3] 	sta vdp_curcnt
c140 : a50e             [ 3] 	lda vdp_curstat		; Get the flash status
c142 : 4980             [ 2] 	eor #0x80			; Invert top bit
c144 : 850e             [ 3] 	sta vdp_curstat
c146 : 450f             [ 3] 	eor vdp_curval		; EOR with whats under cursor
                             	; Use cursor address, write to screen
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank0.s --------------------------------

                             	; ptr is base, offset with X coord in Y register
c148 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_x
c14a : 911e             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
c14c :                       int_vdp_fin	
c14c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c14d :                       update_timers
c14d : e608             [ 5] 	inc vdp_cnt
c14f : d006             [ 3] 	bne inc_kb_timers
c151 : e609             [ 5] 	inc vdp_cnt_hi
c153 : d002             [ 3] 	bne inc_kb_timers
c155 : e60a             [ 5] 	inc vdp_cnt_hi2
c157 :                       inc_kb_timers
c157 : a62b             [ 3] 	ldx kb_deb			; Is debounce 0?
c159 : f002             [ 3] 	beq skip_kb_deb
c15b : c62b             [ 5] 	dec kb_deb
c15d :                       skip_kb_deb
c15d : a62d             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c15f : f002             [ 3] 	beq skip_kb_rep
c161 : c62d             [ 5] 	dec kb_rep
c163 :                       skip_kb_rep
c163 : 60               [ 6] 	rts
                             	
                             
                             	include "utils\utils.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c164 :                       utilPrintSPC
c164 : 48               [ 3] 	pha
c165 : a920             [ 2] 	lda #' '
c167 : 204bc4           [ 6] 	jsr io_put_ch
c16a : 68               [ 4] 	pla
c16b : 60               [ 6] 	rts
                             
c16c :                       utilPrintCRLF
c16c : 48               [ 3] 	pha
c16d : a90d             [ 2] 	lda #UTF_CR
c16f : 204bc4           [ 6] 	jsr io_put_ch
c172 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank0.s --------------------------------

c173 : 60               [ 6] 	rts
                             
c174 :                       utilPrintA
c174 : 8536             [ 3] 	sta tmp_d
c176 : 48               [ 3] 	pha
c177 : 8a               [ 2] 	txa
c178 : 48               [ 3] 	pha
c179 : a536             [ 3] 	lda tmp_d
c17b : 2089c1           [ 6] 	jsr str_a_to_x
c17e : 204bc4           [ 6] 	jsr io_put_ch
c181 : 8a               [ 2] 	txa
c182 : 204bc4           [ 6] 	jsr io_put_ch
c185 : 68               [ 4] 	pla
c186 : aa               [ 2] 	tax
c187 : 68               [ 4] 	pla
c188 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c189 :                       str_a_to_x
c189 : 48               [ 3] 	pha					; Save the byte using later on
c18a : 290f             [ 2] 	and #0x0f			; Mask low nibble
c18c : 18               [ 2] 	clc
c18d : 6930             [ 2] 	adc #'0'			; Convert to UTF
c18f : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c191 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c193 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c195 :                       skip_a_f_1
c195 : aa               [ 2] 	tax					; Low char is in X
c196 : 68               [ 4] 	pla					; Get byte back
c197 : 4a               [ 2] 	lsr a				; Make high nibble low
c198 : 4a               [ 2] 	lsr a
c199 : 4a               [ 2] 	lsr a
c19a : 4a               [ 2] 	lsr a
c19b : 18               [ 2] 	clc
c19c : 6930             [ 2] 	adc #'0'			; Convert to UTF
c19e : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c1a0 : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c1a2 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c1a4 :                       skip_a_f_2
                             
c1a4 : 18               [ 2] 	clc					; No error
c1a5 : 60               [ 6] 	rts					; A high nibble
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c1a6 :                       str_x_to_a
c1a6 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1a8 : 38               [ 2] 	sec					; Process high char in A
c1a9 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1ab : c90a             [ 2] 	cmp #10				; If A < 10 then
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank0.s --------------------------------

c1ad : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c1af : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1b1 :                       skip_x_f_1
c1b1 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c1b3 : b01d             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c1b5 : 0a               [ 2] 	asl a				; This is the high nibble
c1b6 : 0a               [ 2] 	asl a
c1b7 : 0a               [ 2] 	asl a
c1b8 : 0a               [ 2] 	asl a
c1b9 : 48               [ 3] 	pha					; Save the high nibble
c1ba : 8a               [ 2] 	txa					; Now process the low char in X
c1bb : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1bd : 38               [ 2] 	sec
c1be : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1c0 : c90a             [ 2] 	cmp #10				; If A < 10 then
c1c2 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c1c4 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1c6 :                       skip_x_f_2
c1c6 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c1c8 : b007             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c1ca : 853b             [ 3] 	sta num_a			; Store low nibble in temp
c1cc : 68               [ 4] 	pla					; Get high nibble
c1cd : 053b             [ 3] 	ora num_a			; OR with low nibble
                             
c1cf : 18               [ 2] 	clc					; No error
c1d0 : 60               [ 6] 	rts					; A contains value
                             
c1d1 :                       str_x_to_a_errl
c1d1 : 68               [ 4] 	pla
c1d2 :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c1d4 :                       con_n_to_a
c1d4 : 8647             [ 3] 	stx num_tmp
c1d6 : 8548             [ 3] 	sta num_tmp+1
c1d8 : a900             [ 2] 	lda #0
c1da : 853b             [ 3] 	sta num_a
c1dc : 853c             [ 3] 	sta num_a+1
c1de : c000             [ 2] 	cpy #NUM_ANY
c1e0 : f014             [ 3] 	beq con_n_to_a_detect
c1e2 : 88               [ 2] 	dey
c1e3 : d003             [ 3] 	bne con_n_not_dec
c1e5 :                       con_dec_jmp
c1e5 : 4c7ac2           [ 3] 	jmp con_dec_to_a_int
c1e8 :                       con_n_not_dec
c1e8 : 88               [ 2] 	dey
c1e9 : d003             [ 3] 	bne con_n_not_hex
c1eb :                       con_hex_jmp
c1eb : 4c11c2           [ 3] 	jmp con_hex_to_a_int
c1ee :                       con_n_not_hex
c1ee : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank0.s --------------------------------

c1ef : d003             [ 3] 	bne con_n_err
c1f1 :                       con_bin_jmp
c1f1 : 4c50c2           [ 3] 	jmp con_bin_to_a_int
c1f4 :                       con_n_err
c1f4 : 38               [ 2] 	sec
c1f5 : 60               [ 6] 	rts
c1f6 :                       con_n_to_a_detect		; Y is zero on entry
c1f6 : b147             [ 5] 	lda (num_tmp),y
c1f8 : c930             [ 2] 	cmp #'0'
c1fa : d0e9             [ 3] 	bne con_dec_jmp
c1fc : a001             [ 2] 	ldy #1
c1fe : b147             [ 5] 	lda (num_tmp),y
c200 : 0920             [ 2] 	ora #0x20
c202 : c978             [ 2] 	cmp #'x'
c204 : f0e5             [ 4] 	beq con_hex_jmp
c206 : c962             [ 2] 	cmp #'b'
c208 : f0e7             [ 4] 	beq con_bin_jmp
c20a : 4ce5c1           [ 3] 	jmp con_dec_jmp
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c20d :                       con_hex_to_a
c20d : 8647             [ 3] 	stx num_tmp
c20f : 8548             [ 3] 	sta num_tmp+1
c211 :                       con_hex_to_a_int
c211 : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c213 : a002             [ 2] 	ldy #2			; start at first digit
c215 :                       con_hex_digit
c215 : b147             [ 5] 	lda (num_tmp),y
c217 : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c219 : 38               [ 2] 	sec							; Process high char in A
c21a : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c21c : c90a             [ 2] 	cmp #10						; If A < 10 then
c21e : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c220 : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c222 :                       con_hex_skip_x_f_1
c222 : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c224 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c226 : 48               [ 3] 	pha
                             	; make room for lo nibble
c227 : 063b             [ 5] 	asl num_a
c229 : 263c             [ 5] 	rol num_a+1
c22b : 063b             [ 5] 	asl num_a
c22d : 263c             [ 5] 	rol num_a+1
c22f : 063b             [ 5] 	asl num_a
c231 : 263c             [ 5] 	rol num_a+1
c233 : 063b             [ 5] 	asl num_a
c235 : 263c             [ 5] 	rol num_a+1
                             	; save in low nibble
c237 : 68               [ 4] 	pla
c238 : 053b             [ 3] 	ora num_a
c23a : 853b             [ 3] 	sta num_a
c23c : c8               [ 2] 	iny
c23d : ca               [ 2] 	dex
c23e : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c240 :                       con_hex_err
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank0.s --------------------------------

c240 : 38               [ 2] 	sec
c241 : 60               [ 6] 	rts
                             	; found a non-hex digit
c242 :                       con_hex_done
                             	; if no digits processed then error
c242 : c002             [ 2] 	cpy #2
c244 : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c246 : 98               [ 2] 	tya
c247 : aa               [ 2] 	tax
c248 : a902             [ 2] 	lda #NUM_HEX
c24a : 18               [ 2] 	clc
c24b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert bin string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c24c :                       con_bin_to_a
c24c : 8647             [ 3] 	stx num_tmp
c24e : 8548             [ 3] 	sta num_tmp+1
c250 :                       con_bin_to_a_int
c250 : a002             [ 2] 	ldy #2
c252 : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c254 :                       con_bin_digit
c254 : b147             [ 5] 	lda (num_tmp),y
c256 : c930             [ 2] 	cmp #'0'
c258 : 9010             [ 3] 	bcc con_bin_done
c25a : c932             [ 2] 	cmp #'1'+1
c25c : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c25e : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c260 : 263b             [ 5] 	rol num_a
c262 : 263c             [ 5] 	rol num_a+1
c264 : c8               [ 2] 	iny
c265 : ca               [ 2] 	dex
c266 : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c268 : f00a             [ 3] 	beq con_bin_err
c26a :                       con_bin_done
                             	; didn't process any digit = error
c26a : c002             [ 2] 	cpy #2
c26c : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c26e : 98               [ 2] 	tya
c26f : aa               [ 2] 	tax
c270 : a903             [ 2] 	lda #NUM_BIN
c272 : 18               [ 2] 	clc
c273 : 60               [ 6] 	rts
c274 :                       con_bin_err
c274 : 38               [ 2] 	sec
c275 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank0.s --------------------------------

                             ;* Regs affected : CS = Error
                             ;****************************************
c276 :                       con_dec_to_a
c276 : 8647             [ 3] 	stx num_tmp
c278 : 8548             [ 3] 	sta num_tmp+1
c27a :                       con_dec_to_a_int
c27a : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c27c : b147             [ 5] 	lda (num_tmp),y
c27e : c92d             [ 2] 	cmp #'-'
c280 : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c282 : c8               [ 2] 	iny
c283 :                       str_d_find_end
c283 : b147             [ 5] 	lda (num_tmp),y
c285 : c930             [ 2] 	cmp #'0'
c287 : 9007             [ 3] 	bcc str_d_found_end
c289 : c93a             [ 2] 	cmp #'9'+1
c28b : b003             [ 3] 	bcs str_d_found_end
c28d : c8               [ 2] 	iny
c28e : d0f3             [ 3] 	bne str_d_find_end	; Possble wraparound but shou
c290 :                       str_d_found_end
c290 : c007             [ 2] 	cpy #7				; Biggest int is 6 chars
c292 : b051             [ 3] 	bcs str_d_error		; e.g. -32767
c294 : 844a             [ 3] 	sty num_tmp+3
c296 : a900             [ 2] 	lda #0
c298 : 8549             [ 3] 	sta num_tmp+2
c29a : 853b             [ 3] 	sta num_a
c29c : 853c             [ 3] 	sta num_a+1
c29e :                       str_d_process_digit
c29e : 88               [ 2] 	dey
c29f : 3027             [ 3] 	bmi str_d_digits_done
                             
c2a1 : b147             [ 5] 	lda (num_tmp),y
                             
c2a3 : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c2a5 : f021             [ 3] 	beq str_d_digits_done ; also done
                             
c2a7 : 38               [ 2] 	sec
c2a8 : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c2aa : 18               [ 2] 	clc
c2ab : 0a               [ 2] 	asl a
c2ac : 6549             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c2ae : aa               [ 2] 	tax
c2af : a53b             [ 3] 	lda num_a
c2b1 : 7de7c2           [ 4] 	adc str_d_powers,x
c2b4 : 853b             [ 3] 	sta num_a
c2b6 : a53c             [ 3] 	lda num_a+1
c2b8 : 7de8c2           [ 4] 	adc str_d_powers+1,x
c2bb : 853c             [ 3] 	sta num_a+1
c2bd : b026             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c2bf : a549             [ 3] 	lda num_tmp+2
c2c1 : 6914             [ 2] 	adc #20
c2c3 : 8549             [ 3] 	sta num_tmp+2
c2c5 : 4c9ec2           [ 3] 	jmp str_d_process_digit
c2c8 :                       str_d_digits_done
                             	; check if minus
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank0.s --------------------------------

c2c8 : b147             [ 5] 	lda (num_tmp),y
c2ca : c92d             [ 2] 	cmp #'-'
c2cc : d011             [ 3] 	bne str_d_skip_neg
c2ce : a64a             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c2d0 : e002             [ 2] 	cpx #2				; else it's an error
c2d2 : 9011             [ 3] 	bcc str_d_error
c2d4 : a63b             [ 3] 	ldx num_a
c2d6 : a53c             [ 3] 	lda num_a+1
c2d8 : 204bc3           [ 6] 	jsr twos_complement
c2db : 863b             [ 3] 	stx num_a
c2dd : 853c             [ 3] 	sta num_a+1
c2df :                       str_d_skip_neg
c2df : a64a             [ 3] 	ldx num_tmp+3
c2e1 : a901             [ 2] 	lda #NUM_DEC
c2e3 : 18               [ 2] 	clc
c2e4 : 60               [ 6] 	rts
c2e5 :                       str_d_error
c2e5 : 38               [ 2] 	sec
c2e6 : 60               [ 6] 	rts
                             
c2e7 :                       str_d_powers
c2e7 : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c2fb : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c30f : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c323 : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c337 : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c34b :                       twos_complement
c34b : 49ff             [ 2] 	eor #0xff
c34d : 48               [ 3] 	pha
c34e : 8a               [ 2] 	txa
c34f : 49ff             [ 2] 	eor #0xff
c351 : aa               [ 2] 	tax
c352 : 68               [ 4] 	pla
c353 : e8               [ 2] 	inx
c354 : d003             [ 3] 	bne twos_complement_skip_X
c356 : 38               [ 2] 	sec			; Add 1 to A
c357 : 6900             [ 2] 	adc #0
c359 :                       twos_complement_skip_X
c359 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c35a :                       hex_to_bcd
c35a : 08               [ 3] 	php
c35b : 48               [ 3] 	pha
c35c : 8536             [ 3] 	sta tmp_d
c35e : 8a               [ 2] 	txa
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank0.s --------------------------------

c35f : 48               [ 3] 	pha
c360 : a536             [ 3] 	lda tmp_d
                             
c362 : 8647             [ 3] 	stx num_tmp
c364 : 8548             [ 3] 	sta num_tmp+1
c366 : c980             [ 2] 	cmp #0x80			; Negative?
c368 : 9003             [ 3] 	bcc hex_to_bcd_skip_neg
c36a : 204bc3           [ 6] 	jsr twos_complement
c36d :                       hex_to_bcd_skip_neg
c36d : a200             [ 2] 	ldx #0
c36f : 863b             [ 3] 	stx num_a
c371 : 863c             [ 3] 	stx num_a+1
c373 : 863d             [ 3] 	stx num_a+2
c375 : 863e             [ 3] 	stx num_a+3
c377 : a210             [ 2] 	ldx #16
c379 : f8               [ 2] 	sed
c37a :                       bin_to_bcd_bit
c37a : 0647             [ 5] 	asl num_tmp
c37c : 2648             [ 5] 	rol num_tmp+1
c37e : a53b             [ 3] 	lda num_a
c380 : 653b             [ 3] 	adc num_a
c382 : 853b             [ 3] 	sta num_a
c384 : a53c             [ 3] 	lda num_a+1
c386 : 653c             [ 3] 	adc num_a+1
c388 : 853c             [ 3] 	sta num_a+1
c38a : a53d             [ 3] 	lda num_a+2
c38c : 653d             [ 3] 	adc num_a+2
c38e : 853d             [ 3] 	sta num_a+2
c390 : ca               [ 2] 	dex
c391 : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c393 : 68               [ 4] 	pla
c394 : aa               [ 2] 	tax
c395 : 68               [ 4] 	pla
c396 : 28               [ 4] 	plp
c397 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c398 :                       bcd_to_str
                             	_pushAXY
                             
                             
c3a1 : a205             [ 2] 	ldx #5						; Index in to string
c3a3 : a000             [ 2] 	ldy #0						; Current BCD digit
c3a5 :                       bcd_str
c3a5 : b93b00           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
c3a8 : 48               [ 3] 	pha
c3a9 : 290f             [ 2] 	and #0xf
c3ab : 18               [ 2] 	clc
c3ac : 6930             [ 2] 	adc #0x30
c3ae : 954b             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
c3b0 : 68               [ 4] 	pla
c3b1 : 4a               [ 2] 	lsr a
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank0.s --------------------------------

c3b2 : 4a               [ 2] 	lsr a
c3b3 : 4a               [ 2] 	lsr a
c3b4 : 4a               [ 2] 	lsr a
c3b5 : 18               [ 2] 	clc
c3b6 : 6930             [ 2] 	adc #0x30					; Convert to ASCII
c3b8 : 954a             [ 4] 	sta num_buf-1,x
c3ba : ca               [ 2] 	dex
c3bb : ca               [ 2] 	dex
c3bc : c8               [ 2] 	iny
c3bd : c003             [ 2] 	cpy #3						; 3 BCD digits max
c3bf : d0e4             [ 3] 	bne bcd_str
                             
                             	_pullAXY
                             
c3c6 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
c3c7 :                       out_bcd
c3c7 : 48               [ 3] 	pha
c3c8 : 8a               [ 2] 	txa
c3c9 : 48               [ 3] 	pha
c3ca : 08               [ 3] 	php
c3cb : a000             [ 2] 	ldy #0						; How many digits printed
c3cd : a200             [ 2] 	ldx #0						; Index in to string
c3cf :                       out_bcd_digit
c3cf : b54b             [ 4] 	lda num_buf,x
c3d1 : c000             [ 2] 	cpy #0						; If not in leading zero mode
c3d3 : d008             [ 3] 	bne out_bcd_print			; No then go print
                             
c3d5 : c930             [ 2] 	cmp #'0'					; else check if zero
c3d7 : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
c3d9 : 28               [ 4] 	plp
c3da : 08               [ 3] 	php
c3db : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
c3dd :                       out_bcd_print
c3dd : c8               [ 2] 	iny
c3de : 204bc4           [ 6] 	jsr io_put_ch
c3e1 :                       out_bcd_next
c3e1 : e8               [ 2] 	inx
c3e2 : e006             [ 2] 	cpx #6
c3e4 : d0e9             [ 3] 	bne out_bcd_digit
c3e6 : c000             [ 2] 	cpy #0						; If nothing printed
c3e8 : d006             [ 3] 	bne out_bcd_fin
c3ea : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
c3ec : 204bc4           [ 6] 	jsr io_put_ch
c3ef : c8               [ 2] 	iny
c3f0 :                       out_bcd_fin
c3f0 : 28               [ 4] 	plp
c3f1 : 68               [ 4] 	pla
c3f2 : aa               [ 2] 	tax
c3f3 : 68               [ 4] 	pla
c3f4 : 18               [ 2] 	clc
c3f5 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank0.s --------------------------------

                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c3f6 :                       print_a_to_d
c3f6 : 08               [ 3] 	php
c3f7 : c980             [ 2] 	cmp #0x80					; Check if sign bit is set
c3f9 : 9014             [ 4] 	bcc print_a_to_d_skip_neg	; Skip if not (postive
c3fb : 204bc3           [ 6] 	jsr twos_complement			; Flip from 2s complement
c3fe : 205ac3           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c401 : 2098c3           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c404 : a92d             [ 2] 	lda #'-'
c406 : 204bc4           [ 6] 	jsr io_put_ch
c409 : 28               [ 4] 	plp							; Leading zeros preference
c40a : 20c7c3           [ 6] 	jsr out_bcd
c40d : c8               [ 2] 	iny							; Account for sign
c40e : 60               [ 6] 	rts
c40f :                       print_a_to_d_skip_neg
c40f : 205ac3           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c412 : 2098c3           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c415 : 28               [ 4] 	plp							; Leading zeros preference
c416 : 4cc7c3           [ 3] 	jmp out_bcd					; Print +ve string
                             	
                             	include "io\io.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.
                             ;*	On startup, the kernel defaults to keyboard an
                             ;*  examines the BBC DIP switch to decide whether
                             ;*	but when saving and loading points to tape rou
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c419 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank0.s --------------------------------

                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c419 :                       io_init
c419 : a901             [ 2] 	lda #1				; Default = KB/VDP
c41b : 8d0006           [ 4] 	sta io_default
c41e : 4c24c4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c421 :                       io_set_default			; Entry point for default
c421 : ad0006           [ 4] 	lda io_default
c424 :                       io_active_device		; Entry point for A set
c424 : 0a               [ 2] 	asl	a				; x16 the Block number
c425 : 0a               [ 2] 	asl a
c426 : 0a               [ 2] 	asl a
c427 : 0a               [ 2] 	asl a
c428 : a8               [ 2] 	tay
c429 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c42b :                       io_copy_data
c42b : b9aec4           [ 4] 	lda io_devices,y
c42e : 9d0106           [ 5] 	sta io_block,x
c431 : c8               [ 2] 	iny
c432 : e8               [ 2] 	inx
c433 : e010             [ 2] 	cpx #16
c435 : d0f4             [ 3] 	bne io_copy_data
                             	
c437 : a913             [ 2] 	lda #lo(scratch)	; Initialise IO buffer and size
c439 : 8537             [ 3] 	sta buf_lo
c43b : a906             [ 2] 	lda #hi(scratch)
c43d : 8538             [ 3] 	sta buf_hi
c43f : a9ff             [ 2] 	lda #255
c441 : 8539             [ 3] 	sta buf_sz
c443 : a90d             [ 2] 	lda #UTF_CR			; Line terminator is CR
c445 : 853a             [ 3] 	sta buf_ef
c447 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 0 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c448 :                       io_get_ch
c448 : 6c0106           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
c44b :                       io_put_ch
c44b : 6c0306           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c44e :                       io_open_read
c44e : 6c0506           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c451 :                       io_open_write
c451 : 6c0706           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c454 :                       io_close
c454 : 6c0906           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c457 :                       io_delete
c457 : 6c0b06           [ 6] 	jmp (io_block+io_del_f)
                             
                             ;****************************************
                             ;* io_open_ext1
                             ;* Extended function 1
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c45a :                       io_open_ext1
c45a : 6c0d06           [ 6] 	jmp (io_block+io_ext1)
                             	
                             ;****************************************
                             ;* io_open_ext2
                             ;* Extended function 2
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c45d :                       io_open_ext2
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank0.s --------------------------------

c45d : 6c0f06           [ 6] 	jmp (io_block+io_ext2)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c460 :                       io_read_line
c460 : 48               [ 3] 	pha
                             
c461 : 08               [ 3] 	php					; Save echo state
                             	
c462 : a000             [ 2] 	ldy #0x00			; Starting at first byte
c464 :                       io_get_line_byte
c464 : 38               [ 2] 	sec					; Getting bytes synchronously
c465 : 2048c4           [ 6] 	jsr io_get_ch		; Get a byte
c468 : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c46a : 28               [ 4] 	plp					; Get echo state
c46b : 08               [ 3] 	php					; Instantly save it back
c46c : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c46e : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c470 : d005             [ 3] 	bne io_do_echo
c472 : c000             [ 2] 	cpy #0				; Already at beginning?
c474 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c476 : 88               [ 2] 	dey					; Else decrement length
c477 :                       io_do_echo
c477 : 204bc4           [ 6] 	jsr io_put_ch		; Echo it
c47a :                       io_skip_echo
c47a : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c47c : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c47e : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c480 : f003             [ 3] 	beq io_skip_special
c482 : 9137             [ 5] 	sta (buf_lo),y		; Save it
c484 : c8               [ 2] 	iny					; Increase length
c485 :                       io_skip_special
c485 : c53a             [ 3] 	cmp buf_ef			; Is it the terminating char?
c487 : f008             [ 3] 	beq io_get_line_done	; If yes then done
c489 : c439             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c48b : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c48d : 28               [ 4] 	plp					; Remember to pull echo state off stack
c48e : 38               [ 2] 	sec					; Yes, set carry flag
c48f : 68               [ 4] 	pla
c490 : 60               [ 6] 	rts					; And done
c491 :                       io_get_line_done
c491 : a900             [ 2] 	lda #0
c493 : 9137             [ 5] 	sta (buf_lo),y		; Terminate with 0
c495 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c496 : 18               [ 2] 	clc					; Clear carry flag
c497 : 68               [ 4] 	pla
c498 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c499 :                       io_print_line
c499 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank0.s --------------------------------

                             
c49a : 8634             [ 3] 	stx tmp_clo					; Store the string pointer
c49c : 8535             [ 3] 	sta tmp_chi					; lo and hi
c49e : a000             [ 2] 	ldy #0						; Start at the beginning!
c4a0 :                       io_print_line_byte
c4a0 : b134             [ 5] 	lda (tmp_clo),y				; Copy byte to
c4a2 : f006             [ 3] 	beq io_print_done			; If zero then done - print
c4a4 : 204bc4           [ 6] 	jsr io_put_ch				; Transmit
c4a7 : c8               [ 2] 	iny
c4a8 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c4aa :                       io_print_done
c4aa : 68               [ 4] 	pla
c4ab : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c4ac :                       io_null_op
c4ac : 18               [ 2] 	clc
c4ad : 60               [ 6] 	rts
                             	
                             ;* IO devices defined here
c4ae :                       io_devices
                             ;* Device zero is the tape system
                             ;* only offers get and put
                             ;* This is a block based device
c4ae :                       io_device0					; Tape device, input = Tape, outpu
c4ae : f3c6                  	dw	tp_get_byte			; io_get_ch
c4b0 : 1ac6                  	dw	tp_put_byte			; io_put_ch
c4b2 : 83c5                  	dw	tp_open_read		; io_open_r
c4b4 : d4c5                  	dw	tp_open_write		; io_open_w
c4b6 : b6c5                  	dw	tp_close			; io_close_f
c4b8 : acc4                  	dw	io_null_op			; io_del_f
c4ba : 83c5                  	dw	tp_open_bread		; io_ext1 - open for binary re
c4bc : cec5                  	dw	tp_open_bwrite		; io_ext2 - open for binary w
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
                             ;* This is a char based device
c4be :                       io_device1					; Default device, input = screen e
c4be : b8ce                  	dw	gr_get_key			; io_get_ch
c4c0 : eece                  	dw	gr_put_byte			; io_put_ch
c4c2 : acc4                  	dw	io_null_op			; io_open_r
c4c4 : acc4                  	dw	io_null_op			; io_open_w
c4c6 : acc4                  	dw	io_null_op			; io_close_f
c4c8 : acc4                  	dw	io_null_op			; io_del_f
c4ca : acc4                  	dw	io_null_op			; io_ext1
c4cc : acc4                  	dw	io_null_op			; io_ext2
                             ;* Serial device using printer port ACK (input) a
                             ;* This is a char based device
                             ;io_device2					; Serial device, input = Ser, out
                             ;	dw	ser_get_byte		; io_get_ch
                             ;	dw	ser_put_byte		; io_put_ch
                             ;	dw	ser_open			; io_open_r
                             ;	dw	ser_open			; io_open_w
                             ;	dw	ser_close			; io_close_f
                             ;	dw	io_null_op			; io_del_f
                             ;	dw	io_null_op			; io_ext1
                             ;	dw	io_null_op			; io_ext2
                             
c4ce :                       mod_sz_io_e
                             
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank0.s --------------------------------

                             ;* Reset vector points here - 6502 starts here
c4ce :                       init
                             ;	jmp init_test
                             	; First clear ram
c4ce : 78               [ 2] 	sei					; Need this for MOS 6502
c4cf : d8               [ 2] 	cld					; Need this for MOS 6502
c4d0 : 4cfac4           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c4d3 :                       init_2					; init_ram will jump back to here
c4d3 : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c4d5 : 9a               [ 2] 	txs
                             	
c4d6 : 20dcc4           [ 6] 	jsr kernel_init
                             
c4d9 : 4c4bc0           [ 3] 	jmp main
                             
c4dc :                       kernel_init
c4dc : 20bec0           [ 6] 	jsr init_irq		; Initialise IRQ handling
                             	
c4df : 201cc5           [ 6] 	jsr init_via0		; initialise cia 0 - tape inactiv
c4e2 : 206bc5           [ 6] 	jsr tp_init			; Initialise tape handling
                             
c4e5 :                       kernel_test
c4e5 : 20cad3           [ 6] 	jsr init_snd		; initialise the sound chip
                             
c4e8 : 2041cc           [ 6] 	jsr gr_init			; Initialise graphics, default is 
                             	
c4eb : 205ec7           [ 6] 	jsr init_keyboard	; initialise keyboard timer se
c4ee : 2019c4           [ 6] 	jsr io_init			; Set default input/output device
                             
c4f1 : a900             [ 2] 	lda #0
c4f3 : 8508             [ 3] 	sta vdp_cnt
                             
c4f5 : 2069f7           [ 6] 	jsr df_init			; Initialise interpreter
                             
c4f8 : 58               [ 2] 	cli					; irq interrupts enable
                             
c4f9 : 60               [ 6] 	rts
                             
                             	
                             ;* Initialises RAM, skipping page 3 which is for 
                             ;* Zeroes all addressable RAM in the default bank
c4fa :                       init_ram
c4fa : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c4fc : a200             [ 2] 	ldx #0x00			; Page counter starts at zero
c4fe : 8600             [ 3] 	stx 0x00			; Start at page 0
c500 : 8601             [ 3] 	stx 0x01
c502 :                       init_ram_1
c502 : e003             [ 2] 	cpx	#3				; Ignore page 3 (IO page)
c504 : f004             [ 3] 	beq init_ram_skip
c506 :                       init_ram_fill
c506 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c508 : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c50a :                       init_ram_skip
c50a : c8               [ 2] 	iny
c50b : d0f5             [ 3] 	bne init_ram_1		; Do a whole page
c50d : e601             [ 5] 	inc 0x01			; Increase page pointer
c50f : e8               [ 2] 	inx					; Reduce page count
c510 : e0c0             [ 2] 	cpx #0xc0			; Do all pages until page until we g
c512 : d0ee             [ 3] 	bne init_ram_1
                             	
c514 : 4cd3c4           [ 3] 	jmp init_2			; Carry on initialisation
                             
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank0.s --------------------------------

                             ; 6502 Non-maskable interrupt come here
c517 :                       nmi
c517 : 40               [ 6] 	rti
                             
c518 :                       mod_sz_kernel_e
                             
                             
                             	
                             ; Bank specific code goes here
                             	include "cia\cia.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  CIA.S
                             ;*  Code to initialise and utilise the 6522, whic
                             ;*	for various functions on the Oric including;
                             ;*		Port A:
                             ;*			[7..0] 	Printer data bits
                             ;*			[7..0] 	Interface to AY-3-8912
                             ;*		Port B:
                             ;*			[2..0] 	Keyboard matrix row selector
                             ;*			[7]	   	Tape output
                             ;*			[6]    	Tape player motor signal
                             ;*			[4]		Printer strobe
                             ;*		CA1:		Printer ACK
                             ;*		CB1: 		Tape input
                             ;*		CA2,CB2: 	Selecting the AY-3-8912
                             ;*
                             ;*  This file is called cia.s because code was or
                             ;*  for a MOS 6526 from a CMB64, but didn't get a
                             ;*	renaming this file ;-)
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
c518 :                       mod_sz_cia_s
                             	
                             
                             ;****************************************
                             ;* init_via0
                             ;* Initialise cia 0
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
                             ;init_via0_ser					; initialisation bytes for ser
                             ;	ldy #init_ser_tab-init_via0_tab
                             ;	bne init_via0_loop			; always branch
c518 :                       init_via0_tape					; initialisation bytes for tap
c518 : a017             [ 2] 	ldy #init_tape_tab-init_via0_tab
c51a : d002             [ 3] 	bne init_via0_loop			; always branch
c51c :                       init_via0
c51c : a000             [ 2] 	ldy #0						; Standard initialisation of VIA
c51e :                       init_via0_loop
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank0.s --------------------------------

c51e : b92fc5           [ 4] 	lda init_via0_tab,y
c521 : 300b             [ 3] 	bmi init_via0_done
c523 : aa               [ 2] 	tax
c524 : c8               [ 2] 	iny
c525 : b92fc5           [ 4] 	lda init_via0_tab,y
c528 : 9d0003           [ 5] 	sta IO_0,x
c52b : c8               [ 2] 	iny
c52c : d0f0             [ 3] 	bne init_via0_loop
                             	
c52e :                       init_via0_done	
c52e : 60               [ 6] 	rts							; return from sub
                             	
c52f :                       init_via0_tab
c52f : 0e7f                  	db IER, 	0x7f
c531 : 03ff                  	db DDRA,	0xff
c533 : 02f7                  	db DDRB,	0xf7			; Tape motor + KB select
c535 : 00b7                  	db PRB,		0xb7			; Port B default = cassette moto
c537 : 0cdd                  	db PCR,		0xdd			; Ensure AY is not selected (CB1
c539 : 0420                  	db T1CL,	lo(TIMER1_RATE)	; 50Hz
c53b : 0620                  	db T1LL,	lo(TIMER1_RATE)	; 50Hz
c53d : 054e                  	db T1CH,	hi(TIMER1_RATE)	; 50Hz
c53f : 074e                  	db T1LH,	hi(TIMER1_RATE)	; 50Hz
c541 : 0b40                  	db ACR,		0x40			; Timer 1 continuous
c543 : 0ec0                  	db IER,		0xc0			; Timer 1 interrupt enabled
c545 : ff                    	db -1
c546 :                       init_tape_tab
c546 : 0e7f                  	db IER,		0x7f			; Disable all interrupts
c548 : 08f4                  	db T2CL,	0xf4			; Timer 2 used for measuring CB1
c54a : 0c10                  	db PCR,		0x10			; Interrupt on CB1 positive edge
                             ;	db DDRB,	0xff			; Set port B output
c54c : 0bc0                  	db ACR,		0xc0			; T1 continuous and toggle PB7
c54e : 04a0                  	db T1CL,	lo(TAPE_RATE*2)	; Tape rate /2 = 0
c550 : 0501                  	db T1CH,	hi(TAPE_RATE*2)	; Tape rate /2 = 0
c552 : 0040                  	db PRB,		0x40			; Tape motor ON
c554 : ff                    	db -1
                             ;init_ser_tab
                             ;	db IER,		0x7f			; Disable all interrupts
                             ;	db T2CL,	0xf4			; Timer 2 used for measuring bi
                             ;	db PCR,		0xdd			; Ensure AY is not selected (CB
                             ;	db DDRB,	0xff			; Set port B output
                             ;	db -1
                             	
c555 :                       mod_sz_cia_e
                             
                             	include "tape\tape.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TAPE.S
                             ;*	These routines allow for tape input/output
                             ;*	The tape format is not compatible with a regul
                             ;*	but is a block format as follows;
                             ;*	Some zero bits (64) start a block.
                             ;*	Then two bytes of data representing the block 
                             ;*	Then 256 bytes of block data.
                             ;*	Each byte above consists of two '1' start bits
                             ;*	one '0' stop bit.
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank0.s --------------------------------

                             ;*	After each block, 1 second of 4800Hz (seen as 
                             ;*	is transmitted to allow the CPU to deal with t
                             ;*	when subsequently loading.
                             ;*	A bit is 4800Hz half cycle then 4800Hz half cy
                             ;*	'1' or 2400Hz half cycle for a '0', except for
                             ;*	block which is one second of 2400Hz.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c555 :                       tp_open_msg
c555 : 4c6f6164696e67..      	db	"Loading:",0
c55e :                       tp_save_msg
c55e : 536176696e673a00      	db	"Saving:",0
c566 :                       tp_back4
c566 : 0808080800            	db	8,8,8,8,0
                             	
                             ;* tp_init
                             ;* Basic initialisation for tape handling
c56b :                       tp_init
c56b : a900             [ 2] 	lda #0
c56d : 8556             [ 3] 	sta tp_flag
c56f : 8555             [ 3] 	sta tp_idx
c571 : 18               [ 2] 	clc
c572 : 60               [ 6] 	rts
                             
                             ;* Common function to open tape
c573 :                       tp_open_common				; Used by open write too
c573 : 78               [ 2] 	sei						; Interrupts disabled from here..
c574 : 2018c5           [ 6] 	jsr init_via0_tape		; Get ready to output (tape 
                             
                             
c577 : a200             [ 2] 	ldx #0
c579 : 8655             [ 3] 	stx tp_idx				; Initialise block
c57b : 8653             [ 3] 	stx tp_block
c57d : 8654             [ 3] 	stx tp_block+1
c57f : e8               [ 2] 	inx
c580 : 8656             [ 3] 	stx tp_flag				; assume 1 = Read mode
c582 : 60               [ 6] 	rts
                             
                             ;* tp_open_read
                             ;* Open tape settings
                             
c583 :                       fd_cload_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c583 :                       tp_open_bread
c583 :                       tp_open_read
c583 : a055             [ 2] 	ldy #lo(tp_open_msg)
c585 : a9c5             [ 2] 	lda #hi(tp_open_msg)
c587 : 2041cf           [ 6] 	jsr gr_print_msg
                             	
c58a : 2073c5           [ 6] 	jsr tp_open_common
                             
c58d :                       tp_get_fname_start
c58d : 202fc7           [ 6] 	jsr tp_read_byte
c590 : c924             [ 2] 	cmp #'$'				; Find the $ symbol
c592 : d0f9             [ 3] 	bne tp_get_fname_start
                             	
c594 : a209             [ 2] 	ldx #9					; 9 byte header - skip
c596 :                       tp_get_header
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank0.s --------------------------------

c596 : 202fc7           [ 6] 	jsr tp_read_byte
c599 : ca               [ 2] 	dex
c59a : d0fa             [ 3] 	bne tp_get_header
                             	
                             	; X= zero here, now get null terminated filename
c59c :                       tp_get_fname
c59c : 202fc7           [ 6] 	jsr tp_read_byte
c59f : 9d0004           [ 5] 	sta df_linbuff,x
c5a2 : e8               [ 2] 	inx
c5a3 : c900             [ 2] 	cmp #0
c5a5 : d0f5             [ 3] 	bne tp_get_fname
                             
c5a7 : a000             [ 2] 	ldy #lo(df_linbuff)
c5a9 : a904             [ 2] 	lda #hi(df_linbuff)
c5ab : 2041cf           [ 6] 	jsr gr_print_msg
c5ae : a920             [ 2] 	lda #' '
c5b0 : 20eece           [ 6] 	jsr gr_put_byte
                             
c5b3 : 18               [ 2] 	clc
c5b4 : 60               [ 6] 	rts
                             
c5b5 :                       tt_getsync_pc				; ** FOR ORICUTRON EMULATOR **
c5b5 :                       tt_getsync_end_pc			; ** FOR ORICUTRON EMULATOR *
                             
c5b5 : ea               [ 2] 	nop
                             	
                             
                             ;* tp_close
                             ;* Close tape settings
c5b6 :                       tp_close
c5b6 : a556             [ 3] 	lda tp_flag
c5b8 : c902             [ 2] 	cmp #2					; Write mode?
c5ba : d003             [ 3] 	bne tp_close_no_flush	; If not no need to flush
c5bc : 204cc6           [ 6] 	jsr tp_put_block		; Flush the current block
c5bf :                       tp_close_no_flush
c5bf : a90d             [ 2] 	lda #0x0d				; Line feed
c5c1 : 20eece           [ 6] 	jsr gr_put_byte
                             	
c5c4 : 201cc5           [ 6] 	jsr init_via0			; Back to normal
c5c7 : 58               [ 2] 	cli
c5c8 : a900             [ 2] 	lda #0					; Zero tape flag
c5ca : 8556             [ 3] 	sta tp_flag
                             
c5cc :                       tt_csave_end_pc				; ** FOR ORICUTRON EMULATOR **
                             
c5cc : 18               [ 2] 	clc
c5cd : 60               [ 6] 	rts
                             
                             ;* tp_open_write
                             ;* Open tape settings
c5ce :                       tp_open_bwrite
c5ce : a001             [ 2] 	ldy #hi(0x101)
c5d0 : a201             [ 2] 	ldx #lo(0x101)
c5d2 : d004             [ 3] 	bne tp_open_write_start
c5d4 :                       tp_open_write
c5d4 : a018             [ 2] 	ldy #hi(6000+0x101)
c5d6 : a271             [ 2] 	ldx #lo(6000+0x101)
                             
c5d8 :                       fd_csave_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c5d8 :                       tp_open_write_start
c5d8 : 8458             [ 3] 	sty tp_delay+1
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank0.s --------------------------------

c5da : 8657             [ 3] 	stx tp_delay
c5dc : a05e             [ 2] 	ldy #lo(tp_save_msg)
c5de : a9c5             [ 2] 	lda #hi(tp_save_msg)
c5e0 : 2041cf           [ 6] 	jsr gr_print_msg
c5e3 : a000             [ 2] 	ldy #lo(df_linbuff)
c5e5 : a904             [ 2] 	lda #hi(df_linbuff)
c5e7 : 2041cf           [ 6] 	jsr gr_print_msg
c5ea : a920             [ 2] 	lda #' '
c5ec : 20eece           [ 6] 	jsr gr_put_byte
                             	
c5ef : 2073c5           [ 6] 	jsr tp_open_common		; Same as reading but
c5f2 : e656             [ 5] 	inc tp_flag				; Make flag = 2 for write mode
                             
c5f4 :                       tt_writeleader_pc			; ** FOR ORICUTRON EMULATOR *
c5f4 :                       tt_writeleader_end_pc		; ** FOR ORICUTRON EMULATO
c5f4 : a280             [ 2] 	ldx #128				; 128 low bits
c5f6 : 2044c6           [ 6] 	jsr tp_put_delay
                             
c5f9 : a924             [ 2] 	lda #'$'				; Start of header symbol
c5fb : 38               [ 2] 	sec
c5fc : 209bc6           [ 6] 	jsr tp_write_byte
                             	
c5ff : a209             [ 2] 	ldx #9					; Header, for future expansion
c601 : a9ff             [ 2] 	lda #0xff
c603 :                       tp_write_header	
c603 : 38               [ 2] 	sec
c604 : 209bc6           [ 6] 	jsr tp_write_byte
c607 : ca               [ 2] 	dex
c608 : d0f9             [ 3] 	bne tp_write_header
                             	
c60a : a200             [ 2] 	ldx #0
c60c :                       tp_write_fname
c60c : bd0004           [ 4] 	lda df_linbuff,x		; Put the filename
c60f : 38               [ 2] 	sec
c610 : 209bc6           [ 6] 	jsr tp_write_byte
c613 : e8               [ 2] 	inx
c614 : c900             [ 2] 	cmp #0
c616 : d0f4             [ 3] 	bne tp_write_fname
                             	
c618 : 18               [ 2] 	clc
c619 : 60               [ 6] 	rts
                             
                             
                             ;* tp_put_byte
                             ;* Put to byte to tape - if got a block then save
                             
c61a :                       tp_put_byte
c61a : 48               [ 3] 	pha
c61b : 8536             [ 3] 	sta tmp_d
c61d : 8a               [ 2] 	txa
c61e : 48               [ 3] 	pha
c61f : 98               [ 2] 	tya
c620 : 48               [ 3] 	pha
c621 : a536             [ 3] 	lda tmp_d
                             	
c623 : a455             [ 3] 	ldy tp_idx				; Save byte to buffer
c625 : 990002           [ 5] 	sta tp_buf,y
c628 : c8               [ 2] 	iny
c629 : 8455             [ 3] 	sty tp_idx
c62b : d010             [ 3] 	bne tp_put_byte_done
c62d : 204cc6           [ 6] 	jsr tp_put_block		; Flush block to tape
c630 : 18               [ 2] 	clc						; Increment block #
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank0.s --------------------------------

c631 : a553             [ 3] 	lda tp_block
c633 : 6901             [ 2] 	adc #1
c635 : 8553             [ 3] 	sta tp_block
c637 : a554             [ 3] 	lda tp_block+1
c639 : 6900             [ 2] 	adc #0
c63b : 8554             [ 3] 	sta tp_block+1
c63d :                       tp_put_byte_done
c63d : 68               [ 4] 	pla
c63e : a8               [ 2] 	tay
c63f : 68               [ 4] 	pla
c640 : aa               [ 2] 	tax
c641 : 68               [ 4] 	pla
c642 : 18               [ 2] 	clc
c643 : 60               [ 6] 	rts
                             
                             ; tp_put_delay
                             ;* X = number of zero bits to insert
c644 :                       tp_put_delay
c644 : 18               [ 2] 	clc
c645 : 20bec6           [ 6] 	jsr tp_write_bit
c648 : ca               [ 2] 	dex
c649 : d0f9             [ 3] 	bne tp_put_delay
c64b : 60               [ 6] 	rts
                             
                             ;* tp_put_block
                             ;* flush a block to tape
c64c :                       tp_put_block
c64c : 2070c6           [ 6] 	jsr tp_print_block
                             		
c64f : a280             [ 2] 	ldx #128				; 128 low bits
c651 : 2044c6           [ 6] 	jsr tp_put_delay
                             
c654 : a553             [ 3] 	lda tp_block			; Save block number low then high
c656 : 18               [ 2] 	clc
c657 : 209bc6           [ 6] 	jsr tp_write_byte
c65a : a554             [ 3] 	lda tp_block+1
c65c : 38               [ 2] 	sec
c65d : 209bc6           [ 6] 	jsr tp_write_byte
                             
c660 : a200             [ 2] 	ldx #0
c662 :                       tp_put_block_bytes
c662 : bd0002           [ 4] 	lda tp_buf,x			; Then write out all bytes in blo
c665 : 18               [ 2] 	clc
c666 : 209bc6           [ 6] 	jsr tp_write_byte
c669 : e8               [ 2] 	inx
c66a : d0f6             [ 3] 	bne tp_put_block_bytes	; Always 256 bytes
                             	
c66c : 2090c6           [ 6] 	jsr tp_block_gap		; Wait a while, still outputti
                             
c66f : 60               [ 6] 	rts
                             
                             ; tp_print_block
c670 :                       tp_print_block
c670 : a554             [ 3] 	lda tp_block+1			; Print block number hi byte
c672 : 2089c1           [ 6] 	jsr str_a_to_x
c675 : 20eece           [ 6] 	jsr gr_put_byte
c678 : 8a               [ 2] 	txa
c679 : 20eece           [ 6] 	jsr gr_put_byte
c67c : a553             [ 3] 	lda tp_block			; Print block number lo byte
c67e : 2089c1           [ 6] 	jsr str_a_to_x
c681 : 20eece           [ 6] 	jsr gr_put_byte
c684 : 8a               [ 2] 	txa
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank0.s --------------------------------

c685 : 20eece           [ 6] 	jsr gr_put_byte
c688 : a9c5             [ 2] 	lda #hi(tp_back4)		; Go back 4 characters to pri
c68a : a066             [ 2] 	ldy #lo(tp_back4)
c68c : 2041cf           [ 6] 	jsr gr_print_msg
c68f : 60               [ 6] 	rts
                             
                             ; tp_block_gap
                             ; Send 2400 bits of zero ~ 1.5 seconds
                             ; add 0x101 due to how counters decrement
                             ; For binary mode it is just 1 bit gap
c690 :                       tp_block_gap
c690 : a458             [ 3] 	ldy tp_delay+1
c692 : a657             [ 3] 	ldx tp_delay
c694 :                       tp_block_gap_1
c694 : 2044c6           [ 6] 	jsr tp_put_delay
c697 : 88               [ 2] 	dey
c698 : d0fa             [ 3] 	bne tp_block_gap_1
c69a : 60               [ 6] 	rts	
                             
                             ;* tp_write_byte
                             ;* Write a byte to tape which looks like this
                             ;* 11xxxxxxxx0
c69b :                       tt_putbyte_pc				; ** FOR ORICUTRON EMULATOR **
c69b :                       tp_write_byte
c69b : 48               [ 3] 	pha
c69c : 08               [ 3] 	php
c69d : 38               [ 2] 	sec					; 1 for start bit
c69e : 20bec6           [ 6] 	jsr tp_write_bit
c6a1 : 38               [ 2] 	sec					; 1 for start bit
c6a2 : 20bec6           [ 6] 	jsr tp_write_bit
c6a5 : a008             [ 2] 	ldy #8				; 8 bits of data
c6a7 :                       tp_write_byte_bit
c6a7 : 6a               [ 2] 	ror a
c6a8 : 20bec6           [ 6] 	jsr tp_write_bit
c6ab : 88               [ 2] 	dey
c6ac : d0f9             [ 3] 	bne tp_write_byte_bit
c6ae : 18               [ 2] 	clc					; 0 for stop bit
c6af : 20bec6           [ 6] 	jsr tp_write_bit
c6b2 : 28               [ 4] 	plp
c6b3 : 9007             [ 3] 	bcc tp_write_byte_nodelay
c6b5 : 8a               [ 2] 	txa
c6b6 : a220             [ 2] 	ldx #32					; Delays needed
c6b8 : 2044c6           [ 6] 	jsr tp_put_delay
c6bb : aa               [ 2] 	tax
c6bc :                       tp_write_byte_nodelay
c6bc : 68               [ 4] 	pla
c6bd :                       tt_putbyte_end_pc			; ** FOR ORICUTRON EMULATOR *
c6bd : 60               [ 6] 	rts
                             	
                             
                             ;* tp_write_bit
                             ;* Write a bit in C to tape which looks like this
                             ;* Half cycle of 4800Hz, then
                             ;*		half cycle of 4800Hz for a 1
                             ;*		half cycle of 2400Hz for a 0
c6be :                       tp_write_bit
c6be : 48               [ 3] 	pha
c6bf : 8a               [ 2] 	txa
c6c0 : 48               [ 3] 	pha
c6c1 : 08               [ 3] 	php						; Save the bit to be stored
                             
c6c2 : a9d0             [ 2] 	lda #TAPE_RATE			; Half cycle first of 4800Hz
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank0.s --------------------------------

c6c4 : a200             [ 2] 	ldx #0
c6c6 : 8d0603           [ 4] 	sta IO_0+T1LL
c6c9 : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c6cc : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c6cf :                       tp_write_bit_chk1
c6cf : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c6d2 : 50fb             [ 3] 	bvc tp_write_bit_chk1	; V=0? Keep checking
c6d4 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
                             	
c6d7 : 28               [ 4] 	plp						; Get the bit to be stored
c6d8 : a9d0             [ 2] 	lda #TAPE_RATE			; Assume putting out a 1 in 2nd
c6da : b002             [ 3] 	bcs tp_write_bit_t1		; A zero is half the rate (
c6dc : 0a               [ 2] 	asl	a					; TAPE_RATE * 2 need to inc X
c6dd : e8               [ 2] 	inx
c6de :                       tp_write_bit_t1
c6de : 8d0603           [ 4] 	sta IO_0+T1LL
c6e1 : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c6e4 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c6e7 :                       tp_write_bit_chk2
c6e7 : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c6ea : 50fb             [ 3] 	bvc tp_write_bit_chk2	; V=0? Keep checking
c6ec : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
c6ef : 68               [ 4] 	pla
c6f0 : aa               [ 2] 	tax
c6f1 : 68               [ 4] 	pla
c6f2 : 60               [ 6] 	rts
                             
                             
                             
                             ;* tp_get_byte
                             ;* Get a byte from buffer - load blocks as needed
c6f3 :                       tp_get_byte
c6f3 : 8a               [ 2] 	txa
c6f4 : 48               [ 3] 	pha
c6f5 : 98               [ 2] 	tya
c6f6 : 48               [ 3] 	pha
                             	
c6f7 : a455             [ 3] 	ldy tp_idx				; Index in to buffer
c6f9 : d005             [ 4] 	bne tp_get_byte_buf		; No need to load from tape
c6fb : 2010c7           [ 6] 	jsr tp_get_block		; Else load a block from tape
c6fe : a000             [ 2] 	ldy #0					; 0 index is now valid
c700 :                       tp_get_byte_buf
c700 : b90002           [ 4] 	lda tp_buf,y			; Get from memory buffer
c703 : c8               [ 2] 	iny
c704 : 8455             [ 3] 	sty tp_idx				; Never zero on leaving
c706 : 8536             [ 3] 	sta tmp_d
c708 : 68               [ 4] 	pla
c709 : a8               [ 2] 	tay
c70a : 68               [ 4] 	pla
c70b : aa               [ 2] 	tax
c70c : a536             [ 3] 	lda tmp_d
c70e : 18               [ 2] 	clc
c70f : 60               [ 6] 	rts						; Except when buffer done
                             
                             ;* tp_get_block
                             ;* Load a block in to memory
c710 :                       tp_get_block
                             
c710 : 202fc7           [ 6] 	jsr tp_read_byte		; Get block number
c713 : 8553             [ 3] 	sta tp_block
c715 : 202fc7           [ 6] 	jsr tp_read_byte
c718 : 8554             [ 3] 	sta tp_block+1
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank0.s --------------------------------

                             	
c71a : 2070c6           [ 6] 	jsr tp_print_block
                             	
c71d : a000             [ 2] 	ldy #0
c71f : 8455             [ 3] 	sty tp_idx
c721 :                       tp_get_block_bytes
c721 : 202fc7           [ 6] 	jsr tp_read_byte		; Fill buffer
c724 : a455             [ 3] 	ldy tp_idx
c726 : 990002           [ 5] 	sta tp_buf,y
c729 : c8               [ 2] 	iny
c72a : 8455             [ 3] 	sty tp_idx
c72c : d0f3             [ 3] 	bne tp_get_block_bytes	; Always 256 bytes
                             
c72e : 60               [ 6] 	rts
                             	
                             
                             ;* tp_read_byte
                             ;* Read a byte from tape, always expects one '1' 
c72f :                       tt_readbyte_pc				; ** FOR ORICUTRON EMULATOR **
c72f :                       tp_read_byte
c72f :                       tp_read_byte_st
c72f : 2043c7           [ 6] 	jsr tp_read_bit			; Expecting a 1
c732 : 90fb             [ 3] 	bcc tp_read_byte_st
c734 : 2043c7           [ 6] 	jsr tp_read_bit			; Should be another 1
c737 : 90f6             [ 3] 	bcc tp_read_byte_st
                             	; Ok got 2 start
                             	
c739 : a008             [ 2] 	ldy #8				; Get 8 bits
c73b :                       tp_read_byte_bits
c73b : 2043c7           [ 6] 	jsr tp_read_bit
c73e : 6a               [ 2] 	ror a
c73f : 88               [ 2] 	dey
c740 : d0f9             [ 3] 	bne tp_read_byte_bits
                             	; Byte is in A, stop bit is not waited for..
c742 :                       tt_readbyte_end_pc			; ** FOR ORICUTRON EMULATOR 
c742 : 60               [ 6] 	rts
                             
                             ;* tp_read_bit
                             ;* Get a CB1 transition and measure the time
                             ;* The measurement indicates a 1 or 0 received
c743 :                       tp_read_bit
c743 : 48               [ 3] 	pha
c744 : ad0003           [ 4] 	lda IO_0+PRB			; Clear CB1 interrupt flag by rea
c747 :                       tp_read_bit_cb1
c747 :                       tt_getsync_loop_pc			; ** FOR ORICUTRON EMULATOR 
c747 : ad0d03           [ 4] 	lda IO_0+IFR
c74a : 2910             [ 2] 	and #IFR_CB1
c74c : f0f9             [ 3] 	beq tp_read_bit_cb1		; Keep checking until CB1 a
                             
c74e : ad0903           [ 4] 	lda IO_0+T2CH			; Get the high byte of T2 counte
c751 : 48               [ 3] 	pha
c752 : a9ff             [ 2] 	lda #0xff				; Reset T2 counter high byte
c754 : 8d0903           [ 4] 	sta IO_0+T2CH			; Reset high byte of T2 counter
c757 : 68               [ 4] 	pla						; What was previous counter?
                             ;	beq tp_io_error			; If down to zero, then some 
c758 : c9fe             [ 2] 	cmp #0xfe				; C=1 if T2 >= 0xfe else C=0
c75a : 68               [ 4] 	pla
c75b : 60               [ 6] 	rts						; Carry contains the bit received
c75c :                       tp_io_error
                             	SWBRK DFERR_BREAK		; DEFINE A NEW ERROR!
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             	include "keyboard\keyboard.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KEYBOARD.S
                             ;*	Keyboard driver code. It is very slow to scan 
                             ;*	routines here do a basic scan for any key befo
                             ;*	the specific key. Still, it has a noticeable i
                             ;*	CPU especially in dflat which checks the key a
                             ;*	keyword is executed.
                             ;*	Rather than working off interrupts these routi
                             ;*	need to be called as needed. The T1 interrupt 
                             ;*	track of keyboard timers for repeat delay and 
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_keyboard
                             ;* Initialise the keyboard settings
                             ;****************************************
c75e :                       init_keyboard
c75e : a914             [ 2] 	lda #KB_REP_DEL
c760 : 852f             [ 3] 	sta kb_rdel_tim
c762 : a903             [ 2] 	lda #KB_REP_TIM
c764 : 852e             [ 3] 	sta kb_rep_tim
c766 : a902             [ 2] 	lda #KB_DEBOUNCE
c768 : 852c             [ 3] 	sta kb_deb_tim
c76a : a900             [ 2] 	lda #0
c76c : 852a             [ 3] 	sta kb_stat
                             
c76e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_stick
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
                             ;* Returns bit mask of keys pressed
                             ;****************************************
c76f :                       kb_stick
c76f : a900             [ 2] 	lda #0					; Result will be in A
c771 : 48               [ 3] 	pha	
                             	; Select Row 4 only, all keys on this row
c772 : a904             [ 2] 	lda #4
c774 : 8d0003           [ 4] 	sta IO_0+PRB
c777 : a004             [ 2] 	ldy #4
c779 : a20e             [ 2] 	ldx #SND_REG_IOA		; AY Port A for columns
c77b :                       kb_stick_pos
c77b : b90cc9           [ 4] 	lda kb_stick_mask,y		; Get the column mask
c77e : 2000c0           [ 6] 	jsr snd_set				; Activate column
c781 : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
c784 : 2908             [ 2] 	and #KB_SENSE			; Something pressed?
c786 : c908             [ 2] 	cmp #KB_SENSE			; C=1 if set else 0
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank0.s --------------------------------

c788 : 68               [ 4] 	pla
c789 : 2a               [ 2] 	rol a					; Get C in to A
c78a : 48               [ 3] 	pha
c78b : 88               [ 2] 	dey
c78c : 10ed             [ 3] 	bpl kb_stick_pos		; Do all 5 positions
c78e : 68               [ 4] 	pla						; Result in A
c78f : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* kb_any_key
                             ;* Quick check for any key except shifts & ctrl
                             ;* Carry = 1 means key pressed
                             ;****************************************
c790 :                       kb_any_key
                             	; Select all columns except 4
c790 : a910             [ 2] 	lda #0b00010000			; Deselect only col 4
c792 : a20e             [ 2] 	ldx #SND_REG_IOA		; On AY port A
c794 : 2000c0           [ 6] 	jsr snd_set
                             
c797 : a007             [ 2] 	ldy #7					; Start from row 7
c799 :                       kb_any_key_row
c799 : 8c0003           [ 4] 	sty IO_0+PRB			; Select row on port B
c79c : ea               [ 2] 	nop
c79d : ea               [ 2] 	nop
                             	
c79e : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
c7a1 : 2908             [ 2] 	and #KB_SENSE			; Something pressed?
c7a3 : d005             [ 3] 	bne kb_any_key_pressed
c7a5 : 88               [ 2] 	dey						; If not then next row
c7a6 : 10f1             [ 3] 	bpl kb_any_key_row		; Until all rows done
c7a8 :                       kb_any_key_none
c7a8 : 18               [ 2] 	clc						; C=0 means not pressed
c7a9 : 60               [ 6] 	rts
c7aa :                       kb_any_key_pressed
c7aa : 38               [ 2] 	sec						; C=1 means pressed
c7ab : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_read_raw
                             ;* Read keyboard
                             ;* Y = Keyboard code
                             ;* Carry = 1 means key found, 0 = no keys found
                             ;****************************************
c7ac :                       kb_read_raw
c7ac : 2090c7           [ 6] 	jsr kb_any_key			; Quick check is anything down?
c7af : 9027             [ 3] 	bcc kb_read_nothing		; Don't bother if not
c7b1 :                       kb_read_raw_force
c7b1 : a000             [ 2] 	ldy #0					; Start at column 0, row 0
c7b3 :                       kb_check_matrix
c7b3 : 98               [ 2] 	tya
c7b4 : 2907             [ 2] 	and #0b00000111
c7b6 : 8d0003           [ 4] 	sta IO_0+PRB			; Select row from bits 210
                             
c7b9 : 98               [ 2] 	tya
c7ba : 4a               [ 2] 	lsr a					; Get bits 543 for column
c7bb : 4a               [ 2] 	lsr a
c7bc : 4a               [ 2] 	lsr a
                             
c7bd : c904             [ 2] 	cmp #4					; If col 4 then skip over (checked la
c7bf : f01d             [ 3] 	beq kb_skip_col4
                             
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank0.s --------------------------------

c7c1 : aa               [ 2] 	tax						; Index to the col mask
c7c2 : bd04c9           [ 4] 	lda kb_col_mask,x
c7c5 : a20e             [ 2] 	ldx #SND_REG_IOA		; Select Port A of AY
c7c7 : 2000c0           [ 6] 	jsr snd_set				; Set Port A to column mask
c7ca : ea               [ 2] 	nop
c7cb : ea               [ 2] 	nop
c7cc : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
c7cf : 2908             [ 2] 	and #KB_SENSE			; Bit 3 is the sense
c7d1 : d009             [ 3] 	bne kb_read_got
c7d3 : c8               [ 2] 	iny
c7d4 : c040             [ 2] 	cpy #64					; only 64 combinations
c7d6 : d0db             [ 3] 	bne kb_check_matrix
                             	; No key was sensed
                             
c7d8 :                       kb_read_nothing
c7d8 : a000             [ 2] 	ldy #0					; Raw key codes
c7da : 18               [ 2] 	clc						; No key sensed flag
c7db : 60               [ 6] 	rts
c7dc :                       kb_read_got
c7dc : 38               [ 2] 	sec						; Key sensed flag
c7dd : 60               [ 6] 	rts
c7de :                       kb_skip_col4
c7de : a028             [ 2] 	ldy #40					; 40=5*8 skips col 4
c7e0 : d0d1             [ 3] 	bne kb_check_matrix		; Continue	
                             
                             	
                             ;****************************************
                             ;* kb_scan_key
                             ;* Scans for a key, returns zero for no key found
                             ;* Processes caps and shift lock but these don't 
                             ;* A = Key code
                             ;****************************************
c7e2 :                       kb_scan_key
c7e2 : 20acc7           [ 6] 	jsr kb_read_raw			; Check if a key is sensed
c7e5 : b00c             [ 3] 	bcs kb_scan_decode		; go ahead and decode
                             	; If pressed nothing then reset timers
c7e7 : a52f             [ 3] 	lda kb_rdel_tim			; Reset repeat timer to initia
c7e9 : 852d             [ 3] 	sta kb_rep
c7eb : a900             [ 2] 	lda #0
c7ed : 8527             [ 3] 	sta kb_raw				; Reset raw key settings
c7ef : 8528             [ 3] 	sta kb_last				; And last key
c7f1 :                       kb_scan_wait
c7f1 : 38               [ 2] 	sec						; Code not valid
c7f2 : 60               [ 6] 	rts						; And done (A=0)	
c7f3 :                       kb_scan_decode
                             	; If got here then raw key is good
c7f3 : 8427             [ 3] 	sty kb_raw
                             
                             	; Now to get a proper key code translated from r
                             
                             	; Check for shift and ctrl (not debounced!)
c7f5 : a9ef             [ 2] 	lda #0b11101111			; Select column 4
c7f7 : a20e             [ 2] 	ldx #SND_REG_IOA		; On AY port A
c7f9 : 2000c0           [ 6] 	jsr snd_set
                             
                             	; check shifted keys
c7fc : a204             [ 2] 	ldx #4					; Row 4 (left shift)
c7fe : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c801 : ea               [ 2] 	nop
c802 : ea               [ 2] 	nop
                             
c803 : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank0.s --------------------------------

                             
c806 : a207             [ 2] 	ldx #7					; Row 7 (right shift)
c808 : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c80b : ea               [ 2] 	nop
c80c : ea               [ 2] 	nop
                             
c80d : 0d0003           [ 4] 	ora IO_0+PRB			; Combine Port B
c810 : be84c8           [ 4] 	ldx kb_table_std,y		; Pre-load standard key code
c813 : 2908             [ 2] 	and #KB_SENSE			; Bit 3 is the sense
c815 : f003             [ 3] 	beq kb_read_noshift		; Skip over if no shift
c817 : bec4c8           [ 4] 	ldx kb_table_shift,y	; Load up standard key code
c81a :                       kb_read_noshift
c81a : 8629             [ 3] 	stx kb_code				; Save the mapped keycode
                             	; check ctrl key
c81c : a202             [ 2] 	ldx #2					; Row 2 (ctrl key)
c81e : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c821 : ea               [ 2] 	nop
c822 : ea               [ 2] 	nop
                             
c823 : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
c826 : 2908             [ 2] 	and #KB_SENSE
c828 : f00a             [ 3] 	beq kb_skip_ctrl
c82a : a529             [ 3] 	lda kb_code
c82c : 291f             [ 2] 	and #0x1f				; Ctrl will result in codes 0 to 31
c82e : 8529             [ 3] 	sta kb_code				; Override the keycode
c830 : f032             [ 3] 	beq kb_brk
c832 : 1016             [ 3] 	bpl	kb_do_repeat		; Check repeat (bpl is always 
c834 :                       kb_skip_ctrl
c834 : a52a             [ 3] 	lda kb_stat				; Check caps lock
c836 : 2901             [ 2] 	and #KB_CAPSLK
c838 : f010             [ 3] 	beq kb_do_repeat
c83a : a529             [ 3] 	lda kb_code
c83c : c961             [ 2] 	cmp #'a'				; If < 'a' then skip
c83e : 900a             [ 3] 	bcc kb_do_repeat
c840 : c97b             [ 2] 	cmp #'z'+1				; If > 'z' then skip
c842 : b006             [ 3] 	bcs kb_do_repeat
c844 : a529             [ 3] 	lda kb_code				; Get the actual code	
c846 : 4920             [ 2] 	eor #0x20				; Switch off bit 0x20
c848 : 8529             [ 3] 	sta kb_code
c84a :                       kb_do_repeat
c84a : a529             [ 3] 	lda kb_code
c84c : c528             [ 3] 	cmp kb_last				; Same key as last time?
c84e : f004             [ 3] 	beq kb_handle_repeat	; If so, need to check repe
c850 : 8528             [ 3] 	sta kb_last				; Make last code same as this
c852 : 18               [ 2] 	clc						; Code valid
c853 : 60               [ 6] 	rts
c854 :                       kb_handle_repeat
c854 : a62d             [ 3] 	ldx kb_rep				; Has repeat expired?
c856 : d008             [ 3] 	bne	kb_in_repeat		; If not then still in repeat
c858 : a62e             [ 3] 	ldx kb_rep_tim			; Set repeat speed
c85a : 862d             [ 3] 	stx kb_rep
c85c : 8528             [ 3] 	sta kb_last				; Make last code same as this
c85e : 18               [ 2] 	clc						; Code valid
c85f : 60               [ 6] 	rts	
c860 :                       kb_in_repeat
c860 : a900             [ 2] 	lda #0					; Don't emit a keycode
c862 : 38               [ 2] 	sec
c863 : 60               [ 6] 	rts
c864 :                       kb_brk
                             	SWBRK DFERR_OK
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* kb_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=1 means valid
                             ;****************************************
c866 :                       kb_get_key
c866 : 8a               [ 2] 	txa
c867 : 48               [ 3] 	pha
c868 : 98               [ 2] 	tya
c869 : 48               [ 3] 	pha
                             
c86a :                       kb_get_try	
c86a : 08               [ 3] 	php
c86b : 20e2c7           [ 6] 	jsr kb_scan_key
c86e : 900b             [ 3] 	bcc kb_scan_got_key
c870 : 28               [ 4] 	plp						; No key, so check C
c871 : b0f7             [ 3] 	bcs kb_get_try			; Keep looking if C
c873 : 38               [ 2] 	sec						; Indicate key not valid
                             	
c874 : 68               [ 4] 	pla
c875 : a8               [ 2] 	tay
c876 : 68               [ 4] 	pla
c877 : aa               [ 2] 	tax
c878 : a900             [ 2] 	lda #0
                             	
c87a : 60               [ 6] 	rts
c87b :                       kb_scan_got_key
c87b : 28               [ 4] 	plp						; Pull stack
c87c : 18               [ 2] 	clc						; Indicate key valid
                             
c87d : 68               [ 4] 	pla
c87e : a8               [ 2] 	tay
c87f : 68               [ 4] 	pla
c880 : aa               [ 2] 	tax
                             	
c881 : a529             [ 3] 	lda kb_code
                             	
c883 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* kb_table_std (no shift)
                             ;* Each line is one column
                             ;****************************************
c884 :                       kb_table_std
c884 : 376a6d6b20757938      	db '7' ,'j' ,'m' ,'k' ,' ' ,'u' ,'y' ,'8'
c88c : 6e7436392c69686c      	db 'n' ,'t' ,'6' ,'9' ,',' ,'i' ,'h' ,'l'
c894 : 3572623b2e6f6730      	db '5' ,'r' ,'b' ,';' ,'.' ,'o' ,'g' ,'0'
c89c : 7666342d0b70652f      	db 'v' ,'f' ,'4' ,'-' ,0x0b,'p' ,'e' ,'/'
c8a4 : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
c8ac : 311b7a00087f610d      	db '1' ,0x1b,'z' ,0   ,0x08,0x7f,'a' ,0x0d
c8b4 : 7871325c0a5d7300      	db 'x' ,'q' ,'2' ,0x5c,0x0a,']' ,'s' ,0
c8bc : 33646327095b773d      	db '3' ,'d' ,'c' ,0x27,0x09,'[' ,'w' ,'='
                             
                             ;* kb_table_shift (with shift)
c8c4 :                       kb_table_shift
c8c4 : 264a4d4b2055592a      	db '&' ,'J' ,'M' ,'K' ,' ' ,'U' ,'Y' ,'*'
c8cc : 4e545e283c49484c      	db 'N' ,'T' ,'^' ,'(' ,'<' ,'I' ,'H' ,'L'
c8d4 : 2552423a3e4f4729      	db '%' ,'R' ,'B' ,':' ,'>' ,'O' ,'G' ,')'
c8dc : 5646245f0b50453f      	db 'V' ,'F' ,'$' ,'_' ,0x0b,'P' ,'E' ,'?'
c8e4 : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
c8ec : 211b5a00087f410d      	db '!' ,0x1b,'Z' ,0   ,0x08,0x7f,'A' ,0x0d
c8f4 : 5851407c0a7d5300      	db 'X' ,'Q' ,'@' ,'|' ,0x0a,'}' ,'S' ,0
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank0.s --------------------------------

c8fc : 23444322097b572b      	db '#' ,'D' ,'C' ,0x22,0x09,'{' ,'W' ,'+'
                             
c904 :                       kb_col_mask
c904 : fe                    	db 0b11111110
c905 : fd                    	db 0b11111101
c906 : fb                    	db 0b11111011
c907 : f7                    	db 0b11110111
c908 : ef                    	db 0b11101111
c909 : df                    	db 0b11011111
c90a : bf                    	db 0b10111111
c90b : 7f                    	db 0b01111111
                             
c90c :                       kb_stick_mask
c90c : df                    	db 0b11011111		; Left 	= Bit 0
c90d : 7f                    	db 0b01111111		; Right = Bit 1
c90e : f7                    	db 0b11110111		; Up	= Bit 2
c90f : bf                    	db 0b10111111		; Down	= Bit 3
c910 : fe                    	db 0b11111110		; Space	= Bit 4
                             
                             	include "vdp\graph.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.S
                             ;*  This is the graphics module, to handle text a
                             ;*  graphics.
                             ;*  For text modes, this module keeps track of wh
                             ;*  next put a character, and also takes care of 
                             ;*  to the next line as well as scrolling the con
                             ;*  when the cursor has reached the bottom right.
                             ;*  module also enables text input which is echoe
                             ;*  screen, to allow interactive input and editin
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c911 :                       mod_sz_graph_s
                             
                             
                             	include "vdp\font.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  FONT.S
                             ;*  This is the font definition, used to initiali
                             ;*  character set.  This is the standard Oric-1 f
                             ;*	Still called vdp as this code was ported from 
                             ;*	machine using the TMS9918a.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank0.s --------------------------------

                             
c911 :                       vdp_font
                             ; char 32
c911 : 00                    	db %00000000
c912 : 00                    	db %00000000
c913 : 00                    	db %00000000
c914 : 00                    	db %00000000
c915 : 00                    	db %00000000
c916 : 00                    	db %00000000
c917 : 00                    	db %00000000
c918 : 00                    	db %00000000
                             ; char 33
c919 : 08                    	db %00001000
c91a : 08                    	db %00001000
c91b : 08                    	db %00001000
c91c : 08                    	db %00001000
c91d : 08                    	db %00001000
c91e : 00                    	db %00000000
c91f : 08                    	db %00001000
c920 : 00                    	db %00000000
                             ; char 34
c921 : 14                    	db %00010100
c922 : 14                    	db %00010100
c923 : 14                    	db %00010100
c924 : 00                    	db %00000000
c925 : 00                    	db %00000000
c926 : 00                    	db %00000000
c927 : 00                    	db %00000000
c928 : 00                    	db %00000000
                             ; char 35
c929 : 14                    	db %00010100
c92a : 14                    	db %00010100
c92b : 3e                    	db %00111110
c92c : 14                    	db %00010100
c92d : 3e                    	db %00111110
c92e : 14                    	db %00010100
c92f : 14                    	db %00010100
c930 : 00                    	db %00000000
                             ; char 36
c931 : 08                    	db %00001000
c932 : 1e                    	db %00011110
c933 : 28                    	db %00101000
c934 : 1c                    	db %00011100
c935 : 0a                    	db %00001010
c936 : 3c                    	db %00111100
c937 : 08                    	db %00001000
c938 : 00                    	db %00000000
                             ; char 37
c939 : 30                    	db %00110000
c93a : 32                    	db %00110010
c93b : 04                    	db %00000100
c93c : 08                    	db %00001000
c93d : 10                    	db %00010000
c93e : 26                    	db %00100110
c93f : 06                    	db %00000110
c940 : 00                    	db %00000000
                             ; char 38
c941 : 10                    	db %00010000
c942 : 28                    	db %00101000
c943 : 28                    	db %00101000
c944 : 10                    	db %00010000
c945 : 2a                    	db %00101010
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank0.s --------------------------------

c946 : 24                    	db %00100100
c947 : 1a                    	db %00011010
c948 : 00                    	db %00000000
                             ; char 39
c949 : 08                    	db %00001000
c94a : 08                    	db %00001000
c94b : 08                    	db %00001000
c94c : 00                    	db %00000000
c94d : 00                    	db %00000000
c94e : 00                    	db %00000000
c94f : 00                    	db %00000000
c950 : 00                    	db %00000000
                             ; char 40
c951 : 08                    	db %00001000
c952 : 10                    	db %00010000
c953 : 20                    	db %00100000
c954 : 20                    	db %00100000
c955 : 20                    	db %00100000
c956 : 10                    	db %00010000
c957 : 08                    	db %00001000
c958 : 00                    	db %00000000
                             ; char 41
c959 : 08                    	db %00001000
c95a : 04                    	db %00000100
c95b : 02                    	db %00000010
c95c : 02                    	db %00000010
c95d : 02                    	db %00000010
c95e : 04                    	db %00000100
c95f : 08                    	db %00001000
c960 : 00                    	db %00000000
                             ; char 42
c961 : 08                    	db %00001000
c962 : 2a                    	db %00101010
c963 : 1c                    	db %00011100
c964 : 08                    	db %00001000
c965 : 1c                    	db %00011100
c966 : 2a                    	db %00101010
c967 : 08                    	db %00001000
c968 : 00                    	db %00000000
                             ; char 43
c969 : 00                    	db %00000000
c96a : 08                    	db %00001000
c96b : 08                    	db %00001000
c96c : 3e                    	db %00111110
c96d : 08                    	db %00001000
c96e : 08                    	db %00001000
c96f : 00                    	db %00000000
c970 : 00                    	db %00000000
                             ; char 44
c971 : 00                    	db %00000000
c972 : 00                    	db %00000000
c973 : 00                    	db %00000000
c974 : 00                    	db %00000000
c975 : 00                    	db %00000000
c976 : 08                    	db %00001000
c977 : 08                    	db %00001000
c978 : 10                    	db %00010000
                             ; char 45
c979 : 00                    	db %00000000
c97a : 00                    	db %00000000
c97b : 00                    	db %00000000
c97c : 3e                    	db %00111110
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank0.s --------------------------------

c97d : 00                    	db %00000000
c97e : 00                    	db %00000000
c97f : 00                    	db %00000000
c980 : 00                    	db %00000000
                             ; char 46
c981 : 00                    	db %00000000
c982 : 00                    	db %00000000
c983 : 00                    	db %00000000
c984 : 00                    	db %00000000
c985 : 00                    	db %00000000
c986 : 04                    	db %00000100
c987 : 00                    	db %00000000
c988 : 00                    	db %00000000
                             ; char 47
c989 : 00                    	db %00000000
c98a : 02                    	db %00000010
c98b : 04                    	db %00000100
c98c : 08                    	db %00001000
c98d : 10                    	db %00010000
c98e : 20                    	db %00100000
c98f : 00                    	db %00000000
c990 : 00                    	db %00000000
                             ; char 48
c991 : 1c                    	db %00011100
c992 : 22                    	db %00100010
c993 : 26                    	db %00100110
c994 : 2a                    	db %00101010
c995 : 32                    	db %00110010
c996 : 22                    	db %00100010
c997 : 1c                    	db %00011100
c998 : 00                    	db %00000000
                             ; char 49
c999 : 08                    	db %00001000
c99a : 18                    	db %00011000
c99b : 08                    	db %00001000
c99c : 08                    	db %00001000
c99d : 08                    	db %00001000
c99e : 08                    	db %00001000
c99f : 1c                    	db %00011100
c9a0 : 00                    	db %00000000
                             ; char 50
c9a1 : 1c                    	db %00011100
c9a2 : 22                    	db %00100010
c9a3 : 02                    	db %00000010
c9a4 : 04                    	db %00000100
c9a5 : 08                    	db %00001000
c9a6 : 10                    	db %00010000
c9a7 : 3e                    	db %00111110
c9a8 : 00                    	db %00000000
                             ; char 51
c9a9 : 3e                    	db %00111110
c9aa : 02                    	db %00000010
c9ab : 04                    	db %00000100
c9ac : 0c                    	db %00001100
c9ad : 02                    	db %00000010
c9ae : 22                    	db %00100010
c9af : 1c                    	db %00011100
c9b0 : 00                    	db %00000000
                             ; char 52
c9b1 : 04                    	db %00000100
c9b2 : 0c                    	db %00001100
c9b3 : 14                    	db %00010100
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank0.s --------------------------------

c9b4 : 24                    	db %00100100
c9b5 : 3e                    	db %00111110
c9b6 : 04                    	db %00000100
c9b7 : 04                    	db %00000100
c9b8 : 00                    	db %00000000
                             ; char 53
c9b9 : 3e                    	db %00111110
c9ba : 20                    	db %00100000
c9bb : 3c                    	db %00111100
c9bc : 02                    	db %00000010
c9bd : 02                    	db %00000010
c9be : 22                    	db %00100010
c9bf : 1c                    	db %00011100
c9c0 : 00                    	db %00000000
                             ; char 54
c9c1 : 0c                    	db %00001100
c9c2 : 10                    	db %00010000
c9c3 : 20                    	db %00100000
c9c4 : 3c                    	db %00111100
c9c5 : 22                    	db %00100010
c9c6 : 22                    	db %00100010
c9c7 : 1c                    	db %00011100
c9c8 : 00                    	db %00000000
                             ; char 55
c9c9 : 3e                    	db %00111110
c9ca : 02                    	db %00000010
c9cb : 04                    	db %00000100
c9cc : 08                    	db %00001000
c9cd : 10                    	db %00010000
c9ce : 10                    	db %00010000
c9cf : 10                    	db %00010000
c9d0 : 00                    	db %00000000
                             ; char 56
c9d1 : 1c                    	db %00011100
c9d2 : 22                    	db %00100010
c9d3 : 22                    	db %00100010
c9d4 : 1c                    	db %00011100
c9d5 : 22                    	db %00100010
c9d6 : 22                    	db %00100010
c9d7 : 1c                    	db %00011100
c9d8 : 00                    	db %00000000
                             ; char 57
c9d9 : 1c                    	db %00011100
c9da : 22                    	db %00100010
c9db : 22                    	db %00100010
c9dc : 1e                    	db %00011110
c9dd : 02                    	db %00000010
c9de : 04                    	db %00000100
c9df : 18                    	db %00011000
c9e0 : 00                    	db %00000000
                             ; char 58
c9e1 : 00                    	db %00000000
c9e2 : 00                    	db %00000000
c9e3 : 08                    	db %00001000
c9e4 : 00                    	db %00000000
c9e5 : 00                    	db %00000000
c9e6 : 08                    	db %00001000
c9e7 : 00                    	db %00000000
c9e8 : 00                    	db %00000000
                             ; char 59
c9e9 : 00                    	db %00000000
c9ea : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank0.s --------------------------------

c9eb : 08                    	db %00001000
c9ec : 00                    	db %00000000
c9ed : 00                    	db %00000000
c9ee : 08                    	db %00001000
c9ef : 08                    	db %00001000
c9f0 : 10                    	db %00010000
                             ; char 60
c9f1 : 04                    	db %00000100
c9f2 : 08                    	db %00001000
c9f3 : 10                    	db %00010000
c9f4 : 20                    	db %00100000
c9f5 : 10                    	db %00010000
c9f6 : 08                    	db %00001000
c9f7 : 04                    	db %00000100
c9f8 : 00                    	db %00000000
                             ; char 61
c9f9 : 00                    	db %00000000
c9fa : 00                    	db %00000000
c9fb : 3e                    	db %00111110
c9fc : 00                    	db %00000000
c9fd : 3e                    	db %00111110
c9fe : 00                    	db %00000000
c9ff : 00                    	db %00000000
ca00 : 00                    	db %00000000
                             ; char 62
ca01 : 10                    	db %00010000
ca02 : 08                    	db %00001000
ca03 : 04                    	db %00000100
ca04 : 02                    	db %00000010
ca05 : 04                    	db %00000100
ca06 : 08                    	db %00001000
ca07 : 10                    	db %00010000
ca08 : 00                    	db %00000000
                             ; char 63
ca09 : 1c                    	db %00011100
ca0a : 22                    	db %00100010
ca0b : 04                    	db %00000100
ca0c : 08                    	db %00001000
ca0d : 08                    	db %00001000
ca0e : 00                    	db %00000000
ca0f : 08                    	db %00001000
ca10 : 00                    	db %00000000
                             ; char 64
ca11 : 1c                    	db %00011100
ca12 : 22                    	db %00100010
ca13 : 2a                    	db %00101010
ca14 : 2e                    	db %00101110
ca15 : 2c                    	db %00101100
ca16 : 20                    	db %00100000
ca17 : 1e                    	db %00011110
ca18 : 00                    	db %00000000
ca19 :                       vdp_font_a
                             ; char 60
ca19 : 08                    	db %00001000
ca1a : 14                    	db %00010100
ca1b : 22                    	db %00100010
ca1c : 22                    	db %00100010
ca1d : 3e                    	db %00111110
ca1e : 22                    	db %00100010
ca1f : 22                    	db %00100010
ca20 : 00                    	db %00000000
                             ; char 60
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank0.s --------------------------------

ca21 : 3c                    	db %00111100
ca22 : 22                    	db %00100010
ca23 : 22                    	db %00100010
ca24 : 3c                    	db %00111100
ca25 : 22                    	db %00100010
ca26 : 22                    	db %00100010
ca27 : 3c                    	db %00111100
ca28 : 00                    	db %00000000
                             ; char 60
ca29 : 1c                    	db %00011100
ca2a : 22                    	db %00100010
ca2b : 20                    	db %00100000
ca2c : 20                    	db %00100000
ca2d : 20                    	db %00100000
ca2e : 22                    	db %00100010
ca2f : 1c                    	db %00011100
ca30 : 00                    	db %00000000
                             ; char 68
ca31 : 3c                    	db %00111100
ca32 : 22                    	db %00100010
ca33 : 22                    	db %00100010
ca34 : 22                    	db %00100010
ca35 : 22                    	db %00100010
ca36 : 22                    	db %00100010
ca37 : 3c                    	db %00111100
ca38 : 00                    	db %00000000
                             ; char 69
ca39 : 3e                    	db %00111110
ca3a : 20                    	db %00100000
ca3b : 20                    	db %00100000
ca3c : 3c                    	db %00111100
ca3d : 20                    	db %00100000
ca3e : 20                    	db %00100000
ca3f : 3e                    	db %00111110
ca40 : 00                    	db %00000000
                             ; char 70
ca41 : 3e                    	db %00111110
ca42 : 20                    	db %00100000
ca43 : 20                    	db %00100000
ca44 : 3c                    	db %00111100
ca45 : 20                    	db %00100000
ca46 : 20                    	db %00100000
ca47 : 20                    	db %00100000
ca48 : 00                    	db %00000000
                             ; char 71
ca49 : 1e                    	db %00011110
ca4a : 20                    	db %00100000
ca4b : 20                    	db %00100000
ca4c : 20                    	db %00100000
ca4d : 26                    	db %00100110
ca4e : 22                    	db %00100010
ca4f : 1e                    	db %00011110
ca50 : 00                    	db %00000000
                             ; char 72
ca51 : 22                    	db %00100010
ca52 : 22                    	db %00100010
ca53 : 22                    	db %00100010
ca54 : 3e                    	db %00111110
ca55 : 22                    	db %00100010
ca56 : 22                    	db %00100010
ca57 : 22                    	db %00100010
ca58 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank0.s --------------------------------

                             ; char 73
ca59 : 1c                    	db %00011100
ca5a : 08                    	db %00001000
ca5b : 08                    	db %00001000
ca5c : 08                    	db %00001000
ca5d : 08                    	db %00001000
ca5e : 08                    	db %00001000
ca5f : 1c                    	db %00011100
ca60 : 00                    	db %00000000
                             ; char 74
ca61 : 02                    	db %00000010
ca62 : 02                    	db %00000010
ca63 : 02                    	db %00000010
ca64 : 02                    	db %00000010
ca65 : 02                    	db %00000010
ca66 : 22                    	db %00100010
ca67 : 1c                    	db %00011100
ca68 : 00                    	db %00000000
                             ; char 75
ca69 : 22                    	db %00100010
ca6a : 24                    	db %00100100
ca6b : 28                    	db %00101000
ca6c : 30                    	db %00110000
ca6d : 28                    	db %00101000
ca6e : 24                    	db %00100100
ca6f : 22                    	db %00100010
ca70 : 00                    	db %00000000
                             ; char 76
ca71 : 20                    	db %00100000
ca72 : 20                    	db %00100000
ca73 : 20                    	db %00100000
ca74 : 20                    	db %00100000
ca75 : 20                    	db %00100000
ca76 : 20                    	db %00100000
ca77 : 3e                    	db %00111110
ca78 : 00                    	db %00000000
                             ; char 77
ca79 : 22                    	db %00100010
ca7a : 36                    	db %00110110
ca7b : 2a                    	db %00101010
ca7c : 2a                    	db %00101010
ca7d : 22                    	db %00100010
ca7e : 22                    	db %00100010
ca7f : 22                    	db %00100010
ca80 : 00                    	db %00000000
                             ; char 78
ca81 : 22                    	db %00100010
ca82 : 22                    	db %00100010
ca83 : 32                    	db %00110010
ca84 : 2a                    	db %00101010
ca85 : 26                    	db %00100110
ca86 : 22                    	db %00100010
ca87 : 22                    	db %00100010
ca88 : 00                    	db %00000000
                             ; char 79
ca89 : 1c                    	db %00011100
ca8a : 22                    	db %00100010
ca8b : 22                    	db %00100010
ca8c : 22                    	db %00100010
ca8d : 22                    	db %00100010
ca8e : 22                    	db %00100010
ca8f : 1c                    	db %00011100
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank0.s --------------------------------

ca90 : 00                    	db %00000000
                             ; char 80
ca91 : 3c                    	db %00111100
ca92 : 22                    	db %00100010
ca93 : 22                    	db %00100010
ca94 : 3c                    	db %00111100
ca95 : 20                    	db %00100000
ca96 : 20                    	db %00100000
ca97 : 20                    	db %00100000
ca98 : 00                    	db %00000000
                             ; char 81
ca99 : 1c                    	db %00011100
ca9a : 22                    	db %00100010
ca9b : 22                    	db %00100010
ca9c : 22                    	db %00100010
ca9d : 2a                    	db %00101010
ca9e : 24                    	db %00100100
ca9f : 1a                    	db %00011010
caa0 : 00                    	db %00000000
                             ; char 82
caa1 : 3c                    	db %00111100
caa2 : 22                    	db %00100010
caa3 : 22                    	db %00100010
caa4 : 3c                    	db %00111100
caa5 : 28                    	db %00101000
caa6 : 24                    	db %00100100
caa7 : 22                    	db %00100010
caa8 : 00                    	db %00000000
                             ; char 83
caa9 : 1c                    	db %00011100
caaa : 22                    	db %00100010
caab : 20                    	db %00100000
caac : 1c                    	db %00011100
caad : 02                    	db %00000010
caae : 22                    	db %00100010
caaf : 1c                    	db %00011100
cab0 : 00                    	db %00000000
                             ; char 84
cab1 : 3e                    	db %00111110
cab2 : 08                    	db %00001000
cab3 : 08                    	db %00001000
cab4 : 08                    	db %00001000
cab5 : 08                    	db %00001000
cab6 : 08                    	db %00001000
cab7 : 08                    	db %00001000
cab8 : 00                    	db %00000000
                             ; char 85
cab9 : 22                    	db %00100010
caba : 22                    	db %00100010
cabb : 22                    	db %00100010
cabc : 22                    	db %00100010
cabd : 22                    	db %00100010
cabe : 22                    	db %00100010
cabf : 1c                    	db %00011100
cac0 : 00                    	db %00000000
                             ; char 86
cac1 : 22                    	db %00100010
cac2 : 22                    	db %00100010
cac3 : 22                    	db %00100010
cac4 : 22                    	db %00100010
cac5 : 22                    	db %00100010
cac6 : 14                    	db %00010100
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank0.s --------------------------------

cac7 : 08                    	db %00001000
cac8 : 00                    	db %00000000
                             ; char 87
cac9 : 22                    	db %00100010
caca : 22                    	db %00100010
cacb : 22                    	db %00100010
cacc : 2a                    	db %00101010
cacd : 2a                    	db %00101010
cace : 36                    	db %00110110
cacf : 22                    	db %00100010
cad0 : 00                    	db %00000000
                             ; char 88
cad1 : 22                    	db %00100010
cad2 : 22                    	db %00100010
cad3 : 14                    	db %00010100
cad4 : 08                    	db %00001000
cad5 : 14                    	db %00010100
cad6 : 22                    	db %00100010
cad7 : 22                    	db %00100010
cad8 : 00                    	db %00000000
                             ; char 89
cad9 : 22                    	db %00100010
cada : 22                    	db %00100010
cadb : 14                    	db %00010100
cadc : 08                    	db %00001000
cadd : 08                    	db %00001000
cade : 08                    	db %00001000
cadf : 08                    	db %00001000
cae0 : 00                    	db %00000000
                             ; char 90
cae1 : 3e                    	db %00111110
cae2 : 02                    	db %00000010
cae3 : 04                    	db %00000100
cae4 : 08                    	db %00001000
cae5 : 10                    	db %00010000
cae6 : 20                    	db %00100000
cae7 : 3e                    	db %00111110
cae8 : 00                    	db %00000000
                             ; char 91
cae9 : 1e                    	db %00011110
caea : 10                    	db %00010000
caeb : 10                    	db %00010000
caec : 10                    	db %00010000
caed : 10                    	db %00010000
caee : 10                    	db %00010000
caef : 1e                    	db %00011110
caf0 : 00                    	db %00000000
                             ; char 92
caf1 : 00                    	db %00000000
caf2 : 20                    	db %00100000
caf3 : 10                    	db %00010000
caf4 : 08                    	db %00001000
caf5 : 04                    	db %00000100
caf6 : 02                    	db %00000010
caf7 : 00                    	db %00000000
caf8 : 00                    	db %00000000
                             ; char 93
caf9 : 3c                    	db %00111100
cafa : 04                    	db %00000100
cafb : 04                    	db %00000100
cafc : 04                    	db %00000100
cafd : 04                    	db %00000100
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank0.s --------------------------------

cafe : 04                    	db %00000100
caff : 3c                    	db %00111100
cb00 : 00                    	db %00000000
                             ; char 94
cb01 : 08                    	db %00001000
cb02 : 14                    	db %00010100
cb03 : 2a                    	db %00101010
cb04 : 08                    	db %00001000
cb05 : 08                    	db %00001000
cb06 : 08                    	db %00001000
cb07 : 08                    	db %00001000
cb08 : 00                    	db %00000000
                             ; char 95
cb09 : 00                    	db %00000000
cb0a : 00                    	db %00000000
cb0b : 00                    	db %00000000
cb0c : 00                    	db %00000000
cb0d : 00                    	db %00000000
cb0e : 00                    	db %00000000
cb0f : 3e                    	db %00111110
cb10 : 00                    	db %00000000
                             ; char 96
cb11 : 0e                    	db %00001110
cb12 : 10                    	db %00010000
cb13 : 10                    	db %00010000
cb14 : 10                    	db %00010000
cb15 : 3c                    	db %00111100
cb16 : 10                    	db %00010000
cb17 : 3e                    	db %00111110
cb18 : 00                    	db %00000000
                             ; char 97
cb19 : 00                    	db %00000000
cb1a : 00                    	db %00000000
cb1b : 1c                    	db %00011100
cb1c : 02                    	db %00000010
cb1d : 1e                    	db %00011110
cb1e : 22                    	db %00100010
cb1f : 1e                    	db %00011110
cb20 : 00                    	db %00000000
                             ; char 98
cb21 : 20                    	db %00100000
cb22 : 20                    	db %00100000
cb23 : 3c                    	db %00111100
cb24 : 22                    	db %00100010
cb25 : 22                    	db %00100010
cb26 : 22                    	db %00100010
cb27 : 3c                    	db %00111100
cb28 : 00                    	db %00000000
                             ; char 99
cb29 : 00                    	db %00000000
cb2a : 00                    	db %00000000
cb2b : 1e                    	db %00011110
cb2c : 20                    	db %00100000
cb2d : 20                    	db %00100000
cb2e : 20                    	db %00100000
cb2f : 1e                    	db %00011110
cb30 : 00                    	db %00000000
                             ; char 100
cb31 : 02                    	db %00000010
cb32 : 02                    	db %00000010
cb33 : 1e                    	db %00011110
cb34 : 22                    	db %00100010
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank0.s --------------------------------

cb35 : 22                    	db %00100010
cb36 : 22                    	db %00100010
cb37 : 1e                    	db %00011110
cb38 : 00                    	db %00000000
                             ; char 101
cb39 : 00                    	db %00000000
cb3a : 00                    	db %00000000
cb3b : 1c                    	db %00011100
cb3c : 22                    	db %00100010
cb3d : 3e                    	db %00111110
cb3e : 20                    	db %00100000
cb3f : 1e                    	db %00011110
cb40 : 00                    	db %00000000
                             ; char 102
cb41 : 0c                    	db %00001100
cb42 : 12                    	db %00010010
cb43 : 10                    	db %00010000
cb44 : 3c                    	db %00111100
cb45 : 10                    	db %00010000
cb46 : 10                    	db %00010000
cb47 : 10                    	db %00010000
cb48 : 00                    	db %00000000
                             ; char 103
cb49 : 00                    	db %00000000
cb4a : 00                    	db %00000000
cb4b : 1c                    	db %00011100
cb4c : 22                    	db %00100010
cb4d : 22                    	db %00100010
cb4e : 1e                    	db %00011110
cb4f : 02                    	db %00000010
cb50 : 1c                    	db %00011100
                             ; char 104
cb51 : 20                    	db %00100000
cb52 : 20                    	db %00100000
cb53 : 3c                    	db %00111100
cb54 : 22                    	db %00100010
cb55 : 22                    	db %00100010
cb56 : 22                    	db %00100010
cb57 : 22                    	db %00100010
cb58 : 00                    	db %00000000
                             ; char 105
cb59 : 08                    	db %00001000
cb5a : 00                    	db %00000000
cb5b : 18                    	db %00011000
cb5c : 08                    	db %00001000
cb5d : 08                    	db %00001000
cb5e : 08                    	db %00001000
cb5f : 1c                    	db %00011100
cb60 : 00                    	db %00000000
                             ; char 106
cb61 : 04                    	db %00000100
cb62 : 00                    	db %00000000
cb63 : 0c                    	db %00001100
cb64 : 04                    	db %00000100
cb65 : 04                    	db %00000100
cb66 : 04                    	db %00000100
cb67 : 24                    	db %00100100
cb68 : 18                    	db %00011000
                             ; char 107
cb69 : 20                    	db %00100000
cb6a : 20                    	db %00100000
cb6b : 22                    	db %00100010
AS65 Assembler for R6502 [1.42].                                     Page   89
-------------------------------- bank\bank0.s --------------------------------

cb6c : 24                    	db %00100100
cb6d : 38                    	db %00111000
cb6e : 24                    	db %00100100
cb6f : 22                    	db %00100010
cb70 : 00                    	db %00000000
                             ; char 108
cb71 : 18                    	db %00011000
cb72 : 08                    	db %00001000
cb73 : 08                    	db %00001000
cb74 : 08                    	db %00001000
cb75 : 08                    	db %00001000
cb76 : 08                    	db %00001000
cb77 : 1c                    	db %00011100
cb78 : 00                    	db %00000000
                             ; char 109
cb79 : 00                    	db %00000000
cb7a : 00                    	db %00000000
cb7b : 36                    	db %00110110
cb7c : 2a                    	db %00101010
cb7d : 2a                    	db %00101010
cb7e : 2a                    	db %00101010
cb7f : 22                    	db %00100010
cb80 : 00                    	db %00000000
                             ; char 110
cb81 : 00                    	db %00000000
cb82 : 00                    	db %00000000
cb83 : 3c                    	db %00111100
cb84 : 22                    	db %00100010
cb85 : 22                    	db %00100010
cb86 : 22                    	db %00100010
cb87 : 22                    	db %00100010
cb88 : 00                    	db %00000000
                             ; char 111
cb89 : 00                    	db %00000000
cb8a : 00                    	db %00000000
cb8b : 1c                    	db %00011100
cb8c : 22                    	db %00100010
cb8d : 22                    	db %00100010
cb8e : 22                    	db %00100010
cb8f : 1c                    	db %00011100
cb90 : 00                    	db %00000000
                             ; char 112
cb91 : 00                    	db %00000000
cb92 : 00                    	db %00000000
cb93 : 3c                    	db %00111100
cb94 : 22                    	db %00100010
cb95 : 22                    	db %00100010
cb96 : 3c                    	db %00111100
cb97 : 20                    	db %00100000
cb98 : 20                    	db %00100000
                             ; char 113
cb99 : 00                    	db %00000000
cb9a : 00                    	db %00000000
cb9b : 1e                    	db %00011110
cb9c : 22                    	db %00100010
cb9d : 22                    	db %00100010
cb9e : 1e                    	db %00011110
cb9f : 02                    	db %00000010
cba0 : 02                    	db %00000010
                             ; char 114
cba1 : 00                    	db %00000000
cba2 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   90
-------------------------------- bank\bank0.s --------------------------------

cba3 : 2e                    	db %00101110
cba4 : 30                    	db %00110000
cba5 : 20                    	db %00100000
cba6 : 20                    	db %00100000
cba7 : 20                    	db %00100000
cba8 : 00                    	db %00000000
                             ; char 115
cba9 : 00                    	db %00000000
cbaa : 00                    	db %00000000
cbab : 1e                    	db %00011110
cbac : 20                    	db %00100000
cbad : 1c                    	db %00011100
cbae : 02                    	db %00000010
cbaf : 3c                    	db %00111100
cbb0 : 00                    	db %00000000
                             ; char 116
cbb1 : 10                    	db %00010000
cbb2 : 10                    	db %00010000
cbb3 : 3c                    	db %00111100
cbb4 : 10                    	db %00010000
cbb5 : 10                    	db %00010000
cbb6 : 12                    	db %00010010
cbb7 : 0c                    	db %00001100
cbb8 : 00                    	db %00000000
                             ; char 117
cbb9 : 00                    	db %00000000
cbba : 00                    	db %00000000
cbbb : 22                    	db %00100010
cbbc : 22                    	db %00100010
cbbd : 22                    	db %00100010
cbbe : 26                    	db %00100110
cbbf : 1a                    	db %00011010
cbc0 : 00                    	db %00000000
                             ; char 118
cbc1 : 00                    	db %00000000
cbc2 : 00                    	db %00000000
cbc3 : 22                    	db %00100010
cbc4 : 22                    	db %00100010
cbc5 : 22                    	db %00100010
cbc6 : 14                    	db %00010100
cbc7 : 08                    	db %00001000
cbc8 : 00                    	db %00000000
                             ; char 119
cbc9 : 00                    	db %00000000
cbca : 00                    	db %00000000
cbcb : 22                    	db %00100010
cbcc : 22                    	db %00100010
cbcd : 2a                    	db %00101010
cbce : 2a                    	db %00101010
cbcf : 36                    	db %00110110
cbd0 : 00                    	db %00000000
                             ; char 120
cbd1 : 00                    	db %00000000
cbd2 : 00                    	db %00000000
cbd3 : 22                    	db %00100010
cbd4 : 14                    	db %00010100
cbd5 : 08                    	db %00001000
cbd6 : 14                    	db %00010100
cbd7 : 22                    	db %00100010
cbd8 : 00                    	db %00000000
                             ; char 121
cbd9 : 00                    	db %00000000
AS65 Assembler for R6502 [1.42].                                     Page   91
-------------------------------- bank\bank0.s --------------------------------

cbda : 00                    	db %00000000
cbdb : 22                    	db %00100010
cbdc : 22                    	db %00100010
cbdd : 22                    	db %00100010
cbde : 1e                    	db %00011110
cbdf : 02                    	db %00000010
cbe0 : 1c                    	db %00011100
                             ; char 122
cbe1 : 00                    	db %00000000
cbe2 : 00                    	db %00000000
cbe3 : 3e                    	db %00111110
cbe4 : 04                    	db %00000100
cbe5 : 08                    	db %00001000
cbe6 : 10                    	db %00010000
cbe7 : 3e                    	db %00111110
cbe8 : 00                    	db %00000000
                             ; char 123
cbe9 : 0e                    	db %00001110
cbea : 18                    	db %00011000
cbeb : 18                    	db %00011000
cbec : 30                    	db %00110000
cbed : 18                    	db %00011000
cbee : 18                    	db %00011000
cbef : 0e                    	db %00001110
cbf0 : 00                    	db %00000000
                             ; char 124
cbf1 : 08                    	db %00001000
cbf2 : 08                    	db %00001000
cbf3 : 08                    	db %00001000
cbf4 : 08                    	db %00001000
cbf5 : 08                    	db %00001000
cbf6 : 08                    	db %00001000
cbf7 : 08                    	db %00001000
cbf8 : 08                    	db %00001000
                             ; char 125
cbf9 : 38                    	db %00111000
cbfa : 0c                    	db %00001100
cbfb : 0c                    	db %00001100
cbfc : 06                    	db %00000110
cbfd : 0c                    	db %00001100
cbfe : 0c                    	db %00001100
cbff : 38                    	db %00111000
cc00 : 00                    	db %00000000
                             ; char 126
cc01 : 00                    	db %00000000
cc02 : 00                    	db %00000000
cc03 : 10                    	db %00010000
cc04 : 2a                    	db %00101010
cc05 : 04                    	db %00000100
cc06 : 00                    	db %00000000
cc07 : 00                    	db %00000000
cc08 : 00                    	db %00000000
                             ; char 127
cc09 : 3e                    	db %00111110
cc0a : 3e                    	db %00111110
cc0b : 3e                    	db %00111110
cc0c : 3e                    	db %00111110
cc0d : 3e                    	db %00111110
cc0e : 3e                    	db %00111110
cc0f : 3e                    	db %00111110
cc10 : 00                    	db %00000000
                             	
AS65 Assembler for R6502 [1.42].                                     Page   92
-------------------------------- bank\bank0.s --------------------------------

                             	
                             
                             ;****************************************
                             ;* vdp_init_font
                             ;* Initialise fonts from ROM
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cc11 :                       gr_init_font
                             	; Get char base from vdp structure
cc11 : a614             [ 3] 	ldx gr_scrngeom+gr_char
cc13 : 8632             [ 3] 	stx tmp_blo
cc15 : a615             [ 3] 	ldx gr_scrngeom+gr_char+1
cc17 : e8               [ 2] 	inx						; ASCII patterns start 1 page later
cc18 : 8633             [ 3] 	stx tmp_bhi
                             
cc1a : a911             [ 2] 	lda #lo(vdp_font)		; Low byte of fonts source
cc1c : 8534             [ 3] 	sta tmp_clo
cc1e : a9c9             [ 2] 	lda #hi(vdp_font)		; High byte of fonts source
cc20 : 8535             [ 3] 	sta tmp_chi
cc22 : a203             [ 2] 	ldx #3					; Copy 3 pages
cc24 : 4c27cc           [ 3] 	jmp gr_copy_mem
                             
                             	
                             ;****************************************
                             ;* vdp_copy_mem
                             ;* Copy memory pages at a time
                             ;* Input :	clo/hi	=	source
                             ;*			blo/hi	=	dest
                             ;*			X		=	pages to copy 
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cc27 :                       gr_copy_mem
cc27 : a000             [ 2] 	ldy #0					; byte within page
cc29 : a534             [ 3] 	lda tmp_clo				; Low byte of source
cc2b : 8530             [ 3] 	sta tmp_alo
cc2d : a535             [ 3] 	lda tmp_chi				; High byte of source
cc2f : 8531             [ 3] 	sta tmp_ahi
cc31 :                       gr_copy_byte
cc31 : 98               [ 2] 	tya
cc32 : b130             [ 5] 	lda (tmp_alo),y			; Get byte from font table
cc34 : 9132             [ 5] 	sta (tmp_blo),y			; Put it to the memory
cc36 : c8               [ 2] 	iny
cc37 : d0f8             [ 3] 	bne gr_copy_byte		; keep going for 1 page
cc39 : e631             [ 5] 	inc tmp_ahi				; only need to increment high byt
cc3b : e633             [ 5] 	inc tmp_bhi				; source and destination ptr
cc3d : ca               [ 2] 	dex						; page counter
cc3e : d0f1             [ 3] 	bne gr_copy_byte		; keep going for X pages
cc40 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init
                             ;* First initialisation of screen
                             ;****************************************
cc41 :                       gr_init
cc41 : a210             [ 2] 	ldx #VDP_FLASH			; Default cursor flash rate
cc43 : 860b             [ 3] 	stx vdp_curtim
cc45 : 860c             [ 3] 	stx vdp_curcnt
cc47 : a200             [ 2] 	ldx #0
AS65 Assembler for R6502 [1.42].                                     Page   93
-------------------------------- bank\bank0.s --------------------------------

cc49 : 860e             [ 3] 	stx vdp_curstat
                             	
                             	; Hard reset initial geom values (X=0)
cc4b : 2072cc           [ 6] 	jsr gr_init_geom
                             
                             	; Copy font from ROM to char base
cc4e : 2011cc           [ 6] 	jsr gr_init_font
                             	
                             	; Go in to hires mode to generate tables
cc51 : 20d4cc           [ 6] 	jsr gr_init_hires
cc54 : 200dcd           [ 6] 	jsr gr_init_hires_tables
                             
                             	; But start in text mode 
cc57 : 4cbbcc           [ 3] 	jmp gr_init_screen_txt
                             	
                             
                             ;****************************************
                             ;* gr_check_font_copy
                             ;* check font needs to be copied from
                             ;* current location to another
                             ;* A=high byte of page aligned font addr
                             ;* that the font needs to be at
                             ;****************************************
cc5a :                       gr_check_font_copy
                             	; Compare with current high byte
cc5a : c515             [ 3] 	cmp gr_scrngeom+gr_char+1
cc5c : f013             [ 3] 	beq gr_check_font_copy_done
                             	; save A as high byte of destination
cc5e : 8533             [ 3] 	sta tmp_blo+1
                             	; destination low is 0
cc60 : a900             [ 2] 	lda #0
cc62 : 8532             [ 3] 	sta tmp_blo
                             
                             	; Get source from current vdp structure
cc64 : a515             [ 3] 	lda gr_scrngeom+gr_char+1
cc66 : 8535             [ 3] 	sta tmp_clo+1
cc68 : a514             [ 3] 	lda gr_scrngeom+gr_char
cc6a : 8534             [ 3] 	sta tmp_clo
                             
                             	; Copy all 8 pages of font (std + alt) data
cc6c : a208             [ 2] 	ldx #8
cc6e : 2027cc           [ 6] 	jsr gr_copy_mem
cc71 :                       gr_check_font_copy_done
cc71 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init_geom
                             ;* initialise geometry entries from X
                             ;* position from base until -1
                             ;****************************************
cc72 :                       gr_init_geom
                             	; Which geom entry to init = Y
cc72 : bc82cc           [ 4] 	ldy gr_scrngeom_base,x
cc75 : 300a             [ 3] 	bmi gr_init_geom_done
                             	; skip to data and put in A
cc77 : e8               [ 2] 	inx 
cc78 : bd82cc           [ 4] 	lda gr_scrngeom_base,x
                             	; save it in Y
cc7b : 991100           [ 5] 	sta gr_scrngeom,y
                             	; next entry
cc7e : e8               [ 2] 	inx
AS65 Assembler for R6502 [1.42].                                     Page   94
-------------------------------- bank\bank0.s --------------------------------

cc7f : d0f1             [ 3] 	bne gr_init_geom	; Always
cc81 :                       gr_init_geom_done	
cc81 : 60               [ 6] 	rts
                             
                             ; Geometry initialisation tables
cc82 :                       gr_scrngeom_base
cc82 : 0000                  	db gr_mode, 0
cc84 : 0300                  	db gr_char,   lo(TEXTCHAR)
cc86 : 04b4                  	db gr_char+1, hi(TEXTCHAR)
cc88 : 1100                  	db gr_ink, 0
cc8a : 1216                  	db gr_paper, 16+6
cc8c : 1302                  	db gr_margin, 2
cc8e : ff                    	db -1
                             ;* Geometry for text/lores
cc8f :                       gr_scrngeom_text
cc8f : 0000                  	db gr_mode, 0
                             
cc91 : 0300                  	db gr_char,   lo(TEXTCHAR)
cc93 : 04b4                  	db gr_char+1, hi(TEXTCHAR)
                             
cc95 : 0580                  	db gr_text_start,   lo(TEXTSCRN)
cc97 : 06bb                  	db gr_text_start+1, hi(TEXTSCRN)
                             
cc99 : 0760                  	db gr_text_size,   lo(40*28)
cc9b : 0804                  	db gr_text_size+1, hi(40*28)
                             
cc9d : 0928                  	db gr_text_w, 40
cc9f : 0a1c                  	db gr_text_h, 28
cca1 : ff                    	db -1
                             ;* Geometry for hires	
cca2 :                       gr_scrngeom_hires
cca2 : 0001                  	db gr_mode, 1
                             
cca4 : 0100                  	db gr_hi_start,   lo(HISCRN)
cca6 : 02a0                  	db gr_hi_start+1, hi(HISCRN)
cca8 : 0300                  	db gr_char,   lo(HICHAR)
ccaa : 0498                  	db gr_char+1, hi(HICHAR)
                             
ccac : 0568                  	db gr_text_start,   lo(HITEXT)
ccae : 06bf                  	db gr_text_start+1, hi(HITEXT)
                             
ccb0 : 0778                  	db gr_text_size,   lo(40*3)
ccb2 : 0800                  	db gr_text_size+1, hi(40*3)
                             
                             	; Only need to initialise height, width is same 
ccb4 : 0a03                  	db gr_text_h, 3
                             
ccb6 : 0f01                  	db gr_pixmode, 1
ccb8 : 1006                  	db gr_pitch, 6
ccba : ff                    	db -1
                             
                             
                             
                             ;****************************************
                             ;* gr_init_screen_txt
                             ;* initialise the screen in text mode
                             ;****************************************
ccbb :                       gr_init_screen_txt
ccbb : e60d             [ 5] 	inc vdp_curoff
                             
                             	; Check if font copy needed to 0xb400
ccbd : a9b4             [ 2] 	lda #hi(TEXTCHAR)
AS65 Assembler for R6502 [1.42].                                     Page   95
-------------------------------- bank\bank0.s --------------------------------

ccbf : 205acc           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for text
ccc2 : a20d             [ 2] 	ldx #gr_scrngeom_text-gr_scrngeom_base
ccc4 : 2072cc           [ 6] 	jsr gr_init_geom
                             
ccc7 : 20e8d1           [ 6] 	jsr gr_spr_init					; SW Sprites are reset
                             
ccca : a920             [ 2] 	lda #' '						; Blank is SPACE
cccc : 8510             [ 3] 	sta vdp_blank
ccce : 2053cd           [ 6] 	jsr gr_cls
                             
ccd1 : c60d             [ 5] 	dec vdp_curoff
                             
ccd3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires
                             ;* Input : X = Colour table fill value
                             ;* initialise the screen in hires mode
                             ;****************************************
ccd4 :                       gr_init_hires
ccd4 : e60d             [ 5] 	inc vdp_curoff
                             	; Check if font copy needed to 0x9800
ccd6 : a998             [ 2] 	lda #hi(HICHAR)
ccd8 : 205acc           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for hires
ccdb : a220             [ 2] 	ldx #gr_scrngeom_hires-gr_scrngeom_base
ccdd : 2072cc           [ 6] 	jsr gr_init_geom
                             
cce0 : a920             [ 2] 	lda #' '						; Blank is SPACE
cce2 : 8510             [ 3] 	sta vdp_blank
cce4 : 2053cd           [ 6] 	jsr gr_cls
                             
                             	; Zero out hires area 0xa000 for 8000 (0x1f40) b
cce7 : a900             [ 2] 	lda #lo(HISCRN)
cce9 : 8530             [ 3] 	sta tmp_alo
cceb : a9a0             [ 2] 	lda #hi(HISCRN)
cced : 8531             [ 3] 	sta tmp_ahi
ccef : a940             [ 2] 	lda #0x40						; Set bit 6
ccf1 : a000             [ 2] 	ldy #0
ccf3 : a200             [ 2] 	ldx #0
ccf5 :                       vdp_fill_vram_loop
ccf5 : 9130             [ 5] 	sta (tmp_alo),y
ccf7 : c8               [ 2] 	iny
ccf8 : d003             [ 3] 	bne vdp_fill_vram_noinc
ccfa : e631             [ 5] 	inc tmp_ahi
ccfc : e8               [ 2] 	inx
ccfd :                       vdp_fill_vram_noinc
ccfd : e01f             [ 2] 	cpx #hi(0x1f40)			; Reached page count?
ccff : d0f4             [ 3] 	bne vdp_fill_vram_loop
cd01 : c040             [ 2] 	cpy #lo(0x1f40)			; Reached byte in page?
cd03 : d0f0             [ 4] 	bne vdp_fill_vram_loop
                             
                             	; Set hires attribute in the magic location
cd05 : a91e             [ 2] 	lda #30			; Hires attribute
cd07 : 8ddfbf           [ 4] 	sta 0xbfdf		; Last pos of screen memory
                             
cd0a : c60d             [ 5] 	dec vdp_curoff
cd0c : 60               [ 6] 	rts
                             	
AS65 Assembler for R6502 [1.42].                                     Page   96
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* gr_init_hires_tables
                             ;* Generate the hires tables
                             ;* Do this whilst in hires mode
                             ;****************************************
cd0d :                       gr_init_hires_tables
                             	; Initialise address pointer to start of high re
cd0d : a900             [ 2] 	lda #lo(HISCRN)
cd0f : 8530             [ 3] 	sta tmp_alo
cd11 : a9a0             [ 2] 	lda #hi(HISCRN)
cd13 : 8531             [ 3] 	sta tmp_ahi
                             	; Starting from row zero, do 200 rows
cd15 : a000             [ 2] 	ldy #0
cd17 :                       gr_init_tab_row
                             	; Save low and high bytes of screen address in t
cd17 : a530             [ 3] 	lda tmp_alo
cd19 : 99009c           [ 5] 	sta hires_row_low,y
cd1c : a531             [ 3] 	lda tmp_ahi
cd1e : 99c89c           [ 5] 	sta hires_row_hi,y
                             	; add 40 ready for next row
cd21 : 18               [ 2] 	clc
cd22 : a530             [ 3] 	lda tmp_alo
cd24 : 6928             [ 2] 	adc #40
cd26 : 8530             [ 3] 	sta tmp_alo
cd28 : a531             [ 3] 	lda tmp_ahi
cd2a : 6900             [ 2] 	adc #0
cd2c : 8531             [ 3] 	sta tmp_ahi
                             	; Max 200 rows
cd2e : c8               [ 2] 	iny
cd2f : c0c8             [ 2] 	cpy #200
cd31 : d0e4             [ 3] 	bne gr_init_tab_row
                             	; From column 0, do 240 columns
                             	; Mask starts at 0x20, when shifts to 0 then
                             	; the column increments
cd33 : a920             [ 2] 	lda #0x20
cd35 : 8532             [ 3] 	sta tmp_blo			; Pixel mask
cd37 : a200             [ 2] 	ldx #0				; Pixel column
cd39 : a000             [ 2] 	ldy #0				; Byte column
cd3b :                       gr_init_tab_col
                             	; Save current mask and column
cd3b : a532             [ 3] 	lda tmp_blo
cd3d : 9d809e           [ 5] 	sta hires_mask,x
cd40 : 98               [ 2] 	tya
cd41 : 9d909d           [ 5] 	sta hires_col,x
                             	; shift mask, if zero then increment col and res
cd44 : 4632             [ 5] 	lsr tmp_blo
cd46 : d005             [ 3] 	bne gr_init_tab_col_skip
cd48 : a920             [ 2] 	lda #0x20
cd4a : 8532             [ 3] 	sta tmp_blo
cd4c : c8               [ 2] 	iny
cd4d :                       gr_init_tab_col_skip
cd4d : e8               [ 2] 	inx
cd4e : e0f0             [ 2] 	cpx #240
cd50 : d0e9             [ 3] 	bne gr_init_tab_col
cd52 : 60               [ 6] 	rts
                             
                             
                             	
                             ;****************************************
                             ;* gr_cls
                             ;* Clear the text screen
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   97
-------------------------------- bank\bank0.s --------------------------------

cd53 :                       gr_cls
cd53 : e60d             [ 5] 	inc vdp_curoff
                             	; Set screen address for text mode
cd55 : a516             [ 3] 	lda gr_scrngeom+gr_text_start
cd57 : 8525             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cd59 : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
cd5b : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
cd5d : a61b             [ 3] 	ldx gr_scrngeom+gr_text_h		; Count of rows
                             
                             	; X and Y count bytes to fill
cd5f :                       gr_cls_row
cd5f : a000             [ 2] 	ldy #0							; Count of columns
cd61 : a524             [ 3] 	lda gr_scrngeom+gr_margin		; Is there a margin?
cd63 : f00a             [ 3] 	beq gr_cls_skip_marg
cd65 : a523             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
cd67 : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cd69 : c8               [ 2] 	iny
cd6a : a522             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
cd6c : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cd6e : c8               [ 2] 	iny
cd6f :                       gr_cls_skip_marg	
cd6f : a510             [ 3] 	lda vdp_blank
cd71 : 850f             [ 3] 	sta vdp_curval					; Under cursor is also blank
cd73 :                       gr_cls_col
cd73 : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cd75 : c8               [ 2] 	iny
cd76 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_w		; Done all columns?
cd78 : d0f9             [ 3] 	bne gr_cls_col
                             	; Update pointer
cd7a : e8               [ 2] 	inx
cd7b : 18               [ 2] 	clc
cd7c : a525             [ 3] 	lda gr_scrngeom+gr_geom_tmp
cd7e : 651a             [ 3] 	adc gr_scrngeom+gr_text_w
cd80 : 8525             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cd82 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp+1
cd84 : 6900             [ 2] 	adc #0
cd86 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
cd88 : e41b             [ 3] 	cpx gr_scrngeom+gr_text_h		; Done all rows?
cd8a : d0d3             [ 3] 	bne gr_cls_row
                             
                             	; set cursror position to top left
cd8c : a510             [ 3] 	lda vdp_blank
cd8e : 850f             [ 3] 	sta vdp_curval
cd90 : a624             [ 3] 	ldx gr_scrngeom+gr_margin
cd92 : a000             [ 2] 	ldy #0
cd94 : 38               [ 2] 	sec								; Init mode
cd95 : 20c5cd           [ 6] 	jsr gr_set_cur_init
                             
cd98 : c60d             [ 5] 	dec vdp_curoff
                             
cd9a : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* gr_getXY_base
                             ;* Get base screen address using Y coord only
                             ;* Input : X = y coord
                             ;* Output :	gr_geom_tmp updated with base
                             ;* Regs affected : A
                             ;****************************************
cd9b :                       gr_getXY_base
                             	; Find y offset using **X register**
AS65 Assembler for R6502 [1.42].                                     Page   98
-------------------------------- bank\bank0.s --------------------------------

cd9b : 18               [ 2] 	clc
cd9c : bdb0d1           [ 4] 	lda gr_offset_40lo,x
cd9f : 6516             [ 3] 	adc gr_scrngeom+gr_text_start
cda1 : 8525             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cda3 : bdccd1           [ 4] 	lda gr_offset_40hi,x
cda6 : 6517             [ 3] 	adc gr_scrngeom+gr_text_start+1
cda8 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
                             	; A = high byte of base address
cdaa : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* gr_plot
                             ;* Write a byte in the screen pos
                             ;* Input :	Y,X = coord, A = Byte to put
                             ;*			X = Y COORDINATE
                             ;*			Y = X COORDINATE!!
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cdab :                       gr_plot
cdab : 48               [ 3] 	pha					; Save byte to put
cdac : 209bcd           [ 6] 	jsr gr_getXY_base	; base addre
cdaf : 68               [ 4] 	pla					; Get byte to put
cdb0 : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cdb2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_put
                             ;* Write a byte in the current cursor position
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cdb3 :                       gr_put
cdb3 : e60d             [ 5] 	inc vdp_curoff		; Disable cusror
cdb5 : 850f             [ 3] 	sta vdp_curval		; Update cursor value
                             	; Base address plus X offset
cdb7 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_x
cdb9 : 911e             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
cdbb : c60d             [ 5] 	dec vdp_curoff		; Allow cursor flashing
cdbd : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* gr_get
                             ;* Get the byte in the screen pos
                             ;* Input : Y,X = coord (**Y = X coordinate!!)
                             ;* Output : X,Y = address, A = peeked byte
                             ;* Regs affected : All
                             ;****************************************
cdbe :                       gr_get
cdbe : 209bcd           [ 6] 	jsr gr_getXY_base	; Base address
cdc1 : b125             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y
cdc3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_set_cur
                             ;* Set the cursor position
                             ;* Input : X, Y = position
                             ;* Output : None
                             ;* Regs affected : None
AS65 Assembler for R6502 [1.42].                                     Page   99
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
cdc4 :                       gr_set_cur
cdc4 : 18               [ 2] 	clc
cdc5 :                       gr_set_cur_init
cdc5 : e60d             [ 5] 	inc vdp_curoff				; Disable cursor
                             	
cdc7 : b00e             [ 3] 	bcs gr_set_cur_skip			; Skip restore if C=1
cdc9 : 8630             [ 3] 	stx tmp_alo
cdcb : 8431             [ 3] 	sty tmp_ahi
                             	; First restore what is under the cursor
                             	; in case cursor is ON
cdcd : 8425             [ 3] 	sty gr_scrngeom+gr_geom_tmp
cdcf : a50f             [ 3] 	lda vdp_curval
cdd1 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_x
cdd3 : 911e             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
cdd5 : a425             [ 3] 	ldy gr_scrngeom+gr_geom_tmp
cdd7 :                       gr_set_cur_skip
                             	; Save new cursor position
cdd7 : 861c             [ 3] 	stx gr_scrngeom+gr_cur_x
cdd9 : 841d             [ 3] 	sty gr_scrngeom+gr_cur_y
                             
                             	; Now calculate the new cursor vram address
cddb : a61d             [ 3] 	ldx gr_scrngeom+gr_cur_y
cddd : 209bcd           [ 6] 	jsr gr_getXY_base
                             	; Update pointer in tmp, A already has high byte
cde0 : 851f             [ 3] 	sta gr_scrngeom+gr_cur_ptr+1
cde2 : a525             [ 3] 	lda gr_scrngeom+gr_geom_tmp
cde4 : 851e             [ 3] 	sta gr_scrngeom+gr_cur_ptr
                             	; Read screen at this position, offset with X co
cde6 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_x
cde8 : b11e             [ 5] 	lda (gr_scrngeom+gr_cur_ptr),y
cdea : 850f             [ 3] 	sta vdp_curval
                             	; Reset cursor so it's visible
cdec : a900             [ 2] 	lda #0
cdee : 850e             [ 3] 	sta vdp_curstat
cdf0 : a901             [ 2] 	lda #1
cdf2 : 850c             [ 3] 	sta vdp_curcnt
                             
cdf4 : c60d             [ 5] 	dec vdp_curoff
                             
cdf6 : 60               [ 6] 	rts
                             	
                             
                             
                             ;****************************************
                             ;* gr_scroll_up
                             ;* Scroll screen one line up
                             ;****************************************
cdf7 :                       gr_scroll_up
cdf7 : e60d             [ 5] 	inc vdp_curoff
                             	
                             	; Set source in a and dest in b
                             	; b is first line, source is second
cdf9 : 18               [ 2] 	clc
cdfa : a516             [ 3] 	lda gr_scrngeom+gr_text_start
cdfc : 8532             [ 3] 	sta tmp_blo
cdfe : 651a             [ 3] 	adc gr_scrngeom+gr_text_w
ce00 : 8530             [ 3] 	sta tmp_alo
ce02 : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
ce04 : 8533             [ 3] 	sta tmp_bhi
ce06 : 6900             [ 2] 	adc #0
ce08 : 8531             [ 3] 	sta tmp_ahi
AS65 Assembler for R6502 [1.42].                                     Page  100
-------------------------------- bank\bank0.s --------------------------------

                             	
                             	; Restore what was underneath cursor
ce0a : a50f             [ 3] 	lda vdp_curval
ce0c : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_x
ce0e : 911e             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
                             	; x = lines to scroll (1 less than screen height
ce10 : a61b             [ 3] 	ldx gr_scrngeom+gr_text_h
ce12 : ca               [ 2] 	dex
                             
ce13 :                       gr_scroll_cpy_ln
                             	; Start from right hand edge (easier)
ce13 : a41a             [ 3] 	ldy gr_scrngeom+gr_text_w
ce15 : 88               [ 2] 	dey
ce16 :                       gr_scroll_char
                             	; get char from source and copy to dest
ce16 : b130             [ 5] 	lda (tmp_alo),y
ce18 : 9132             [ 5] 	sta (tmp_blo),y
ce1a : 88               [ 2] 	dey
ce1b : 10f9             [ 3] 	bpl gr_scroll_char
                             
                             	; Update source address
ce1d : 18               [ 2] 	clc
ce1e : a530             [ 3] 	lda tmp_alo
ce20 : 651a             [ 3] 	adc gr_scrngeom+gr_text_w
ce22 : 8530             [ 3] 	sta tmp_alo
ce24 : a531             [ 3] 	lda tmp_ahi
ce26 : 6900             [ 2] 	adc #0
ce28 : 8531             [ 3] 	sta tmp_ahi
                             	; Update destination address
ce2a : 18               [ 2] 	clc
ce2b : a532             [ 3] 	lda tmp_blo
ce2d : 651a             [ 3] 	adc gr_scrngeom+gr_text_w
ce2f : 8532             [ 3] 	sta tmp_blo
ce31 : a533             [ 3] 	lda tmp_bhi
ce33 : 6900             [ 2] 	adc #0
ce35 : 8533             [ 3] 	sta tmp_bhi
                             
                             	; One line complete
ce37 : ca               [ 2] 	dex
ce38 : d0d9             [ 3] 	bne gr_scroll_cpy_ln
                             
                             	; Source is pointing at last line
                             	; Last line needs filling
ce3a : a000             [ 2] 	ldy #0							; Start from left
ce3c : a524             [ 3] 	lda gr_scrngeom+gr_margin		; Margin?
ce3e : f00a             [ 3] 	beq gr_scroll_marg				; Skip if not
ce40 : a523             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
ce42 : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
ce44 : c8               [ 2] 	iny
ce45 : a522             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
ce47 : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
ce49 : c8               [ 2] 	iny	
ce4a :                       gr_scroll_marg
                             	; Needs to be filled with blank
ce4a : a510             [ 3] 	lda vdp_blank
ce4c : 850f             [ 3] 	sta vdp_curval			; Also this is the cursor value
ce4e :                       gr_scroll_erase_ln
ce4e : 9132             [ 5] 	sta (tmp_blo),y	
ce50 : c8               [ 2] 	iny
ce51 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_w
ce53 : d0f9             [ 3] 	bne gr_scroll_erase_ln
AS65 Assembler for R6502 [1.42].                                     Page  101
-------------------------------- bank\bank0.s --------------------------------

                             
ce55 : c60d             [ 5] 	dec vdp_curoff
                             
ce57 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_new_ln
                             ;* Carry out a new line
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce58 :                       gr_new_ln
                             ;	_pushAXY
                             	; X pos is zero, Y needs to increment
ce58 : a624             [ 3] 	ldx gr_scrngeom+gr_margin
ce5a : a41d             [ 3] 	ldy gr_scrngeom+gr_cur_y
ce5c : c8               [ 2] 	iny
ce5d : c41b             [ 3] 	cpy gr_scrngeom+gr_text_h
ce5f : d00c             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
                             	; Common routine also used by cursor right
ce61 :                       gr_scroll_routine
ce61 : 88               [ 2] 	dey
ce62 : 8a               [ 2] 	txa
ce63 : 48               [ 3] 	pha
ce64 : 98               [ 2] 	tya
ce65 : 48               [ 3] 	pha
ce66 : 20f7cd           [ 6] 	jsr gr_scroll_up
ce69 : 68               [ 4] 	pla
ce6a : a8               [ 2] 	tay
ce6b : 68               [ 4] 	pla
ce6c : aa               [ 2] 	tax
ce6d :                       gr_nl_skip_nl
ce6d : 20c4cd           [ 6] 	jsr gr_set_cur
                             ;	_pullAXY
ce70 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* gr_cur_right
                             ;* Advance cursor position
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce71 :                       gr_cur_right
                             ;	_pushAXY
                             	; Load cursor x,y position
ce71 : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_x
ce73 : a41d             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
ce75 : e8               [ 2] 	inx
                             	; Check if reached past edge of line
ce76 : e41a             [ 3] 	cpx gr_scrngeom+gr_text_w
ce78 : d0f3             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then wrap to next line
ce7a : a624             [ 3] 	ldx gr_scrngeom+gr_margin
ce7c : c8               [ 2] 	iny
ce7d : c41b             [ 3] 	cpy gr_scrngeom+gr_text_h
ce7f : f0e0             [ 3] 	beq gr_scroll_routine		; Common scroll routine
AS65 Assembler for R6502 [1.42].                                     Page  102
-------------------------------- bank\bank0.s --------------------------------

ce81 : d0ea             [ 3] 	bne gr_nl_skip_nl			; Common set cursor
                             
                             ;****************************************
                             ;* gr_cur_left
                             ;* Advance cursor left
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce83 :                       gr_cur_left
                             ;	_pushAXY
                             	; Load cursor x,y position, load X last to check
ce83 : a41d             [ 3] 	ldy gr_scrngeom+gr_cur_y
ce85 : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_x
                             	
                             	; Decrement screen pointer
                             	; Move cursor left
ce87 : e424             [ 3] 	cpx gr_scrngeom+gr_margin	; Already at left marg
ce89 : d007             [ 3] 	bne gr_cur_skip_at_left		; No, then just go left
ce8b : c000             [ 2] 	cpy #0						; Else check if can wrap up
ce8d : f007             [ 3] 	beq gr_cur_skip_at_tl
ce8f : 88               [ 2] 	dey
ce90 : a61a             [ 3] 	ldx gr_scrngeom+gr_text_w
ce92 :                       gr_cur_skip_at_left
ce92 : ca               [ 2] 	dex
ce93 : 20c4cd           [ 6] 	jsr gr_set_cur
                             
ce96 :                       gr_cur_skip_at_tl	
                             ;	_pullAXY
ce96 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_up
                             ;* Advance cursor up
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce97 :                       gr_cur_up
                             ;	_pushAXY
                             	; Load cursor x,y position, load Y last to check
ce97 : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_x
ce99 : a41d             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	
ce9b : f004             [ 3] 	beq gr_cur_skip_at_top	; If already at the top, 
ce9d : 88               [ 2] 	dey
ce9e : 20c4cd           [ 6] 	jsr gr_set_cur
                             	
cea1 :                       gr_cur_skip_at_top	
                             ;	_pullAXY
cea1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_down
                             ;* Advance cursor down
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cea2 :                       gr_cur_down
                             ;	_pushAXY
                             	; Load cursor x,y position
AS65 Assembler for R6502 [1.42].                                     Page  103
-------------------------------- bank\bank0.s --------------------------------

cea2 : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_x
cea4 : a41d             [ 3] 	ldy gr_scrngeom+gr_cur_y
cea6 : c8               [ 2] 	iny
cea7 : c41b             [ 3] 	cpy gr_scrngeom+gr_text_h			; If already at  bot
cea9 : f003             [ 3] 	beq gr_cur_skip_at_bot				; then don't do anythi
ceab : 20c4cd           [ 6] 	jsr gr_set_cur
                             
ceae :                       gr_cur_skip_at_bot
                             ;	_pullAXY
ceae : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_del
                             ;* Action del
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ceaf :                       gr_del
                             ;	_pushAXY
ceaf : 2083ce           [ 6] 	jsr gr_cur_left
ceb2 : a920             [ 2] 	lda #' '							; Put a space
ceb4 : 20b3cd           [ 6] 	jsr gr_put
                             ;	_pullAXY
ceb7 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=0 means valid code
                             ;****************************************
ceb8 :                       gr_get_key
                             	; save X,Y but A is ok to trample
ceb8 : 8a               [ 2] 	txa
ceb9 : 48               [ 3] 	pha
ceba : 98               [ 2] 	tya
cebb : 48               [ 3] 	pha
cebc :                       gr_get_key_2
cebc : 08               [ 3] 	php
cebd : 2066c8           [ 6] 	jsr kb_get_key
cec0 : 9006             [ 3] 	bcc gr_key_check_key
cec2 : 28               [ 4] 	plp									; Get async pref
cec3 : b0f7             [ 3] 	bcs	gr_get_key_2					; Keep checking if sync
cec5 : 38               [ 2] 	sec
cec6 : b019             [ 3] 	bcs gr_key_tidy_up					; Finish if not
cec8 :                       gr_key_check_key						; Check the key pressed
cec8 : c901             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
ceca : d004             [ 3] 	bne gr_key_skip_copy
cecc : a50f             [ 3] 	lda vdp_curval						; If yes the get char under 
cece : b00f             [ 3] 	bcs gr_key_got_key					; Always branches (n=1, c
ced0 :                       gr_key_skip_copy
ced0 : c914             [ 2] 	cmp #CTRL_CAPS
ced2 : d00b             [ 3] 	bne gr_key_got_key
ced4 : a52a             [ 3] 	lda kb_stat							; Toggle caps bit
ced6 : 4901             [ 2] 	eor #KB_CAPSLK
ced8 : 852a             [ 3] 	sta kb_stat
ceda : 28               [ 4] 	plp									; Get back synchronous pref
cedb : b0df             [ 3] 	bcs gr_get_key_2					; And check again for sync
cedd : 900b             [ 3] 	bcc gr_key_no_key					; Else no key
cedf :                       gr_key_got_key
AS65 Assembler for R6502 [1.42].                                     Page  104
-------------------------------- bank\bank0.s --------------------------------

cedf : 28               [ 4] 	plp
cee0 : 18               [ 2] 	clc									; Ensure C=0 for valid key
cee1 :                       gr_key_tidy_up
                             	; restore X,Y but don't lose A
cee1 : 8536             [ 3] 	sta tmp_d
cee3 : 68               [ 4] 	pla
cee4 : a8               [ 2] 	tay
cee5 : 68               [ 4] 	pla
cee6 : aa               [ 2] 	tax
cee7 : a536             [ 3] 	lda tmp_d
cee9 : 60               [ 6] 	rts
ceea :                       gr_key_no_key
ceea : 28               [ 4] 	plp
ceeb : 38               [ 2] 	sec									; Ensure C=1 for invalid key
ceec : b0f3             [ 3] 	bcs gr_key_tidy_up					; Always branches	
                             	
                             ;****************************************
                             ;* gr_put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ceee :                       gr_put_byte
                             	_pushAXY
                             
cef7 : 2000cf           [ 6] 	jsr gr_put_byte_low
                             	_pullAXY
                             
ceff : 60               [ 6] 	rts
                             	
cf00 :                       gr_put_byte_low
cf00 : c97f             [ 2] 	cmp #UTF_DEL			; Del key
cf02 : f004             [ 3] 	beq gr_process_special
cf04 : c920             [ 2] 	cmp #32					; Special char?
cf06 : b01c             [ 3] 	bcs gr_printable		; >=32 == carry clear
cf08 :                       gr_process_special
                             	; Else find special behaviour to do
cf08 : a2ff             [ 2] 	ldx #-1
cf0a : 8530             [ 3] 	sta tmp_alo
cf0c :                       gr_special_loop
cf0c : e8               [ 2] 	inx
cf0d : bd2bcf           [ 4] 	lda gr_special_ch,x
cf10 : f011             [ 3] 	beq gr_no_special
cf12 : c530             [ 3] 	cmp tmp_alo
cf14 : d0f6             [ 3] 	bne gr_special_loop
cf16 : bd33cf           [ 4] 	lda gr_special_fn_lo,x
cf19 : 8530             [ 3] 	sta tmp_alo
cf1b : bd3acf           [ 4] 	lda gr_special_fn_hi,x
cf1e : 8531             [ 3] 	sta tmp_ahi
cf20 : 6c3000           [ 6] 	jmp (tmp_alo)
cf23 :                       gr_no_special
cf23 : 60               [ 6] 	rts
                             	;	Normal caracter processing here.
cf24 :                       gr_printable
                             	; Place in current position and move right
cf24 : 20b3cd           [ 6] 	jsr gr_put
cf27 : 2071ce           [ 6] 	jsr gr_cur_right
cf2a : 60               [ 6] 	rts
                             
cf2b :                       gr_special_ch
cf2b : 0d                    	db UTF_CR
AS65 Assembler for R6502 [1.42].                                     Page  105
-------------------------------- bank\bank0.s --------------------------------

cf2c : 7f                    	db UTF_DEL
cf2d : 08                    	db CRSR_LEFT
cf2e : 09                    	db CRSR_RIGHT
cf2f : 0b                    	db CRSR_UP
cf30 : 0a                    	db CRSR_DOWN
cf31 : 0c                    	db UTF_FF
cf32 : 00                    	db 0
                             
cf33 :                       gr_special_fn_lo
cf33 : 58                    	db lo(gr_new_ln)
cf34 : af                    	db lo(gr_del)
cf35 : 83                    	db lo(gr_cur_left)
cf36 : 71                    	db lo(gr_cur_right)
cf37 : 97                    	db lo(gr_cur_up)
cf38 : a2                    	db lo(gr_cur_down)
cf39 : 53                    	db lo(gr_cls)
                             
cf3a :                       gr_special_fn_hi
cf3a : ce                    	db hi(gr_new_ln)
cf3b : ce                    	db hi(gr_del)
cf3c : ce                    	db hi(gr_cur_left)
cf3d : ce                    	db hi(gr_cur_right)
cf3e : ce                    	db hi(gr_cur_up)
cf3f : ce                    	db hi(gr_cur_down)
cf40 : cd                    	db hi(gr_cls)
                             
                             ; Special command to print to the screen
                             ; Y,A=Message, zero terminated
cf41 :                       gr_print_msg
cf41 : 8447             [ 3] 	sty num_tmp
cf43 : 8548             [ 3] 	sta num_tmp+1
cf45 : a000             [ 2] 	ldy #0
cf47 :                       gr_print_msg_loop
cf47 : b147             [ 5] 	lda (num_tmp),y
cf49 : f006             [ 3] 	beq gr_print_msg_done
cf4b : 20eece           [ 6] 	jsr gr_put_byte
cf4e : c8               [ 2] 	iny
cf4f : d0f6             [ 3] 	bne gr_print_msg_loop
cf51 :                       gr_print_msg_done
cf51 : a548             [ 3] 	lda num_tmp+1
cf53 : a447             [ 3] 	ldy num_tmp
cf55 : 60               [ 6] 	rts
                             
                             ;******* HIRES STUFF *****
                             ;****************************************
                             ;* gr_hchar
                             ;* Plot character to hires X,Y coordinates with c
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cf56 :                       gr_hchar
                             	; Multiply char code by 8
                             	; and add to char font base
                             	; tmp_clo contains base address
cf56 : 0a               [ 2] 	asl a
cf57 : 2635             [ 5] 	rol tmp_chi	
cf59 : 0a               [ 2] 	asl a
cf5a : 2635             [ 5] 	rol tmp_chi	
cf5c : 0a               [ 2] 	asl a
cf5d : 2635             [ 5] 	rol tmp_chi
cf5f : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  106
-------------------------------- bank\bank0.s --------------------------------

cf60 : 6514             [ 3] 	adc gr_scrngeom+gr_char
cf62 : 8534             [ 3] 	sta tmp_clo
cf64 : a535             [ 3] 	lda tmp_chi
cf66 : 2907             [ 2] 	and #7
cf68 : 6515             [ 3] 	adc gr_scrngeom+gr_char+1
cf6a : 8535             [ 3] 	sta tmp_chi
                             
                             	; Set up destination position
cf6c : 20fccf           [ 6] 	jsr gr_point_setup
                             	; tmp_alo contains address including column offs
cf6f : 18               [ 2] 	clc
cf70 : 98               [ 2] 	tya
cf71 : 6530             [ 3] 	adc tmp_alo
cf73 : 8530             [ 3] 	sta tmp_alo
cf75 : a531             [ 3] 	lda tmp_ahi
cf77 : 6900             [ 2] 	adc #0
cf79 : 8531             [ 3] 	sta tmp_ahi
                             	
cf7b : a532             [ 3] 	lda tmp_blo					; Get the mask
cf7d : a207             [ 2] 	ldx #7
cf7f :                       gr_hchar_mask					; Calculate how many shifts to 
cf7f : ca               [ 2] 	dex
cf80 : 4a               [ 2] 	lsr a
cf81 : d0fc             [ 3] 	bne gr_hchar_mask
cf83 : 8632             [ 3] 	stx tmp_blo					; number between 1 and 6 : shift
                             
                             	; copy font bytes and shift the required number 
                             	; go from bottom to top as data gets stored on t
cf85 : a007             [ 2] 	ldy #7
cf87 :                       gr_hchar_getfont
cf87 : b134             [ 5] 	lda (tmp_clo),y
cf89 : 853b             [ 3] 	sta ztmp_24
cf8b : a900             [ 2] 	lda #0
cf8d : 853c             [ 3] 	sta ztmp_24+1
                             	
                             	; shift right number of times
cf8f : a632             [ 3] 	ldx tmp_blo
cf91 :                       gr_hchar_rot1bit
cf91 : ca               [ 2] 	dex
cf92 : f00d             [ 3] 	beq gr_hchar_rot1bit_nx
cf94 : 463b             [ 5] 	lsr ztmp_24					; Rotate left hand side
cf96 : a53c             [ 3] 	lda ztmp_24+1				; Rotate right hand side
cf98 : 9002             [ 3] 	bcc gr_hchar_rot1bit_bcc
cf9a : 0940             [ 2] 	ora #0x40					; account for 6 bits per byte
cf9c :                       gr_hchar_rot1bit_bcc
cf9c : 4a               [ 2] 	lsr a
cf9d : 853c             [ 3] 	sta ztmp_24+1
cf9f : 10f0             [ 3] 	bpl gr_hchar_rot1bit		; Always as lsr sets N=0
cfa1 :                       gr_hchar_rot1bit_nx
cfa1 : a53c             [ 3] 	lda ztmp_24+1				; Get RHS
cfa3 : 48               [ 3] 	pha							; Push RHS on to stack
cfa4 : a53b             [ 3] 	lda ztmp_24					; Get LHS
cfa6 : 48               [ 3] 	pha							; Push that too - LH gets pulled first
cfa7 : 88               [ 2] 	dey							; Bottom to to lines
cfa8 : 10dd             [ 3] 	bpl gr_hchar_getfont
                             
                             	; Now copy shift source to destination, accounti
cfaa : a200             [ 2] 	ldx #0
cfac :                       gr_hchar_copyline
cfac : a420             [ 3] 	ldy gr_scrngeom+gr_pixmode	; Mode determines how
cfae : f024             [ 3] 	beq gr_hchar_copyline_0
cfb0 : c002             [ 2] 	cpy #2
AS65 Assembler for R6502 [1.42].                                     Page  107
-------------------------------- bank\bank0.s --------------------------------

cfb2 : f010             [ 3] 	beq gr_hchar_copyline_2
                             
                             	; Mode = 1 : OR
cfb4 : a000             [ 2] 	ldy #0						; Get lh side source
cfb6 : 68               [ 4] 	pla
cfb7 : 1130             [ 5] 	ora (tmp_alo),y
cfb9 : 9130             [ 5] 	sta (tmp_alo),y
cfbb : c8               [ 2] 	iny							; Get rh side source
cfbc : 68               [ 4] 	pla
cfbd : 1130             [ 5] 	ora (tmp_alo),y
cfbf : 9130             [ 5] 	sta (tmp_alo),y
cfc1 : 4ce9cf           [ 3] 	jmp gr_hchar_copyline_nx
cfc4 :                       gr_hchar_copyline_2	
                             	; Mode = 2 : EOR
cfc4 : a000             [ 2] 	ldy #0						; Get lh side source
cfc6 : 68               [ 4] 	pla
cfc7 : 5130             [ 5] 	eor (tmp_alo),y
cfc9 : 9130             [ 5] 	sta (tmp_alo),y
cfcb : c8               [ 2] 	iny							; Get rh side source
cfcc : 68               [ 4] 	pla
cfcd : 5130             [ 5] 	eor (tmp_alo),y
cfcf : 9130             [ 5] 	sta (tmp_alo),y
cfd1 : 4ce9cf           [ 3] 	jmp gr_hchar_copyline_nx
cfd4 :                       gr_hchar_copyline_0
                             	; Mode = 0 : erase
cfd4 : a000             [ 2] 	ldy #0						; Get lh side source
cfd6 : 68               [ 4] 	pla
cfd7 : 853b             [ 3] 	sta ztmp_24
cfd9 : 1130             [ 5] 	ora (tmp_alo),y
cfdb : 453b             [ 3] 	eor ztmp_24
cfdd : 9130             [ 5] 	sta (tmp_alo),y
cfdf : c8               [ 2] 	iny							; Get rh side source
cfe0 : 68               [ 4] 	pla
cfe1 : 853b             [ 3] 	sta ztmp_24
cfe3 : 1130             [ 5] 	ora (tmp_alo),y
cfe5 : 453b             [ 3] 	eor ztmp_24
cfe7 : 9130             [ 5] 	sta (tmp_alo),y
cfe9 :                       gr_hchar_copyline_nx
cfe9 : 18               [ 2] 	clc							; Next address
cfea : a530             [ 3] 	lda tmp_alo
cfec : 6928             [ 2] 	adc #40
cfee : 8530             [ 3] 	sta tmp_alo
cff0 : a531             [ 3] 	lda tmp_alo+1
cff2 : 6900             [ 2] 	adc #0
cff4 : 8531             [ 3] 	sta tmp_alo+1
cff6 : e8               [ 2] 	inx
cff7 : e008             [ 2] 	cpx #8
cff9 : d0b1             [ 3] 	bne gr_hchar_copyline
cffb : 60               [ 6] 	rts							; Done after 8 lines
                             
                             ;****************************************
                             ;* gr_point_setup
                             ;* Calculate information about a pixel location
                             ;* Input : X,Y = coord
                             ;* Output : None
                             ;* Regs affected :
                             ;* tmp_alo,hi contains the row base address
                             ;* tmp_blo contains the mask index
                             ;* tmp_bhi contains the column offset in to row
                             ;* Y is same as tmp_bhi
                             ;* X is same as tmp_blo
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  108
-------------------------------- bank\bank0.s --------------------------------

cffc :                       gr_point_setup
                             	; Get row address
cffc : b9009c           [ 4] 	lda hires_row_low,y
cfff : 8530             [ 3] 	sta tmp_alo
d001 : b9c89c           [ 4] 	lda hires_row_hi,y
d004 : 8531             [ 3] 	sta tmp_ahi
                             	; Get the pixel mask
d006 : bd809e           [ 4] 	lda hires_mask,x
d009 : 8532             [ 3] 	sta tmp_blo
                             	; Get the column offset to Y
d00b : bc909d           [ 4] 	ldy hires_col,x
d00e : 60               [ 6] 	rts
                             
                             ;* Get pixel value at X,Y in to A	
d00f :                       gr_pixel
d00f : 20fccf           [ 6] 	jsr gr_point_setup				; Set up mask and addresse
d012 : b130             [ 5] 	lda (tmp_alo),y					; Get screen byte
d014 : 2532             [ 3] 	and tmp_blo						; Check if pixel coincides with
d016 : 60               [ 6] 	rts
                             	
                             ;* Plot a point based on X,Y coordinates
d017 :                       gr_point
d017 : 20fccf           [ 6] 	jsr gr_point_setup				; Set up mask and addresse
                             ;* Plot a point based on tmp_alo base, Y offset a
d01a :                       gr_point_plot
d01a : b130             [ 5] 	lda (tmp_alo),y					; Get screen byte
d01c : a620             [ 3] 	ldx gr_scrngeom+gr_pixmode		; Look at the mode
d01e : e002             [ 2] 	cpx #2							; If eor mode then go and write
d020 : f006             [ 3] 	beq gr_point_eor
d022 : 0532             [ 3] 	ora tmp_blo						; Or with MASK
d024 : e000             [ 2] 	cpx #0							; But if not then eor
d026 : d002             [ 3] 	bne gr_point_write
d028 :                       gr_point_eor
d028 : 4532             [ 3] 	eor tmp_blo						; EOR with MASK
d02a :                       gr_point_write
d02a : 9130             [ 5] 	sta (tmp_alo),y
d02c : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* gr_circle
                             ;* Draw a circle centre x0,y0, radius r
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = r
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d02d :                       gr_circle
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003b =                       grc_x0 	= (num_a)
003c =                       grc_y0 	= (num_a+1)
003d =                       grc_r 	= (num_a+2)
003e =                       grc_x 	= (num_a+3)
0040 =                       grc_y	= (num_b+1)
0041 =                       grc_d	= (num_b+2)
                             
                             	;x = radius
d02d : a53d             [ 3] 	lda grc_r
d02f : 853e             [ 3] 	sta grc_x
                             	;decision = 1 - x
AS65 Assembler for R6502 [1.42].                                     Page  109
-------------------------------- bank\bank0.s --------------------------------

d031 : a900             [ 2] 	lda #0
                             	;y = 0
d033 : 8540             [ 3] 	sta grc_y
d035 : 18               [ 2] 	clc			; A=0 so CLC subtracts 1 :-)
d036 : e53e             [ 3] 	sbc grc_x
d038 : 8541             [ 3] 	sta grc_d
d03a :                       gr_circle_plot
                             	;while(x >= y)
d03a : a53e             [ 3] 	lda grc_x
d03c : c540             [ 3] 	cmp grc_y
d03e : 902a             [ 3] 	bcc gr_circle_done
                             	;plot 8 points on current x,y
d040 : 206bd0           [ 6] 	jsr gr_circle_points
                             	;y++
d043 : e640             [ 5] 	inc grc_y
                             	;if d<=0
d045 : a541             [ 3] 	lda grc_d
d047 : f014             [ 3] 	beq gr_circle_d_lte0
d049 : 3012             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
d04b : c63e             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
d04d : a540             [ 3] 	lda grc_y
d04f : 38               [ 2] 	sec
d050 : e53e             [ 3] 	sbc grc_x
d052 : 0a               [ 2] 	asl a
d053 : 18               [ 2] 	clc
d054 : 6901             [ 2] 	adc #1
d056 : 6541             [ 3] 	adc grc_d
d058 : 8541             [ 3] 	sta grc_d
d05a : 4c3ad0           [ 3] 	jmp gr_circle_plot	
d05d :                       gr_circle_d_lte0
                             	;decision += 2 * y + 1
d05d : a540             [ 3] 	lda grc_y
d05f : 0a               [ 2] 	asl a
d060 : 18               [ 2] 	clc
d061 : 6901             [ 2] 	adc #1
d063 : 6541             [ 3] 	adc grc_d
d065 : 8541             [ 3] 	sta grc_d
d067 : 4c3ad0           [ 3] 	jmp gr_circle_plot	
d06a :                       gr_circle_done
d06a : 60               [ 6] 	rts
d06b :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
d06b : a53e             [ 3] 	lda grc_x
d06d : 18               [ 2] 	clc
d06e : 653b             [ 3] 	adc grc_x0
d070 : aa               [ 2] 	tax
d071 : a540             [ 3] 	lda grc_y
d073 : 18               [ 2] 	clc
d074 : 653c             [ 3] 	adc grc_y0
d076 : a8               [ 2] 	tay
d077 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
d07a : a540             [ 3] 	lda grc_y
d07c : 18               [ 2] 	clc
d07d : 653b             [ 3] 	adc grc_x0
d07f : aa               [ 2] 	tax
d080 : a53e             [ 3] 	lda grc_x
AS65 Assembler for R6502 [1.42].                                     Page  110
-------------------------------- bank\bank0.s --------------------------------

d082 : 18               [ 2] 	clc
d083 : 653c             [ 3] 	adc grc_y0
d085 : a8               [ 2] 	tay
d086 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
d089 : a53b             [ 3] 	lda grc_x0
d08b : 38               [ 2] 	sec
d08c : e53e             [ 3] 	sbc grc_x
d08e : aa               [ 2] 	tax
d08f : a540             [ 3] 	lda grc_y
d091 : 18               [ 2] 	clc
d092 : 653c             [ 3] 	adc grc_y0
d094 : a8               [ 2] 	tay
d095 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
d098 : a53b             [ 3] 	lda grc_x0
d09a : 38               [ 2] 	sec
d09b : e540             [ 3] 	sbc grc_y
d09d : aa               [ 2] 	tax
d09e : a53e             [ 3] 	lda grc_x
d0a0 : 18               [ 2] 	clc
d0a1 : 653c             [ 3] 	adc grc_y0
d0a3 : a8               [ 2] 	tay
d0a4 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
d0a7 : a53b             [ 3] 	lda grc_x0
d0a9 : 38               [ 2] 	sec
d0aa : e53e             [ 3] 	sbc grc_x
d0ac : aa               [ 2] 	tax
d0ad : a53c             [ 3] 	lda grc_y0
d0af : 38               [ 2] 	sec
d0b0 : e540             [ 3] 	sbc grc_y
d0b2 : a8               [ 2] 	tay
d0b3 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
d0b6 : a53b             [ 3] 	lda grc_x0
d0b8 : 38               [ 2] 	sec
d0b9 : e540             [ 3] 	sbc grc_y
d0bb : aa               [ 2] 	tax
d0bc : a53c             [ 3] 	lda grc_y0
d0be : 38               [ 2] 	sec
d0bf : e53e             [ 3] 	sbc grc_x
d0c1 : a8               [ 2] 	tay
d0c2 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
d0c5 : a53e             [ 3] 	lda grc_x
d0c7 : 18               [ 2] 	clc
d0c8 : 653b             [ 3] 	adc grc_x0
d0ca : aa               [ 2] 	tax
d0cb : a53c             [ 3] 	lda grc_y0
d0cd : 38               [ 2] 	sec
d0ce : e540             [ 3] 	sbc grc_y
d0d0 : a8               [ 2] 	tay
d0d1 : 2017d0           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
d0d4 : a540             [ 3] 	lda grc_y
d0d6 : 18               [ 2] 	clc
d0d7 : 653b             [ 3] 	adc grc_x0
d0d9 : aa               [ 2] 	tax
d0da : a53c             [ 3] 	lda grc_y0
d0dc : 38               [ 2] 	sec
d0dd : e53e             [ 3] 	sbc grc_x
AS65 Assembler for R6502 [1.42].                                     Page  111
-------------------------------- bank\bank0.s --------------------------------

d0df : a8               [ 2] 	tay
d0e0 : 2017d0           [ 6] 	jsr gr_point
d0e3 : 60               [ 6] 	rts
                             
                             	
                             	
                             ;****************************************
                             ;* gr_line
                             ;* Draw a line from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d0e4 :                       gr_line
                             
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003b =                       grl_x0 	= (num_a)
003c =                       grl_y0 	= (num_a+1)
003d =                       grl_x1 	= (num_a+2)
003e =                       grl_y1 	= (num_a+3)
003f =                       grl_dx	= (ztmp_24+4)
0040 =                       grl_dy	= (ztmp_24+5)
0041 =                       grl_xyyx= (ztmp_24+6)
0042 =                       grl_2dx	= (ztmp_24+7)			; Word
0044 =                       grl_2dy	= (ztmp_24+9)			; Word
0046 =                       grl_2dxy= (ztmp_24+11)			; Word
0048 =                       grl_sinx= (ztmp_24+13)
0049 =                       grl_p	= (ztmp_24+14)			; Word
004b =                       grl_siny= (ztmp_24+16)
                             
d0e4 : a900             [ 2] 	lda #0
d0e6 : 8541             [ 3] 	sta grl_xyyx				; Assume normal xy axis
                             	
                             	; check if abs(dy)>abs(dx) if so need to swap xy
                             	; num_b = abs(x), num_b+1 = abs(dy)
d0e8 : 38               [ 2] 	sec
d0e9 : a53d             [ 3] 	lda grl_x1
d0eb : e53b             [ 3] 	sbc grl_x0
d0ed : b004             [ 3] 	bcs gr_line_skip_dx_neg
d0ef : 49ff             [ 2] 	eor #0xff
d0f1 : 6901             [ 2] 	adc #1
d0f3 :                       gr_line_skip_dx_neg
d0f3 : 853f             [ 3] 	sta grl_dx
d0f5 : 38               [ 2] 	sec
d0f6 : a53e             [ 3] 	lda grl_y1
d0f8 : e53c             [ 3] 	sbc grl_y0
d0fa : b004             [ 4] 	bcs gr_line_skip_dy_neg
d0fc : 49ff             [ 2] 	eor #0xff
d0fe : 6901             [ 2] 	adc #1
d100 :                       gr_line_skip_dy_neg
d100 : 8540             [ 3] 	sta grl_dy
d102 : c53f             [ 3] 	cmp grl_dx
d104 : 901a             [ 3] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
d106 : a53b             [ 3] 	lda grl_x0					; swap x0 and y0
d108 : a63c             [ 3] 	ldx grl_y0
d10a : 853c             [ 3] 	sta grl_y0
d10c : 863b             [ 3] 	stx grl_x0
AS65 Assembler for R6502 [1.42].                                     Page  112
-------------------------------- bank\bank0.s --------------------------------

d10e : a53d             [ 3] 	lda grl_x1					; swap x1 and y1
d110 : a63e             [ 3] 	ldx grl_y1
d112 : 853e             [ 3] 	sta grl_y1
d114 : 863d             [ 3] 	stx grl_x1
d116 : a53f             [ 3] 	lda grl_dx					; swap dy and dx
d118 : a640             [ 3] 	ldx grl_dy
d11a : 8540             [ 3] 	sta grl_dy
d11c : 863f             [ 3] 	stx grl_dx
d11e : e641             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             
d120 :                       gr_line_skip_xy_swap
                             	; assume going from left to right and top to bot
d120 : a901             [ 2] 	lda #1
d122 : a0ff             [ 2] 	ldy #255					; -1
d124 : 8548             [ 3] 	sta grl_sinx
d126 : 854b             [ 3] 	sta grl_siny
                             	
                             	; check going right to left
d128 : a53b             [ 3] 	lda grl_x0
d12a : c53d             [ 3] 	cmp grl_x1
d12c : 9002             [ 3] 	bcc gr_line_skip_left
d12e : 8448             [ 3] 	sty grl_sinx				; make -1
d130 :                       gr_line_skip_left
                             	; check going bottom to top
d130 : a53c             [ 3] 	lda grl_y0
d132 : c53e             [ 3] 	cmp grl_y1
d134 : 9002             [ 3] 	bcc gr_line_skip_y_up
d136 : 844b             [ 3] 	sty grl_siny				; make -1
                             
d138 :                       gr_line_skip_y_up
d138 : a53f             [ 3] 	lda grl_dx
d13a : 0a               [ 2] 	asl a
d13b : 8542             [ 3] 	sta grl_2dx					; 2*dx (word)
d13d : a900             [ 2] 	lda #0
d13f : 8543             [ 3] 	sta grl_2dx+1
d141 : 2643             [ 5] 	rol grl_2dx+1
                             
d143 : a540             [ 3] 	lda grl_dy
d145 : 0a               [ 2] 	asl a
d146 : 8544             [ 3] 	sta grl_2dy					; 2*dy (word)
d148 : a900             [ 2] 	lda #0
d14a : 8545             [ 3] 	sta grl_2dy+1
d14c : 2645             [ 5] 	rol grl_2dy+1
                             	
                             ;    p=2*dy-dx;					; p (word)
d14e : 38               [ 2] 	sec
d14f : a544             [ 3] 	lda grl_2dy
d151 : e53f             [ 3] 	sbc grl_dx
d153 : 8549             [ 3] 	sta grl_p
d155 : a545             [ 3] 	lda grl_2dy+1
d157 : e900             [ 2] 	sbc #0
d159 : 854a             [ 3] 	sta grl_p+1
                             	
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
d15b : 38               [ 2] 	sec
d15c : a544             [ 3] 	lda grl_2dy
d15e : e542             [ 3] 	sbc grl_2dx
d160 : 8546             [ 3] 	sta grl_2dxy
d162 : a545             [ 3] 	lda grl_2dy+1
d164 : e543             [ 3] 	sbc grl_2dx+1
d166 : 8547             [ 3] 	sta grl_2dxy+1
                             
AS65 Assembler for R6502 [1.42].                                     Page  113
-------------------------------- bank\bank0.s --------------------------------

d168 :                       gr_line_pixel
d168 : a63b             [ 3] 	ldx grl_x0
d16a : a43c             [ 3] 	ldy grl_y0
d16c : a541             [ 3] 	lda grl_xyyx				; Swapped?
d16e : f004             [ 3] 	beq gr_line_yx_skip
d170 : a63c             [ 3] 	ldx grl_y0
d172 : a43b             [ 3] 	ldy grl_x0
d174 :                       gr_line_yx_skip
d174 : 2017d0           [ 6] 	jsr gr_point				; Plot point x,y
                             	
d177 : a53b             [ 3] 	lda grl_x0					; Check if done
d179 : c53d             [ 3] 	cmp grl_x1
d17b : f032             [ 3] 	beq gr_line_done
                             
                             	; Increment x always
d17d : 18               [ 2] 	clc
d17e : a53b             [ 3] 	lda grl_x0
d180 : 6548             [ 3] 	adc grl_sinx
d182 : 853b             [ 3] 	sta grl_x0
                             
                             	; check sign of p
d184 : a54a             [ 3] 	lda grl_p+1
d186 : 3017             [ 3] 	bmi gr_line_neg_p
                             
                             	; if p >=0
                             	
                             	; y=y+increment
d188 : 18               [ 2] 	clc
d189 : a53c             [ 3] 	lda grl_y0
d18b : 654b             [ 3] 	adc grl_siny
d18d : 853c             [ 3] 	sta grl_y0
                             	
                             	; p=p+2*dy-2*dx
                             	_addZPWord grl_p,grl_2dxy
                             
d19c : 4c68d1           [ 3] 	jmp gr_line_pixel
                             
d19f :                       gr_line_neg_p
                             	; if p < 0
                             	; p=p+2*dy
                             	_addZPWord grl_p,grl_2dy
                             
                             	
d1ac : 4c68d1           [ 3] 	jmp gr_line_pixel
d1af :                       gr_line_done
d1af : 60               [ 6] 	rts
                             
                             
                             ; Line drawing pseudo code
                             ;    while(x<x1)
                             ;    {
                             ;        putpixel(x,y);
                             ;        if(p>=0)
                             ;        {
                             ;            y=y+1;
                             ;            p=p+2*dy-2*dx;
                             ;        }
                             ;        else
                             ;        {
                             ;            p=p+2*dy;
                             ;        }
                             ;        x=x+1;
AS65 Assembler for R6502 [1.42].                                     Page  114
-------------------------------- bank\bank0.s --------------------------------

                             ;    }
                             
                             
                             ;* These tables are to speed up calculating the 
                             ;* offset for plot commands
d1b0 :                       gr_offset_40lo
d1b0 : 00285078a0            	db lo(000*40), lo(001*40), lo(002*40), lo(003*40
d1b5 : c8f0184068            	db lo(005*40), lo(006*40), lo(007*40), lo(008*40
d1ba : 90b8e00830            	db lo(010*40), lo(011*40), lo(012*40), lo(013*40
d1bf : 5880a8d0f8            	db lo(015*40), lo(016*40), lo(017*40), lo(018*40
d1c4 : 20487098c0            	db lo(020*40), lo(021*40), lo(022*40), lo(023*40
d1c9 : e81038                	db lo(025*40), lo(026*40), lo(027*40)
d1cc :                       gr_offset_40hi
d1cc : 0000000000            	db hi(000*40), hi(001*40), hi(002*40), hi(003*40
d1d1 : 0000010101            	db hi(005*40), hi(006*40), hi(007*40), hi(008*40
d1d6 : 0101010202            	db hi(010*40), hi(011*40), hi(012*40), hi(013*40
d1db : 0202020202            	db hi(015*40), hi(016*40), hi(017*40), hi(018*40
d1e0 : 0303030303            	db hi(020*40), hi(021*40), hi(022*40), hi(023*40
d1e5 : 030404                	db hi(025*40), hi(026*40), hi(027*40)
                             
                             
                             ;* Character based sprites for text mode only
d1e8 :                       mod_sz_sprite_s
                             ;* Initialisation
d1e8 :                       gr_spr_init
d1e8 : a21f             [ 2] 	ldx #31							; Start at last sprite
d1ea :                       gr_spr_init_loop
d1ea : a9ff             [ 2] 	lda #-1							; Put -1 in the x coords
d1ec : 9d00b4           [ 5] 	sta spr_curX,x
d1ef : 9d20b4           [ 5] 	sta spr_newX,x
d1f2 : ca               [ 2] 	dex								; Next sprite
d1f3 : 10f5             [ 3] 	bpl gr_spr_init_loop			; Until all 32 sprites in
d1f5 : 60               [ 6] 	rts
                             
                             	
                             ;* Erase all active sprites
d1f6 :                       gr_spr_erase
                             	; First restore background from sprites
                             	; that are active and new pos is different from 
d1f6 : a21f             [ 2] 	ldx #31							; Start at last sprite
d1f8 :                       gr_spr_erase_loop	
d1f8 : bd00b4           [ 4] 	lda spr_curX,x					; Is sprite active?
d1fb : 3008             [ 4] 	bmi gr_spr_erase_next
d1fd : 8530             [ 3] 	sta tmp_alo						; x pos saved for later
d1ff :                       gr_spr_erase_do
d1ff : bda0b4           [ 4] 	lda spr_bgnd,x					; Get the background
d202 : 2050d2           [ 6] 	jsr gr_spr_put					; And restore it
d205 :                       gr_spr_erase_next
d205 : ca               [ 2] 	dex
d206 : 10f0             [ 4] 	bpl gr_spr_erase_loop
d208 : 60               [ 6] 	rts
                             
                             ;* Get ready for new position
d209 :                       gr_spr_new
d209 : a21f             [ 2] 	ldx #31							; Start at last sprite
d20b :                       gr_spr_new_loop
d20b : bd20b4           [ 4] 	lda spr_newX,x					; Is the new position active?
d20e : 3029             [ 3] 	bmi gr_spr_new_next
d210 : 8530             [ 3] 	sta tmp_alo						; x pos saved for later
d212 :                       gr_spr_new_pos
d212 : bd60b4           [ 4] 	lda spr_newY,x					; Get new Y
d215 : 9d40b4           [ 5] 	sta spr_curY,x					; Update new->cur Y
AS65 Assembler for R6502 [1.42].                                     Page  115
-------------------------------- bank\bank0.s --------------------------------

                             	; Calculate screen address
                             	; save as part of sprite data and in zp area
d218 : a8               [ 2] 	tay
d219 : 18               [ 2] 	clc
d21a : b9b0d1           [ 4] 	lda gr_offset_40lo,y
d21d : 6980             [ 2] 	adc #lo(TEXTSCRN)
d21f : 8525             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d221 : 9dc0b4           [ 5] 	sta spr_baseadrl,x
d224 : b9ccd1           [ 4] 	lda gr_offset_40hi,y
d227 : 69bb             [ 2] 	adc #hi(TEXTSCRN)
d229 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d22b : 9de0b4           [ 5] 	sta spr_baseadrh,x
d22e : a430             [ 3] 	ldy tmp_alo						; Get x pos back in to Y reg
d230 : 98               [ 2] 	tya
d231 : 9d00b4           [ 5] 	sta spr_curX,x					; Update new->cur X
d234 : b125             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y	; Get background
d236 : 9da0b4           [ 5] 	sta spr_bgnd,x					; And save this
d239 :                       gr_spr_new_next
d239 : ca               [ 2] 	dex
d23a : 10cf             [ 3] 	bpl gr_spr_new_loop
d23c : 60               [ 6] 	rts
                             
                             
                             ; Draw all active sprites
                             ; Active sprites are always drawn - 0 = lowest pr
d23d :                       gr_spr_draw
d23d : a21f             [ 2] 	ldx #31							; Start at last sprite
d23f :                       gr_spr_draw_loop	
d23f : bd20b4           [ 4] 	lda spr_newX,x					; Is sprite active?
d242 : 8530             [ 3] 	sta tmp_alo
d244 : 3006             [ 3] 	bmi gr_spr_draw_next
d246 : bd80b4           [ 4] 	lda spr_chr,x					; Get the sprite char
d249 : 2050d2           [ 6] 	jsr gr_spr_put
d24c :                       gr_spr_draw_next
d24c : ca               [ 2] 	dex
d24d : 10f0             [ 3] 	bpl gr_spr_draw_loop
d24f : 60               [ 6] 	rts
                             
                             
                             ;* Common routine to put A to screen address
                             ;* Used for erase and draw of sprites
d250 :                       gr_spr_put
d250 : 48               [ 3] 	pha
d251 : bdc0b4           [ 4] 	lda spr_baseadrl,x		; Get the screen pointer
d254 : 8525             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d256 : bde0b4           [ 4] 	lda spr_baseadrh,x
d259 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d25b : a430             [ 3] 	ldy tmp_alo						; Y reg is in tmp_alo
d25d : 68               [ 4] 	pla								; Get back the char to 
d25e : 9125             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y	; put on to scre
d260 : 60               [ 6] 	rts
                             
                             
                             ;* Update spr A with char X
d261 :                       gr_spr_char
d261 : a8               [ 2] 	tay
d262 : 8a               [ 2] 	txa
d263 : 9980b4           [ 5] 	sta spr_chr,y
d266 : 60               [ 6] 	rts
                             
                             ;* Locate what is at the location of sprite A, re
                             ;* C=1 if sprite it not active
AS65 Assembler for R6502 [1.42].                                     Page  116
-------------------------------- bank\bank0.s --------------------------------

d267 :                       gr_spr_hit
d267 : aa               [ 2] 	tax
d268 : bd00b4           [ 4] 	lda spr_curX,x
d26b : c980             [ 2] 	cmp #0x80						; If A>=0x80 then C=1
d26d : bda0b4           [ 4] 	lda spr_bgnd,x
d270 : 60               [ 6] 	rts
                             	
                             ;* Update spr A with coords X,Y
d271 :                       gr_spr_pos
d271 : 8430             [ 3] 	sty tmp_alo
d273 : a8               [ 2] 	tay
d274 : 8a               [ 2] 	txa								; X coord still in X reg
d275 : 9920b4           [ 5] 	sta spr_newX,y
d278 : a530             [ 3] 	lda tmp_alo						; Y coord from temp
d27a : 9960b4           [ 5] 	sta spr_newY,y
d27d : 60               [ 6] 	rts
                             
                             ;* Update all sprite positions from df_tmpptra, d
d27e :                       gr_spr_multi_pos
d27e : a03e             [ 2] 	ldy #62
d280 : a21f             [ 2] 	ldx #31
d282 :                       gr_spr_multi_loop
d282 : b19f             [ 5] 	lda (df_tmpptra),y
d284 : 9d20b4           [ 5] 	sta spr_newX,x
d287 : b1a1             [ 5] 	lda (df_tmpptrb),y
d289 : 9d60b4           [ 5] 	sta spr_newY,x
d28c : 88               [ 2] 	dey
d28d : 88               [ 2] 	dey
d28e : ca               [ 2] 	dex
d28f : 10f1             [ 3] 	bpl gr_spr_multi_loop
d291 : 60               [ 6] 	rts
                             
d292 :                       mod_sz_sprite_e
d292 :                       mod_sz_graph_e
                             
                             ;	; Calculate destination address
                             ;	lda #0
                             ;	sta tmp_ahi
                             ;	
                             ;	tya				; Row number in A
                             ;	; Multiply 8
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	sta tmp_alo
                             ;	
                             ;	; Multiply 32
                             ;	; Use partial result from m8
                             ;	lda tmp_ahi
                             ;	sta tmp_bhi
                             ;	lda tmp_alo
                             ;	; Just two more rotates to get m32
                             ;	asl a
                             ;	rol tmp_bhi
                             ;	asl a
                             ;	rol tmp_bhi
                             ;	sta tmp_blo
                             ;	; Add m8 and m32 for m40
                             ;	clc
AS65 Assembler for R6502 [1.42].                                     Page  117
-------------------------------- bank\bank0.s --------------------------------

                             ;	lda tmp_alo
                             ;	adc tmp_blo
                             ;	sta tmp_alo
                             ;	lda tmp_ahi
                             ;	adc tmp_bhi
                             ;	; Add high byte of screen address
                             ;	adc gr_scrngeom+vdp_scrn+1
                             ;	sta tmp_ahi
                             ;	; Dest offset in tmp_alo
                             ;	
                             ;	; pixel x coord in to A
                             ;	; We dvide by 48 doing trial subtracts
                             ;	; This leaves Y with a number 0..5
                             ;	; And A has the remainder 0..47
                             ;	; Use these to look up byte column and mask
                             ;	; We don't do more than 5 trial subtracts
                             ;	; plus the table size is much smaller
                             ;	; Comprimise of space vs speed
                             ;	txa
                             ;	ldy #0				; Start at segment 0
                             ;	sec
                             ;gr_point_d48
                             ;	sbc #48
                             ;	iny
                             ;	bcs gr_point_d48				; Keep going until underflo
                             ;
                             ;	dey								; Adjust segment count
                             ;	adc #48							; Get remainder in A
                             ;	tax								; Put remainder in to X (0..47)
                             ;	lda gr_col_seg,y				; Get the start column of s
                             ;	clc
                             ;	adc gr_col_offset,x				; Add segment offset usi
                             ;	tay								; We have the byte column in Y
                             ;	sty tmp_bhi						; Save in tmp, also still in Y
                             ;	stx tmp_blo						; Save remainder 0..47
                             ;	rts
                             
                             ;gr_point_mask
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;gr_col_offset
                             ;	db 0,0,0,0,0,0
                             ;	db 1,1,1,1,1,1
                             ;	db 2,2,2,2,2,2
                             ;	db 3,3,3,3,3,3
                             ;	db 4,4,4,4,4,4
                             ;	db 5,5,5,5,5,5
                             ;	db 6,6,6,6,6,6
                             ;	db 7,7,7,7,7,7
                             ;gr_col_seg
                             ;	db 0,8,16,24,32
                             
                             	include "monitor\cmd.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
AS65 Assembler for R6502 [1.42].                                     Page  118
-------------------------------- bank\bank0.s --------------------------------

                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  CMD.S
                             ;*	A really simple monitor that needs to be impro
                             ;*	optimised.  Only has these commands;
                             ;*		dxxxx			Dump memory location xxxx
                             ;*						Press enter for more else stop
                             ;*		sxxxx [yy]		Set memory location xxxx with hex
                             ;*						bytes, respond with next location
                             ;*		q				Quit
                             ;*	Now you see why this needs optimising!
                             ;*
                             ;************************************************
                             
0092 =                       cmd_lo					= df_currdat
0093 =                       cmd_hi					= (df_currdat+1)
                             
                             	; ROM code
                             	code  
                             
d292 :                       _mod_sz_cmd_s
                             
d292 :                       command_line
d292 : a0a0             [ 2] 	ldy #160					; Maximum line length
d294 : 8439             [ 3] 	sty buf_sz
                             
d296 :                       cmd_ready
                             	_println_low msg_ready
                             
                             
d29d : 38               [ 2] 	sec							; Set carry flag = echo characters
d29e : 2060c4           [ 6] 	jsr io_read_line			; Get a command line
d2a1 : a000             [ 2] 	ldy #0
d2a3 : b137             [ 5] 	lda (buf_lo),y
d2a5 : c971             [ 2] 	cmp #'q'
d2a7 : d001             [ 3] 	bne cmd_check_cmd
d2a9 : 60               [ 6] 	rts
d2aa :                       cmd_check_cmd
d2aa : 20bcd2           [ 6] 	jsr cmd_parse				; Find command and execute
d2ad : b003             [ 3] 	bcs cmd_error				; Carry set = error condition
d2af : 4c96d2           [ 3] 	jmp cmd_ready
                             
d2b2 :                       cmd_error
                             	_println_low msg_errmsg
                             
d2b9 : 4c96d2           [ 3] 	jmp cmd_ready
                             
                             
                             ;****************************************
                             ;* cmd_parse
                             ;* Parse the command line in the io buffer
                             ;* Regs affected : 
                             ;****************************************
d2bc :                       cmd_parse
d2bc : c8               [ 2] 	iny						; Ready for next char
                             	
d2bd :                       cmd_check_d
d2bd : c964             [ 2] 	cmp #'d'				; Check for d
d2bf : d003             [ 3] 	bne cmd_check_s
AS65 Assembler for R6502 [1.42].                                     Page  119
-------------------------------- bank\bank0.s --------------------------------

d2c1 : 4cf7d2           [ 3] 	jmp cmd_dumpmem
d2c4 :                       cmd_check_s
d2c4 : c973             [ 2] 	cmp #'s'				; Check for s
d2c6 : d0ea             [ 3] 	bne cmd_error
d2c8 : 4cd1d2           [ 3] 	jmp cmd_setmem
                             
d2cb :                       cmd_not_found
d2cb : a901             [ 2] 	lda #CMD_ERR_NOTFOUND
d2cd : 855b             [ 3] 	sta errno
d2cf : 38               [ 2] 	sec
d2d0 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_setmem
                             ;* Set the memory at address AAAA to byte string
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d2d1 :                       cmd_setmem
d2d1 : 208ed3           [ 6] 	jsr cmd_parse_word
d2d4 : b01f             [ 3] 	bcs cmd_setmem_err
d2d6 :                       cmd_setmem_byte
d2d6 : 2072d3           [ 6] 	jsr cmd_parse_byte
d2d9 : b01a             [ 3] 	bcs cmd_setmem_err
d2db : 2069d3           [ 6] 	jsr cmd_poke				; Poke A in to cmd_lo, hi
d2de : 2059d3           [ 6] 	jsr cmd_incmem
d2e1 : 20a0d3           [ 6] 	jsr cmd_parse_next_parm		; Try and find another 
d2e4 : 90f0             [ 3] 	bcc cmd_setmem_byte			; Process if found, else f
d2e6 : a593             [ 3] 	lda cmd_hi
d2e8 : 2074c1           [ 6] 	jsr utilPrintA
d2eb : a592             [ 3] 	lda cmd_lo
d2ed : 2074c1           [ 6] 	jsr utilPrintA
d2f0 : 206cc1           [ 6] 	jsr utilPrintCRLF
d2f3 : 18               [ 2] 	clc
d2f4 : 60               [ 6] 	rts
d2f5 :                       cmd_setmem_err
d2f5 : 38               [ 2] 	sec
d2f6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_dumpmem
                             ;* Dump memory at address AAAA
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d2f7 :                       cmd_dumpmem
d2f7 : 208ed3           [ 6] 	jsr cmd_parse_word			; Get address to dump
d2fa : 9001             [ 3] 	bcc cmd_dumpmem_block
d2fc : 60               [ 6] 	rts							; C is set
d2fd :                       cmd_dumpmem_block
d2fd : a593             [ 3] 	lda cmd_hi					; Show the address
d2ff : 2074c1           [ 6] 	jsr utilPrintA
d302 : a592             [ 3] 	lda cmd_lo
d304 : 2074c1           [ 6] 	jsr utilPrintA
d307 : a920             [ 2] 	lda #' '
d309 : 204bc4           [ 6] 	jsr io_put_ch
                             	
d30c : a008             [ 2] 	ldy #8						; 8 Bytes per line
AS65 Assembler for R6502 [1.42].                                     Page  120
-------------------------------- bank\bank0.s --------------------------------

d30e :                       cmd_dumpmem_byte
d30e : 2060d3           [ 6] 	jsr cmd_peek
d311 : 2074c1           [ 6] 	jsr utilPrintA
d314 : 2064c1           [ 6] 	jsr utilPrintSPC
d317 : 2059d3           [ 6] 	jsr cmd_incmem
d31a : 88               [ 2] 	dey
d31b : d0f1             [ 3] 	bne cmd_dumpmem_byte
d31d :                       cmd_dumpmemASCII
d31d : 38               [ 2] 	sec							; Move pointer back to start
d31e : a592             [ 3] 	lda cmd_lo
d320 : e908             [ 2] 	sbc #8
d322 : 8592             [ 3] 	sta cmd_lo
d324 : a593             [ 3] 	lda cmd_hi
d326 : e900             [ 2] 	sbc #0
d328 : 8593             [ 3] 	sta cmd_hi
                             	
d32a : 2064c1           [ 6] 	jsr utilPrintSPC
d32d : a008             [ 2] 	ldy #8						; 8 Bytes per line
d32f :                       cmd_dumpmem_ascii
d32f : a22e             [ 2] 	ldx #'.'					; Non-printable char
d331 : 2060d3           [ 6] 	jsr cmd_peek
d334 : c920             [ 2] 	cmp #' '					; <32 is unprintable
d336 : b001             [ 3] 	bcs cmd_dump_skip_ctrl
d338 : 8a               [ 2] 	txa							; Replace with dot
d339 :                       cmd_dump_skip_ctrl
d339 : c97f             [ 2] 	cmp #UTF_DEL				; >= DEL is unprintable
d33b : 9001             [ 3] 	bcc cmd_dump_skip_del
d33d : 8a               [ 2] 	txa							; Replace with dot
d33e :                       cmd_dump_skip_del	
d33e : 204bc4           [ 6] 	jsr io_put_ch
d341 : 2059d3           [ 6] 	jsr cmd_incmem
d344 : 88               [ 2] 	dey		
d345 : d0e8             [ 3] 	bne cmd_dumpmem_ascii		; Show 8 bytes
d347 : 38               [ 2] 	sec
d348 : 2048c4           [ 6] 	jsr io_get_ch				; Wait for key press
d34b : c90d             [ 2] 	cmp #UTF_CR		
d34d : d003             [ 3] 	bne cmd_dumpmemFin			; Any key but enter finishe
                             ;	jsr io_put_ch				; Do new line
d34f : 4cfdd2           [ 3] 	jmp cmd_dumpmem_block
d352 :                       cmd_dumpmemFin
d352 : a90d             [ 2] 	lda #UTF_CR
d354 : 204bc4           [ 6] 	jsr io_put_ch
d357 : 18               [ 2] 	clc
d358 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* cmd_incmem
                             ;* Increment pointer
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : cmd_lo, cmd_hi
                             ;* Regs affected : 
                             ;****************************************
d359 :                       cmd_incmem
                             	_incZPWord cmd_lo
                             
d35f : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_peek
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi
AS65 Assembler for R6502 [1.42].                                     Page  121
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d360 :                       cmd_peek
d360 : 8636             [ 3] 	stx tmp_d
d362 : a200             [ 2] 	ldx #0
d364 : a192             [ 6] 	lda (cmd_lo,x)
d366 : a636             [ 3] 	ldx tmp_d
d368 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_poke
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d369 :                       cmd_poke
d369 : 8636             [ 3] 	stx tmp_d
d36b : a200             [ 2] 	ldx #0
d36d : 8192             [ 6] 	sta (cmd_lo,x)
d36f : a636             [ 3] 	ldx tmp_d
d371 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_byte
                             ;* Find 2 char hex byte
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = value
                             ;* Regs affected : A,Y
                             ;****************************************
d372 :                       cmd_parse_byte
d372 : 20a0d3           [ 6] 	jsr cmd_parse_next_parm	; Find the next paramete
d375 : b015             [ 3] 	bcs cmd_parse_byte_err
d377 : b137             [ 5] 	lda (buf_lo),y			; Get hi nibble of high byte
d379 : f011             [ 3] 	beq cmd_parse_byte_err	; If no char then error w
d37b : 48               [ 3] 	pha						; Save on stack
d37c : c8               [ 2] 	iny
d37d : b137             [ 5] 	lda (buf_lo),y			; Get lo nibble of high byte
d37f : f00a             [ 3] 	beq cmd_parse_byte_errp	; If no char then error 
d381 : aa               [ 2] 	tax						; Lo nibble goes to X
d382 : 68               [ 4] 	pla						; Restore hi nibble
d383 : 20a6c1           [ 6] 	jsr str_x_to_a			; Convert from hex to A
d386 : b004             [ 3] 	bcs cmd_parse_byte_err	; If error then stop
d388 : c8               [ 2] 	iny						; Point to next char
d389 : 18               [ 2] 	clc
d38a : 60               [ 6] 	rts						; A contains the byte
d38b :                       cmd_parse_byte_errp
d38b : 68               [ 4] 	pla
d38c :                       cmd_parse_byte_err
d38c : aa               [ 2] 	tax
d38d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_word
                             ;* Find 4 char hex word
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = hi, X = 
                             ;* Regs affected : A,X,Y
                             ;****************************************
d38e :                       cmd_parse_word
d38e : 2072d3           [ 6] 	jsr cmd_parse_byte			; Get hi byte of word
AS65 Assembler for R6502 [1.42].                                     Page  122
-------------------------------- bank\bank0.s --------------------------------

d391 : b00b             [ 3] 	bcs cmd_word_err
d393 : 8593             [ 3] 	sta cmd_hi					; Save hi byte of word
d395 : 2072d3           [ 6] 	jsr cmd_parse_byte			; Get lo byte of word
d398 : b004             [ 3] 	bcs cmd_word_err
d39a : 8592             [ 3] 	sta cmd_lo
d39c : 18               [ 2] 	clc
d39d : 60               [ 6] 	rts
d39e :                       cmd_word_err
d39e : 38               [ 2] 	sec
d39f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_next_parm
                             ;* Find next non-white space
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d3a0 :                       cmd_parse_next_parm
d3a0 : 88               [ 2] 	dey
d3a1 :                       cmd_find_parm
d3a1 : c8               [ 2] 	iny
d3a2 : b137             [ 5] 	lda (buf_lo),y
d3a4 : c900             [ 2] 	cmp #0
d3a6 : f005             [ 3] 	beq cmd_next_parm_err	; If z then no parms, fin 
d3a8 : c920             [ 2] 	cmp #' '				; Ignore space
d3aa : f0f5             [ 3] 	beq cmd_find_parm
d3ac : 18               [ 2] 	clc						; else ok, C is cleared
d3ad :                       cmd_next_parm_err
d3ad : 60               [ 6] 	rts
                             
                             	
d3ae : 3e00                  msg_ready				db ">\x0"
d3b0 : 3f0d00                msg_errmsg				db "?\xd\x0"
d3b3 :                       _mod_sz_cmd_e
                             
                             	include "sound\sound.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SOUND.S
                             ;*  Sound driver module - routines to access the 
                             ;*  This sound chip was found in a number of popu
                             ;*  in the early to mid 80s, including my first c
                             ;*  the Oric-1, as well as the MSX range.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
d3b3 :                       mod_sz_sound_s
                             
                             
                             ;****************************************
                             ;* snd_get_note
AS65 Assembler for R6502 [1.42].                                     Page  123
-------------------------------- bank\bank0.s --------------------------------

                             ;* Get a note from the music scale table
                             ;* Input : Octave in X, note in Y
                             ;* Output : A,X = Value hi,lo
                             ;* Regs affected : X
                             ;****************************************
d3b3 :                       snd_get_note
d3b3 : 98               [ 2] 	tya
d3b4 : 0a               [ 2] 	asl a
d3b5 : a8               [ 2] 	tay
                             	; Get note for octave 0
d3b6 : b9e6d3           [ 4] 	lda snd_music_tab,y
d3b9 : 8530             [ 3] 	sta tmp_alo
d3bb : b9e7d3           [ 4] 	lda snd_music_tab+1,y
                             	
d3be :                       snd_get_note_oct
d3be : ca               [ 2] 	dex
d3bf : 3006             [ 3] 	bmi snd_note_done
                             	; Divide freq by 2 each octave
d3c1 : 4a               [ 2] 	lsr a
d3c2 : 6630             [ 5] 	ror tmp_alo
d3c4 : 4cbed3           [ 3] 	jmp snd_get_note_oct
d3c7 :                       snd_note_done
d3c7 : a630             [ 3] 	ldx tmp_alo
d3c9 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_snd
                             ;* Initialise sound - after cia 1 has been initia
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d3ca :                       init_snd
d3ca : a20f             [ 2] 	ldx #15
d3cc :                       init_snd_regs
d3cc : bdd6d3           [ 4] 	lda snd_init_tab,x
d3cf : 2000c0           [ 6] 	jsr snd_set				; Set X to A
d3d2 : ca               [ 2] 	dex
d3d3 : 10f7             [ 3] 	bpl init_snd_regs		; 16 regs
                             	
d3d5 : 60               [ 6] 	rts						; return from sub
                             
                             	; Register array initialisation values
                             	; Assuming 1.34Mhz input clock
d3d6 :                       snd_init_tab
d3d6 : 50                    	db 0x50				; R0 = Channel A Tone Low
d3d7 : 00                    	db 0x00				; R1 = Channel A Tone High
d3d8 : 00                    	db 0x00				; R2 = Channel B Tone Low
d3d9 : 01                    	db 0x01				; R3 = Channel B Tone High
d3da : 00                    	db 0x00				; R4 = Channel C Tone Low
d3db : 02                    	db 0x02				; R5 = Channel C Tone High
d3dc : 00                    	db 0x00				; R6 = Noise period
d3dd : 7e                    	db 0b01111110		; R7 = Control : IOB input, IOA o
d3de : 1f                    	db 0x1f				; R8 = Channel A Vol
d3df : 1f                    	db 0x1f				; R9 = Channel B Vol
d3e0 : 1f                    	db 0x1f				; R10 = Channel C Vol
d3e1 : 00                    	db 0x00				; R11 = Envelope Period Low
d3e2 : 05                    	db 0x05				; R12 = Envelope Period High
d3e3 : 00                    	db 0b00000000		; R13 = Envelope Shape : 0000
d3e4 : ff                    	db 0xff				; R14 = IO Port A - KB lines disabled
d3e5 : 00                    	db 0x00				; R15 = IO Port B ; Initialise to 0 (
AS65 Assembler for R6502 [1.42].                                     Page  124
-------------------------------- bank\bank0.s --------------------------------

                             
d3e6 :                       snd_music_tab
d3e6 : 7707                  	dw 1911				; C		0
d3e8 : 0c07                  	dw 1804				; C#	1
d3ea : a706                  	dw 1703				; D		2
d3ec : 4706                  	dw 1607				; D#	3
d3ee : ed05                  	dw 1517				; E		4
d3f0 : 9805                  	dw 1432				; F		5
d3f2 : 4705                  	dw 1351				; F#	6
d3f4 : fc04                  	dw 1276				; G		7
d3f6 : b404                  	dw 1204				; G#	8
d3f8 : 7004                  	dw 1136				; A		9
d3fa : 3104                  	dw 1073				; A#	10
d3fc : f403                  	dw 1012				; B		11
                             
d3fe :                       mod_sz_sound_e
                             
d3fe :                       mod_sz_bios_e
d3fe :                       mod_sz_language_s
                             	include "utils\intmath.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INTMATH.S
                             ;*  Core module for integer maths supported by df
                             ;*  Now supports signed integers in 2s complement
                             ;*  Uses the intmath registers: num_a, num_b, num
                             ;*  Most inputs are through num_a and num_b, with
                             ;*  num_a
                             ;*  Operations: add, sub, swap, 8 bit mult, mult,
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* Add : A + B result in A
                             ;****************************************
d3fe :                       int_add
d3fe : 18               [ 2] 	clc
d3ff : a53b             [ 3] 	lda num_a
d401 : 653f             [ 3] 	adc num_b
d403 : 853b             [ 3] 	sta num_a
d405 : a53c             [ 3] 	lda num_a+1
d407 : 6540             [ 3] 	adc num_b+1
d409 : 853c             [ 3] 	sta num_a+1
d40b : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Sub : A - B result in A
                             ;****************************************
d40c :                       int_sub
d40c : 38               [ 2] 	sec
d40d : a53b             [ 3] 	lda num_a
d40f : e53f             [ 3] 	sbc num_b
d411 : 853b             [ 3] 	sta num_a
AS65 Assembler for R6502 [1.42].                                     Page  125
-------------------------------- bank\bank0.s --------------------------------

d413 : a53c             [ 3] 	lda num_a+1
d415 : 6540             [ 3] 	adc num_b+1
d417 : 853c             [ 3] 	sta num_a+1
d419 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Swp : A <-> B 
                             ;****************************************
d41a :                       int_swp
d41a : a53b             [ 3] 	lda num_a
d41c : a63f             [ 3] 	ldx num_b
d41e : 853f             [ 3] 	sta num_b
d420 : 863b             [ 3] 	stx num_a
d422 : a53c             [ 3] 	lda num_a+1
d424 : a640             [ 3] 	ldx num_b+1
d426 : 8540             [ 3] 	sta num_b+1
d428 : 863c             [ 3] 	stx num_a+1
d42a : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;* B assumed to be an 8 bit quantity 
                             ;****************************************
d42b :                       int_fast_mult
                             	_cpyZPWord num_a,num_tmp
                             
d433 : a900             [ 2] 	lda #0
d435 : 853b             [ 3] 	sta num_a
d437 : 853c             [ 3] 	sta num_a+1
d439 : a008             [ 2] 	ldy #8
d43b :                       int_fast_mult_cycle
d43b : 463f             [ 5] 	lsr num_b
d43d : 900d             [ 3] 	bcc int_fast_mult_next
d43f : 18               [ 2] 	clc
d440 : a53b             [ 3] 	lda num_a
d442 : 6547             [ 3] 	adc num_tmp
d444 : 853b             [ 3] 	sta num_a
d446 : a53c             [ 3] 	lda num_a+1
d448 : 6548             [ 3] 	adc num_tmp+1
d44a : 853c             [ 3] 	sta num_a+1
d44c :                       int_fast_mult_next
d44c : 0647             [ 5] 	asl num_tmp
d44e : 2648             [ 5] 	rol num_tmp+1
d450 : 88               [ 2] 	dey
d451 : d0e8             [ 3] 	bne int_fast_mult_cycle
d453 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;****************************************
d454 :                       int_mult
                             	_cpyZPWord num_a,num_tmp
                             
d45c : a900             [ 2] 	lda #0
d45e : 853b             [ 3] 	sta num_a
d460 : 853c             [ 3] 	sta num_a+1
d462 : a010             [ 2] 	ldy #16
d464 :                       int_mult_cycle
d464 : 4640             [ 5] 	lsr num_b+1
d466 : 663f             [ 5] 	ror num_b
d468 : 900d             [ 3] 	bcc int_mult_next
d46a : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  126
-------------------------------- bank\bank0.s --------------------------------

d46b : a53b             [ 3] 	lda num_a
d46d : 6547             [ 3] 	adc num_tmp
d46f : 853b             [ 3] 	sta num_a
d471 : a53c             [ 3] 	lda num_a+1
d473 : 6548             [ 3] 	adc num_tmp+1
d475 : 853c             [ 3] 	sta num_a+1
d477 :                       int_mult_next
d477 : 0647             [ 5] 	asl num_tmp
d479 : 2648             [ 5] 	rol num_tmp+1
d47b : 88               [ 2] 	dey
d47c : d0e6             [ 3] 	bne int_mult_cycle
d47e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Div : A / B result in A, remainder X
                             ;****************************************
d47f :                       int_div
                             	; adjust signs
d47f : a900             [ 2] 	lda #0
d481 : 8547             [ 3] 	sta num_tmp				; Assume all +ve
d483 : a53c             [ 3] 	lda num_a+1				; Check A hi
d485 : 100f             [ 3] 	bpl int_div_skip_negA
d487 : e647             [ 5] 	inc num_tmp				; Record sign flip
d489 : 38               [ 2] 	sec						; 2's complement A
d48a : a900             [ 2] 	lda #0					; by 0-A
d48c : e53b             [ 3] 	sbc num_a				; A is now +ve
d48e : 853b             [ 3] 	sta num_a
d490 : a900             [ 2] 	lda #0
d492 : e53c             [ 3] 	sbc num_a+1
d494 : 853c             [ 3] 	sta num_a+1	
d496 :                       int_div_skip_negA
d496 : a540             [ 3] 	lda num_b+1				; Check B hi
d498 : 100f             [ 3] 	bpl int_div_skip_negB
d49a : e647             [ 5] 	inc num_tmp				; Record sign flip
d49c : 38               [ 2] 	sec						; 2's complement B
d49d : a900             [ 2] 	lda #0					; by 0-B
d49f : e53f             [ 3] 	sbc num_b				; B is now +ve
d4a1 : 853f             [ 3] 	sta num_b
d4a3 : a900             [ 2] 	lda #0
d4a5 : e540             [ 3] 	sbc num_b+1
d4a7 : 8540             [ 3] 	sta num_b+1
d4a9 :                       int_div_skip_negB			; num_tmp bit 0=1 for result 
                             	; x is the remainder
d4a9 : a900             [ 2] 	lda #0
d4ab : 8543             [ 3] 	sta num_x
d4ad : 8544             [ 3] 	sta num_x+1
                             	; 16 bit division
d4af : a010             [ 2] 	ldy #16
d4b1 :                       int_div_cycle
                             	; shift a left 1 bit
d4b1 : 063b             [ 5] 	asl num_a
d4b3 : 263c             [ 5] 	rol num_a+1
                             	; shift in to remainder
d4b5 : 2643             [ 5] 	rol num_x
d4b7 : 2644             [ 5] 	rol num_x+1
                             	; try and subtract b from remainder
d4b9 : 38               [ 2] 	sec
d4ba : a543             [ 3] 	lda num_x
d4bc : e53f             [ 3] 	sbc num_b
d4be : aa               [ 2] 	tax
d4bf : a544             [ 3] 	lda num_x+1
d4c1 : e540             [ 3] 	sbc num_b+1
AS65 Assembler for R6502 [1.42].                                     Page  127
-------------------------------- bank\bank0.s --------------------------------

d4c3 : 9006             [ 3] 	bcc int_div_skip
                             	; so b did fit in to remainder, save it
d4c5 : 8643             [ 3] 	stx num_x
d4c7 : 8544             [ 3] 	sta num_x+1
d4c9 : e63b             [ 5] 	inc num_a
d4cb :                       int_div_skip
                             	; carry on for 16 bits
d4cb : 88               [ 2] 	dey
d4cc : d0e3             [ 3] 	bne int_div_cycle
                             	; result in a, remainder in x
                             	; check num_tmp bit 0
d4ce : a547             [ 3] 	lda num_tmp
d4d0 : 2901             [ 2] 	and #1
d4d2 : f00d             [ 3] 	beq int_div_noflip
d4d4 : 38               [ 2] 	sec						; 2's complement A
d4d5 : a900             [ 2] 	lda #0					; by 0-A
d4d7 : e53b             [ 3] 	sbc num_a				; A is now +ve
d4d9 : 853b             [ 3] 	sta num_a
d4db : a900             [ 2] 	lda #0
d4dd : e53c             [ 3] 	sbc num_a+1
d4df : 853c             [ 3] 	sta num_a+1	
d4e1 :                       int_div_noflip
d4e1 : 60               [ 6] 	rts
                             	
                             
                             	include "dflat\dflat.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.S
                             ;*  This is the main controller code file for dfl
                             ;*  This file includes all the required dflat sou
                             ;*  needed:
                             ;*  - error.s is the error handling module
                             ;*  - var.s is the variable handling module
                             ;*  - tokenise.s is the tokenisation module
                             ;*  - progedit.s is the program editing module
                             ;*  - runtime.s is the runtime module
                             ;*  - stack.s is the stack handling module
                             ;*  The above modules include further source file
                             ;*  needed.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
d4e2 :                       mod_sz_dflat_s
                             	
                             ;	include "dflat\error.s"  ** included in the mai
                             	include "dflat\var.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
AS65 Assembler for R6502 [1.42].                                     Page  128
-------------------------------- bank\bank0.s --------------------------------

                             ;*  credit of original my authorship please!
                             ;*
                             ;*  VAR.S
                             ;*  This module handles all the variable manageme
                             ;*  When a new variable is detected during tokeni
                             ;*  is added to the variable tables.  Any subsequ
                             ;*  that variable is tokenised as an index in to 
                             ;*  table.  There are two variable tables:
                             ;*  Variable name table (VNT) keeps track of vari
                             ;*  Variable value table (VVT) maintains variable
                             ;*  including type, dimension (if array) and of c
                             ;*  actual values.  For an array, the value is a 
                             ;*  memory grabbed using the 'malloc' function (s
                             ;*  This approach to variable managemet is direct
                             ;*  Atari 8 bit.  The disadvantage is that during
                             ;*  session you may end up having a much larger v
                             ;*  table than you need.  Why?  Well because say 
                             ;*  %a as a new variable, but then later change i
                             ;*  In this case %a remains in the variable table
                             ;*  only ever adds to the table!  However it is e
                             ;*  solved - when you save and then reload from n
                             ;*  program, the variable table is built up as th
                             ;*  is loaded.
                             ;*  The VNT grows DOWN from the top of free memor
                             ;*  the VVT growing UP from just below the VNT.
                             ;*	This means that the VVT for a variable will al
                             ;*	found in a fixed place in the VVT table and me
                             ;*	For the VNT (names) it grows from vvstart at l
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code  
                             
d4e2 :                       mod_sz_var_s
                             
                             
                             ;****************************************
                             ;* Find a variable
                             ;* CC if found, A has index
                             ;****************************************
d4e2 :                       df_var_find
                             	; start at the beginning of the vnt table
                             	; vars are stored in reverse order
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
                             	; start at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
d4f2 :                       df_var_match_vnt
                             	; If reached top of VVT then not found
d4f2 : a59f             [ 3] 	lda df_tmpptra
d4f4 : c56b             [ 3] 	cmp df_vvtstrt
d4f6 : d006             [ 3] 	bne df_var_match_vnt_do
d4f8 : a5a0             [ 3] 	lda df_tmpptra+1
d4fa : c56c             [ 3] 	cmp df_vvtstrt+1
d4fc : f04c             [ 4] 	beq df_var_find_no_vnt
d4fe :                       df_var_match_vnt_do
                             	; match each char in buffer with vnt
d4fe : a47a             [ 3] 	ldy df_linoff
d500 : a200             [ 2] 	ldx #0
AS65 Assembler for R6502 [1.42].                                     Page  129
-------------------------------- bank\bank0.s --------------------------------

d502 :                       df_var_match_vnt_sym
d502 : b90004           [ 4] 	lda df_linbuff,y
d505 : c1a1             [ 6] 	cmp (df_tmpptrb,x)
d507 : d01f             [ 3] 	bne df_var_vnt_sym_nomatch
                             	; if single char match then increment
                             	; source and search
d509 : c8               [ 2] 	iny
                             	_incZPWord df_tmpptrb
                             
                             	; if more chars in vnt entry then continue
d510 : a1a1             [ 6] 	lda (df_tmpptrb,x)
d512 : d0ee             [ 3] 	bne df_var_match_vnt_sym
                             	; if no more chars in vnt entry but
                             	; but chars in buffer then try next vnt
d514 : b90004           [ 4] 	lda df_linbuff,y
                             	; check for valid alpha-numeric
d517 : 20e2d6           [ 6] 	jsr df_tk_isalphanum
d51a : 9002             [ 3] 	bcc df_var_check_type
                             	; if there is a valid alpha-num then no match
d51c : b00a             [ 3] 	bcs df_var_vnt_sym_nomatch
d51e :                       df_var_check_type
                             	; if not alpha-num then check for type
                             	; string or int postfix didn't match with VNT
d51e : c925             [ 2] 	cmp #'%'
d520 : f006             [ 3] 	beq df_var_vnt_sym_nomatch
d522 : c924             [ 2] 	cmp #'$'
d524 : f002             [ 3] 	beq df_var_vnt_sym_nomatch
                             	; ok, all good got a match
d526 : d028             [ 3] 	bne df_var_find_true
d528 :                       df_var_vnt_sym_nomatch
                             	; find the zero terminator
d528 : a1a1             [ 6] 	lda (df_tmpptrb,x)
d52a : f009             [ 3] 	beq	df_var_vnt_entry_end
                             	_incZPWord df_tmpptrb
                             
d532 : 4c28d5           [ 3] 	jmp df_var_vnt_sym_nomatch
d535 :                       df_var_vnt_entry_end
                             	; skip over zero terminator
                             	_incZPWord df_tmpptrb
                             
                             	; update vvt address pointer
d53b : 18               [ 2] 	clc
d53c : a59f             [ 3] 	lda df_tmpptra
d53e : 6908             [ 2] 	adc #8
d540 : 859f             [ 3] 	sta df_tmpptra
d542 : a5a0             [ 3] 	lda df_tmpptra+1
d544 : 6900             [ 2] 	adc #0
d546 : 85a0             [ 3] 	sta df_tmpptra+1
d548 : d0a8             [ 4] 	bne df_var_match_vnt		; Always - high byte is no
                             
                             	; if at end of vnt then no matches found
d54a :                       df_var_find_no_vnt
d54a : a900             [ 2] 	lda #0
d54c : a200             [ 2] 	ldx #0
d54e : 38               [ 2] 	sec
d54f : 60               [ 6] 	rts
                             
d550 :                       df_var_find_true
                             	; Get slot address into x,a
d550 : a69f             [ 3] 	ldx df_tmpptra
d552 : a5a0             [ 3] 	lda df_tmpptra+1
                             	
AS65 Assembler for R6502 [1.42].                                     Page  130
-------------------------------- bank\bank0.s --------------------------------

                             	; Consume characters found in source
d554 : 847a             [ 3] 	sty df_linoff
d556 : 18               [ 2] 	clc
d557 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Insert a variable name in to vnt
                             ;* X = number of bytes to make room
                             ;* Space allocated is;
                             ;*	8 bytes for the new VVT entry
                             ;*  X bytes for the new VNT entry
                             ;* df_vntstrt is new var name entry
                             ;* df_vvtend is new vvt entry
                             ;****************************************
d558 :                       df_var_insert_space
                             	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! *
                             
                             	; adjust down the VNT start by VVT size (for ext
                             	; put it in tmpptrb
d558 : 38               [ 2] 	sec
d559 : a567             [ 3] 	lda df_vntstrt
d55b : e908             [ 2] 	sbc #DFVVT_SZ
d55d : 8567             [ 3] 	sta df_vntstrt
d55f : a568             [ 3] 	lda df_vntstrt+1
d561 : e900             [ 2] 	sbc #0
d563 : 8568             [ 3] 	sta df_vntstrt+1
                             	
                             	; adjust VNT end by VVT size (for extra VVT entr
                             	; and put it in tmpptrc
d565 : 38               [ 2] 	sec
d566 : a569             [ 3] 	lda df_vntend
d568 : e908             [ 2] 	sbc #DFVVT_SZ
d56a : 8569             [ 3] 	sta df_vntend
d56c : a56a             [ 3] 	lda df_vntend+1
d56e : e900             [ 2] 	sbc #0
d570 : 856a             [ 3] 	sta df_vntend+1
                             
                             	; Set copy point to new start of VNT
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             
                             	; Now move all bytes from old VNT (higher up) to
d57a : 18               [ 2] 	clc
d57b :                       df_var_move_byte
                             	; When pointer = vntend then done
d57b : a59f             [ 3] 	lda df_tmpptra
d57d : c569             [ 3] 	cmp df_vntend
d57f : d006             [ 3] 	bne df_var_move_byte_do
d581 : a5a0             [ 3] 	lda df_tmpptra+1
d583 : c56a             [ 3] 	cmp df_vntend+1
d585 : f011             [ 3] 	beq df_var_move_byte_fin
d587 :                       df_var_move_byte_do
                             	; First the source byte VVT size higher in memor
d587 : a008             [ 2] 	ldy #DFVVT_SZ
d589 : b19f             [ 5] 	lda (df_tmpptra),y
                             	; And copy to new position lower in memory
d58b : a000             [ 2] 	ldy #0
d58d : 919f             [ 5] 	sta (df_tmpptra),y
                             	; Increment memor pointer
                             	_incZPWord df_tmpptra
                             
AS65 Assembler for R6502 [1.42].                                     Page  131
-------------------------------- bank\bank0.s --------------------------------

d595 : 4c7bd5           [ 3] 	jmp df_var_move_byte		; Always as C is not touch
d598 :                       df_var_move_byte_fin
                             	
                             	; Now subtract X bytes from VNT start to accommo
d598 : 8636             [ 3] 	stx tmp_d
d59a : 38               [ 2] 	sec
d59b : a567             [ 3] 	lda df_vntstrt
d59d : e536             [ 3] 	sbc tmp_d
d59f : 8567             [ 3] 	sta df_vntstrt
d5a1 : a568             [ 3] 	lda df_vntstrt+1
d5a3 : e900             [ 2] 	sbc #0
d5a5 : 8568             [ 3] 	sta df_vntstrt+1
                             
                             	; VVT end is the same as VNT end
                             	_cpyZPWord df_vntend,df_vvtend
                             
                             
                             	; Copy done increment variable count
d5af : e66f             [ 5] 	inc df_varcnt
d5b1 : 18               [ 2] 	clc
d5b2 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* Analyse variable name
                             ;* Return type in A
                             ;* NOT C = It is a variable
                             ;* C = It is not a variable
                             ;* X = Length including pre-fixes
                             ;* Y = Offset to next char after var name
                             ;****************************************
d5b3 :                       df_var_analyse
                             	; Default type is INT
d5b3 : a901             [ 2] 	lda #DFVVT_INT
d5b5 : 859f             [ 3] 	sta df_tmpptra
                             	
                             	; start at the current buffer position
d5b7 : a47a             [ 3] 	ldy df_linoff
                             	
                             	; check for PROC prefix
d5b9 : b90004           [ 4] 	lda df_linbuff,y
d5bc : c95f             [ 2] 	cmp #'_'
                             	; if it is not proc then get the name
d5be : d005             [ 3] 	bne df_var_not_proc
                             	; else set type to PROC
d5c0 : a940             [ 2] 	lda #DFVVT_PROC
d5c2 : 859f             [ 3] 	sta df_tmpptra
                             	; skip over prefix
d5c4 : c8               [ 2] 	iny
d5c5 :                       df_var_not_proc
                             	; found the actual number of alpha nums
d5c5 : a2ff             [ 2] 	ldx #0xff
                             	; go back on pos on index as loop always does in
d5c7 : 88               [ 2] 	dey
d5c8 :                       df_var_type_countlen
                             	; count alpha nums
d5c8 : c8               [ 2] 	iny
d5c9 : e8               [ 2] 	inx
d5ca : b90004           [ 4] 	lda df_linbuff,y
                             	; first char has to be alpha, rest can be alpha-
d5cd : e000             [ 2] 	cpx #0
d5cf : d007             [ 3] 	bne df_var_type_countlen_alphanum
AS65 Assembler for R6502 [1.42].                                     Page  132
-------------------------------- bank\bank0.s --------------------------------

d5d1 : 20d2d6           [ 6] 	jsr df_tk_isalpha
d5d4 : b0f2             [ 3] 	bcs df_var_type_countlen
d5d6 : 9005             [ 3] 	bcc df_var_type_countlen_done
d5d8 :                       df_var_type_countlen_alphanum
d5d8 : 20e2d6           [ 6] 	jsr df_tk_isalphanum
d5db : b0eb             [ 3] 	bcs df_var_type_countlen
d5dd :                       df_var_type_countlen_done
d5dd : e000             [ 2] 	cpx #0
d5df : d00a             [ 3] 	bne df_var_analyse_chk_post
                             	; if zero alphanums error but not fatal
d5e1 :                       df_var_analyse_err
                             	; If already prefix of PROC then fatal error
d5e1 : a59f             [ 3] 	lda df_tmpptra
d5e3 : c940             [ 2] 	cmp #DFVVT_PROC
d5e5 : f002             [ 3] 	beq df_var_analyse_fatal_err
d5e7 : 38               [ 2] 	sec
d5e8 : 60               [ 6] 	rts
d5e9 :                       df_var_analyse_fatal_err
                             	SWBRK DFERR_SYNTAX
                             
d5eb :                       df_var_analyse_chk_post
                             	; first see if the char is % or $
                             	; but cannot already have PROC prefix
d5eb : c925             [ 2] 	cmp #'%'
d5ed : d00d             [ 3] 	bne df_var_analyse_chk_dollar
d5ef : a69f             [ 3] 	ldx df_tmpptra
d5f1 : e040             [ 2] 	cpx #DFVVT_PROC
d5f3 : f0f4             [ 3] 	beq df_var_analyse_fatal_err
                             	; Set to INT type although it is the default alr
d5f5 : a901             [ 2] 	lda #DFVVT_INT
d5f7 : 859f             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
d5f9 : c8               [ 2] 	iny
d5fa : d00f             [ 4] 	bne df_var_analyse_chk_arry
d5fc :                       df_var_analyse_chk_dollar
                             	; now see if the char is $
                             	; but cannot already have PROC prefix
d5fc : c924             [ 2] 	cmp #'$'
d5fe : d00b             [ 4] 	bne df_var_analyse_chk_arry
d600 : a69f             [ 3] 	ldx df_tmpptra
d602 : e040             [ 2] 	cpx #DFVVT_PROC
d604 : f0e3             [ 4] 	beq df_var_analyse_fatal_err
                             	; Set to STRING type
d606 : a904             [ 2] 	lda #DFVVT_STR
d608 : 859f             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
d60a : c8               [ 2] 	iny
d60b :                       df_var_analyse_chk_arry
                             	; Check for array type vs PROC
d60b : b90004           [ 4] 	lda df_linbuff,y
d60e : c95b             [ 2] 	cmp #'['
d610 : d00a             [ 3] 	bne df_var_not_arry
                             	; array and proc type not compatible
d612 : a59f             [ 3] 	lda df_tmpptra
d614 : c940             [ 2] 	cmp #DFVVT_PROC
d616 : f0d1             [ 4] 	beq df_var_analyse_fatal_err
d618 : 0980             [ 2] 	ora #DFVVT_ARRY
d61a : 859f             [ 3] 	sta df_tmpptra
d61c :                       df_var_not_arry
                             	; Ok got everything
                             	; calculate length from y
                             	; y is next char after var name
AS65 Assembler for R6502 [1.42].                                     Page  133
-------------------------------- bank\bank0.s --------------------------------

d61c : 98               [ 2] 	tya
d61d : 38               [ 2] 	sec
d61e : e57a             [ 3] 	sbc df_linoff			; where we started
                             	; put len in X
d620 : aa               [ 2] 	tax
                             	; put type in A
d621 : a59f             [ 3] 	lda df_tmpptra
d623 : 18               [ 2] 	clc
d624 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find or create a variable
                             ;* If found then type needs to match mask
                             ;* Not a fatal error because could be part
                             ;* of a trial of different parsing options
                             ;****************************************
d625 :                       df_var_findcreate
                             	; save mask
d625 : 48               [ 3] 	pha
d626 : 20e2d4           [ 6] 	jsr df_var_find
d629 : b013             [ 3] 	bcs df_var_findcreate_create
                             	; restore mask to check for 0 then push
d62b : 68               [ 4] 	pla
d62c : 48               [ 3] 	pha
                             	; don't check mask if zero
d62d : f008             [ 3] 	beq df_var_findcreate_found
                             	; restore mask
d62f : 68               [ 4] 	pla
d630 : a000             [ 2] 	ldy #DFVVT_TYPE
d632 : 319f             [ 5] 	and (df_tmpptra),y
                             	; but if mask is non zero then this must be non 
d634 : f019             [ 3] 	beq df_var_findcreate_err
d636 : 48               [ 3] 	pha		; Dummy push to match the pla
d637 :                       df_var_findcreate_found
                             	; discard mask
d637 : 68               [ 4] 	pla	
                             	; put slot address in x,a
d638 : a69f             [ 3] 	ldx df_tmpptra
d63a : a5a0             [ 3] 	lda df_tmpptra+1
d63c : 18               [ 2] 	clc
d63d : 60               [ 6] 	rts
                             	
                             	;* If no existing variable found, add one to VNT
d63e :                       df_var_findcreate_create
                             	; find type (A) and length (X)
d63e : 20b3d5           [ 6] 	jsr df_var_analyse
                             	; keep A temporarily
d641 : 859f             [ 3] 	sta df_tmpptra
                             	; if not a variable then return with C=1
d643 : b009             [ 3] 	bcs df_var_findcreate_errp
                             	; check if mask needs to be applied
d645 : 68               [ 4] 	pla
d646 : f009             [ 3] 	beq df_var_analyse_ok
                             	; else mask and check
d648 : 259f             [ 3] 	and df_tmpptra
                             	; mask match is ok
d64a : d005             [ 3] 	bne df_var_analyse_ok
                             	; else return not found
d64c : f001             [ 3] 	beq df_var_findcreate_err
d64e :                       df_var_findcreate_errp
d64e : 68               [ 4] 	pla
d64f :                       df_var_findcreate_err
AS65 Assembler for R6502 [1.42].                                     Page  134
-------------------------------- bank\bank0.s --------------------------------

d64f : 38               [ 2] 	sec
d650 : 60               [ 6] 	rts
                             
d651 :                       df_var_analyse_ok
                             	; extra space for zero terminator
d651 : e8               [ 2] 	inx
                             	; save data in reverse order to when needed
                             	; by the initialise section x,a (var name sz, ty
                             	; insert space of X bytes
d652 : a59f             [ 3] 	lda df_tmpptra
d654 : 48               [ 3] 	pha
d655 : 8a               [ 2] 	txa
d656 : 48               [ 3] 	pha
                             	
d657 : 2058d5           [ 6] 	jsr df_var_insert_space
d65a : 9002             [ 3] 	bcc df_var_initialise_var
                             	; error inserting space
                             	SWBRK DFERR_OK
                             
                             	
d65e :                       df_var_initialise_var
d65e : 68               [ 4] 	pla
d65f : 85a3             [ 3] 	sta df_tmpptrc				; var name size + 1
                             
d661 : 68               [ 4] 	pla							; type
d662 : a000             [ 2] 	ldy #DFVVT_TYPE
d664 : 916d             [ 5] 	sta (df_vvtend),y			; put type in vvt slot
d666 : a900             [ 2] 	lda #0						; zero the rest
d668 : a007             [ 2] 	ldy #7
d66a :                       df_var_zero_vnt
d66a : 916d             [ 5] 	sta (df_vvtend),y
d66c : 88               [ 2] 	dey
d66d : d0fb             [ 3] 	bne df_var_zero_vnt
                             
d66f : c6a3             [ 5] 	dec df_tmpptrc				; 1 less to copy variable name
                             
d671 : a67a             [ 3] 	ldx df_linoff				; Start at var name beginning
d673 : a000             [ 2] 	ldy #0
                             	; copy variable name to vnt slot
d675 :                       df_var_findcreate_copy
d675 : bd0004           [ 4] 	lda df_linbuff,x
d678 : 9167             [ 5] 	sta (df_vntstrt),y
d67a : e8               [ 2] 	inx
d67b : c8               [ 2] 	iny
d67c : c6a3             [ 5] 	dec df_tmpptrc
d67e : d0f5             [ 3] 	bne df_var_findcreate_copy
                             	; put in zero terminator
d680 : a900             [ 2] 	lda #0
d682 : 9167             [ 5] 	sta (df_vntstrt),y
                             
                             	; Put X in to Y
d684 : 8a               [ 2] 	txa
d685 : a8               [ 2] 	tay
                             
                             	; Return address of slot in X,A
d686 : a66d             [ 3] 	ldx df_vvtend
d688 : a56e             [ 3] 	lda df_vvtend+1
                             	
d68a : 847a             [ 3] 	sty df_linoff				; Y is the main index used
                             
d68c : 18               [ 2] 	clc
d68d : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  135
-------------------------------- bank\bank0.s --------------------------------

                             	
d68e :                       mod_sz_var_e
                             
                             	include "dflat\tokenise.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKENISE.S
                             ;*  Controlling module for tokenisation.  Basical
                             ;*  module is given a raw input buffer, which it 
                             ;*  attempt to tokenise fully.  Any syntax errors
                             ;*  thrown at the first point of detection.  If a
                             ;*  well, the parsed input will be in a tokenised
                             ;*  which can be executed in immediate mode or sa
                             ;*  line number order to memory.
                             ;*  dflat syntax is very simple - every statement
                             ;*  with a keyword.  The only exception is assign
                             ;*  procedure invocation - but even these scenari
                             ;*  tokenised so during runtime we just execute t
                             ;*  The raw buffer is consumed one byte at a time
                             ;*  tokenised buffer is written one byte at a tim
                             ;*  syntax means there is no need to undo reads o
                             ;*  or tokenised buffer.  The only refinement is 
                             ;*  allowed to peek a character in the raw buffer
                             ;*  consuming it.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
d68e :                       mod_sz_tokenise_s
                             
                             
                             ;****************************************
                             ;* df_tk_peek_buf
                             ;* Return next char in A but no change to pointer
                             ;****************************************
d68e :                       df_tk_peek_buf
d68e : a47a             [ 3] 	ldy df_linoff
d690 : b90004           [ 4] 	lda df_linbuff,y
d693 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_get_buf
                             ;* Return next char in A and inc pointer
                             ;* Don't advance if null char found and Z=1
                             ;****************************************
d694 :                       df_tk_get_buf
d694 : a47a             [ 3] 	ldy df_linoff
d696 : b90004           [ 4] 	lda df_linbuff,y
d699 : f003             [ 3] 	beq df_tk_get_buf_null
d69b : c8               [ 2] 	iny
d69c : 847a             [ 3] 	sty df_linoff
d69e :                       df_tk_get_buf_null
d69e : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  136
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* df_tk_put_tok
                             ;* Put A in token buffer and inc pointer
                             ;****************************************
d69f :                       df_tk_put_tok
d69f : a47b             [ 3] 	ldy df_tokoff
d6a1 : 998004           [ 5] 	sta df_tokbuff,y
d6a4 : c8               [ 2] 	iny
d6a5 : 847b             [ 3] 	sty df_tokoff
d6a7 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isdigit
                             ;* Check char in A for number 0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6a8 :                       df_tk_isdigit
d6a8 : c93a             [ 2] 	cmp #'9'+1
d6aa : b005             [ 3] 	bcs df_tk_isdigit_false
d6ac : c930             [ 2] 	cmp #'0'
d6ae : 9001             [ 3] 	bcc df_tk_isdigit_false
d6b0 : 60               [ 6] 	rts						; C must be 1
d6b1 :                       df_tk_isdigit_false
d6b1 : 18               [ 2] 	clc
d6b2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isbin
                             ;* Check char in A for binary digit
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6b3 :                       df_tk_isbin
d6b3 : c930             [ 2] 	cmp #'0'
d6b5 : f005             [ 3] 	beq df_tk_isbin_true	; C=1
d6b7 : c931             [ 2] 	cmp #'1'
d6b9 : f001             [ 3] 	beq df_tk_isbin_true	; C=1
d6bb : 18               [ 2] 	clc
d6bc :                       df_tk_isbin_true
d6bc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_ishex
                             ;* Check char in A for number 0-9, A-F, a-f
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6bd :                       df_tk_ishex
d6bd : 48               [ 3] 	pha
d6be : 20a8d6           [ 6] 	jsr df_tk_isdigit
d6c1 : b00a             [ 3] 	bcs df_tk_ishex_truep
d6c3 : 0920             [ 2] 	ora #0x20
d6c5 : c967             [ 2] 	cmp #'f'+1
d6c7 : b006             [ 3] 	bcs df_tk_ishex_false
d6c9 : c961             [ 2] 	cmp #'a'
d6cb : 9002             [ 3] 	bcc df_tk_ishex_false
                             	; C must be 1 here
d6cd :                       df_tk_ishex_truep
d6cd : 68               [ 4] 	pla
d6ce : 60               [ 6] 	rts
d6cf :                       df_tk_ishex_false
d6cf : 18               [ 2] 	clc
d6d0 : 68               [ 4] 	pla
d6d1 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  137
-------------------------------- bank\bank0.s --------------------------------

                             	
                             ;****************************************
                             ;* df_tk_isalpha
                             ;* Check next char in A alpha a-z, A-Z
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6d2 :                       df_tk_isalpha
d6d2 : 48               [ 3] 	pha
d6d3 : 0920             [ 2] 	ora #0x20					; Convert to lower case for checki
d6d5 : c97b             [ 2] 	cmp #'z'+1
d6d7 : b006             [ 3] 	bcs df_tk_isalpha_false
d6d9 : c961             [ 2] 	cmp #'a'
d6db : 9002             [ 3] 	bcc df_tk_isalpha_false
                             	; C must be 1 here
d6dd : 68               [ 4] 	pla
d6de : 60               [ 6] 	rts
d6df :                       df_tk_isalpha_false
d6df : 68               [ 4] 	pla
d6e0 : 18               [ 2] 	clc
d6e1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalphanum
                             ;* Check next char A for a-z,A-Z,0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6e2 :                       df_tk_isalphanum
d6e2 : 20d2d6           [ 6] 	jsr df_tk_isalpha
d6e5 : 9001             [ 3] 	bcc df_tk_try_digit
d6e7 : 60               [ 6] 	rts
d6e8 :                       df_tk_try_digit
d6e8 : 20a8d6           [ 6] 	jsr df_tk_isdigit
d6eb : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_tk_isproc
                             ;* Check next char A for _
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6ec :                       df_tk_isproc
d6ec : c95f             [ 2] 	cmp #'_'
d6ee : f002             [ 3] 	beq df_tk_isproc_true	; C=1
d6f0 : 18               [ 2] 	clc
d6f1 : 60               [ 6] 	rts
d6f2 :                       df_tk_isproc_true
d6f2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
d6f3 :                       df_tk_skip_ws
d6f3 :                       df_tk_ws_loop1
d6f3 : 208ed6           [ 6] 	jsr df_tk_peek_buf
d6f6 : 2011d7           [ 6] 	jsr df_tk_isws
d6f9 : 9008             [ 4] 	bcc df_tk_ws_done
d6fb : e67a             [ 5] 	inc df_linoff
d6fd : 209fd6           [ 6] 	jsr df_tk_put_tok
d700 : 4cf3d6           [ 3] 	jmp df_tk_ws_loop1
d703 :                       df_tk_ws_done
d703 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  138
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
d704 :                       df_tk_strip_ws
d704 :                       df_tk_sws_loop1
d704 : 208ed6           [ 6] 	jsr df_tk_peek_buf
d707 : 2011d7           [ 6] 	jsr df_tk_isws
d70a : 90f7             [ 3] 	bcc df_tk_ws_done
d70c : e67a             [ 5] 	inc df_linoff
d70e : 90f4             [ 3] 	bcc df_tk_sws_loop1		; Always as C is not touche
d710 :                       df_tk_sws_done
d710 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isws
                             ;* Check char is ws (only space is counted)
                             ;* Return: CC = False, CS = True
                             ;****************************************
d711 :                       df_tk_isws
d711 : c920             [ 2] 	cmp #' '
d713 : d001             [ 3] 	bne df_tk_isws_false
                             	; C must be 1 here
d715 : 60               [ 6] 	rts
d716 :                       df_tk_isws_false	
d716 : 18               [ 2] 	clc
d717 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* CC = found, CS = Error
                             ;****************************************
d718 :                       df_tk_expect
d718 : 48               [ 3] 	pha
                             	; skip ws
d719 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; peek the buffer
d71c : 68               [ 4] 	pla
d71d : a47a             [ 3] 	ldy df_linoff
d71f : d90004           [ 4] 	cmp df_linbuff,y
                             	; if not expected char then error
d722 : d002             [ 3] 	bne df_tk_expecterr
d724 : 18               [ 2] 	clc
d725 : 60               [ 6] 	rts
d726 :                       df_tk_expecterr
d726 : 38               [ 2] 	sec
d727 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* CC = found, CS = Error
                             ;****************************************
d728 :                       df_tk_expect_tok
d728 : 2018d7           [ 6] 	jsr df_tk_expect
d72b : b007             [ 3] 	bcs df_tk_expecttokret
d72d : 2094d6           [ 6] 	jsr df_tk_get_buf
d730 : 209fd6           [ 6] 	jsr df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page  139
-------------------------------- bank\bank0.s --------------------------------

d733 : 18               [ 2] 	clc
d734 :                       df_tk_expecttokret
d734 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* FATAL IF NOT FOUND
                             ;****************************************
d735 :                       df_tk_expect_tok_err
d735 : 2028d7           [ 6] 	jsr df_tk_expect_tok
d738 : b001             [ 3] 	bcs df_tk_expect_tok_fatal
                             	; C must be 0 here
d73a : 60               [ 6] 	rts
d73b :                       df_tk_expect_tok_fatal
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant number
                             ;****************************************
d73d :                       df_tk_num
                             	; X,A = address, linbuff must be on page boundar
d73d : 18               [ 2] 	clc
d73e : a900             [ 2] 	lda #lo(df_linbuff)
d740 : 657a             [ 3] 	adc df_linoff
d742 : aa               [ 2] 	tax
d743 : a904             [ 2] 	lda #hi(df_linbuff)
d745 : 6900             [ 2] 	adc #0
d747 : a000             [ 2] 	ldy #0				; any numeric format
d749 : 20d4c1           [ 6] 	jsr con_n_to_a
d74c : b033             [ 3] 	bcs df_tk_num_err
                             	; A = format
                             	; X = how many digits processed
                             	; Jump over that many chars
d74e : a8               [ 2] 	tay
d74f : 18               [ 2] 	clc
d750 : 8a               [ 2] 	txa
d751 : 657a             [ 3] 	adc df_linoff
d753 : 857a             [ 3] 	sta df_linoff
                             	; Now tokenise an integer
d755 : 98               [ 2] 	tya
d756 : c901             [ 2] 	cmp #NUM_DEC
d758 : d004             [ 3] 	bne df_tk_num_hexbin
d75a : a909             [ 2] 	lda #DFTK_INTDEC	; decimal always an int
d75c : d014             [ 3] 	bne df_tk_num_put
d75e :                       df_tk_num_hexbin
d75e : 18               [ 2] 	clc
d75f : 6904             [ 2] 	adc #4				; Default to BYT
d761 : c907             [ 2] 	cmp #NUM_BIN+4
d763 : f009             [ 3] 	beq df_tk_num_bin
d765 : e004             [ 2] 	cpx #4				; 4 chars processed = byte
d767 : f009             [ 3] 	beq df_tk_num_put
d769 :                       df_tk_num_makeint
d769 : 18               [ 2] 	clc
d76a : 6904             [ 2] 	adc #4				; now make INT
d76c : d004             [ 3] 	bne df_tk_num_put
d76e :                       df_tk_num_bin
d76e : e00a             [ 2] 	cpx #0x0a			; 10 chars processed = byte
d770 : d0f7             [ 3] 	bne df_tk_num_makeint
d772 :                       df_tk_num_put
AS65 Assembler for R6502 [1.42].                                     Page  140
-------------------------------- bank\bank0.s --------------------------------

d772 : 209fd6           [ 6] 	jsr df_tk_put_tok
d775 : a53b             [ 3] 	lda num_a
d777 : 209fd6           [ 6] 	jsr df_tk_put_tok
d77a : a53c             [ 3] 	lda num_a+1
d77c : 209fd6           [ 6] 	jsr df_tk_put_tok
d77f : 18               [ 2] 	clc
d780 : 60               [ 6] 	rts
d781 :                       df_tk_num_err
d781 : 38               [ 2] 	sec
d782 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant char
                             ;****************************************
d783 :                       df_tk_char
                             	; skip the first quote
d783 : 2094d6           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d786 : a900             [ 2] 	lda #DFTK_CHR
d788 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; get the char value and save
d78b : 2094d6           [ 6] 	jsr df_tk_get_buf
d78e : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; always put two bytes in, even for a BYTE type
d791 : a900             [ 2] 	lda #0
d793 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; next byte must be single quote
d796 : 2094d6           [ 6] 	jsr df_tk_get_buf
d799 : c927             [ 2] 	cmp #0x27
d79b : d002             [ 3] 	bne df_tk_char_err
d79d : 18               [ 2] 	clc
d79e : 60               [ 6] 	rts
d79f :                       df_tk_char_err
d79f : 38               [ 2] 	sec
d7a0 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant string
                             ;****************************************
d7a1 :                       df_tk_str
                             	; skip the first quote
d7a1 : 2094d6           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d7a4 : a910             [ 2] 	lda #DFTK_STRLIT
d7a6 : 209fd6           [ 6] 	jsr df_tk_put_tok
d7a9 :                       df_tk_str_ch
                             	; copy string chars in to token buffer
                             	; until another quote or end of line
d7a9 : 2094d6           [ 6] 	jsr df_tk_get_buf
d7ac : c900             [ 2] 	cmp #0
d7ae : f011             [ 3] 	beq df_tk_str_err
d7b0 : c922             [ 2] 	cmp #0x22
d7b2 : f006             [ 3] 	beq df_tk_str_don
d7b4 : 209fd6           [ 6] 	jsr df_tk_put_tok
d7b7 : 4ca9d7           [ 3] 	jmp df_tk_str_ch
d7ba :                       df_tk_str_don
                             	; zero terminated strings
d7ba : a900             [ 2] 	lda #0
d7bc : 209fd6           [ 6] 	jsr df_tk_put_tok
d7bf : 18               [ 2] 	clc
d7c0 : 60               [ 6] 	rts
d7c1 :                       df_tk_str_err
AS65 Assembler for R6502 [1.42].                                     Page  141
-------------------------------- bank\bank0.s --------------------------------

                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ;****************************************
                             ;* Tokenise a constant (num, string, char)
                             ;****************************************
d7c3 :                       df_tk_const
d7c3 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; Check what constant it is
d7c6 : 208ed6           [ 6] 	jsr df_tk_peek_buf
                             	; Minus symbol could be start of a number
d7c9 : c92d             [ 2] 	cmp #'-'
d7cb : f005             [ 3] 	beq df_tk_const_try_num
d7cd : 20a8d6           [ 6] 	jsr df_tk_isdigit
d7d0 : 9003             [ 3] 	bcc df_tk_const_try_str
d7d2 :                       df_tk_const_try_num
d7d2 : 4c3dd7           [ 3] 	jmp df_tk_num
d7d5 :                       df_tk_const_try_str
                             	; check for double quote
d7d5 : c922             [ 2] 	cmp #0x22
d7d7 : d003             [ 3] 	bne df_tk_const_try_char
d7d9 : 4ca1d7           [ 3] 	jmp df_tk_str
d7dc :                       df_tk_const_try_char
                             	; check for single apostrophe
d7dc : c927             [ 2] 	cmp #0x27
d7de : d003             [ 3] 	bne df_tk_const_err
d7e0 : 4c83d7           [ 3] 	jmp df_tk_char
d7e3 :                       df_tk_const_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ;****************************************
                             ;* Tokenise a variable - A = mask
                             ;* Return : A = variable index
                             ;****************************************
d7e5 :                       df_tk_var
                             	; Find or create variable, address in X,A
d7e5 : 2025d6           [ 6] 	jsr df_var_findcreate
d7e8 : 9001             [ 3] 	bcc df_tk_var_cont
d7ea : 60               [ 6] 	rts
d7eb :                       df_tk_var_cont
                             	; Save X,A for later
d7eb : 48               [ 3] 	pha
d7ec : 8a               [ 2] 	txa
d7ed : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d7ee : a911             [ 2] 	lda #DFTK_VAR					
d7f0 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
d7f3 : 68               [ 4] 	pla
d7f4 : 209fd6           [ 6] 	jsr df_tk_put_tok
d7f7 : 68               [ 4] 	pla
d7f8 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; count of any array indices
d7fb :                       df_tk_var_ck
                             	; check if array procesing needed
d7fb : a95b             [ 2] 	lda #'['
d7fd : 2028d7           [ 6] 	jsr df_tk_expect_tok
d800 : b003             [ 3] 	bcs df_tk_var_noarry
                             	; process numeric expression in bracket
d802 : 20a5d8           [ 6] 	jsr df_tk_narry
d805 :                       df_tk_var_noarry
AS65 Assembler for R6502 [1.42].                                     Page  142
-------------------------------- bank\bank0.s --------------------------------

d805 : 18               [ 2] 	clc
d806 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a parameter in proc definition
                             ;* Return : A = variable index
                             ;****************************************
d807 :                       df_tk_parm
                             	; if preceeding with non-local qualifier DFTK_VA
d807 : 208ed6           [ 6] 	jsr df_tk_peek_buf
d80a : c926             [ 2] 	cmp #DFTK_VARPARM
d80c : d006             [ 3] 	bne df_tk_parm_skip_var
                             	; get the qualifier and put in token buffer
d80e : 2094d6           [ 6] 	jsr df_tk_get_buf
d811 : 209fd6           [ 6] 	jsr df_tk_put_tok	
d814 :                       df_tk_parm_skip_var
                             	; don't have a certain type of var
d814 : a900             [ 2] 	lda #0
d816 : 4ce5d7           [ 3] 	jmp df_tk_var
                             	
                             	
                             ;****************************************
                             ;* Tokenise a variable to localise
                             ;* Return : A,X = variable index
                             ;****************************************
d819 :                       df_tk_localvar
                             	; Find or create variable, index in A
d819 : 2025d6           [ 6] 	jsr df_var_findcreate
d81c : 9001             [ 3] 	bcc df_tk_localvar_cont
d81e : 60               [ 6] 	rts
d81f :                       df_tk_localvar_cont
                             	; Save variable address for later
d81f : 48               [ 3] 	pha
d820 : 8a               [ 2] 	txa
d821 : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d822 : a911             [ 2] 	lda #DFTK_VAR					
d824 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
d827 : 68               [ 4] 	pla
d828 : 209fd6           [ 6] 	jsr df_tk_put_tok
d82b : 68               [ 4] 	pla
d82c : 209fd6           [ 6] 	jsr df_tk_put_tok
d82f : 18               [ 2] 	clc
d830 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise call or def of proc
                             ;* Mode : A = 0 means def, else call
                             ;****************************************
d831 :                       df_tk_proc
d831 : 8589             [ 3] 	sta df_procmode
d833 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; Find or create proc, index in A
d836 : a940             [ 2] 	lda #DFVVT_PROC
d838 : 2025d6           [ 6] 	jsr df_var_findcreate
d83b : b066             [ 3] 	bcs df_tk_proc_err
                             
                             	; Save variable address for later
d83d : 868c             [ 3] 	stx df_procptr
d83f : 858d             [ 3] 	sta df_procptr+1
                             
AS65 Assembler for R6502 [1.42].                                     Page  143
-------------------------------- bank\bank0.s --------------------------------

                             	; Put PROC escape in token buffer
d841 : a912             [ 2] 	lda #DFTK_PROC					
d843 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
d846 : a58c             [ 3] 	lda df_procptr
d848 : 209fd6           [ 6] 	jsr df_tk_put_tok
d84b : a58d             [ 3] 	lda df_procptr+1
d84d : 209fd6           [ 6] 	jsr df_tk_put_tok
                             
                             	; initially assume no args
d850 : a900             [ 2] 	lda #0
d852 : 858a             [ 3] 	sta df_procargs
                             	
                             	; Must have an open bracket
d854 : a928             [ 2] 	lda #'('
d856 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; if immediately followed by close bracket then 
d859 : 208ed6           [ 6] 	jsr df_tk_peek_buf
d85c : c929             [ 2] 	cmp #')'
d85e : f030             [ 3] 	beq df_tk_proc_noparm
                             	; else tokenise parm variables
d860 :                       df_tk_proc_parms
d860 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; call appropriate routine for mode
d863 : a589             [ 3] 	lda df_procmode
d865 : d006             [ 3] 	bne df_tk_proc_call
                             	; tokenise parameter variable in def mode
d867 : 2007d8           [ 6] 	jsr df_tk_parm
d86a : 4c76d8           [ 3] 	jmp df_tk_proc_skip_call
d86d :                       df_tk_proc_call
                             	; tokenise expression in call mode
                             	;**CHECK**
d86d : a58a             [ 3] 	lda df_procargs	; procargs could be impacted ins
d86f : 48               [ 3] 	pha
d870 : 2027d9           [ 6] 	jsr df_tk_expression
d873 : 68               [ 4] 	pla
d874 : 858a             [ 3] 	sta df_procargs
d876 :                       df_tk_proc_skip_call
d876 : b02a             [ 3] 	bcs df_tk_proc_errp
                             	; increment number of args
d878 : e68a             [ 5] 	inc df_procargs
                             	; what is next non ws char
d87a : 20f3d6           [ 6] 	jsr df_tk_skip_ws
d87d : c92c             [ 2] 	cmp #','
d87f : f006             [ 3] 	beq df_tk_proc_comma
d881 : c929             [ 2] 	cmp #')' 
d883 : d01d             [ 3] 	bne df_tk_proc_errp
d885 : f009             [ 3] 	beq df_tk_proc_noparm
                             	; comma found, more parms to process
d887 :                       df_tk_proc_comma
d887 : 2094d6           [ 6] 	jsr df_tk_get_buf
d88a : 209fd6           [ 6] 	jsr df_tk_put_tok
d88d : 4c60d8           [ 3] 	jmp df_tk_proc_parms
d890 :                       df_tk_proc_noparm
                             	; consume the close bracket
d890 : 2094d6           [ 6] 	jsr df_tk_get_buf
d893 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	
                             	; update arg count if def mode
d896 : a689             [ 3] 	ldx df_procmode
d898 : d006             [ 3] 	bne df_tk_proc_skip_args
                             	; use address of proc
AS65 Assembler for R6502 [1.42].                                     Page  144
-------------------------------- bank\bank0.s --------------------------------

                             	; put arg count in dim2
d89a : a004             [ 2] 	ldy #DFVVT_DIM2
d89c : a58a             [ 3] 	lda df_procargs
d89e : 918c             [ 5] 	sta (df_procptr),y
d8a0 :                       df_tk_proc_skip_args	
d8a0 : 18               [ 2] 	clc
d8a1 : 60               [ 6] 	rts
d8a2 :                       df_tk_proc_errp
d8a2 : 68               [ 4] 	pla
d8a3 :                       df_tk_proc_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse array index
                             ;****************************************
d8a5 :                       df_tk_narry
                             	; if array open bracket encountered
                             	; then tokenise a numeric expression
d8a5 : 2027d9           [ 6] 	jsr df_tk_expression
                             	; If a comma is next, then another expression
d8a8 : a92c             [ 2] 	lda #','
d8aa : 2028d7           [ 6] 	jsr df_tk_expect_tok
d8ad : b003             [ 3] 	bcs df_tk_narry_end
d8af : 2027d9           [ 6] 	jsr df_tk_expression
d8b2 :                       df_tk_narry_end
                             	; after the second dimension, must be close sq b
d8b2 : a95d             [ 2] 	lda #']'
d8b4 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
d8b7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse bracket
                             ;****************************************
d8b8 :                       df_tk_nbrkt
                             	; if  open bracket encountered
                             	; then tokenise a numeric expression
d8b8 : 2027d9           [ 6] 	jsr df_tk_expression
d8bb : a929             [ 2] 	lda #')'
d8bd : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
d8c0 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Parse call to numeric proc
                             ;****************************************
d8c1 :                       df_tk_nterm_proc
                             	; call mode
d8c1 : a901             [ 2] 	lda #1
d8c3 : 2031d8           [ 6] 	jsr df_tk_proc
d8c6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse numeric term
                             ;****************************************
d8c7 :                       df_tk_nterm
                             	; skip any ws first, copying in to tokbuff
                             	; A containts the non-ws char
d8c7 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
d8ca : c900             [ 2] 	cmp #0
d8cc : d002             [ 3] 	bne df_tk_nterm_cont
d8ce : 38               [ 2] 	sec
d8cf : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  145
-------------------------------- bank\bank0.s --------------------------------

d8d0 :                       df_tk_nterm_cont
                             	; if open bracket then process it
d8d0 : c928             [ 2] 	cmp #'('
d8d2 : d00a             [ 3] 	bne df_tk_nterm_tryfn
                             	; get the bracket and put in token buffer
d8d4 : 2094d6           [ 6] 	jsr df_tk_get_buf
d8d7 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; go process the open bracket
d8da : 20b8d8           [ 6] 	jsr df_tk_nbrkt
d8dd : 60               [ 6] 	rts
d8de :                       df_tk_nterm_tryfn
d8de : 48               [ 3] 	pha
                             	; try decoding a built-in function
d8df : a902             [ 2] 	lda #DFTK_FN
d8e1 : 2006da           [ 6] 	jsr df_tk_matchtok
d8e4 : b00e             [ 3] 	bcs df_tk_nterm_try_proc
                             	; pull old A in to Y but don't use
d8e6 : 68               [ 4] 	pla
d8e7 : a8               [ 2] 	tay
                             	; restore A and put the token with MSB set
d8e8 : 8a               [ 2] 	txa
d8e9 : 0980             [ 2] 	ora #0x80
d8eb : 209fd6           [ 6] 	jsr df_tk_put_tok
d8ee : 20d7d9           [ 6] 	jsr df_tk_exec_parser 
d8f1 : b01b             [ 4] 	bcs df_tk_nterm_err
d8f3 : 60               [ 6] 	rts
d8f4 :                       df_tk_nterm_try_proc
d8f4 : 68               [ 4] 	pla
                             	; if it's not a func then try proc
d8f5 : 20ecd6           [ 6] 	jsr df_tk_isproc
d8f8 : 9006             [ 4] 	bcc df_tk_nterm_try_var
d8fa : 20c1d8           [ 6] 	jsr df_tk_nterm_proc
d8fd : b00f             [ 4] 	bcs df_tk_nterm_err
d8ff : 60               [ 6] 	rts
d900 :                       df_tk_nterm_try_var
                             	; Non-zero mask means var must be this type
d900 : a900             [ 2] 	lda #0
d902 : 20e5d7           [ 6] 	jsr df_tk_var
d905 : b001             [ 3] 	bcs df_tk_nterm_try_const
d907 : 60               [ 6] 	rts
d908 :                       df_tk_nterm_try_const
                             	; Try decoding a constant
d908 : 20c3d7           [ 6] 	jsr df_tk_const
d90b : b001             [ 3] 	bcs df_tk_nterm_err
d90d : 60               [ 6] 	rts
d90e :                       df_tk_nterm_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric operator
                             ;****************************************
d910 :                       df_tk_nop
d910 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
d913 : c900             [ 2] 	cmp #0
d915 : f00e             [ 3] 	beq df_tk_nop_false
                             	; must be an operator token for numeric
d917 : a90c             [ 2] 	lda #DFTK_OP | DFTK_STROP
d919 : 2006da           [ 6] 	jsr df_tk_matchtok
d91c : b007             [ 3] 	bcs df_tk_nop_false
                             	; got a token
d91e : 0980             [ 2] 	ora #DFTK_TOKEN
AS65 Assembler for R6502 [1.42].                                     Page  146
-------------------------------- bank\bank0.s --------------------------------

d920 : 209fd6           [ 6] 	jsr df_tk_put_tok
d923 : 18               [ 2] 	clc
d924 : 60               [ 6] 	rts
d925 :                       df_tk_nop_false
d925 : 38               [ 2] 	sec
d926 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse numeric expression
                             ;****************************************
d927 :                       df_tk_expression
                             	; Tokenise a numeric term
d927 : 20c7d8           [ 6] 	jsr df_tk_nterm
                             	; Try and tokenise a numeric operator
d92a : 2010d9           [ 6] 	jsr df_tk_nop
                             	; If an operator was tokenised
                             	; then loop back for another term
d92d : 90f8             [ 3] 	bcc df_tk_expression
                             	; If no operator was found then
                             	; expression is done
d92f : 18               [ 2] 	clc
d930 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find expected token and parse expression
                             ;****************************************
d931 :                       df_tk_tok_expression
d931 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
d934 : 4c27d9           [ 3] 	jmp df_tk_expression
                             
                             
                             ;****************************************
                             ;* Check end of statement
                             ;****************************************
d937 :                       df_tk_isEOS
d937 : a93a             [ 2] 	lda #':'
d939 : 2028d7           [ 6] 	jsr df_tk_expect_tok
d93c : 9002             [ 3] 	bcc df_tk_eos
d93e : 18               [ 2] 	clc
d93f : 60               [ 6] 	rts
d940 :                       df_tk_eos
                             	; this is the position of the next statement
d940 : a57b             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
d942 : a47d             [ 3] 	ldy df_nxtstidx
d944 : 998004           [ 5] 	sta df_tokbuff,y
d947 : 38               [ 2] 	sec
d948 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* Parse user defined proc
                             ;****************************************
d949 :                       df_tk_parse_user_proc
                             	; put proc token in as a call
d949 : a981             [ 2] 	lda #0x81
d94b : 209fd6           [ 6] 	jsr df_tk_put_tok
d94e : a901             [ 2] 	lda #1
d950 : 2031d8           [ 6] 	jsr df_tk_proc
d953 : 60               [ 6] 	rts
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  147
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* Parse a command
                             ;* Do not fatal error if this fails
                             ;****************************************
d954 :                       df_tk_parse_command
                             	; only looking for keywords
d954 : a901             [ 2] 	lda #DFTK_KW
d956 : 2006da           [ 6] 	jsr df_tk_matchtok
                             	; if didn't find regular keywords then try non f
d959 : b010             [ 3] 	bcs df_tk_parse_command_err
                             	; if match then store token in the line buffer
                             	; Set MSB
d95b : 0980             [ 2] 	ora #0x80
d95d : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; call the parser to do tokenise based on the st
d960 : a581             [ 3] 	lda df_symoff
d962 : 20d7d9           [ 6] 	jsr df_tk_exec_parser
d965 : b004             [ 3] 	bcs df_tk_parse_command_err
                             	; [1] ignore white space but keep it
d967 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
d96a :                       df_tk_parse_command_done
d96a : 18               [ 2] 	clc
d96b :                       df_tk_parse_command_err
d96b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* lexer
                             ;****************************************
d96c :                       df_lexer_line
d96c : a900             [ 2] 	lda #0
                             	; start at the beginning of the line buffer
d96e : 857a             [ 3] 	sta df_linoff
                             	; start at the beginning of the tokenised buffer
d970 : 857b             [ 3] 	sta df_tokoff
                             	; set current line to the token buffer
d972 : a980             [ 2] 	lda #lo(df_tokbuff)
d974 : 8584             [ 3] 	sta df_currlin
d976 : a904             [ 2] 	lda #hi(df_tokbuff)
d978 : 8585             [ 3] 	sta df_currlin+1
                             	; Set the line length to 0
d97a : a900             [ 2] 	lda #0
d97c : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	
                             	; any leading white space, ignore and discard
d97f : 2004d7           [ 6] 	jsr df_tk_strip_ws
                             
                             	; if peek next character is a number then assume
                             	; else assume a statement
d982 : 20a8d6           [ 6] 	jsr df_tk_isdigit
d985 : 9006             [ 3] 	bcc df_lexer_skip_lnum
                             	; if line number then capture the line number an
d987 : 20e6d9           [ 6] 	jsr df_tk_linenum
d98a : 4c95d9           [ 3] 	jmp df_tk_body
d98d :                       df_lexer_skip_lnum
                             	; if no line number then zero out the line numbe
                             	; line zero will indicate an immediate mode comm
d98d : a900             [ 2] 	lda #0
d98f : 209fd6           [ 6] 	jsr df_tk_put_tok				; Line num low byte
d992 : 209fd6           [ 6] 	jsr df_tk_put_tok				; Line num high byte
d995 :                       df_tk_body
AS65 Assembler for R6502 [1.42].                                     Page  148
-------------------------------- bank\bank0.s --------------------------------

                             	; Offset for next statement
d995 : a57b             [ 3] 	lda df_tokoff
d997 : 857d             [ 3] 	sta df_nxtstidx
d999 : a900             [ 2] 	lda #0
d99b : 209fd6           [ 6] 	jsr df_tk_put_tok				; Offset to next statement
                             	; [1] capture white space from line buffer in to
d99e : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; If next non ws is zero then this is an empty l
                             	; so return with length zero but line number fil
                             	; token buffer
d9a1 : c900             [ 2] 	cmp #0
d9a3 : f02e             [ 3] 	beq df_tk_line_empty
                             	; if next char is _ then parse a user defined pr
d9a5 : 20ecd6           [ 6] 	jsr df_tk_isproc
d9a8 : 9006             [ 3] 	bcc df_tk_try_command
d9aa : 2049d9           [ 6] 	jsr df_tk_parse_user_proc
d9ad : 4cbcd9           [ 3] 	jmp df_tk_done
d9b0 :                       df_tk_try_command
                             	; try  a keyword
d9b0 : 2054d9           [ 6] 	jsr df_tk_parse_command
d9b3 : b002             [ 3] 	bcs	df_tk_try_assign
d9b5 : 9005             [ 3] 	bcc df_tk_done
d9b7 :                       df_tk_try_assign
                             	; nothing but to try an assignment operation
d9b7 : 204edd           [ 6] 	jsr df_tk_assign
d9ba : b019             [ 3] 	bcs	df_tk_parseerror
d9bc :                       df_tk_done
                             	; put statement index stuff here in case of mult
                             	; check for : and if present tokenise plus updat
                             	; then go back to try and process another statem
d9bc : 2037d9           [ 6] 	jsr df_tk_isEOS
d9bf : b0d4             [ 3] 	bcs df_tk_body
                             	; if not at end of line, then must be error
d9c1 : 208ed6           [ 6] 	jsr df_tk_peek_buf
d9c4 : c900             [ 2] 	cmp #0
d9c6 : d00d             [ 3] 	bne df_tk_parseerror
                             	; Get line length length
d9c8 : a47b             [ 3] 	ldy df_tokoff
                             	; ensure there is always a zero after the last t
d9ca : a900             [ 2] 	lda #0
d9cc : 998004           [ 5] 	sta df_tokbuff,y
                             	; save the line length
d9cf : 98               [ 2] 	tya
d9d0 : 8d8004           [ 4] 	sta df_tokbuff
d9d3 :                       df_tk_line_empty
d9d3 : 18               [ 2] 	clc
d9d4 : 60               [ 6] 	rts
d9d5 :                       df_tk_parseerror
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* df_tk_parsestatement
                             ;* Execute parse routine for this statement
                             ;* Input: df_tokoff is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
d9d7 :                       df_tk_exec_parser
d9d7 : 0a               [ 2] 	asl a
d9d8 : aa               [ 2] 	tax
d9d9 : bd13dc           [ 4] 	lda df_tk_tokenjmp,x
d9dc : 859f             [ 3] 	sta df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  149
-------------------------------- bank\bank0.s --------------------------------

d9de : bd14dc           [ 4] 	lda df_tk_tokenjmp+1,x
d9e1 : 85a0             [ 3] 	sta df_tmpptra+1
d9e3 : 6c9f00           [ 6] 	jmp (df_tmpptra)
                             	
                             
                             ;****************************************
                             ;* df_tk_linenum
                             ;* Tokenise line number
                             ;****************************************
d9e6 :                       df_tk_linenum
                             	; Convert line number to 16 bit number
                             	; Save the line number
                             	; Increment the buffer pointer
d9e6 : 18               [ 2] 	clc
d9e7 : a900             [ 2] 	lda #lo(df_linbuff)
d9e9 : 657a             [ 3] 	adc df_linoff
d9eb : aa               [ 2] 	tax
d9ec : a904             [ 2] 	lda #hi(df_linbuff)
d9ee : 6900             [ 2] 	adc #0
d9f0 : a001             [ 2] 	ldy #1			; Decimal format only
d9f2 : 20d4c1           [ 6] 	jsr con_n_to_a
d9f5 : 18               [ 2] 	clc
d9f6 : 8a               [ 2] 	txa
d9f7 : 657a             [ 3] 	adc df_linoff
d9f9 : 857a             [ 3] 	sta df_linoff
                             	; Now save line number
d9fb : a53b             [ 3] 	lda num_a
d9fd : 209fd6           [ 6] 	jsr df_tk_put_tok
da00 : a53c             [ 3] 	lda num_a+1
da02 : 209fd6           [ 6] 	jsr df_tk_put_tok
da05 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;*			df_symoff is the symbol table index
                             ;****************************************
da06 :                       df_tk_matchtok
                             	; save the mask to check types against
da06 : 48               [ 3] 	pha
                             	; Start at token symbols beginning
da07 : a988             [ 2] 	lda #lo(df_tokensyms)
da09 : 857f             [ 3] 	sta df_symtab
da0b : a9da             [ 2] 	lda #hi(df_tokensyms)
da0d : 8580             [ 3] 	sta df_symtab+1
da0f : a900             [ 2] 	lda #0
da11 : 8581             [ 3] 	sta df_symoff
da13 :                       df_tk_checknexttok
                             	; check this token type first
da13 : 68               [ 4] 	pla
da14 : 48               [ 3] 	pha
da15 : a681             [ 3] 	ldx df_symoff
da17 : 3dd3dc           [ 4] 	and df_tk_tokentype,x
da1a : f032             [ 3] 	beq df_tk_symnomatch
                             	; Special check for operator token
                             	; because of order of precedence fudge
                             	; ******FIX THIS ONE DAY!!!!!!******
                             	; if parm and token type = DFTK_OP then ok
AS65 Assembler for R6502 [1.42].                                     Page  150
-------------------------------- bank\bank0.s --------------------------------

                             	; if parm and token type <> DFTK_OP then not ok
da1c : bdd3dc           [ 4] 	lda df_tk_tokentype,x
da1f : 2908             [ 2] 	and #DFTK_OP
da21 : f009             [ 3] 	beq df_tk_matchtok_skip_op
da23 : 68               [ 4] 	pla
da24 : 48               [ 3] 	pha
da25 : 2908             [ 2] 	and #DFTK_OP
da27 : 3dd3dc           [ 4] 	and df_tk_tokentype,x
da2a : f022             [ 3] 	beq df_tk_symnomatch	
da2c :                       df_tk_matchtok_skip_op
                             	; From the line buffer current pointer
                             	; Check for a token match
da2c : a47a             [ 3] 	ldy df_linoff
da2e : a200             [ 2] 	ldx #0
da30 :                       df_tk_checktokch
                             	; Get symtable char
                             	; and mask off MSB
da30 : a17f             [ 6] 	lda (df_symtab,x)
                             	; Save the value and mask off MSB
da32 : 48               [ 3] 	pha
da33 : 297f             [ 2] 	and #0x7f
                             	; Compare with current line buffer char
da35 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
da38 : d013             [ 3] 	bne df_tk_symnomatchp
                             	; If match and symbol has MSB then
                             	; all of the symbol matched
da3a : 68               [ 4] 	pla 
da3b : 3033             [ 3] 	bmi df_tk_symfound
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
da43 : c8               [ 2] 	iny
                             	; If buffer is '.' then let this be a match
da44 : b90004           [ 4] 	lda df_linbuff,y
da47 : c92e             [ 2] 	cmp #'.'
da49 : f025             [ 3] 	beq df_tk_symfound
da4b : d0e3             [ 3] 	bne df_tk_checktokch	; branch always
da4d :                       df_tk_symnomatchp
da4d : 68               [ 4] 	pla
da4e :                       df_tk_symnomatch
                             	; Increment symbol counter to next symbol
da4e : e681             [ 5] 	inc df_symoff
da50 :                       df_tk_symnextentry
da50 : a200             [ 2] 	ldx #0
da52 : a17f             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is MSB
da54 : 3009             [ 3] 	bmi  df_tk_foundsymend
                             	_incZPWord df_symtab
                             
da5c : 4c50da           [ 3] 	jmp df_tk_symnextentry
da5f :                       df_tk_foundsymend
                             	; Increment char to point to new symbol
                             	; for matching with line buffer
                             	_incZPWord df_symtab
                             
                             	; If next char is not zero then
                             	; try and match with line buffer
da65 : a17f             [ 6] 	lda (df_symtab,x)
da67 : d0aa             [ 3] 	bne df_tk_checknexttok
                             	; else symbol table exhausted
AS65 Assembler for R6502 [1.42].                                     Page  151
-------------------------------- bank\bank0.s --------------------------------

                             	; so no match found
                             	; pop mask off stack
da69 : 68               [ 4] 	pla	
                             	; Zero symbol counter
da6a : a900             [ 2] 	lda #0
da6c : 8581             [ 3] 	sta df_symoff
                             	; Set C to indicate error (no match)
da6e : 38               [ 2] 	sec
da6f : 60               [ 6] 	rts
da70 :                       df_tk_symfound
                             	; Full match with keyword in symtable but
                             	; if matching with something that ended in alpha
                             	; then check the next buffer char is not alphanu
                             	; as this could be part of a variable name
                             	; Point to next buffer char in any case
da70 : c8               [ 2] 	iny
                             	; First mask off MSB
da71 : 297f             [ 2] 	and #0x7f
                             	; Then check if alpha
da73 : 20d2d6           [ 6] 	jsr df_tk_isalpha
                             	; if not alpha then we're definitely done
da76 : 9008             [ 3] 	bcc df_tk_symfound_final
                             	; else check buffer
da78 : b90004           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
da7b : 20e2d6           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
da7e : b0ce             [ 3] 	bcs df_tk_symnomatch
da80 :                       df_tk_symfound_final
                             	; pop mask off stack
da80 : 68               [ 4] 	pla
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
da81 : 847a             [ 3] 	sty df_linoff
da83 : a581             [ 3] 	lda df_symoff
da85 : aa               [ 2] 	tax
da86 : 18               [ 2] 	clc
da87 : 60               [ 6] 	rts
                             
                             	include "dflat\tksymtab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKSYMTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page  152
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; ROM code
                             	code  
                             
                             ; Statement Token table
                             ; keywords
da88 :                       df_tokensyms
da88 : 80                    	db	0x80						; Implicit numeric assign
da89 : 80                    	db	0x80						; Implicit call procedure
da8a : bb                    	db	";"+0x80					; Comment
da8b : 7072696e746cee        	db	"printl",'n'+0x80			; println exprlist
da92 : 7072696e7461f4        	db	"printa",'t'+0x80			; printat x,y,exprlist
da99 : 7072696ef4            	db	"prin",'t'+0x80				; print exprlist
da9e : 6465e6                	db	"de",'f'+0x80				; def_subname
daa1 : 656e646465e6          	db	"endde",'f'+0x80			; enddef
daa7 : 7265747572ee          	db	"retur",'n'+0x80			; return
daad : 61626f72f4            	db	"abor",'t'+0x80				; abort
dab2 : 6c6f6361ec            	db	"loca",'l'+0x80				; local varlist
dab7 : 6469ed                	db	"di",'m'+0x80				; dim varlist
daba : 7265706561f4          	db	"repea",'t'+0x80			; repeat
dac0 : 756e7469ec            	db	"unti", 'l'+0x80			; until condition
dac5 : 666ff2                	db	"fo",'r'+0x80				; for var=start,end,incremen
dac8 : 6e6578f4              	db	"nex",'t'+0x80				; next
dacc : 7768696ce5            	db	"whil",'e'+0x80				; while condition
dad1 : 77656ee4              	db	"wen",'d'+0x80				; wend
dad5 : 69e6                  	db	"i",'f'+0x80				; if condition
dad7 : 656c73e5              	db	"els",'e'+0x80				; else
dadb : 656e6469e6            	db	"endi",'f'+0x80				; endif
dae0 : 656c69e6              	db	"eli",'f'+0x80				; elif condition
dae4 : 646174e1              	db	"dat",'a'+0x80				; data
dae8 : ae                    	db	'.'+0x80					; assembler command
dae9 : 7275ee                	db	"ru",'n'+0x80				; run
daec : 6c6973f4              	db	"lis",'t'+0x80				; list _proc-|*|line,line
daf0 : 696e7075f4            	db	"inpu",'t'+0x80				; input var
daf5 : 746578f4              	db	"tex",'t'+0x80				; text
daf9 : 706c6ff4              	db	"plo",'t'+0x80				; plot x,y,char|string
dafd : 637572736ff2          	db	"curso",'r'+0x80			; cursor n
db03 : 636cf3                	db	"cl",'s'+0x80				; cls
db06 : 706f6be5              	db	"pok",'e'+0x80				; poke a,v
db0a : 646f6be5              	db	"dok",'e'+0x80				; doke a,v
db0e : 736f756ee4            	db	"soun",'d'+0x80				; sound
db13 : 6d757369e3            	db	"musi",'c'+0x80				; music
db18 : 706c61f9              	db	"pla",'y'+0x80				; play
db1c : 736176e5              	db	"sav",'e'+0x80				; save "fname"
db20 : 6c6f61e4              	db	"loa",'d'+0x80				; load "fname"
db24 : 726561e4              	db	"rea",'d'+0x80				; read
db28 : 6e65f7                	db	"ne",'w'+0x80				; new
db2b : 72656e75ed            	db	"renu",'m'+0x80				; renum start,offset,incre
db30 : 776169f4              	db	"wai",'t'+0x80				; wait delay
db34 : 72657365f4            	db	"rese",'t'+0x80				; reset var
db39 : 68697265f3            	db	"hire",'s'+0x80				; hires col
db3e : 706f696ef4            	db	"poin",'t'+0x80				; point x,y
db43 : 6c696ee5              	db	"lin",'e'+0x80				; line x0,y0,x1,y1
db47 : 7069786d6f64e5        	db	"pixmod",'e'+0x80			; pixmode n
db4e : 696eeb                	db	"in",'k'+0x80				; ink n
db51 : 70617065f2            	db	"pape",'r'+0x80				; paper n
db56 : 636972636ce5          	db	"circl",'e'+0x80			; circle x,y,r
db5c : 68696d65ed            	db	"hime",'m'+0x80				; himem addr
db61 : 6d6f6e69746ff2        	db	"monito",'r'+0x80			; monitor
db68 : 737072636861f2        	db	"sprcha",'r'+0x80			; sprchar sp,ch
db6f : 737072706ff3          	db	"sprpo",'s'+0x80			; sprpos sp,x,y
db75 : 7370727570e4          	db	"sprup",'d'+0x80			; sprupd
AS65 Assembler for R6502 [1.42].                                     Page  153
-------------------------------- bank\bank0.s --------------------------------

db7b : 737072696e69f4        	db	"sprini",'t'+0x80			; sprinit
db82 : 7370726d756c74e9      	db	"sprmult",'i'+0x80			; sprmulti x[],y[]
db8a : 62736176e5            	db	"bsav",'e'+0x80				; bsave addr,len,"fname"
db8f : 626c6f61e4            	db	"bloa",'d'+0x80				; bload addr,"fname"
db94 : 74736176e5            	db	"tsav",'e'+0x80				; tsave "fname"
db99 : 746c6f61e4            	db	"tloa",'d'+0x80				; tload "fname"
                             ; Functions
db9e : 7065656ba8            	db	"peek",'('+0x80				; peek(x)
dba3 : 6465656ba8            	db	"deek",'('+0x80				; peek(x)
dba8 : 737469636ba8          	db	"stick",'('+0x80			; stick(x)
dbae : 676574a8              	db	"get",'('+0x80				; get(x)
dbb2 : 636872a8              	db	"chr",'('+0x80				; chr(x)
dbb6 : 6c656674a8            	db	"left",'('+0x80				; left(x$,y)
dbbb : 7269676874a8          	db	"right",'('+0x80			; right(x$,y)
dbc1 : 6d6964a8              	db	"mid",'('+0x80				; mid(x$,y)
dbc5 : 6c656ea8              	db	"len",'('+0x80				; len(x$)
dbc9 : 6d656da8              	db	"mem",'('+0x80				; mem(x)
dbcd : 7363726ea8            	db	"scrn",'('+0x80				; scrn(x,y)
dbd2 : 726e64a8              	db	"rnd",'('+0x80				; rnd(x)
dbd6 : 656c6170736564a8      	db	"elapsed",'('+0x80			; elapsed(var)
dbde : 63616c6ca8            	db	"call",'('+0x80				; call(addr,A,X,Y)
dbe3 : 686578a8              	db	"hex",'('+0x80				; hex(x)
dbe7 : 617363a8              	db	"asc",'('+0x80				; asc(x$)
dbeb : 76616ca8              	db	"val",'('+0x80				; val(x$)
dbef : 706978656ca8          	db	"pixel",'('+0x80			; pixel(x,y)
dbf5 : 737072686974a8        	db	"sprhit",'('+0x80			; sprhit(sp)
                             ; Numeric operators, in priority
dbfc : aa                    	db	'*'+0x80					; Multiply
dbfd : af                    	db 	'/'+0x80					; Divide
dbfe : dc                    	db 	'\\'+0x80					; Modulus
dbff : 3cbc                  	db	'<','<'+0x80				; Shift left
dc01 : 3ebe                  	db	'>','>'+0x80				; Shift right
dc03 : ab                    	db 	'+'+0x80					; Add
dc04 : ad                    	db	'-'+0x80					; Subtract
                             ; Bool and conditional operators, in priority
dc05 : a6                    	db '&'+0x80						; AND
dc06 : fc                    	db '|'+0x80						; OR
dc07 : de                    	db '^'+0x80						; EOR
dc08 : 3cbd                  	db "<",'='+0x80					; Less than or equal
dc0a : 3ebd                  	db ">",'='+0x80					; Greater than or equal
dc0c : 3cbe                  	db "<",'>'+0x80					; Not equal
dc0e : bc                    	db '<'+0x80						; Less than
dc0f : be                    	db '>'+0x80						; Greater than
dc10 : 3dbd                  	db "=",'='+0x80					; Equality (always last)
                             
dc12 : 00                    	db  0
                             
                             
                             	
                             	
                             	include "dflat\tkjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
AS65 Assembler for R6502 [1.42].                                     Page  154
-------------------------------- bank\bank0.s --------------------------------

                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
dc13 :                       df_tk_tokenjmp
dc13 : 4edd                  	dw	df_tk_assign
dc15 : 0ede                  	dw	df_tk_callproc
dc17 : 56dd                  	dw	df_tk_comment
dc19 : b6dd                  	dw	df_tk_println
dc1b : aadd                  	dw	df_tk_printat
dc1d : b6dd                  	dw	df_tk_print
dc1f : efdd                  	dw	df_tk_def
dc21 : 47de                  	dw	df_tk_enddef
dc23 : 49de                  	dw	df_tk_return
dc25 : 47de                  	dw	df_tk_abort
dc27 : dedd                  	dw	df_tk_local
dc29 : cddd                  	dw	df_tk_dim
dc2b : 47de                  	dw	df_tk_repeat
dc2d : 49de                  	dw	df_tk_until
dc2f : f5dd                  	dw	df_tk_for
dc31 : 47de                  	dw	df_tk_next
dc33 : 49de                  	dw	df_tk_while
dc35 : 47de                  	dw	df_tk_wend
dc37 : 49de                  	dw	df_tk_if
dc39 : 47de                  	dw	df_tk_else
dc3b : 47de                  	dw	df_tk_endif
dc3d : 49de                  	dw	df_tk_elseif
dc3f : b6dd                  	dw	df_tk_data
dc41 : 54f9                  	dw	df_tk_asm_parse_command
dc43 : 47de                  	dw	df_tk_run
dc45 : 87dd                  	dw	df_tk_list
dc47 : c4dd                  	dw	df_tk_input
dc49 : 47de                  	dw	df_tk_text
dc4b : 56de                  	dw	df_tk_plot
dc4d : 49de                  	dw	df_tk_cursor
dc4f : 47de                  	dw	df_tk_cls
dc51 : 4dde                  	dw	df_tk_poke
dc53 : 4dde                  	dw	df_tk_doke
dc55 : 56de                  	dw	df_tk_sound
dc57 : 5fde                  	dw	df_tk_music
dc59 : 5fde                  	dw	df_tk_play
dc5b : 49de                  	dw	df_tk_save
dc5d : 49de                  	dw	df_tk_load
dc5f : cddd                  	dw	df_tk_read
dc61 : 47de                  	dw	df_tk_new
dc63 : 56de                  	dw	df_tk_renum
dc65 : 49de                  	dw	df_tk_wait
dc67 : 10de                  	dw	df_tk_reset
dc69 : 47de                  	dw	df_tk_hires
AS65 Assembler for R6502 [1.42].                                     Page  155
-------------------------------- bank\bank0.s --------------------------------

dc6b : 4dde                  	dw	df_tk_point
dc6d : 5fde                  	dw	df_tk_line
dc6f : 49de                  	dw	df_tk_pixmode
dc71 : 49de                  	dw	df_tk_ink
dc73 : 49de                  	dw	df_tk_paper
dc75 : 56de                  	dw	df_tk_circle
dc77 : 49de                  	dw	df_tk_himem
dc79 : 47de                  	dw	df_tk_monitor
dc7b : 4dde                  	dw	df_tk_sprchar
dc7d : 56de                  	dw	df_tk_sprpos
dc7f : 47de                  	dw	df_tk_sprupd
dc81 : 47de                  	dw	df_tk_sprinit
dc83 : 4dde                  	dw	df_tk_sprmulti
dc85 : 56de                  	dw	df_tk_bsave
dc87 : 4dde                  	dw	df_tk_bload
dc89 : 49de                  	dw	df_tk_tsave
dc8b : 49de                  	dw	df_tk_tload
                             	
dc8d : 19de                  	dw	df_tk_peek
dc8f : 19de                  	dw	df_tk_deek
dc91 : 1cde                  	dw	df_tk_stick
dc93 : 19de                  	dw	df_tk_get
dc95 : 19de                  	dw	df_tk_chr
dc97 : 2dde                  	dw	df_tk_left
dc99 : 2dde                  	dw	df_tk_right
dc9b : 33de                  	dw	df_tk_mid
dc9d : 19de                  	dw	df_tk_len
dc9f : 19de                  	dw	df_tk_mem
dca1 : 2dde                  	dw	df_tk_scrn
dca3 : 19de                  	dw	df_tk_rnd
dca5 : 22de                  	dw	df_tk_elapsed
dca7 : 39de                  	dw	df_tk_call
dca9 : 19de                  	dw	df_tk_hex
dcab : 19de                  	dw	df_tk_asc
dcad : 19de                  	dw	df_tk_val
dcaf : 2dde                  	dw	df_tk_pixel
dcb1 : 19de                  	dw	df_tk_sprhit
                             	
dcb3 : 47de                  	dw	df_tk_mult
dcb5 : 47de                  	dw	df_tk_div
dcb7 : 47de                  	dw	df_tk_mod
dcb9 : 47de                  	dw	df_tk_asl
dcbb : 47de                  	dw	df_tk_lsr
dcbd : 47de                  	dw	df_tk_add
dcbf : 47de                  	dw	df_tk_sub
                             	
dcc1 : 47de                  	dw	df_tk_and
dcc3 : 47de                  	dw	df_tk_or
dcc5 : 47de                  	dw	df_tk_eor
dcc7 : 47de                  	dw	df_tk_lte
dcc9 : 47de                  	dw	df_tk_gte
dccb : 47de                  	dw	df_tk_ne
dccd : 47de                  	dw	df_tk_lt
dccf : 47de                  	dw	df_tk_gt
dcd1 : 47de                  	dw	df_tk_eq
                             
                             
                             	
                             	
                             	
                             	
                             	
AS65 Assembler for R6502 [1.42].                                     Page  156
-------------------------------- bank\bank0.s --------------------------------

                             	include "dflat\tktyptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser type table (is it a keyword, function
                             ; In token order of df_tokensyms
dcd3 :                       df_tk_tokentype
dcd3 : 01                    	db	DFTK_KW
dcd4 : 01                    	db	DFTK_KW
dcd5 : 01                    	db	DFTK_KW
dcd6 : 01                    	db	DFTK_KW
dcd7 : 01                    	db	DFTK_KW
dcd8 : 01                    	db	DFTK_KW
dcd9 : 01                    	db	DFTK_KW
dcda : 01                    	db	DFTK_KW
dcdb : 01                    	db	DFTK_KW
dcdc : 01                    	db	DFTK_KW
dcdd : 01                    	db	DFTK_KW
dcde : 01                    	db	DFTK_KW
dcdf : 01                    	db	DFTK_KW
dce0 : 01                    	db	DFTK_KW
dce1 : 01                    	db	DFTK_KW
dce2 : 01                    	db	DFTK_KW
dce3 : 01                    	db	DFTK_KW
dce4 : 01                    	db	DFTK_KW
dce5 : 01                    	db	DFTK_KW
dce6 : 01                    	db	DFTK_KW
dce7 : 01                    	db	DFTK_KW
dce8 : 01                    	db	DFTK_KW
dce9 : 01                    	db	DFTK_KW
dcea : 01                    	db	DFTK_KW
dceb : 01                    	db	DFTK_KW
dcec : 01                    	db	DFTK_KW
dced : 01                    	db	DFTK_KW
dcee : 01                    	db	DFTK_KW
dcef : 01                    	db	DFTK_KW
dcf0 : 01                    	db	DFTK_KW
dcf1 : 01                    	db	DFTK_KW
dcf2 : 01                    	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page  157
-------------------------------- bank\bank0.s --------------------------------

dcf3 : 01                    	db	DFTK_KW
dcf4 : 01                    	db	DFTK_KW
dcf5 : 01                    	db	DFTK_KW
dcf6 : 01                    	db	DFTK_KW
dcf7 : 01                    	db	DFTK_KW
dcf8 : 01                    	db	DFTK_KW
dcf9 : 01                    	db	DFTK_KW
dcfa : 01                    	db	DFTK_KW
dcfb : 01                    	db	DFTK_KW
dcfc : 01                    	db	DFTK_KW
dcfd : 01                    	db	DFTK_KW
dcfe : 01                    	db	DFTK_KW
dcff : 01                    	db	DFTK_KW
dd00 : 01                    	db	DFTK_KW
dd01 : 01                    	db	DFTK_KW
dd02 : 01                    	db	DFTK_KW
dd03 : 01                    	db	DFTK_KW
dd04 : 01                    	db	DFTK_KW
dd05 : 01                    	db	DFTK_KW
dd06 : 01                    	db	DFTK_KW
dd07 : 01                    	db	DFTK_KW
dd08 : 01                    	db	DFTK_KW
dd09 : 01                    	db	DFTK_KW
dd0a : 01                    	db	DFTK_KW
dd0b : 01                    	db	DFTK_KW
dd0c : 01                    	db	DFTK_KW
dd0d : 01                    	db	DFTK_KW
dd0e : 01                    	db	DFTK_KW
dd0f : 01                    	db	DFTK_KW
                             
dd10 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd11 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd12 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd13 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd14 : 42                    	db 	DFTK_FN | DFTK_STR
dd15 : 42                    	db 	DFTK_FN | DFTK_STR
dd16 : 42                    	db 	DFTK_FN | DFTK_STR
dd17 : 42                    	db 	DFTK_FN | DFTK_STR
dd18 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd19 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd1a : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd1b : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd1c : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd1d : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd1e : 42                    	db 	DFTK_FN | DFTK_STR
dd1f : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd20 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd21 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd22 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                             	;* Operators add the order of precedence (0=high
dd23 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd24 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd25 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd26 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
dd27 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
dd28 : 3e                    	db 	DFTK_OP | DFTK_STROP | DFTK_INT | DFTK_BYT +
dd29 : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
                             
dd2a : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd2b : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd2c : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd2d : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
AS65 Assembler for R6502 [1.42].                                     Page  158
-------------------------------- bank\bank0.s --------------------------------

dd2e : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd2f : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd30 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd31 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd32 : 3f                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                             
                             
                             	
                             	
                             	
                             	
                             
                             	include "dflat\toksubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKSUBS.S
                             ;*  Module that implements the tokenisation of ke
                             ;*  When a line is being parsed, the index of the
                             ;*  found in the symbol table is used to call a r
                             ;*  here.  The job of a routine here is then to f
                             ;*  parse the raw input e.g. a command that takes
                             ;*  parameters, need to do what it needs to ident
                             ;*  Despite the number of keywords in dflat, this
                             ;*  anywhere near the size of rtsubs.s (the runti
                             ;*  equivalent of this) because there is so much 
                             ;*  synactically.
                             ;*  The tokenised output is put in to its own buf
                             ;*  if the whole input was tokenised successfully
                             ;*  dflat will either try and execute (if in imme
                             ;*  mode), or save it to program memory in line n
                             ;*  order.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
dd33 :                       mod_sz_toksubs_s
                             
                             ;****************************************
                             ;* Parse assignment preamble
                             ;****************************************
dd33 :                       df_tk_preassign
                             	; Put assignment token
                             	; assume its a numeric int for now
dd33 : a980             [ 2] 	lda #0x80
dd35 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	
                             	; first find or create a variable
dd38 : a900             [ 2] 	lda #0	
dd3a : 20e5d7           [ 6] 	jsr df_tk_var
                             	; next char should be '='
dd3d : a93d             [ 2] 	lda #'='
dd3f : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; skip more ws
dd42 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
AS65 Assembler for R6502 [1.42].                                     Page  159
-------------------------------- bank\bank0.s --------------------------------

                             	; should not be at end of line
dd45 : 208ed6           [ 6] 	jsr df_tk_peek_buf
dd48 : f002             [ 3] 	beq df_tk_parse_ass_err
dd4a : 18               [ 2] 	clc
dd4b : 60               [ 6] 	rts
dd4c :                       df_tk_parse_ass_err
dd4c :                       df_tk_error
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric assignment
                             ;****************************************
dd4e :                       df_tk_assign
dd4e : 2033dd           [ 6] 	jsr df_tk_preassign
                             	; tokenise an expression (int or byte)
dd51 : 2027d9           [ 6] 	jsr df_tk_expression
dd54 : 18               [ 2] 	clc
dd55 : 60               [ 6] 	rts
                             
                             
dd56 :                       df_tk_comment
                             	; copy all subsequent chars to token
dd56 : 2094d6           [ 6] 	jsr df_tk_get_buf
dd59 : f006             [ 3] 	beq df_tk_comment_done
dd5b : 209fd6           [ 6] 	jsr df_tk_put_tok
dd5e : 4c56dd           [ 3] 	jmp df_tk_comment
dd61 :                       df_tk_comment_done
dd61 : 18               [ 2] 	clc
dd62 : 60               [ 6] 	rts
                             
                             ; Utility to get procedure name with _
dd63 :                       df_tk_listp_procname
                             	; try and find the first proc
dd63 : a95f             [ 2] 	lda #'_'
dd65 : 2028d7           [ 6] 	jsr df_tk_expect_tok
dd68 : b01b             [ 3] 	bcs df_tk_listp_procname_err
                             	; now get first alpha then all alphanum
dd6a : 208ed6           [ 6] 	jsr df_tk_peek_buf
dd6d : 20d2d6           [ 6] 	jsr df_tk_isalpha
dd70 : 9013             [ 3] 	bcc df_tk_listp_procname_err
dd72 :                       df_tk_listp_procname_ch
dd72 : 208ed6           [ 6] 	jsr df_tk_peek_buf
dd75 : 20e2d6           [ 6] 	jsr df_tk_isalphanum
dd78 : 9009             [ 3] 	bcc df_tk_listp_procname_ok
dd7a : 2094d6           [ 6] 	jsr df_tk_get_buf
dd7d : 209fd6           [ 6] 	jsr df_tk_put_tok
dd80 : 4c72dd           [ 3] 	jmp df_tk_listp_procname_ch
dd83 :                       df_tk_listp_procname_ok
dd83 : 18               [ 2] 	clc
dd84 : 60               [ 6] 	rts
dd85 :                       df_tk_listp_procname_err
dd85 : 38               [ 2] 	sec
dd86 : 60               [ 6] 	rts
                             
dd87 :                       df_tk_list
dd87 : 2063dd           [ 6] 	jsr df_tk_listp_procname
                             	; if not found try '*' or normal list
dd8a : b008             [ 3] 	bcs df_tk_list_procs
                             	; the '-' allows to list to end
dd8c : a92d             [ 2] 	lda #'-'
                             	; find and add if it exists
AS65 Assembler for R6502 [1.42].                                     Page  160
-------------------------------- bank\bank0.s --------------------------------

dd8e : 2028d7           [ 6] 	jsr df_tk_expect_tok
dd91 : 4ca8dd           [ 3] 	jmp df_tk_list_done
                             	; '*' means list procs
dd94 :                       df_tk_list_procs
                             	; try and find the first proc
dd94 : a92a             [ 2] 	lda #'*'
dd96 : 2028d7           [ 6] 	jsr df_tk_expect_tok
dd99 : 900d             [ 3] 	bcc df_tk_list_done
                             	; else normal line number
dd9b :                       df_tk_list_line
                             	; tokenise an expression
dd9b : 2027d9           [ 6] 	jsr df_tk_expression
                             	; if not at the end then keep going
dd9e : a92c             [ 2] 	lda #','
dda0 : 2028d7           [ 6] 	jsr df_tk_expect_tok
dda3 : b003             [ 3] 	bcs df_tk_list_done
                             	; else get the next expression
dda5 : 2027d9           [ 6] 	jsr df_tk_expression	
dda8 :                       df_tk_list_done
dda8 : 18               [ 2] 	clc
dda9 : 60               [ 6] 	rts
                             
ddaa :                       df_tk_printat
                             	; Must get 2 parms for x,y
ddaa : 204dde           [ 6] 	jsr df_tk_2parms
                             	; if not at the end then keep going
ddad : a92c             [ 2] 	lda #','
ddaf : 2028d7           [ 6] 	jsr df_tk_expect_tok
ddb2 : 9002             [ 3] 	bcc df_tk_print
                             	; else done
ddb4 : 18               [ 2] 	clc
ddb5 : 60               [ 6] 	rts
ddb6 :                       df_tk_data
ddb6 :                       df_tk_println
ddb6 :                       df_tk_print
ddb6 :                       df_tk_asm_db
ddb6 :                       df_tk_asm_dw
                             	; tokenise an expression
ddb6 : 2027d9           [ 6] 	jsr df_tk_expression
                             	; is there more to come?
ddb9 : a92c             [ 2] 	lda #','
ddbb : 2028d7           [ 6] 	jsr df_tk_expect_tok
ddbe : b002             [ 3] 	bcs df_tk_print_done
ddc0 : 90f4             [ 3] 	bcc df_tk_print
ddc2 :                       df_tk_print_done
ddc2 : 18               [ 2] 	clc
ddc3 : 60               [ 6] 	rts
                             
ddc4 :                       df_tk_input
ddc4 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
ddc7 : a900             [ 2] 	lda #0
ddc9 : 20e5d7           [ 6] 	jsr df_tk_var
                             	; either cc or cs depending on error condition
ddcc : 60               [ 6] 	rts
                             	
ddcd :                       df_tk_read
ddcd :                       df_tk_dim
ddcd : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
ddd0 : a900             [ 2] 	lda #0
ddd2 : 20e5d7           [ 6] 	jsr df_tk_var
AS65 Assembler for R6502 [1.42].                                     Page  161
-------------------------------- bank\bank0.s --------------------------------

                             	; if not at the end then keep going
ddd5 : a92c             [ 2] 	lda #','
ddd7 : 2028d7           [ 6] 	jsr df_tk_expect_tok
ddda : 90f1             [ 3] 	bcc df_tk_dim
dddc : 18               [ 2] 	clc
dddd : 60               [ 6] 	rts
                             
ddde :                       df_tk_local
ddde : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
dde1 : a900             [ 2] 	lda #0
dde3 : 2019d8           [ 6] 	jsr df_tk_localvar
                             	; if not at the end then keep going
dde6 : a92c             [ 2] 	lda #','
dde8 : 2028d7           [ 6] 	jsr df_tk_expect_tok
ddeb : 90f1             [ 3] 	bcc df_tk_local
dded : 18               [ 2] 	clc
ddee : 60               [ 6] 	rts
                             
                             ; A = 0 : Def
                             ; A = 1 : Call
ddef :                       df_tk_def
ddef : a900             [ 2] 	lda #0
ddf1 : 2031d8           [ 6] 	jsr df_tk_proc
ddf4 : 60               [ 6] 	rts
                             
                             
                             ; syntax : for a=1,10,1
ddf5 :                       df_tk_for
ddf5 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise the for variable
ddf8 : a901             [ 2] 	lda #DFVVT_INT
ddfa : 20e5d7           [ 6] 	jsr df_tk_var
                             
                             	; always expect '='
                             	; then starting value
ddfd : a93d             [ 2] 	lda #'='
ddff : 2031d9           [ 6] 	jsr df_tk_tok_expression
                             	
                             	; always expect ',' separator
                             	; then ending value
de02 : a92c             [ 2] 	lda #','
de04 : 2031d9           [ 6] 	jsr df_tk_tok_expression
                             
                             	; always expect ',' separator
                             	; then step value
de07 : a92c             [ 2] 	lda #','
de09 : 2031d9           [ 6] 	jsr df_tk_tok_expression
                             
de0c :                       df_tk_for_done
de0c : 18               [ 2] 	clc
de0d : 60               [ 6] 	rts
                             	
                             ; call to proc should not occur by itself
de0e :                       df_tk_callproc
de0e : 38               [ 2] 	sec
de0f : 60               [ 6] 	rts
                             
                             ; timer reset expects an int variable only
de10 :                       df_tk_reset
de10 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
AS65 Assembler for R6502 [1.42].                                     Page  162
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; tokenise a variable
de13 : a901             [ 2] 	lda #DFVVT_INT
de15 : 20e5d7           [ 6] 	jsr df_tk_var
de18 : 60               [ 6] 	rts
                             
                             ; These functions expect 1 parmeter
de19 :                       df_tk_len
de19 :                       df_tk_chr
de19 :                       df_tk_get
de19 :                       df_tk_deek
de19 :                       df_tk_vpeek
de19 :                       df_tk_peek
de19 :                       df_tk_mem
de19 :                       df_tk_rnd
de19 :                       df_tk_hex
de19 :                       df_tk_asc
de19 :                       df_tk_val
de19 :                       df_tk_sprhit
de19 : 2027d9           [ 6] 	jsr df_tk_expression
de1c :                       df_tk_closebrkt
de1c :                       df_tk_stick				; This function needs no parms
de1c : a929             [ 2] 	lda #')'
de1e : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
de21 : 60               [ 6] 	rts
                             
                             ; This function expects a variable only
de22 :                       df_tk_elapsed
de22 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
de25 : a901             [ 2] 	lda #DFVVT_INT
de27 : 20e5d7           [ 6] 	jsr df_tk_var
                             	; must have close braket
de2a : 4c1cde           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 2 parameters
de2d :                       df_tk_left
de2d :                       df_tk_right
de2d :                       df_tk_scrn
de2d :                       df_tk_pixel
de2d : 204dde           [ 6] 	jsr df_tk_2parms
de30 : 4c1cde           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 3 parameters
de33 :                       df_tk_mid
de33 : 2056de           [ 6] 	jsr df_tk_3parms
de36 : 4c1cde           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 4 parameters
de39 :                       df_tk_call
de39 : 204dde           [ 6] 	jsr df_tk_2parms
de3c : a92c             [ 2] 	lda #','
de3e : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
de41 : 204dde           [ 6] 	jsr df_tk_2parms
de44 : 4c1cde           [ 3] 	jmp df_tk_closebrkt
                             
                             ;all these commands require no parameters
de47 :                       df_tk_else
de47 :                       df_tk_endif
de47 :                       df_tk_enddef
de47 :                       df_tk_abort
AS65 Assembler for R6502 [1.42].                                     Page  163
-------------------------------- bank\bank0.s --------------------------------

de47 :                       df_tk_repeat
de47 :                       df_tk_next
de47 :                       df_tk_wend
de47 :                       df_tk_run
de47 :                       df_tk_dir
de47 :                       df_tk_cls
de47 :                       df_tk_new
de47 :                       df_tk_mult
de47 :                       df_tk_div
de47 :                       df_tk_mod
de47 :                       df_tk_asl
de47 :                       df_tk_lsr
de47 :                       df_tk_add
de47 :                       df_tk_sub
de47 :                       df_tk_and
de47 :                       df_tk_or
de47 :                       df_tk_eor
de47 :                       df_tk_lte
de47 :                       df_tk_lt
de47 :                       df_tk_gte
de47 :                       df_tk_gt
de47 :                       df_tk_ne
de47 :                       df_tk_eq
de47 :                       df_tk_monitor
de47 :                       df_tk_sprupd
de47 :                       df_tk_sprinit
de47 :                       df_tk_text
de47 :                       df_tk_hires
de47 : 18               [ 2] 	clc
de48 : 60               [ 6] 	rts
                             
                             ; These commands expect 1 parameter	
de49 :                       df_tk_while
de49 :                       df_tk_until
de49 :                       df_tk_if
de49 :                       df_tk_elseif
de49 :                       df_tk_wait
de49 :                       df_tk_cursor
de49 :                       df_tk_del
de49 :                       df_tk_chdir
de49 :                       df_tk_return
de49 :                       df_tk_load
de49 :                       df_tk_save
de49 :                       df_tk_tload
de49 :                       df_tk_tsave
de49 :                       df_tk_pixmode
de49 :                       df_tk_ink
de49 :                       df_tk_paper
de49 :                       df_tk_himem
                             
de49 :                       df_tk_asm_org
de49 :                       df_tk_asm_opt
de49 :                       df_tk_asm_ds
                             
                             	; first parm
de49 : 2027d9           [ 6] 	jsr df_tk_expression
de4c : 60               [ 6] 	rts
                             
                             ; These commands expect 2 numeric parameters
de4d :                       df_tk_setvdp
de4d :                       df_tk_poke
de4d :                       df_tk_doke
AS65 Assembler for R6502 [1.42].                                     Page  164
-------------------------------- bank\bank0.s --------------------------------

de4d :                       df_tk_point
de4d :                       df_tk_sprchar
de4d :                       df_tk_sprmulti
de4d :                       df_tk_bload
de4d :                       df_tk_2parms
                             	; first parm
de4d : 2027d9           [ 6] 	jsr df_tk_expression
                             	; tokenise second parm
de50 : a92c             [ 2] 	lda #','
de52 : 2031d9           [ 6] 	jsr df_tk_tok_expression
de55 : 60               [ 6] 	rts
                             
                             ; these commands expect 3 numeric parameters
de56 :                       df_tk_hchar
de56 :                       df_tk_plot
de56 :                       df_tk_circle
de56 :                       df_tk_sound
de56 :                       df_tk_colour
de56 :                       df_tk_spritepos
de56 :                       df_tk_renum
de56 :                       df_tk_sprpos
de56 :                       df_tk_bsave
de56 :                       df_tk_3parms
de56 : 204dde           [ 6] 	jsr df_tk_2parms
                             	; tokenise third parm
de59 : a92c             [ 2] 	lda #','
de5b : 2031d9           [ 6] 	jsr df_tk_tok_expression
de5e : 60               [ 6] 	rts
                             
                             ; these commands expect 4 numeric parameters
de5f :                       df_tk_play
de5f :                       df_tk_music
de5f :                       df_tk_line
de5f :                       df_tk_4parms
de5f : 204dde           [ 6] 	jsr df_tk_2parms
de62 : a92c             [ 2] 	lda #','
de64 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
de67 : 204dde           [ 6] 	jsr df_tk_2parms
de6a : 60               [ 6] 	rts
                             
de6b :                       mod_sz_toksubs_e
                             
                             
de6b :                       mod_sz_tokenise_e
                             
                             
                             
                             	include "dflat\progedit.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROGEDIT.S
                             ;*  dflat module to enable editing of a dflat pro
                             ;*  dflat bascially starts here - waiting for use
                             ;*  when a line is entered, if it is not preceede
                             ;*  line number it is tokenised and attempted to 
                             ;*  immediatly.  If it is preceeded by a line num
AS65 Assembler for R6502 [1.42].                                     Page  165
-------------------------------- bank\bank0.s --------------------------------

                             ;*  number is used to save the tokenised line in 
                             ;*  position in memory.
                             ;*  So this is just like a good old editing sessi
                             ;*  nearly any common flavour of 80s basic. Howev
                             ;*  tokenises everything except whitespace and st
                             ;*  constants - even when saving.  Unlike my trus
                             ;*  where I could type in any garbage and it woul
                             ;*  saved with the line number, dflat needs to be
                             ;*  tokenise the line.  So it's actually a bit mo
                             ;*  Atari 8 bit BASIC.
                             ;*
                             ;************************************************
                             
de6b :                       mod_sz_progedit_s
                             
                             ;****************************************
                             ;* df_pg_find_line
                             ;* Find a line number in X(L), A(H)
                             ;* Return X(L), A(H) of line, Y = Length
                             ;* C=1 Exact match not found, C=0 Exact Found
                             ;* If not exact match then next highest line addr
                             ;* Will be in X and A
                             ;****************************************
de6b :                       df_pg_find_line
de6b : 863b             [ 3] 	stx num_a
de6d : 853c             [ 3] 	sta num_a+1
de6f : a563             [ 3] 	lda df_prgstrt
de71 : 8547             [ 3] 	sta num_tmp
de73 : a564             [ 3] 	lda df_prgstrt+1
de75 : 8548             [ 3] 	sta num_tmp+1
de77 :                       df_pg_check_next_line
de77 : a547             [ 3] 	lda num_tmp
de79 : c565             [ 3] 	cmp df_prgend
de7b : d011             [ 3] 	bne df_pg_check_line
de7d : a548             [ 3] 	lda num_tmp+1
de7f : c566             [ 3] 	cmp df_prgend+1
de81 : d00b             [ 3] 	bne df_pg_check_line
de83 :                       df_pr_line_gt_target	
                             	; End of program or line > target
                             	; Load Y with the length
de83 : a200             [ 2] 	ldx #0
de85 : a147             [ 6] 	lda (num_tmp,x)
de87 : a8               [ 2] 	tay
de88 : a647             [ 3] 	ldx num_tmp
de8a : a548             [ 3] 	lda num_tmp+1
de8c : 38               [ 2] 	sec
de8d : 60               [ 6] 	rts
de8e :                       df_pg_check_line
de8e : a001             [ 2] 	ldy #DFTK_LINNUM
de90 : a53b             [ 3] 	lda num_a
de92 : d147             [ 5] 	cmp (num_tmp),y
de94 : d012             [ 3] 	bne df_pr_line_nomatch
de96 : c8               [ 2] 	iny
de97 : a53c             [ 3] 	lda num_a+1
de99 : d147             [ 5] 	cmp (num_tmp),y
de9b : d00b             [ 3] 	bne df_pr_line_nomatch
                             	; Got an exact match
de9d : a200             [ 2] 	ldx #0
de9f : a147             [ 6] 	lda (num_tmp,x)
dea1 : a8               [ 2] 	tay
dea2 : a647             [ 3] 	ldx num_tmp
dea4 : a548             [ 3] 	lda num_tmp+1
AS65 Assembler for R6502 [1.42].                                     Page  166
-------------------------------- bank\bank0.s --------------------------------

dea6 : 18               [ 2] 	clc
dea7 : 60               [ 6] 	rts
dea8 :                       df_pr_line_nomatch
                             	; Check if this line > target
dea8 : 38               [ 2] 	sec
dea9 : a001             [ 2] 	ldy #DFTK_LINNUM
deab : a53b             [ 3] 	lda num_a
dead : f147             [ 5] 	sbc (num_tmp),y
deaf : c8               [ 2] 	iny
deb0 : a53c             [ 3] 	lda num_a+1
deb2 : f147             [ 5] 	sbc (num_tmp),y
deb4 : 90cd             [ 3] 	bcc df_pr_line_gt_target
deb6 :                       df_pr_line_next
                             	; Else we go to next line
deb6 : a200             [ 2] 	ldx #0
deb8 : 18               [ 2] 	clc
deb9 : a547             [ 3] 	lda num_tmp
debb : 6147             [ 6] 	adc (num_tmp,x)
debd : 8547             [ 3] 	sta num_tmp
debf : a548             [ 3] 	lda num_tmp+1
dec1 : 6900             [ 2] 	adc #0
dec3 : 8548             [ 3] 	sta num_tmp+1
dec5 : 4c77de           [ 3] 	jmp df_pg_check_next_line
                             	
                             ;****************************************
                             ;* df_pg_insert_block
                             ;* Insert a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
dec8 :                       df_pg_insert_block
                             	; Inserting requires a block copy from
                             	; end of program space to the insert address
                             	
                             	; Save address as this is the lowest address
dec8 : 863b             [ 3] 	stx num_a
deca : 853c             [ 3] 	sta num_a+1
                             	; End of program space is the first byte to move
decc : a565             [ 3] 	lda df_prgend
dece : 8543             [ 3] 	sta num_x
ded0 : a566             [ 3] 	lda df_prgend+1
ded2 : 8544             [ 3] 	sta num_x+1	
ded4 :                       df_pg_insert_byte
                             	; Move a byte from the current top
ded4 : a200             [ 2] 	ldx #0
ded6 : a143             [ 6] 	lda (num_x,x)
                             	; To the new top (+Y)
ded8 : 9143             [ 5] 	sta (num_x),y
                             	; Compare current address with lowest
deda : a543             [ 3] 	lda num_x
dedc : c53b             [ 3] 	cmp num_a
dede : d014             [ 3] 	bne df_pg_insert_next_byte
dee0 : a544             [ 3] 	lda num_x+1
dee2 : c53c             [ 3] 	cmp num_a+1
dee4 : d00e             [ 3] 	bne df_pg_insert_next_byte
                             	; Finished, update program end pointer
dee6 : 18               [ 2] 	clc
dee7 : 98               [ 2] 	tya
dee8 : 6565             [ 3] 	adc df_prgend
deea : 8565             [ 3] 	sta df_prgend
deec : a566             [ 3] 	lda df_prgend+1
deee : 6900             [ 2] 	adc #0
AS65 Assembler for R6502 [1.42].                                     Page  167
-------------------------------- bank\bank0.s --------------------------------

def0 : 8566             [ 3] 	sta df_prgend+1
def2 : 18               [ 2] 	clc
def3 : 60               [ 6] 	rts
def4 :                       df_pg_insert_next_byte
                             	; Decrement current address
def4 : 38               [ 2] 	sec
def5 : a543             [ 3] 	lda num_x
def7 : e901             [ 2] 	sbc #1
def9 : 8543             [ 3] 	sta num_x
defb : a544             [ 3] 	lda num_x+1
defd : e900             [ 2] 	sbc #0
deff : 8544             [ 3] 	sta num_x+1
df01 : 4cd4de           [ 3] 	jmp df_pg_insert_byte
                             
                             ;****************************************
                             ;* df_pg_delete_block
                             ;* Delete a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
df04 :                       df_pg_delete_block
                             	; Deleting requires a block copy from
                             	; deletion address to end of program
                             	
                             	; Save address as this is the start address
df04 : 863b             [ 3] 	stx num_a
df06 : 853c             [ 3] 	sta num_a+1
df08 :                       df_pg_delete_byte
                             	; Move a byte from current+Y
df08 : b13b             [ 5] 	lda (num_a),y
                             	; Down to current
df0a : a200             [ 2] 	ldx #0
df0c : 813b             [ 6] 	sta (num_a,x)
                             	; Compare current address with lowest
df0e : a53b             [ 3] 	lda num_a
df10 : c565             [ 3] 	cmp df_prgend
df12 : d017             [ 3] 	bne df_pg_delete_next_byte
df14 : a53c             [ 3] 	lda num_a+1
df16 : c566             [ 3] 	cmp df_prgend+1
df18 : d011             [ 3] 	bne df_pg_delete_next_byte
                             	; Finished, update program end pointer
df1a : 843b             [ 3] 	sty num_a
df1c : 38               [ 2] 	sec
df1d : a565             [ 3] 	lda df_prgend
df1f : e53b             [ 3] 	sbc num_a
df21 : 8565             [ 3] 	sta df_prgend
df23 : a566             [ 3] 	lda df_prgend+1
df25 : e900             [ 2] 	sbc #0
df27 : 8566             [ 3] 	sta df_prgend+1
df29 : 18               [ 2] 	clc
df2a : 60               [ 6] 	rts
df2b :                       df_pg_delete_next_byte
                             	; Decrement current address
df2b : 18               [ 2] 	clc
df2c : a53b             [ 3] 	lda num_a
df2e : 6901             [ 2] 	adc #1
df30 : 853b             [ 3] 	sta num_a
df32 : a53c             [ 3] 	lda num_a+1
df34 : 6900             [ 2] 	adc #0
df36 : 853c             [ 3] 	sta num_a+1
df38 : 4c08df           [ 3] 	jmp df_pg_delete_byte
                             
AS65 Assembler for R6502 [1.42].                                     Page  168
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* Get a line of input
                             ;* Input: C=1 for echo, 0 for no echo
                             ;* Output: C=0 means linbuff is valid
                             ;****************************************
df3b :                       df_pg_inputline
                             	; C is set on input for echo or not
                             	; Read a line of input
df3b : 2060c4           [ 6] 	jsr io_read_line
                             	
                             	; If nothing entered then sec
df3e : c000             [ 2] 	cpy #0
df40 : d002             [ 3] 	bne df_pg_inputline_ok
df42 : 38               [ 2] 	sec
df43 : 60               [ 6] 	rts
df44 :                       df_pg_inputline_ok
                             	; Copy input bytes to line buffer
                             	; for lexical analysis
df44 :                       df_pg_copyinputtolinbuff
df44 : b137             [ 5] 	lda (buf_lo),y
df46 : 990004           [ 5] 	sta df_linbuff,y
df49 : 88               [ 2] 	dey
df4a : 10f8             [ 3] 	bpl df_pg_copyinputtolinbuff
df4c : 18               [ 2] 	clc
df4d : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_pg_dflat
                             ;* Start a dflat editing session
                             ;****************************************
df4e :                       df_pg_dflat
                             	; stack pointer
df4e : ba               [ 2] 	tsx
df4f : 865d             [ 3] 	stx df_sp
                             	; error handler address
df51 : a962             [ 2] 	lda #lo(df_trap_error)
df53 : 855e             [ 3] 	sta df_pc
df55 : a9f8             [ 2] 	lda #hi(df_trap_error)
df57 : 855f             [ 3] 	sta df_pc+1
                             	
                             	; make sure normal I/O is resumed
                             	;jsr io_init_default
df59 :                       df_pg_prompt
df59 : a2f2             [ 2] 	ldx #lo(df_pg_prompt_msg)
df5b : a9df             [ 2] 	lda #hi(df_pg_prompt_msg)
df5d : 2099c4           [ 6] 	jsr io_print_line
df60 : a900             [ 2] 	lda #0
df62 : 855c             [ 3] 	sta df_immed
df64 :                       df_pg_getcommand
                             	; current line is the token buffer when editing
df64 : a980             [ 2] 	lda #lo(df_tokbuff)
df66 : 8584             [ 3] 	sta df_currlin
df68 : a904             [ 2] 	lda #hi(df_tokbuff)
df6a : 8585             [ 3] 	sta df_currlin+1
df6c : 38               [ 2] 	sec
df6d : 203bdf           [ 6] 	jsr df_pg_inputline
df70 : b01b             [ 3] 	bcs df_pg_done
df72 : 208fdf           [ 6] 	jsr df_pg_tokenise
df75 : a55c             [ 3] 	lda df_immed
df77 : f0eb             [ 3] 	beq df_pg_getcommand
AS65 Assembler for R6502 [1.42].                                     Page  169
-------------------------------- bank\bank0.s --------------------------------

                             	; clear variables ready to run the statement
df79 : 20f9df           [ 6] 	jsr df_initrun
                             	; run from tokbuff
df7c : a280             [ 2] 	ldx #lo(df_tokbuff)
df7e : a904             [ 2] 	lda #hi(df_tokbuff)
                             	; always skip length and line number
df80 : a003             [ 2] 	ldy #3
df82 : 8486             [ 3] 	sty df_exeoff
                             	; init currlin
df84 : 20eee3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; start execution
df87 : 2003e4           [ 6] 	jsr df_rt_exec_stat
                             	; Go and get another line of input
df8a : 4c59df           [ 3] 	jmp df_pg_prompt
                             	; if blank line then return to cmd
df8d :                       df_pg_done
df8d : 18               [ 2] 	clc
df8e : 60               [ 6] 	rts
                             
                             	; tokenise the line
df8f :                       df_pg_tokenise
df8f : a900             [ 2] 	lda #0
df91 : 855b             [ 3] 	sta errno
df93 : 206cd9           [ 6] 	jsr df_lexer_line
                             	; check if line number == 0
df96 : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
df99 : d00f             [ 3] 	bne df_pg_line_number
df9b : ad8204           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
df9e : d00a             [ 3] 	bne df_pg_line_number
                             	; check if line empty
dfa0 : ad8004           [ 4] 	lda df_tokbuff
dfa3 : f004             [ 3] 	beq df_pg_nothing
                             	
                             	; line number == 0 so in immediate mode from tok
                             	; don't zero out the line length as some routine
                             	; run the line in immediate mode
dfa5 : a901             [ 2] 	lda #1
dfa7 : 855c             [ 3] 	sta df_immed
dfa9 :                       df_pg_nothing
dfa9 : 60               [ 6] 	rts
                             
                             	; put the numbered line in to the right bit of m
dfaa :                       df_pg_line_number
                             	; Check if this line exists
dfaa : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
dfad : aa               [ 2] 	tax
dfae : ad8204           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
dfb1 : 206bde           [ 6] 	jsr df_pg_find_line
                             	; Save line address for later X then A
dfb4 : 8536             [ 3] 	sta tmp_d
dfb6 : 8a               [ 2] 	txa
dfb7 : 48               [ 3] 	pha
dfb8 : a536             [ 3] 	lda tmp_d
dfba : 48               [ 3] 	pha
                             	; If line exists then it needs deleting
dfbb : b003             [ 3] 	bcs df_pg_skip_del_line
                             
                             	; delete line from program
dfbd : 2004df           [ 6] 	jsr df_pg_delete_block
dfc0 :                       df_pg_skip_del_line
                             	; If line length is zero
                             	; then nothing else to do (i.e. line was deleted
AS65 Assembler for R6502 [1.42].                                     Page  170
-------------------------------- bank\bank0.s --------------------------------

dfc0 : ad8004           [ 4] 	lda df_tokbuff+DFTK_LINLEN
                             	; save the tokenised line length
dfc3 : 48               [ 3] 	pha
dfc4 : d004             [ 3] 	bne df_pg_insertline
                             	; Length was zero, so get temp stuff off stack
dfc6 : 68               [ 4] 	pla
dfc7 : 68               [ 4] 	pla
dfc8 : 68               [ 4] 	pla
dfc9 : 60               [ 6] 	rts
                             
                             	; insert a program line unless it is immediate
dfca :                       df_pg_insertline
                             	; Restore previously saved length
dfca : 68               [ 4] 	pla
dfcb : a8               [ 2] 	tay
                             	; Restore previously saved address to reinsert t
dfcc : 68               [ 4] 	pla
dfcd : 8536             [ 3] 	sta tmp_d
dfcf : 68               [ 4] 	pla
dfd0 : aa               [ 2] 	tax
dfd1 : a536             [ 3] 	lda tmp_d
                             	; And save it all back to stack again A,X,Y
                             	_pushAXY
                             
                             	; We now have insert address and length
dfdc : 20c8de           [ 6] 	jsr df_pg_insert_block
                             	; Restore length and sub 1 to get index in to th
dfdf : 68               [ 4] 	pla
dfe0 : a8               [ 2] 	tay
dfe1 : 88               [ 2] 	dey
                             	; Restore address to a pointer, X is pulled firs
dfe2 : 68               [ 4] 	pla
dfe3 : aa               [ 2] 	tax
dfe4 : 863b             [ 3] 	stx num_a
dfe6 : 68               [ 4] 	pla
dfe7 : 853c             [ 3] 	sta num_a+1
                             	; num_a is destination, tokbuff is source, Y is 
dfe9 :                       df_pg_insertlinbyte
dfe9 : b98004           [ 4] 	lda df_tokbuff,y
dfec : 913b             [ 5] 	sta (num_a),y
dfee : 88               [ 2] 	dey
dfef : 10f8             [ 3] 	bpl df_pg_insertlinbyte
dff1 : 60               [ 6] 	rts
                             	
dff2 :                       df_pg_prompt_msg
dff2 : 52656164790d00        	db "Ready",UTF_CR,0
                             
dff9 :                       mod_sz_progedit_e
                             
                             	include "dflat\runtime.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RUNTIME.S
                             ;*  This module is the runtime coordinator.  When
                             ;*  wants to run a program, execution of statemen
                             ;*  required procedure starts and proceeds from t
AS65 Assembler for R6502 [1.42].                                     Page  171
-------------------------------- bank\bank0.s --------------------------------

                             ;*  according to normal program flow.
                             ;*  This module also contains critical routines f
                             ;*  evaluation of expressions (numeric and string
                             ;*  Whilst the code to implement a specific comma
                             ;*  rtsubs.s, this is the key module that control
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
dff9 :                       mod_sz_runtime_s
                             
                             ;****************************************
                             ;* df_initrun
                             ;* Initialise program space for runtime
                             ;****************************************
dff9 :                       df_initrun
                             	; Set the key mask to check every 32 instruction
dff9 : a920             [ 2] 	lda #0x20
dffb : 855a             [ 3] 	sta df_checkmsk
                             	
                             	; String and array heap initialisation
                             	; Grows up from end of prog space PLUS 1
                             	; Initially empty (dim will allocate)
                             	_cpyZPWord df_prgend,df_starstrt
                             
                             	_incZPWord df_starstrt
                             
                             	_cpyZPWord df_starstrt,df_starend
                             
                             	
e013 : a2ff             [ 2] 	ldx #0xff
                             	; Reset runtime stack (grows down)
e015 : 8674             [ 3] 	stx df_rtstop
                             	; make X=0
e017 : e8               [ 2] 	inx
                             	; Reset parameter stack (grows up)
e018 : 8675             [ 3] 	stx df_parmtop
                             	; Reset data pointer high byte
e01a : 8693             [ 3] 	stx df_currdat+1
                             	; if nest counter zeroed
e01c : 8691             [ 3] 	stx df_ifnest
                             	
                             	; clear proc addresses
e01e : 2022e0           [ 6] 	jsr df_rt_init_vvt
                             
                             ;	clc
e021 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Initialise vvt
                             ;****************************************
e022 :                       df_rt_init_vvt
                             	; starting at beginning of vvt
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
e02a : a200             [ 2] 	ldx #0
e02c :                       df_rt_init_vvt_slot
e02c : a59f             [ 3] 	lda df_tmpptra
e02e : c56b             [ 3] 	cmp df_vvtstrt
e030 : d006             [ 3] 	bne df_rt_init_vvt_slot_undim
AS65 Assembler for R6502 [1.42].                                     Page  172
-------------------------------- bank\bank0.s --------------------------------

e032 : a5a0             [ 3] 	lda df_tmpptra+1
e034 : c56c             [ 3] 	cmp df_vvtstrt+1
e036 : f02d             [ 3] 	beq df_rt_init_done
e038 :                       df_rt_init_vvt_slot_undim
                             	; Only zero out proc and array pointers
                             	; Scalar variables are not initialised
e038 : a000             [ 2] 	ldy #0
e03a : b19f             [ 5] 	lda (df_tmpptra),y
e03c : 29c0             [ 2] 	and #DFVVT_PROC|DFVVT_ARRY
e03e : f016             [ 3] 	beq df_rt_init_vvt_skip
                             	; skip over the first byte which is variable typ
e040 : c8               [ 2] 	iny
                             	; zero out first 3 bytes for proc and arrays
e041 : a900             [ 2] 	lda #0
e043 : 919f             [ 5] 	sta (df_tmpptra),y
e045 : c8               [ 2] 	iny
e046 : 919f             [ 5] 	sta (df_tmpptra),y
e048 : c8               [ 2] 	iny
e049 : 919f             [ 5] 	sta (df_tmpptra),y
e04b : c8               [ 2] 	iny
                             	; before doing dim2 check if proc
                             	; as we don't want to erase the parm count
e04c : a19f             [ 6] 	lda (df_tmpptra,x)
e04e : 2940             [ 2] 	and #DFVVT_PROC
e050 : d004             [ 3] 	bne df_rt_init_vvt_skip
                             	; if not proc then zero dim2
e052 : a900             [ 2] 	lda #0
e054 : 919f             [ 5] 	sta (df_tmpptra),y	
e056 :                       df_rt_init_vvt_skip
                             	; increment pointer to next slot
                             	_adcZPWord df_tmpptra,8
                             
e063 : 90c7             [ 3] 	bcc df_rt_init_vvt_slot 	; Always branches
e065 :                       df_rt_init_done
e065 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* pop  X,A result from operator stack
                             ;****************************************
e066 :                       df_rt_getnval
                             	; evaluate the expression
e066 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; get X,A off operator stack
e069 : 4c42f7           [ 3] 	jmp df_ost_popInt
                             
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* Push result to operator stack
                             ;****************************************
e06c :                       df_rt_neval
                             	; push terminator on cpu stack
                             	; so we know where we are
e06c : a900             [ 2] 	lda #0
e06e : 48               [ 3] 	pha
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword token push on to operator stack
e06f :                       df_rt_neval_optk
e06f : a486             [ 3] 	ldy df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  173
-------------------------------- bank\bank0.s --------------------------------

                             	; check end of line
                             
e071 : c47c             [ 3] 	cpy df_eolidx
e073 : f03c             [ 3] 	beq df_rt_neval_process
e075 : c47d             [ 3] 	cpy df_nxtstidx
e077 : f038             [ 3] 	beq df_rt_neval_process
e079 : b184             [ 5] 	lda (df_currlin),y
e07b : 3022             [ 3] 	bmi df_rt_neval_tk
e07d : c920             [ 2] 	cmp #DFTK_ESCVAL
e07f : 9018             [ 3] 	bcc df_rt_neval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ']'
e081 : c92c             [ 2] 	cmp #','
e083 : f02c             [ 3] 	beq df_rt_neval_process
e085 : c95d             [ 2] 	cmp #']'
e087 : f028             [ 3] 	beq df_rt_neval_process
                             	; check for brackets
                             	; if close bracket then process
e089 : c929             [ 2] 	cmp #')'
e08b : f024             [ 3] 	beq df_rt_neval_process
                             	; if bracket then evaluate expression recursivel
e08d : c928             [ 2] 	cmp #'('
e08f : d05e             [ 3] 	bne df_rt_neval_nextbyte
                             	; move past open bracket
e091 : e686             [ 5] 	inc df_exeoff
                             	; call evaluation function recursively
e093 : 206ce0           [ 6] 	jsr df_rt_neval
e096 : 4cefe0           [ 3] 	jmp df_rt_neval_nextbyte
e099 :                       df_rt_neval_esc
e099 : 20f4e0           [ 6] 	jsr df_rt_eval_esc
e09c : 4cefe0           [ 3] 	jmp df_rt_neval_nextbyte
                             	; if a token then push on operator stack
e09f :                       df_rt_neval_tk
e09f : 297f             [ 2] 	and #0x7f
                             	; check if op (look up type using X as index)
                             	; X contains the current operator index
                             	
e0a1 : aa               [ 2] 	tax
e0a2 : bdd3dc           [ 4] 	lda df_tk_tokentype,x
                             	; A contains token type
e0a5 : 48               [ 3] 	pha
e0a6 : 2908             [ 2] 	and #DFTK_OP
e0a8 : d011             [ 3] 	bne df_rt_neval_tk_opp
                             	; check if fn
e0aa : 68               [ 4] 	pla
e0ab : 2902             [ 2] 	and #DFTK_FN
e0ad : d03b             [ 3] 	bne df_rt_neval_tk_fn
                             
                             	; If got here then something wrong
                             	SWBRK DFERR_OK
                             
                             
e0b1 :                       df_rt_neval_process	
                             	; pop operator off stack and execute
                             	; keep popping until reached the terminator
e0b1 : 68               [ 4] 	pla
e0b2 : f006             [ 3] 	beq df_rt_neval_done
                             	; run the token code
e0b4 : 2073e4           [ 6] 	jsr df_rt_run_token
                             	; top two bytes on ost stack is the result
e0b7 : 4cb1e0           [ 3] 	jmp df_rt_neval_process
e0ba :                       df_rt_neval_done
AS65 Assembler for R6502 [1.42].                                     Page  174
-------------------------------- bank\bank0.s --------------------------------

e0ba : 60               [ 6] 	rts
                             
e0bb :                       df_rt_neval_tk_opp
e0bb : 68               [ 4] 	pla				; Get A off stack which is the type
e0bc :                       df_rt_neval_tk_op
                             	; X=Op, A=Type
                             	; if this op < current top of op stack
                             	; then do the op as it is higher priority so sho
                             	; not be pushed
                             	; what is top of the op stack?
                             	; save current op token value
                             	; C=0 means process the op now, else don't
                             	; save current operator index
e0bc : 869f             [ 3] 	stx df_tmpptra
                             	; mask off to keep priority
e0be : 2907             [ 2] 	and #DFTK_OPMSK
e0c0 : 85a1             [ 3] 	sta df_tmpptrb
                             	; peek top of op stack - pull and push X
e0c2 : 68               [ 4] 	pla
e0c3 : 48               [ 3] 	pha
e0c4 : aa               [ 2] 	tax
                             	; if 0 then nothing so push op
e0c5 : f01d             [ 3] 	beq df_rt_neval_pushOp
                             	; use it to index in to type table
e0c7 : bdd3dc           [ 4] 	lda df_tk_tokentype,x
                             	; mask off to keep priority
e0ca : 2907             [ 2] 	and #DFTK_OPMSK
                             	; compare with the saved token type which includ
e0cc : c5a1             [ 3] 	cmp df_tmpptrb
                             	; if top of stack >= current then C=1
                             	; else C=0
                             	; what is the state of C?
                             	; if 1 then just pushOp
e0ce : f002             [ 3] 	beq df_rt_neval_donow
e0d0 : b012             [ 3] 	bcs df_rt_neval_pushOp
e0d2 :                       df_rt_neval_donow
                             	; was C=0 so process now before pushing the new 
                             	; get operator off cpu stack
e0d2 : 68               [ 4] 	pla
e0d3 : a8               [ 2] 	tay		; Save whilst need to push other things
                             	; save the current op on cpu stack
e0d4 : a59f             [ 3] 	lda df_tmpptra
e0d6 : 48               [ 3] 	pha
e0d7 : aa               [ 2] 	tax		; X = current op
e0d8 : 98               [ 2] 	tya		; Get A back from Y (new op)
                             	; now run the token in A that came off the stack
e0d9 : 2073e4           [ 6] 	jsr df_rt_run_token
                             	; get current op off cpu stack in to X
e0dc : 68               [ 4] 	pla
e0dd : aa               [ 2] 	tax
                             	; get the token type in to A
e0de : bdd3dc           [ 4] 	lda df_tk_tokentype,x
                             	; now go back around again to check whether to p
e0e1 : 4cbce0           [ 3] 	jmp df_rt_neval_tk_op
e0e4 :                       df_rt_neval_pushOp
                             	; push the operator
e0e4 : a59f             [ 3] 	lda df_tmpptra
e0e6 : 48               [ 3] 	pha
e0e7 : 4cefe0           [ 3] 	jmp df_rt_neval_nextbyte
                             
e0ea :                       df_rt_neval_tk_fn
e0ea : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  175
-------------------------------- bank\bank0.s --------------------------------

e0eb : 8a               [ 2] 	txa
                             	; run a fn token - returns a value on stack
e0ec : 2073e4           [ 6] 	jsr df_rt_run_token
                             	; move to next byte
e0ef :                       df_rt_neval_nextbyte
e0ef : e686             [ 5] 	inc df_exeoff
e0f1 : 4c6fe0           [ 3] 	jmp df_rt_neval_optk
                             	; keep going until non-ws char found or end of l
                             
                             
                             	
                             ; jump to escape evaluation routine
e0f4 :                       df_rt_eval_esc
e0f4 : 0a               [ 2] 	asl a
e0f5 : aa               [ 2] 	tax
e0f6 : bd03e1           [ 4] 	lda df_rt_eval_esc_tab,x
e0f9 : 859f             [ 3] 	sta df_tmpptra
e0fb : bd04e1           [ 4] 	lda df_rt_eval_esc_tab+1,x
e0fe : 85a0             [ 3] 	sta df_tmpptra+1
e100 : 6c9f00           [ 6] 	jmp (df_tmpptra)
                             	
e103 :                       df_rt_eval_esc_tab
e103 : c8e1                  	dw df_rt_eval_chr
e105 : d4e1                  	dw df_rt_eval_reserved
e107 : d4e1                  	dw df_rt_eval_reserved
e109 : d4e1                  	dw df_rt_eval_reserved
e10b : d4e1                  	dw df_rt_eval_reserved	
e10d : d4e1                  	dw df_rt_eval_reserved	; no such thing as bytdec
e10f : c8e1                  	dw df_rt_eval_bythex
e111 : c8e1                  	dw df_rt_eval_bytbin
e113 : d4e1                  	dw df_rt_eval_reserved	
e115 : c8e1                  	dw df_rt_eval_intdec
e117 : c8e1                  	dw df_rt_eval_inthex
e119 : c8e1                  	dw df_rt_eval_intbin
e11b : d4e1                  	dw df_rt_eval_reserved
e11d : d4e1                  	dw df_rt_eval_reserved
e11f : d4e1                  	dw df_rt_eval_reserved
e121 : d4e1                  	dw df_rt_eval_reserved	
e123 : d6e1                  	dw df_rt_eval_strlit
e125 : 1fe2                  	dw df_rt_eval_var
e127 : 1de3                  	dw df_rt_eval_proc
                             
                             
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination is string accumulator
                             ;****************************************
e129 :                       df_rt_seval
e129 : a678             [ 3] 	ldx df_sevalptr
e12b : a579             [ 3] 	lda df_sevalptr+1
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination buffer / space
                             ;****************************************
e12d :                       df_rt_sval
                             	; keep X,A on the stack - will be modified
e12d : 8536             [ 3] 	sta tmp_d
e12f : 48               [ 3] 	pha
e130 : 8a               [ 2] 	txa
e131 : 48               [ 3] 	pha
e132 : a536             [ 3] 	lda tmp_d
                             	; push original destination
AS65 Assembler for R6502 [1.42].                                     Page  176
-------------------------------- bank\bank0.s --------------------------------

e134 : 2017f7           [ 6] 	jsr df_ost_pushStr	
                             	; Push the destination to the 6502 stack
                             	; hi byte first then lo
                             	; push string idx so we know our starting positi
                             	; in the string buffer
                             	; this limits all evaluations to 255 bytes
                             ;	lda df_stridx
                             ;	jsr df_st_pushOp
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword operator token push on to operator 
                             	; if keyword function token run it
                             
e137 :                       df_rt_seval_optk
e137 : a486             [ 3] 	ldy df_exeoff
                             	; check end of line
e139 : c47c             [ 3] 	cpy df_eolidx
e13b : f06e             [ 3] 	beq df_rt_seval_done
e13d : c47d             [ 3] 	cpy df_nxtstidx
e13f : f06a             [ 3] 	beq df_rt_seval_done
                             
e141 : b184             [ 5] 	lda (df_currlin),y
e143 : 301c             [ 3] 	bmi df_rt_seval_tk
                             
e145 : c920             [ 2] 	cmp #DFTK_ESCVAL
e147 : 900a             [ 3] 	bcc df_rt_seval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ')'
e149 : c92c             [ 2] 	cmp #','
e14b : f05e             [ 3] 	beq df_rt_seval_done
e14d : c929             [ 2] 	cmp #')'
e14f : f05a             [ 3] 	beq df_rt_seval_done
e151 : d053             [ 3] 	bne df_rt_seval_nextbyte
e153 :                       df_rt_seval_esc
                             	; the only escape char is STRLIT, VAR or PROC
e153 : c910             [ 2] 	cmp #DFTK_STRLIT
e155 : f047             [ 3] 	beq	df_rt_seval_esc_strlit
e157 : c911             [ 2] 	cmp #DFTK_VAR
e159 : f026             [ 3] 	beq	df_rt_seval_esc_var
e15b : c912             [ 2] 	cmp #DFTK_PROC
e15d : f045             [ 3] 	beq	df_rt_seval_esc_proc
                             
                             	; error if got here
                             	SWBRK DFERR_SYNTAX
                             
                             
                             	; if a token then push on operator stack
e161 :                       df_rt_seval_tk
e161 : 8486             [ 3] 	sty df_exeoff
e163 : 297f             [ 2] 	and #0x7f
                             	; check if op
e165 : aa               [ 2] 	tax
e166 : bdd3dc           [ 4] 	lda df_tk_tokentype,x
e169 : 2904             [ 2] 	and #DFTK_STROP
e16b : d009             [ 3] 	bne df_rt_seval_tk_op
                             	; check if fn
e16d : bdd3dc           [ 4] 	lda df_tk_tokentype,x
e170 : 2902             [ 2] 	and #DFTK_FN
e172 : d006             [ 3] 	bne df_rt_seval_tk_fn	
                             	
                             	; token type mismatch if got here
AS65 Assembler for R6502 [1.42].                                     Page  177
-------------------------------- bank\bank0.s --------------------------------

                             	SWBRK DFERR_TYPEMISM
                             
                             
e176 :                       df_rt_seval_tk_op
                             	; the only op is $+
                             	; so just ignore!
e176 : 8a               [ 2] 	txa
e177 : 4ca6e1           [ 3] 	jmp df_rt_seval_nextbyte
                             
e17a :                       df_rt_seval_tk_fn
e17a : 8a               [ 2] 	txa
e17b : 2073e4           [ 6] 	jsr df_rt_run_token
e17e : 4c85e1           [ 3] 	jmp df_rt_seval_copy
                             
e181 :                       df_rt_seval_esc_var
                             	; go process the variable as a normal RVAL
e181 : 18               [ 2] 	clc
e182 : 201fe2           [ 6] 	jsr df_rt_eval_var
                             	; copy source off rt stack to destination
e185 :                       df_rt_seval_copy
                             	; pull destination pointer
e185 : 68               [ 4] 	pla
e186 : 859f             [ 3] 	sta df_tmpptra
e188 : 68               [ 4] 	pla
e189 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; pop source string pointer off stack
e18b : 2047f7           [ 6] 	jsr df_ost_popStr
e18e : 86a1             [ 3] 	stx df_tmpptrb
e190 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; go and copy the string
e192 : 20afe1           [ 6] 	jsr df_rt_copyStr
                             	; now save the destination
e195 : a5a0             [ 3] 	lda df_tmpptra+1
e197 : 48               [ 3] 	pha
e198 : a59f             [ 3] 	lda df_tmpptra
e19a : 48               [ 3] 	pha
                             	
e19b : 4ca6e1           [ 3] 	jmp df_rt_seval_nextbyte
                             	
e19e :                       df_rt_seval_esc_strlit
                             	; evaluate string literal
e19e : 20d6e1           [ 6] 	jsr df_rt_eval_strlit
e1a1 : 4c85e1           [ 3] 	jmp df_rt_seval_copy
                             	
e1a4 :                       df_rt_seval_esc_proc
                             	; not yet suported *******
                             	SWBRK DFERR_OK
                             
                             	
e1a6 :                       df_rt_seval_nextbyte
e1a6 : e686             [ 5] 	inc df_exeoff
e1a8 : 4c37e1           [ 3] 	jmp df_rt_seval_optk
                             	; keep going until non-ws char found or end of l
e1ab :                       df_rt_seval_done
                             	; 
e1ab : 68               [ 4] 	pla
e1ac : 68               [ 4] 	pla
                             	
e1ad : 18               [ 2] 	clc
e1ae : 60               [ 6] 	rts
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  178
-------------------------------- bank\bank0.s --------------------------------

                             ; Copy string from ptrb to ptra
e1af :                       df_rt_copyStr
e1af : a000             [ 2] 	ldy #0
e1b1 :                       df_rt_copyStr_ch
e1b1 : b1a1             [ 5] 	lda (df_tmpptrb),y
e1b3 : 919f             [ 5] 	sta (df_tmpptra),y
e1b5 : f003             [ 3] 	beq df_rt_copyStr_done
e1b7 : c8               [ 2] 	iny
e1b8 : d0f7             [ 3] 	bne df_rt_copyStr_ch	; Always relying in Y never
e1ba :                       df_rt_copyStr_done
e1ba : 98               [ 2] 	tya
e1bb : 18               [ 2] 	clc
e1bc : 659f             [ 3] 	adc df_tmpptra
e1be : 859f             [ 3] 	sta df_tmpptra
e1c0 : a5a0             [ 3] 	lda df_tmpptra+1
e1c2 : 6900             [ 2] 	adc #0
e1c4 : 85a0             [ 3] 	sta df_tmpptra+1
e1c6 : 18               [ 2] 	clc
e1c7 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Evaluate and push numeric value
                             ;****************************************
e1c8 :                       df_rt_eval_intdec
e1c8 :                       df_rt_eval_bytdec
e1c8 :                       df_rt_eval_inthex
e1c8 :                       df_rt_eval_bythex
e1c8 :                       df_rt_eval_intbin
e1c8 :                       df_rt_eval_bytbin
e1c8 :                       df_rt_eval_chr
                             	; numeric constant
e1c8 : c8               [ 2] 	iny
e1c9 : b184             [ 5] 	lda (df_currlin),y
e1cb : aa               [ 2] 	tax
e1cc : c8               [ 2] 	iny
e1cd : b184             [ 5] 	lda (df_currlin),y
                             	; save offset before calling any routine
e1cf : 8486             [ 3] 	sty df_exeoff
                             	; push number on to stack
e1d1 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
e1d4 :                       df_rt_eval_reserved
                             	; should not get here
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* Evaluate and push string constant
                             ;****************************************
e1d6 :                       df_rt_eval_strlit
e1d6 : 8486             [ 3] 	sty df_exeoff
                             	; calculate the effective address
                             	; y + currlin
e1d8 : 98               [ 2] 	tya
                             	; set carry to add one extra
e1d9 : 38               [ 2] 	sec
e1da : 6584             [ 3] 	adc df_currlin
e1dc : 859f             [ 3] 	sta df_tmpptra
e1de : aa               [ 2] 	tax
e1df : a585             [ 3] 	lda df_currlin+1
e1e1 : 6900             [ 2] 	adc #0
e1e3 : 85a0             [ 3] 	sta df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  179
-------------------------------- bank\bank0.s --------------------------------

                             	
                             	; push string on to stack
e1e5 : 2017f7           [ 6] 	jsr df_ost_pushStr
                             	; now proceed until end of string found
e1e8 : a486             [ 3] 	ldy df_exeoff
e1ea :                       df_rt_eval_strlit_ch
e1ea : b184             [ 5] 	lda (df_currlin),y
e1ec : f003             [ 3] 	beq df_rt_eval_strlit_done
e1ee : c8               [ 2] 	iny
e1ef : d0f9             [ 3] 	bne df_rt_eval_strlit_ch
e1f1 :                       df_rt_eval_strlit_done	; Always relying on Y neve
e1f1 : 8486             [ 3] 	sty df_exeoff
e1f3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return array parameter
                             ;* A has parm
                             ;****************************************
e1f4 :                       df_rt_arry_parm
                             	; move past open bracket or comma
e1f4 : e686             [ 5] 	inc df_exeoff
                             	; evaluate expression inside bracket
e1f6 : 2066e0           [ 6] 	jsr df_rt_getnval
e1f9 : 8a               [ 2] 	txa
                             ;	clc
e1fa : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Return double array parameter
                             ;* X = dim1, Y = dim2
                             ;****************************************
e1fb :                       df_rt_arry_parm2
                             	; go get array parm 1
e1fb : 20f4e1           [ 6] 	jsr df_rt_arry_parm
e1fe : 48               [ 3] 	pha
e1ff : a200             [ 2] 	ldx #0
e201 : a486             [ 3] 	ldy df_exeoff
e203 :                       df_rt_arry_parm2_term
e203 : b184             [ 5] 	lda (df_currlin),y
e205 : c95d             [ 2] 	cmp #']'
e207 : f011             [ 3] 	beq df_rt_arry_parm2_skiparry2
e209 : c92c             [ 2] 	cmp #','
e20b : f006             [ 3] 	beq df_rt_arry_parm2_arry2
e20d : 8486             [ 3] 	sty df_exeoff
e20f : c8               [ 2] 	iny
e210 : 4c03e2           [ 3] 	jmp df_rt_arry_parm2_term
e213 :                       df_rt_arry_parm2_arry2
                             	; get second dimension and put in Y
e213 : 20f4e1           [ 6] 	jsr df_rt_arry_parm
e216 : a8               [ 2] 	tay
e217 : 68               [ 4] 	pla
e218 : aa               [ 2] 	tax
                             ;	clc
e219 : 60               [ 6] 	rts
e21a :                       df_rt_arry_parm2_skiparry2
e21a : a000             [ 2] 	ldy #0
e21c : 68               [ 4] 	pla
e21d : aa               [ 2] 	tax
                             ;	clc
e21e : 60               [ 6] 	rts
                             
                             	
AS65 Assembler for R6502 [1.42].                                     Page  180
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* Evaluate and push variable
                             ;* The actual value is pushed if numeric
                             ;* The pointer is pushed if string
                             ;* Carry Set = LVAR else normal RVAR
                             ;* LVAR : Y = line index, A=vvt type, tmpptra = v
                             ;****************************************
e21f :                       df_rt_eval_var
                             	; save carry bit
e21f : 08               [ 3] 	php
                             	; if lvar mode then already passed escape token
e220 : b010             [ 3] 	bcs df_rt_eval_lvskip
                             	; move past var escape token
e222 : c8               [ 2] 	iny
                             	; get var vvt address
e223 : b184             [ 5] 	lda (df_currlin),y
e225 : 859f             [ 3] 	sta df_tmpptra
e227 : c8               [ 2] 	iny
e228 : 8486             [ 3] 	sty df_exeoff
e22a : b184             [ 5] 	lda (df_currlin),y
e22c : 85a0             [ 3] 	sta df_tmpptra+1
                             	; push vvt type first as this is the last thing 
e22e : a200             [ 2] 	ldx #0
e230 : a19f             [ 6] 	lda (df_tmpptra,x)
e232 :                       df_rt_eval_lvskip
e232 : 48               [ 3] 	pha
                             	; Test A
e233 : aa               [ 2] 	tax
                             	; simple variable
e234 : 1012             [ 3] 	bpl df_rt_eval_var_notarry
                             	; even if an array if no dimensions then return 
                             	; if at end of statement or line then simple cop
e236 : c47c             [ 3] 	cpy df_eolidx
e238 : f02b             [ 3] 	beq df_rt_eval_var_simple
e23a : c47d             [ 3] 	cpy df_nxtstidx
e23c : f027             [ 3] 	beq df_rt_eval_var_simple
                             	; if next ch is not [ then simple copy
e23e : c8               [ 2] 	iny
e23f : b184             [ 5] 	lda (df_currlin),y
e241 : 88               [ 2] 	dey
e242 : c95b             [ 2] 	cmp #'['
e244 : d01f             [ 3] 	bne df_rt_eval_var_simple
                             	; go do array handling
e246 : f02b             [ 3] 	beq df_rt_eval_var_do_arry
e248 :                       df_rt_eval_var_notarry
                             	; pull the type, not needed here
e248 : 68               [ 4] 	pla
                             	; pull C and check if lvar wanted rather than rv
e249 : 28               [ 4] 	plp
e24a : b00c             [ 3] 	bcs df_rt_eval_lvar
                             	; just push the vvt lo,hi value
e24c : a001             [ 2] 	ldy #DFVVT_LO
e24e : b19f             [ 5] 	lda (df_tmpptra),y
e250 : aa               [ 2] 	tax
e251 : a002             [ 2] 	ldy #DFVVT_HI
e253 : b19f             [ 5] 	lda (df_tmpptra),y
                             
e255 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
e258 :                       df_rt_eval_lvar
                             	; it's not an array, push the address of DFVVT_L
                             	; add DFVVT_LO offset to slot address in X,A
AS65 Assembler for R6502 [1.42].                                     Page  181
-------------------------------- bank\bank0.s --------------------------------

e258 : 18               [ 2] 	clc
e259 : a901             [ 2] 	lda #DFVVT_LO
e25b : 659f             [ 3] 	adc df_tmpptra
e25d : aa               [ 2] 	tax
e25e : a5a0             [ 3] 	lda df_tmpptra+1
e260 : 6900             [ 2] 	adc #0
                             
                             	; push pointer to lo,hi
e262 : 4c1cf7           [ 3] 	jmp df_ost_pushPtr
                             	
e265 :                       df_rt_eval_var_simple
                             	; clean up stack
e265 : 68               [ 4] 	pla
e266 : 68               [ 4] 	pla
                             	; simply get lo,hi and push ptr on stack
e267 : a001             [ 2] 	ldy #DFVVT_LO
e269 : b19f             [ 5] 	lda (df_tmpptra),y
e26b : aa               [ 2] 	tax
e26c : a002             [ 2] 	ldy #DFVVT_HI
e26e : b19f             [ 5] 	lda (df_tmpptra),y
e270 : 4c1cf7           [ 3] 	jmp df_ost_pushPtr
                             	
e273 :                       df_rt_eval_var_do_arry
                             	; move past var index
e273 : e686             [ 5] 	inc df_exeoff
                             	; zero out x,y as they have dimension info
e275 : a200             [ 2] 	ldx #0
e277 : a000             [ 2] 	ldy #0
                             	
                             	; ** Array handling routine **
                             	; A on stack = type
                             	; save vvt address
e279 : a5a0             [ 3] 	lda df_tmpptra+1
e27b : 48               [ 3] 	pha
e27c : a59f             [ 3] 	lda df_tmpptra
e27e : 48               [ 3] 	pha
                             	
                             	; get array parms in X,Y
e27f : 20fbe1           [ 6] 	jsr df_rt_arry_parm2
                             	; restore vvt address
e282 : 68               [ 4] 	pla
e283 : 859f             [ 3] 	sta df_tmpptra
e285 : 68               [ 4] 	pla
e286 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; save dimension indices for later
                             	; save x last as needed first
                             	; A ok to trample
e288 : 98               [ 2] 	tya
e289 : 48               [ 3] 	pha
e28a : 8a               [ 2] 	txa
e28b : 48               [ 3] 	pha
                             	; if y is zero then need to decide some stuff
e28c : c000             [ 2] 	cpy #0
e28e : d012             [ 3] 	bne df_rt_eval_var_dim2adj
                             	; if dim2 > 0 then swap x,y
e290 : a004             [ 2] 	ldy #DFVVT_DIM2
e292 : b19f             [ 5] 	lda (df_tmpptra),y
e294 : a000             [ 2] 	ldy #0
e296 : c900             [ 2] 	cmp #0
e298 : f008             [ 3] 	beq df_rt_eval_var_dim2adj
                             	; pop from stack in swapped order
e29a : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  182
-------------------------------- bank\bank0.s --------------------------------

e29b : a8               [ 2] 	tay
e29c : 68               [ 4] 	pla
e29d : aa               [ 2] 	tax
                             	; save back on stack, A ok to trample
e29e : 98               [ 2] 	tya
e29f : 48               [ 3] 	pha
e2a0 : 8a               [ 2] 	txa
e2a1 : 48               [ 3] 	pha
                             	
e2a2 :                       df_rt_eval_var_dim2adj
                             	; don't let y=0
e2a2 : c000             [ 2] 	cpy #0
e2a4 : d001             [ 3] 	bne df_rt_eval_var_dim2adjy
e2a6 : c8               [ 2] 	iny
e2a7 :                       df_rt_eval_var_dim2adjy
                             	; don't let x=0
e2a7 : e000             [ 2] 	cpx #0
e2a9 : d001             [ 3] 	bne df_rt_eval_var_dim2adjx
e2ab : e8               [ 2] 	inx
e2ac :                       df_rt_eval_var_dim2adjx
                             	;calculate offset
                             	;(y-1)*dim1 + (x-1)
e2ac : ca               [ 2] 	dex
e2ad : 88               [ 2] 	dey
                             	; (y-1)
e2ae : 843b             [ 3] 	sty num_a
e2b0 : a900             [ 2] 	lda #0
e2b2 : 853c             [ 3] 	sta num_a+1
                             	; if y is 0 then no need to multiply
e2b4 : c000             [ 2] 	cpy #0
e2b6 : f00d             [ 3] 	beq df_rt_eval_var_nomult
                             	; (dim1)
e2b8 : a003             [ 2] 	ldy #DFVVT_DIM1
e2ba : a900             [ 2] 	lda #0
e2bc : 8540             [ 3] 	sta num_b+1
e2be : b19f             [ 5] 	lda (df_tmpptra),y
e2c0 : 853f             [ 3] 	sta num_b
                             	; (y-1)*dim1 num_a has result
e2c2 : 202bd4           [ 6] 	jsr int_fast_mult
e2c5 :                       df_rt_eval_var_nomult
                             	; move x to a
e2c5 : 8a               [ 2] 	txa
                             	; add x to num_a
e2c6 : 18               [ 2] 	clc
e2c7 : 653b             [ 3] 	adc num_a
e2c9 : 853b             [ 3] 	sta num_a
e2cb : a53c             [ 3] 	lda num_a+1
e2cd : 6900             [ 2] 	adc #0
e2cf : 853c             [ 3] 	sta num_a+1
                             	; now have element offset in num_a
                             	; dimensions in x and y
e2d1 : 68               [ 4] 	pla
e2d2 : aa               [ 2] 	tax
e2d3 : 68               [ 4] 	pla
e2d4 : a8               [ 2] 	tay
                             	; get type of variable originally found
e2d5 : 68               [ 4] 	pla
e2d6 : 48               [ 3] 	pha
e2d7 : 2901             [ 2] 	and #DFVVT_INT
e2d9 : f004             [ 3] 	beq df_rt_eval_var_push
                             	; if it is int then multiply offset by 2
e2db : 063b             [ 5] 	asl num_a
AS65 Assembler for R6502 [1.42].                                     Page  183
-------------------------------- bank\bank0.s --------------------------------

e2dd : 263c             [ 5] 	rol num_a+1
e2df :                       df_rt_eval_var_push
                             	; add pointer in lo,hi to num_a
e2df : 18               [ 2] 	clc
e2e0 : a001             [ 2] 	ldy #DFVVT_LO
e2e2 : b19f             [ 5] 	lda (df_tmpptra),y
e2e4 : 653b             [ 3] 	adc num_a
e2e6 : 853b             [ 3] 	sta num_a
e2e8 : a002             [ 2] 	ldy #DFVVT_HI
e2ea : b19f             [ 5] 	lda (df_tmpptra),y
e2ec : d002             [ 3] 	bne df_rt_array_exists
                             	; if vvt address hi is zero then array not dimen
                             	SWBRK DFERR_DIM
                             
e2f0 :                       df_rt_array_exists
e2f0 : 653c             [ 3] 	adc num_a+1
e2f2 : 853c             [ 3] 	sta num_a+1	
                             	; get the type
e2f4 : 68               [ 4] 	pla
                             	; if not int or byte then push string
e2f5 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
e2f7 : f01c             [ 4] 	beq df_rt_eval_var_str
                             	; get LVAR preference
e2f9 : 28               [ 4] 	plp
e2fa : b01a             [ 4] 	bcs df_rt_eval_ptr
                             	; need to load lo and hi for int
                             	; but only lo for byt
e2fc : 2901             [ 2] 	and #DFVVT_INT
e2fe : f00b             [ 4] 	beq df_rt_eval_byt
                             	; push the contents pointed to by num_a
e300 : a000             [ 2] 	ldy #0
e302 : b13b             [ 5] 	lda (num_a),y
e304 : aa               [ 2] 	tax
e305 : c8               [ 2] 	iny
e306 : b13b             [ 5] 	lda (num_a),y
e308 : 4c0af7           [ 3] 	jmp df_ost_pushInt
e30b :                       df_rt_eval_byt
e30b : a000             [ 2] 	ldy #0
e30d : b13b             [ 5] 	lda (num_a),y
e30f : aa               [ 2] 	tax
e310 : a900             [ 2] 	lda #0
e312 : 4c0af7           [ 3] 	jmp df_ost_pushInt
e315 :                       df_rt_eval_var_str
e315 : 28               [ 4] 	plp
e316 :                       df_rt_eval_ptr
                             ;	clc
                             	; put num_a not contents
e316 : a63b             [ 3] 	ldx num_a
e318 : a53c             [ 3] 	lda num_a+1
e31a : 4c1cf7           [ 3] 	jmp df_ost_pushPtr
                             	
e31d :                       df_rt_eval_proc
e31d : a575             [ 3] 	lda df_parmtop				; Save current position of par
e31f : 48               [ 3] 	pha
e320 : 209ef5           [ 6] 	jsr df_rt_proc				; Go and call the user functio
e323 : 68               [ 4] 	pla							; Get back the original parameter stac
e324 : c575             [ 3] 	cmp df_parmtop				; if it is the same, then no r
e326 : f002             [ 3] 	beq df_rt_eval_proc_err
e328 : 18               [ 2] 	clc
e329 : 60               [ 6] 	rts
e32a :                       df_rt_eval_proc_err
                             	; if no return value then report an errror
AS65 Assembler for R6502 [1.42].                                     Page  184
-------------------------------- bank\bank0.s --------------------------------

                             	SWBRK DFERR_RETURN
                             
                             
                             
                             
                             ;****************************************
                             ;* get two ints off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
e32c :                       df_rt_get2Ints
                             	; the first int popped is actually the second pa
e32c : 2042f7           [ 6] 	jsr df_ost_popInt
e32f : 86a1             [ 3] 	stx df_tmpptrb
e331 : 85a2             [ 3] 	sta df_tmpptrb+1
                             
e333 : 2042f7           [ 6] 	jsr df_ost_popInt
e336 : 869f             [ 3] 	stx df_tmpptra
e338 : 85a0             [ 3] 	sta df_tmpptra+1
e33a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* get two strings off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
e33b :                       df_rt_get2Strs
                             	; the first int popped is actually the second pa
e33b : 2047f7           [ 6] 	jsr df_ost_popStr
e33e : 86a1             [ 3] 	stx df_tmpptrb
e340 : 85a2             [ 3] 	sta df_tmpptrb+1
                             
e342 : 2047f7           [ 6] 	jsr df_ost_popStr
e345 : 869f             [ 3] 	stx df_tmpptra
e347 : 85a0             [ 3] 	sta df_tmpptra+1
e349 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 2 ints runtime parsing
                             ;****************************************
e34a :                       df_rt_parm_2ints
                             	; evaluate 1st parm
e34a : 206ce0           [ 6] 	jsr df_rt_neval
                             	; jump over comma
e34d : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e34f : 206ce0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 2nd parm
e352 : 2042f7           [ 6] 	jsr df_ost_popInt
e355 : 86a1             [ 3] 	stx df_tmpptrb
e357 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
e359 : 2042f7           [ 6] 	jsr df_ost_popInt
e35c : 869f             [ 3] 	stx df_tmpptra
e35e : 85a0             [ 3] 	sta df_tmpptra+1
e360 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 3 ints runtime parsing
                             ;****************************************
e361 :                       df_rt_parm_3ints
                             	; evaluate 1st parm
e361 : 206ce0           [ 6] 	jsr df_rt_neval
AS65 Assembler for R6502 [1.42].                                     Page  185
-------------------------------- bank\bank0.s --------------------------------

e364 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e366 : 206ce0           [ 6] 	jsr df_rt_neval
e369 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e36b : 206ce0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 3rd parm
e36e : 2042f7           [ 6] 	jsr df_ost_popInt
e371 : 86a3             [ 3] 	stx df_tmpptrc
e373 : 85a4             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
e375 : 2042f7           [ 6] 	jsr df_ost_popInt
e378 : 86a1             [ 3] 	stx df_tmpptrb
e37a : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
e37c : 2042f7           [ 6] 	jsr df_ost_popInt
e37f : 869f             [ 3] 	stx df_tmpptra
e381 : 85a0             [ 3] 	sta df_tmpptra+1
e383 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 4 ints runtime parsing
                             ;****************************************
e384 :                       df_rt_parm_4ints
                             	; evaluate 1st parm
e384 : 206ce0           [ 6] 	jsr df_rt_neval
e387 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e389 : 206ce0           [ 6] 	jsr df_rt_neval
e38c : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e38e : 206ce0           [ 6] 	jsr df_rt_neval
e391 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
e393 : 206ce0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 4th parm
e396 : 2042f7           [ 6] 	jsr df_ost_popInt
e399 : 86a5             [ 3] 	stx df_tmpptrd
e39b : 85a6             [ 3] 	sta df_tmpptrd+1
                             	; pop 3rd parm
e39d : 2042f7           [ 6] 	jsr df_ost_popInt
e3a0 : 86a3             [ 3] 	stx df_tmpptrc
e3a2 : 85a4             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
e3a4 : 2042f7           [ 6] 	jsr df_ost_popInt
e3a7 : 86a1             [ 3] 	stx df_tmpptrb
e3a9 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
e3ab : 2042f7           [ 6] 	jsr df_ost_popInt
e3ae : 869f             [ 3] 	stx df_tmpptra
e3b0 : 85a0             [ 3] 	sta df_tmpptra+1
e3b2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 5 ints runtime parsing
                             ;****************************************
e3b3 :                       df_rt_parm_5ints
                             	; evaluate 1st parm
e3b3 : 206ce0           [ 6] 	jsr df_rt_neval
e3b6 : e686             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  186
-------------------------------- bank\bank0.s --------------------------------

                             	; evaluate the 2nd parm
e3b8 : 206ce0           [ 6] 	jsr df_rt_neval
e3bb : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e3bd : 206ce0           [ 6] 	jsr df_rt_neval
e3c0 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
e3c2 : 206ce0           [ 6] 	jsr df_rt_neval
e3c5 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 5th parm
e3c7 : 206ce0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 5th parm
e3ca : 2042f7           [ 6] 	jsr df_ost_popInt
e3cd : 86a7             [ 3] 	stx df_tmpptre
e3cf : 85a8             [ 3] 	sta df_tmpptre+1
                             	; pop 4th parm
e3d1 : 2042f7           [ 6] 	jsr df_ost_popInt
e3d4 : 86a5             [ 3] 	stx df_tmpptrd
e3d6 : 85a6             [ 3] 	sta df_tmpptrd+1
                             	; pop 3rd parm
e3d8 : 2042f7           [ 6] 	jsr df_ost_popInt
e3db : 86a3             [ 3] 	stx df_tmpptrc
e3dd : 85a4             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd parm
e3df : 2042f7           [ 6] 	jsr df_ost_popInt
e3e2 : 86a1             [ 3] 	stx df_tmpptrb
e3e4 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; pop 1st parm
e3e6 : 2042f7           [ 6] 	jsr df_ost_popInt
e3e9 : 869f             [ 3] 	stx df_tmpptra
e3eb : 85a0             [ 3] 	sta df_tmpptra+1
                             
e3ed : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* initialise statement to be executed
                             ;* X,A = line pointer, Y=statement offset
                             ;****************************************
e3ee :                       df_rt_init_stat_ptr
                             	; save current line
e3ee : 8684             [ 3] 	stx df_currlin
e3f0 : 8585             [ 3] 	sta df_currlin+1
e3f2 : 847e             [ 3] 	sty df_curstidx
e3f4 : 8486             [ 3] 	sty df_exeoff
e3f6 : a000             [ 2] 	ldy #0
e3f8 : b184             [ 5] 	lda (df_currlin),y
e3fa : 857c             [ 3] 	sta df_eolidx
e3fc : a47e             [ 3] 	ldy df_curstidx
e3fe : b184             [ 5] 	lda (df_currlin),y
e400 : 857d             [ 3] 	sta df_nxtstidx
e402 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Execute from a statement pointed to
                             ;* by currlin and exeoff
                             ;****************************************
e403 :                       df_rt_exec_stat
e403 : a684             [ 3] 	ldx df_currlin
e405 : a585             [ 3] 	lda df_currlin+1
e407 : a486             [ 3] 	ldy df_exeoff
e409 :                       df_rt_exec_init_ptr
AS65 Assembler for R6502 [1.42].                                     Page  187
-------------------------------- bank\bank0.s --------------------------------

e409 : 20eee3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; assume normal flow of control if next line hi 
                             	; this means no line can execute below page 1, n
e40c : a900             [ 2] 	lda #0
e40e : 8588             [ 3] 	sta df_nextlin+1
                             
                             	; find first token in statement
e410 :                       df_rt_exec_find_tok
e410 : c8               [ 2] 	iny
e411 : b184             [ 5] 	lda (df_currlin),y
e413 : 10fb             [ 3] 	bpl df_rt_exec_find_tok
e415 :                       df_rt_exec_found_tok
                             	; skip past token to next byte in readiness
e415 : c8               [ 2] 	iny
e416 : 8486             [ 3] 	sty df_exeoff
                             	; save the token
e418 : 48               [ 3] 	pha
                             	; Run that statement
e419 : 2073e4           [ 6] 	jsr df_rt_run_token
                             	; what token was run, if it was enddef or return
e41c : 68               [ 4] 	pla
e41d : c987             [ 2] 	cmp #DFRT_ENDDEF
e41f : f041             [ 3] 	beq df_rt_exec_end
e421 : c988             [ 2] 	cmp #DFRT_RETURN
e423 : f03d             [ 3] 	beq df_rt_exec_end
                             	
                             	; check for break, asynch get
e425 : e659             [ 5] 	inc df_checkkey					; Don't check every time els
e427 : a55a             [ 3] 	lda df_checkmsk					; Check the mask (normally 0
e429 : 2559             [ 3] 	and df_checkkey
e42b : f00e             [ 3] 	beq df_rt_exec_no_key
e42d : 18               [ 2] 	clc
e42e : 2048c4           [ 6] 	jsr io_get_ch
e431 : b008             [ 3] 	bcs df_rt_exec_no_key
e433 : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
e435 : f02d             [ 3] 	beq df_rt_exec_ctrl_c
e437 : c91a             [ 2] 	cmp #UTF_BRK					; CTRK-Z?
e439 : f02d             [ 3] 	beq df_rt_exec_ctrl_z
e43b :                       df_rt_exec_no_key
                             	; check if normal flow of control
e43b : a588             [ 3] 	lda df_nextlin+1
e43d : d02b             [ 3] 	bne df_rt_exec_jump
                             	; try and execute another statement
e43f : a47d             [ 3] 	ldy df_nxtstidx
e441 : 8486             [ 3] 	sty df_exeoff
e443 : d0be             [ 3] 	bne df_rt_exec_stat
                             
                             	; reached end of line, move to next
e445 : a200             [ 2] 	ldx #0
e447 : 18               [ 2] 	clc
e448 : a184             [ 6] 	lda (df_currlin,x)
e44a : 6584             [ 3] 	adc df_currlin
e44c : 8584             [ 3] 	sta df_currlin
e44e : a585             [ 3] 	lda df_currlin+1
e450 : 6900             [ 2] 	adc #0
e452 : 8585             [ 3] 	sta df_currlin+1
                             	
                             	; start from first statement in new line
e454 : a003             [ 2] 	ldy #3
e456 : 8486             [ 3] 	sty df_exeoff
                             
                             	; check if this line has any content (length >0)
AS65 Assembler for R6502 [1.42].                                     Page  188
-------------------------------- bank\bank0.s --------------------------------

e458 : a184             [ 6] 	lda (df_currlin,x)
e45a : 857c             [ 3] 	sta df_eolidx
                             	; no more lines (len = 0), program done
e45c : d0a5             [ 3] 	bne df_rt_exec_stat
                             	; else done
                             	; normally wouldn't get here except immediate mo
                             	; if line number <> 0 then error
e45e : a55c             [ 3] 	lda df_immed
e460 : f004             [ 3] 	beq df_rt_unexpected_end
e462 :                       df_rt_exec_end
e462 : 18               [ 2] 	clc
e463 : 60               [ 6] 	rts
e464 :                       df_rt_exec_ctrl_c
                             	SWBRK DFERR_BREAK
                             
e466 :                       df_rt_unexpected_end
                             	SWBRK DFERR_IMMEDIATE
                             
e468 :                       df_rt_exec_ctrl_z
                             	; Force a break with zero error number
                             	; this will drop in to the monitor
e468 : 0000                  	db 0,0
                             
                             	; if hi byte of nextline is not zero then
                             	; current line = next line
e46a :                       df_rt_exec_jump
                             	; initialise statement pointer from nextlin,toks
e46a : a687             [ 3] 	ldx df_nextlin
e46c : a588             [ 3] 	lda df_nextlin+1
e46e : a47d             [ 3] 	ldy df_nxtstidx
e470 : 4c09e4           [ 3] 	jmp df_rt_exec_init_ptr
                             
                             	
                             ;****************************************
                             ;* Run statement in A
                             ;****************************************
e473 :                       df_rt_run_token
                             	; mask off MSB
                             ;	and #0x7f
                             	; multiply by 2
e473 : 0a               [ 2] 	asl a
e474 : aa               [ 2] 	tax
e475 : bd60e5           [ 4] 	lda df_rt_tokenjmp,x
e478 : 859f             [ 3] 	sta df_tmpptra
e47a : bd61e5           [ 4] 	lda df_rt_tokenjmp+1,x
e47d : 85a0             [ 3] 	sta df_tmpptra+1
                             	; execution code finishes with rts
e47f : 6c9f00           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* X,A : Line Address, Y = Index
                             ;* C=0 Found next statement
                             ;* C=1 No statement found
                             ;****************************************
e482 :                       df_rt_nextstat
                             	; save pointer
e482 : 868e             [ 3] 	stx df_lineptr
e484 : 858f             [ 3] 	sta df_lineptr+1
                             	; if end of program then err
e486 : a200             [ 2] 	ldx #0
e488 : a18e             [ 6] 	lda (df_lineptr,x)
AS65 Assembler for R6502 [1.42].                                     Page  189
-------------------------------- bank\bank0.s --------------------------------

e48a : f01c             [ 3] 	beq df_rt_nextstat_err
                             	; if next statement idx 0
e48c : b18e             [ 5] 	lda (df_lineptr),y
                             	; then go to next line
e48e : f007             [ 3] 	beq df_rt_nextstat_ln
                             	; else make this Y
e490 : a8               [ 2] 	tay
                             	; X = line low
e491 : a68e             [ 3] 	ldx df_lineptr
                             	; A = line high
e493 : a58f             [ 3] 	lda df_lineptr+1
e495 : 18               [ 2] 	clc
e496 : 60               [ 6] 	rts
e497 :                       df_rt_nextstat_ln
                             	; for next line, add line length to ptr
e497 : 18               [ 2] 	clc
e498 : a18e             [ 6] 	lda (df_lineptr,x)
e49a : 658e             [ 3] 	adc df_lineptr
e49c : 858e             [ 3] 	sta df_lineptr
e49e : a58f             [ 3] 	lda df_lineptr+1
e4a0 : 6900             [ 2] 	adc #0
e4a2 : 858f             [ 3] 	sta df_lineptr+1
                             	; if end of program set C
e4a4 : a18e             [ 6] 	lda (df_lineptr,x)
e4a6 : d004             [ 3] 	bne df_rt_nextstat_dn
e4a8 :                       df_rt_nextstat_err
e4a8 : a000             [ 2] 	ldy #0
e4aa : 38               [ 2] 	sec
e4ab : 60               [ 6] 	rts
e4ac :                       df_rt_nextstat_dn
e4ac : a68e             [ 3] 	ldx df_lineptr
e4ae : a58f             [ 3] 	lda df_lineptr+1
                             	; always skip line number and length for start o
e4b0 : a003             [ 2] 	ldy #3
e4b2 : 18               [ 2] 	clc
e4b3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push current line and statement to runtime sta
                             ;****************************************
e4b4 :                       df_rt_push_stat
e4b4 : a57e             [ 3] 	lda df_curstidx
e4b6 : 20c0f6           [ 6] 	jsr df_rst_pushByte
e4b9 : a585             [ 3] 	lda df_currlin+1
e4bb : a684             [ 3] 	ldx df_currlin
e4bd : 4cd8f6           [ 3] 	jmp df_rst_pushWord
                             ;	clc
                             ;	rts
                             
                             ;****************************************
                             ;* Pop line and statement from runtime stack
                             ;* And transfer control to next statement
                             ;****************************************
e4c0 :                       df_rt_pop_stat
e4c0 : 20e6f6           [ 6] 	jsr df_rst_popWord
e4c3 : 8687             [ 3] 	stx	df_nextlin
e4c5 : 8588             [ 3] 	sta df_nextlin+1
e4c7 : 20c9f6           [ 6] 	jsr df_rst_popByte
e4ca : a8               [ 2] 	tay
e4cb : a687             [ 3] 	ldx df_nextlin
e4cd : a588             [ 3] 	lda df_nextlin+1
e4cf : 2082e4           [ 6] 	jsr df_rt_nextstat
AS65 Assembler for R6502 [1.42].                                     Page  190
-------------------------------- bank\bank0.s --------------------------------

e4d2 : 8687             [ 3] 	stx df_nextlin
e4d4 : 8588             [ 3] 	sta df_nextlin+1
e4d6 : 847d             [ 3] 	sty df_nxtstidx
                             ;	clc
e4d8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find proc definition in procptr
                             ;* Only call if proc not found before
                             ;****************************************
e4d9 :                       df_rt_findproc
                             	; start at program beginning
                             	_cpyZPWord df_prgstrt,df_lineptr
                             
e4e1 : a003             [ 2] 	ldy #3
e4e3 : 8490             [ 3] 	sty df_lineidx
e4e5 : a200             [ 2] 	ldx #0
e4e7 : a18e             [ 6] 	lda (df_lineptr,x)
e4e9 : f034             [ 4] 	beq df_rt_findproc_err
e4eb :                       df_rt_findproc_cmd
e4eb : c8               [ 2] 	iny
e4ec : b18e             [ 5] 	lda (df_lineptr),y
e4ee : 10fb             [ 3] 	bpl df_rt_findproc_cmd
e4f0 : c986             [ 2] 	cmp #DFRT_DEF
e4f2 : d017             [ 4] 	bne df_rt_findproc_nextstat
                             	; skip def token
e4f4 : c8               [ 2] 	iny
                             	; skip proc escape token
e4f5 : c8               [ 2] 	iny
                             	; now check the proc address against procptr
e4f6 : b18e             [ 5] 	lda (df_lineptr),y
e4f8 : c58c             [ 3] 	cmp df_procptr
e4fa : d00f             [ 4] 	bne df_rt_findproc_nextstat
e4fc : c8               [ 2] 	iny
e4fd : b18e             [ 5] 	lda (df_lineptr),y
e4ff : c58d             [ 3] 	cmp df_procptr+1
e501 : d008             [ 3] 	bne df_rt_findproc_nextstat
                             	
                             	; found it, return AXY with line details
e503 : a68e             [ 3] 	ldx df_lineptr
e505 : a58f             [ 3] 	lda df_lineptr+1
e507 : a490             [ 3] 	ldy df_lineidx
e509 : 18               [ 2] 	clc
e50a : 60               [ 6] 	rts
e50b :                       df_rt_findproc_nextstat
                             	; restore AXY line details and find next stateme
e50b : a68e             [ 3] 	ldx df_lineptr
e50d : a58f             [ 3] 	lda df_lineptr+1
e50f : a490             [ 3] 	ldy df_lineidx
e511 : 2082e4           [ 6] 	jsr df_rt_nextstat
e514 : b009             [ 3] 	bcs df_rt_findproc_err
e516 : 868e             [ 3] 	stx df_lineptr
e518 : 858f             [ 3] 	sta df_lineptr+1
e51a : 8490             [ 3] 	sty df_lineidx
e51c : 4cebe4           [ 3] 	jmp df_rt_findproc_cmd
                             	; error
e51f :                       df_rt_findproc_err
                             	SWBRK DFERR_NOPROC
                             
                             	
                             ;****************************************
                             ;* Find an escape value
AS65 Assembler for R6502 [1.42].                                     Page  191
-------------------------------- bank\bank0.s --------------------------------

                             ;* Does not check for end of line or statement
                             ;****************************************
e521 :                       df_rt_findescval
e521 : a486             [ 3] 	ldy df_exeoff
e523 : 88               [ 2] 	dey
e524 :                       df_rt_findescval_loop
e524 : c8               [ 2] 	iny
e525 : b184             [ 5] 	lda (df_currlin),y
e527 : c920             [ 2] 	cmp #DFTK_ESCVAL
e529 : b0f9             [ 3] 	bcs df_rt_findescval_loop
e52b : 8486             [ 3] 	sty df_exeoff
e52d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Skip white space
                             ;* Does not check for end of line or statement
                             ;* A contains non-ws char, df_exeoff updated
                             ;****************************************
e52e :                       df_rt_skip_ws
e52e : a486             [ 3] 	ldy df_exeoff
e530 : 88               [ 2] 	dey
e531 :                       df_rt_skip_ws_loop
e531 : c8               [ 2] 	iny
e532 : b184             [ 5] 	lda (df_currlin),y
e534 : c920             [ 2] 	cmp #' '
e536 : f0f9             [ 3] 	beq df_rt_skip_ws_loop
e538 : 8486             [ 3] 	sty df_exeoff
e53a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Get an lvar
                             ;* Assumes next token will be escape DFTK_VAR
                             ;* tmpptra contains vvt slot address
                             ;* X,A is the lvar pointer
                             ;****************************************
e53b :                       df_rt_getlvar
e53b : 2021e5           [ 6] 	jsr df_rt_findescval
                             	; move past the escape value
e53e : c8               [ 2] 	iny
                             
                             	; get variable address
e53f : b184             [ 5] 	lda (df_currlin),y
e541 : 859f             [ 3] 	sta df_tmpptra
e543 : c8               [ 2] 	iny
e544 : b184             [ 5] 	lda (df_currlin),y
e546 : 85a0             [ 3] 	sta df_tmpptra+1	
                             	
e548 : 8486             [ 3] 	sty df_exeoff
                             	; get the type
e54a : a000             [ 2] 	ldy #0
e54c : b19f             [ 5] 	lda (df_tmpptra),y
                             	; set carry flag to return pointer (lvar)
e54e : 38               [ 2] 	sec
e54f : a486             [ 3] 	ldy df_exeoff
e551 : 201fe2           [ 6] 	jsr df_rt_eval_var
e554 : 4c4cf7           [ 3] 	jmp df_ost_popPtr
                             ;	rts
                             
                             ;****************************************
                             ;* Pop stat from rt stack and continue
                             ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HE
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  192
-------------------------------- bank\bank0.s --------------------------------

e557 :                       df_rt_pop_stat_go
e557 : 20c0e4           [ 6] 	jsr df_rt_pop_stat
                             	; restore stack pointer so we don't lose this en
e55a : 68               [ 4] 	pla
e55b : a8               [ 2] 	tay
e55c : 8474             [ 3] 	sty df_rtstop
e55e : 18               [ 2] 	clc
e55f : 60               [ 6] 	rts
                             
                             	include "dflat\rtjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime token an
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
e560 :                       df_rt_tokenjmp
e560 : 5ded                  	dw	df_rt_assign
e562 : 9ef5                  	dw	df_rt_proc
e564 : 6eed                  	dw	df_rt_comment
e566 : 15ed                  	dw	df_rt_println
e568 : d2ec                  	dw	df_rt_printat
e56a : dcec                  	dw	df_rt_print
e56c : f7f5                  	dw	df_rt_def			; 0x86
e56e : 79f6                  	dw	df_rt_enddef		; 0x87
e570 : 7ef6                  	dw	df_rt_return		; 0x88
e572 : 16f5                  	dw	df_rt_abort			; 0x89
e574 : 28eb                  	dw	df_rt_local
e576 : 58eb                  	dw	df_rt_dim
e578 : ebe9                  	dw	df_rt_repeat		; 0x8c
e57a : f3e9                  	dw	df_rt_until
e57c : 4ee9                  	dw	df_rt_for			; 0x8e
e57e : 8ce9                  	dw	df_rt_next			; 0x8f
e580 : 24e8                  	dw	df_rt_while			; 0x90
e582 : 87e8                  	dw	df_rt_wend			; 0x81
e584 : 0ae9                  	dw	df_rt_if			; 0x92
e586 : f8e8                  	dw	df_rt_else			; 0x93
e588 : f3e8                  	dw	df_rt_endif			; 0x94
e58a : f8e8                  	dw	df_rt_elseif		; 0x95
e58c : 6eed                  	dw	df_rt_data			; 0x96
AS65 Assembler for R6502 [1.42].                                     Page  193
-------------------------------- bank\bank0.s --------------------------------

e58e : 50fa                  	dw	df_rt_asm_assemble	; 0x97 df_rt_asm_assemble
e590 : 6fed                  	dw	df_rt_run
e592 : 6fee                  	dw	df_rt_list
e594 : ecea                  	dw	df_rt_input
e596 : 6bec                  	dw	df_rt_text
e598 : e4eb                  	dw	df_rt_plot
e59a : 58ec                  	dw	df_rt_cursor
e59c : e1eb                  	dw	df_rt_cls
e59e : e5f0                  	dw	df_rt_poke
e5a0 : d6f0                  	dw	df_rt_doke
e5a2 : 18f1                  	dw	df_rt_sound
e5a4 : 2bf1                  	dw	df_rt_music
e5a6 : 40f1                  	dw	df_rt_play
e5a8 : 3af2                  	dw	df_rt_save
e5aa : 8cf2                  	dw	df_rt_load
e5ac : d0ea                  	dw	df_rt_read
e5ae : 21e8                  	dw	df_rt_new
e5b0 : 84ed                  	dw	df_rt_renum
e5b2 : b9ec                  	dw	df_rt_wait
e5b4 : f2f2                  	dw	df_rt_reset
e5b6 : 6eec                  	dw	df_rt_hires
e5b8 : 87ec                  	dw	df_rt_point
e5ba : a3ec                  	dw	df_rt_line
e5bc : 71ec                  	dw	df_rt_pixmode
e5be : 77ec                  	dw	df_rt_ink
e5c0 : 7dec                  	dw	df_rt_paper
e5c2 : 91ec                  	dw	df_rt_circle
e5c4 : 5eec                  	dw	df_rt_himem
e5c6 : 1de8                  	dw	df_rt_monitor
e5c8 : 18f5                  	dw	df_rt_sprchar
e5ca : 22f5                  	dw	df_rt_sprpos
e5cc : 2ef5                  	dw	df_rt_sprupd
e5ce : 37f5                  	dw	df_rt_sprinit
e5d0 : 3af5                  	dw	df_rt_sprmulti
e5d2 : 19f2                  	dw	df_rt_bsave
e5d4 : e6f1                  	dw	df_rt_bload
e5d6 : 91f1                  	dw	df_rt_tsave
e5d8 : acf1                  	dw	df_rt_tload
                             
e5da : 0af3                  	dw	df_rt_peek
e5dc : 07f3                  	dw	df_rt_deek
e5de : 99f3                  	dw	df_rt_stick
e5e0 : a1f3                  	dw	df_rt_get
e5e2 : 44f4                  	dw	df_rt_chr
e5e4 : 8df4                  	dw	df_rt_left
e5e6 : a0f4                  	dw	df_rt_right
e5e8 : bdf4                  	dw	df_rt_mid
e5ea : ddf4                  	dw	df_rt_len
e5ec : 49f3                  	dw	df_rt_mem
e5ee : b7f3                  	dw	df_rt_scrn
e5f0 : 25f3                  	dw	df_rt_rnd
e5f2 : d5f3                  	dw	df_rt_elapsed
e5f4 : f0f3                  	dw	df_rt_call
e5f6 : 5af4                  	dw	df_rt_hex
e5f8 : ebf4                  	dw	df_rt_asc
e5fa : fef4                  	dw	df_rt_val
e5fc : c6f3                  	dw	df_rt_pixel
e5fe : 40f5                  	dw	df_rt_sprhit
                             	
e600 : 73e6                  	dw	df_rt_mult
e602 : 94e6                  	dw	df_rt_div
e604 : b5e6                  	dw	df_rt_mod
AS65 Assembler for R6502 [1.42].                                     Page  194
-------------------------------- bank\bank0.s --------------------------------

e606 : d6e6                  	dw	df_rt_asl
e608 : e9e6                  	dw	df_rt_lsr
e60a : 4de6                  	dw	df_rt_add
e60c : 60e6                  	dw	df_rt_sub
                             	
e60e : fce6                  	dw	df_rt_and
e610 : 0be7                  	dw	df_rt_or
e612 : 1ae7                  	dw	df_rt_eor
e614 : b3e7                  	dw	df_rt_comlte
e616 : bce7                  	dw	df_rt_comgte
e618 : c5e7                  	dw	df_rt_comne
e61a : 98e7                  	dw	df_rt_comlt
e61c : a1e7                  	dw	df_rt_comgt
e61e : aae7                  	dw	df_rt_comeq
                             
                             
                             ; escape sequence handlers
                             ; to do the reverse of tokenising during the list
                             ; command which is also used to save to disk.
e620 :                       df_rt_escjmp
e620 : 45ef                  	dw df_rt_lst_chr
e622 : 44ef                  	dw df_rt_lst_reserved
e624 : 44ef                  	dw df_rt_lst_reserved
e626 : 44ef                  	dw df_rt_lst_reserved
e628 : 44ef                  	dw df_rt_lst_reserved	
e62a : 44ef                  	dw df_rt_lst_reserved	; no such thing as bytdec
e62c : 62ef                  	dw df_rt_lst_bythex
e62e : 87ef                  	dw df_rt_lst_bytbin
e630 : 44ef                  	dw df_rt_lst_reserved	
e632 : b3ef                  	dw df_rt_lst_intdec
e634 : 75ef                  	dw df_rt_lst_inthex
e636 : 90ef                  	dw df_rt_lst_intbin
e638 : 44ef                  	dw df_rt_lst_reserved
e63a : 44ef                  	dw df_rt_lst_reserved
e63c : 44ef                  	dw df_rt_lst_reserved
e63e : 44ef                  	dw df_rt_lst_reserved	
e640 : 13f0                  	dw df_rt_lst_strlit
e642 : beef                  	dw df_rt_lst_var
e644 : beef                  	dw df_rt_lst_proc
                             
                             	include "dflat\rtsubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTSUBS.S
                             ;*  Module that implements the runtime execution 
                             ;*  keywords and functions.
                             ;*  So this is where most of the action is for ru
                             ;*  a line is being executed, the dflat runtime c
                             ;*  jumps through the runtime table to routines h
                             ;*  Every dflat statement begins with a token (ig
                             ;*  whitespace), even the implicit assignment and
                             ;*  invocation.
                             ;*
                             ;************************************************
                             
                             	; ROM code
AS65 Assembler for R6502 [1.42].                                     Page  195
-------------------------------- bank\bank0.s --------------------------------

                             	code  
                             
e646 :                       mod_sz_rtsubs_s
                             
                             	include "dflat\numop.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  NUMOP.S
                             ;*	Dflat number AND string operators.
                             ;*  Uses the operator stack to get parameters, le
                             ;*  result on the operator stack.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; common pushint code
e646 :                       df_rt_putintres
e646 : a69f             [ 3] 	ldx df_tmpptra
e648 : a5a0             [ 3] 	lda df_tmpptra+1
e64a : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; add two numbers
e64d :                       df_rt_add
e64d : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e65d : 4c46e6           [ 3] 	jmp df_rt_putintres
                             	
                             ; subtract
e660 :                       df_rt_sub
e660 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	_subZPWord df_tmpptra,df_tmpptrb
                             
e670 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; multiply
e673 :                       df_rt_mult
e673 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e686 : 2054d4           [ 6] 	jsr int_mult
                             	_cpyZPWord num_a,df_tmpptra
                             
e691 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; divide
e694 :                       df_rt_div
e694 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
AS65 Assembler for R6502 [1.42].                                     Page  196
-------------------------------- bank\bank0.s --------------------------------

e6a7 : 207fd4           [ 6] 	jsr int_div
                             	_cpyZPWord num_a,df_tmpptra
                             
e6b2 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; mod
e6b5 :                       df_rt_mod
e6b5 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e6c8 : 207fd4           [ 6] 	jsr int_div
                             	_cpyZPWord num_x,df_tmpptra
                             
e6d3 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; shift left
e6d6 :                       df_rt_asl
e6d6 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e6d9 : a6a1             [ 3] 	ldx df_tmpptrb
e6db : e8               [ 2] 	inx
e6dc :                       df_rt_aslbit
e6dc : ca               [ 2] 	dex
e6dd : f007             [ 3] 	beq df_rt_asldone
e6df : 069f             [ 5] 	asl df_tmpptra
e6e1 : 26a0             [ 5] 	rol df_tmpptra+1
e6e3 : 4cdce6           [ 3] 	jmp df_rt_aslbit
e6e6 :                       df_rt_asldone
e6e6 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; shift right
e6e9 :                       df_rt_lsr
e6e9 : 202ce3           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e6ec : a6a1             [ 3] 	ldx df_tmpptrb
e6ee : e8               [ 2] 	inx
e6ef :                       df_rt_lsrbit
e6ef : ca               [ 2] 	dex
e6f0 : f007             [ 3] 	beq df_rt_lsrdone
e6f2 : 46a0             [ 5] 	lsr df_tmpptra+1
e6f4 : 669f             [ 5] 	ror df_tmpptra
e6f6 : 4cefe6           [ 3] 	jmp df_rt_lsrbit
e6f9 :                       df_rt_lsrdone
e6f9 : 4c46e6           [ 3] 	jmp df_rt_putintres
                             
                             ; logical and
e6fc :                       df_rt_and
e6fc : 202ce3           [ 6] 	jsr df_rt_get2Ints
e6ff : a59f             [ 3] 	lda df_tmpptra
e701 : 25a1             [ 3] 	and df_tmpptrb
e703 : aa               [ 2] 	tax
e704 : a5a0             [ 3] 	lda df_tmpptra+1
e706 : 25a2             [ 3] 	and df_tmpptrb+1
e708 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             	
                             ; logical or
e70b :                       df_rt_or
e70b : 202ce3           [ 6] 	jsr df_rt_get2Ints
e70e : a59f             [ 3] 	lda df_tmpptra
e710 : 05a1             [ 3] 	ora df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  197
-------------------------------- bank\bank0.s --------------------------------

e712 : aa               [ 2] 	tax
e713 : a5a0             [ 3] 	lda df_tmpptra+1
e715 : 05a2             [ 3] 	ora df_tmpptrb+1
e717 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; logical eor
e71a :                       df_rt_eor
e71a : 202ce3           [ 6] 	jsr df_rt_get2Ints
e71d : a59f             [ 3] 	lda df_tmpptra
e71f : 45a1             [ 3] 	eor df_tmpptrb
e721 : aa               [ 2] 	tax
e722 : a5a0             [ 3] 	lda df_tmpptra+1
e724 : 45a2             [ 3] 	eor df_tmpptrb+1
e726 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; a==b common function
e729 :                       df_rt_aequb
e729 : a59f             [ 3] 	lda df_tmpptra
e72b : c5a1             [ 3] 	cmp df_tmpptrb
e72d : d004             [ 3] 	bne df_rt_aequbFin
e72f : a5a0             [ 3] 	lda df_tmpptra+1
e731 : c5a2             [ 3] 	cmp df_tmpptrb+1
e733 :                       df_rt_aequbFin
e733 : 60               [ 6] 	rts
                             
                             ; a-b common function
e734 :                       df_rt_asubb
e734 : 38               [ 2] 	sec
e735 : a59f             [ 3] 	lda df_tmpptra
e737 : e5a1             [ 3] 	sbc df_tmpptrb
e739 : a5a0             [ 3] 	lda df_tmpptra+1
e73b : e5a2             [ 3] 	sbc df_tmpptrb+1
e73d : 5002             [ 3] 	bvc df_rt_asubbFin
e73f : 4980             [ 2] 	eor #0x80
e741 :                       df_rt_asubbFin
e741 : 60               [ 6] 	rts
                             
                             ; b-a common function
e742 :                       df_rt_bsuba
e742 : 38               [ 2] 	sec
e743 : a5a1             [ 3] 	lda df_tmpptrb
e745 : e59f             [ 3] 	sbc df_tmpptra
e747 : a5a2             [ 3] 	lda df_tmpptrb+1
e749 : e5a0             [ 3] 	sbc df_tmpptra+1
e74b : 5002             [ 3] 	bvc df_rt_bsubaFin
e74d : 4980             [ 2] 	eor #0x80
e74f :                       df_rt_bsubaFin
e74f : 60               [ 6] 	rts
                             
                             ; common routine push true
e750 :                       df_rt_true
e750 : a2ff             [ 2] 	ldx #0xff
e752 : 8a               [ 2] 	txa
e753 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; common routine push false
e756 :                       df_rt_false
e756 : a200             [ 2] 	ldx #0x00
e758 : 8a               [ 2] 	txa
e759 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; a < b == (a-b) < 0
AS65 Assembler for R6502 [1.42].                                     Page  198
-------------------------------- bank\bank0.s --------------------------------

e75c :                       df_rt_lt
e75c : 202ce3           [ 6] 	jsr df_rt_get2Ints
e75f : 2034e7           [ 6] 	jsr df_rt_asubb
e762 : 30ec             [ 3] 	bmi df_rt_true
e764 : 10f0             [ 3] 	bpl df_rt_false
                             
                             ; a <=b == !(b-a > 0)
e766 :                       df_rt_lte
e766 : 202ce3           [ 6] 	jsr df_rt_get2Ints
e769 :                       df_rt_lte_calc
e769 : 2042e7           [ 6] 	jsr df_rt_bsuba
e76c : 30e8             [ 3] 	bmi df_rt_false
e76e : 10e0             [ 3] 	bpl df_rt_true
                             
                             ; a > b == (b-a) < 0
e770 :                       df_rt_gt
e770 : 202ce3           [ 6] 	jsr df_rt_get2Ints
e773 : 2042e7           [ 6] 	jsr df_rt_bsuba
e776 : 30d8             [ 3] 	bmi df_rt_true
e778 : 10dc             [ 3] 	bpl df_rt_false
                             
                             ; a >= b == (a-b >=0)
e77a :                       df_rt_gte
e77a : 202ce3           [ 6] 	jsr df_rt_get2Ints
e77d :                       df_rt_gte_calc
e77d : 2034e7           [ 6] 	jsr df_rt_asubb
e780 : 10ce             [ 3] 	bpl df_rt_true
e782 : 30d2             [ 3] 	bmi df_rt_false
                             
                             ; a == b
e784 :                       df_rt_eq
e784 : 202ce3           [ 6] 	jsr df_rt_get2Ints
e787 : 2029e7           [ 6] 	jsr df_rt_aequb
e78a : d0ca             [ 3] 	bne df_rt_false
e78c : f0c2             [ 3] 	beq df_rt_true
                             
                             ; a <> b
e78e :                       df_rt_ne
e78e : 202ce3           [ 6] 	jsr df_rt_get2Ints
e791 : 2029e7           [ 6] 	jsr df_rt_aequb
e794 : f0c0             [ 3] 	beq df_rt_false
e796 : d0b8             [ 3] 	bne df_rt_true
                             
                             ; Common usage of boolean operators for num and s
                             
e798 :                       df_rt_comlt
                             	; First find the data type on the stack
e798 : 203cf7           [ 6] 	jsr df_ost_peekType
e79b : 2980             [ 2] 	and #DFST_STR
e79d : d04a             [ 3] 	bne df_rt_slt
                             	; If not string then assume number
e79f : f0bb             [ 3] 	beq df_rt_lt
                             
e7a1 :                       df_rt_comgt
                             	; First find the data type on the stack
e7a1 : 203cf7           [ 6] 	jsr df_ost_peekType
e7a4 : 2980             [ 2] 	and #DFST_STR
e7a6 : d048             [ 3] 	bne df_rt_sgt
                             	; If not string then assume number
e7a8 : f0c6             [ 3] 	beq df_rt_gt
                             
e7aa :                       df_rt_comeq
AS65 Assembler for R6502 [1.42].                                     Page  199
-------------------------------- bank\bank0.s --------------------------------

                             	; First find the data type on the stack
e7aa : 203cf7           [ 6] 	jsr df_ost_peekType
e7ad : 2980             [ 2] 	and #DFST_STR
e7af : d048             [ 3] 	bne df_rt_seq
                             	; If not string then assume number
e7b1 : f0d1             [ 3] 	beq df_rt_eq
                             
e7b3 :                       df_rt_comlte
                             	; First find the data type on the stack
e7b3 : 203cf7           [ 6] 	jsr df_ost_peekType
e7b6 : 2980             [ 2] 	and #DFST_STR
e7b8 : d014             [ 3] 	bne df_rt_slte
                             	; If not string then assume number
e7ba : f0aa             [ 3] 	beq df_rt_lte
                             	
e7bc :                       df_rt_comgte
                             	; First find the data type on the stack
e7bc : 203cf7           [ 6] 	jsr df_ost_peekType
e7bf : 2980             [ 2] 	and #DFST_STR
e7c1 : d018             [ 3] 	bne df_rt_sgte
                             	; If not string then assume number
e7c3 : f0b5             [ 3] 	beq df_rt_gte
                             
e7c5 :                       df_rt_comne
                             	; First find the data type on the stack
e7c5 : 203cf7           [ 6] 	jsr df_ost_peekType
e7c8 : 2980             [ 2] 	and #DFST_STR
e7ca : d016             [ 3] 	bne df_rt_sne
                             	; If not string then assume number
e7cc : f0c0             [ 3] 	beq df_rt_ne
                             
                             
                             ;********** STRING OPS **********
                             
                             ; string less than or equal
e7ce :                       df_rt_slte
e7ce : 2000e8           [ 6] 	jsr df_rt_str_comp
e7d1 : 3005             [ 3] 	bmi df_rt_str_comp_true
e7d3 : f003             [ 3] 	beq df_rt_str_comp_true
e7d5 :                       df_rt_str_comp_false
e7d5 : 4c56e7           [ 3] 	jmp df_rt_false
e7d8 :                       df_rt_str_comp_true
e7d8 : 4c50e7           [ 3] 	jmp df_rt_true	
                             
                             ; string greater then or equal	
e7db :                       df_rt_sgte
e7db : 2000e8           [ 6] 	jsr df_rt_str_comp
e7de : 10f8             [ 3] 	bpl df_rt_str_comp_true
e7e0 : 30f3             [ 3] 	bmi df_rt_str_comp_false
                             
                             ; string not equal
e7e2 :                       df_rt_sne
e7e2 : 2000e8           [ 6] 	jsr df_rt_str_comp
e7e5 : d0f1             [ 3] 	bne df_rt_str_comp_true
e7e7 : f0ec             [ 3] 	beq df_rt_str_comp_false
                             
                             ; string less than
e7e9 :                       df_rt_slt
e7e9 : 2000e8           [ 6] 	jsr df_rt_str_comp
e7ec : 30ea             [ 3] 	bmi df_rt_str_comp_true
e7ee : 10e5             [ 3] 	bpl df_rt_str_comp_false
                             
AS65 Assembler for R6502 [1.42].                                     Page  200
-------------------------------- bank\bank0.s --------------------------------

                             ; string greater than
e7f0 :                       df_rt_sgt
e7f0 : 2000e8           [ 6] 	jsr df_rt_str_comp
e7f3 : 30e0             [ 3] 	bmi df_rt_str_comp_false
e7f5 : f0de             [ 3] 	beq df_rt_str_comp_false
e7f7 : d0df             [ 3] 	bne df_rt_str_comp_true
                             
                             ; string equal
e7f9 :                       df_rt_seq
e7f9 : 2000e8           [ 6] 	jsr df_rt_str_comp
e7fc : f0da             [ 3] 	beq df_rt_str_comp_true
e7fe : d0d5             [ 3] 	bne df_rt_str_comp_false
                             
                             ; common string comparator
                             ; N=1 means <
                             ; Z=0 means >
                             ; Z=1 means ==
e800 :                       df_rt_str_comp
e800 : 203be3           [ 6] 	jsr df_rt_get2Strs
e803 : a000             [ 2] 	ldy #0
e805 :                       df_rt_str_comp_byte
e805 : b19f             [ 5] 	lda (df_tmpptra),y
e807 : aa               [ 2] 	tax							; Save op1 char in X
e808 : d1a1             [ 5] 	cmp (df_tmpptrb),y
                             	; if c=0 then <
e80a : 9008             [ 3] 	bcc df_rt_str_comp_lt
                             	; if c=1 and nz then >
e80c : d009             [ 3] 	bne df_rt_str_comp_gt
                             	; if here then both strings still the same
e80e : 8a               [ 2] 	txa							; What was op1 char
                             	; if char is zero then end
e80f : f009             [ 3] 	beq df_rt_str_comp_eq
                             	; else do next char
e811 : c8               [ 2] 	iny
e812 : d0f1             [ 3] 	bne df_rt_str_comp_byte ; Always - relying on Y 
e814 :                       df_rt_str_comp_lt
e814 : a9ff             [ 2] 	lda #0xff
e816 : 60               [ 6] 	rts
e817 :                       df_rt_str_comp_gt
e817 : a901             [ 2] 	lda #0x01
e819 : 60               [ 6] 	rts
e81a :                       df_rt_str_comp_eq
e81a : a900             [ 2] 	lda #0x00
e81c : 60               [ 6] 	rts
                             
                             
                             
                             
e81d :                       df_rt_monitor
e81d : 2092d2           [ 6] 	jsr command_line
e820 : 60               [ 6] 	rts
                             	
e821 :                       df_rt_new
e821 : 4c77f7           [ 3] 	jmp df_clear
                             	
e824 :                       df_rt_while
                             	; push statement address
e824 : 20b4e4           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_WHILE token
e827 : a990             [ 2] 	lda #DFRT_WHILE
e829 : 20c0f6           [ 6] 	jsr df_rst_pushByte
                             
AS65 Assembler for R6502 [1.42].                                     Page  201
-------------------------------- bank\bank0.s --------------------------------

                             	; get value in A,X
e82c : 2066e0           [ 6] 	jsr df_rt_getnval
                             
                             	; if value<>0 then continue
e82f : e000             [ 2] 	cpx #0
e831 : f001             [ 3] 	beq df_rt_while_done
e833 : 60               [ 6] 	rts
e834 :                       df_rt_while_done
                             	; pop while data off stack as not needed
e834 : 20e6f6           [ 6] 	jsr df_rst_popWord
e837 : 20e6f6           [ 6] 	jsr df_rst_popWord
                             	; while evaluated false so find wend
                             	; but check for any nested while/wends
                             	; nest = 1 to start
e83a : a591             [ 3] 	lda df_ifnest
e83c : 48               [ 3] 	pha
e83d : a901             [ 2] 	lda #1
e83f : 8591             [ 3] 	sta df_ifnest
                             	; find the matching else/elseif/endif
                             	; start from current statement
                             	_cpyZPWord df_currlin,df_nextlin
                             
e849 :                       df_rt_findwend
e849 : a687             [ 3] 	ldx df_nextlin
e84b : a588             [ 3] 	lda df_nextlin+1
e84d : a47e             [ 3] 	ldy df_curstidx
e84f : 2082e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e852 : b031             [ 3] 	bcs df_rt_wend_end
e854 : 8687             [ 3] 	stx df_nextlin
e856 : 8588             [ 3] 	sta df_nextlin+1
e858 : 847e             [ 3] 	sty df_curstidx
                             	; find the command token
e85a :                       df_rt_while_cmd
e85a : c8               [ 2] 	iny
e85b : b187             [ 5] 	lda (df_nextlin),y
e85d : 10fb             [ 3] 	bpl df_rt_while_cmd
                             	; check for wend
e85f : c991             [ 2] 	cmp #DFRT_WEND
e861 : d019             [ 3] 	bne df_rt_check_while
                             	; decrement nest
e863 : c691             [ 5] 	dec df_ifnest
                             	; if not zero then go find more commands
e865 : d0e2             [ 3] 	bne df_rt_findwend
                             	; else found it, restore if nest
                             	; and skip the wend statement
e867 : 68               [ 4] 	pla
e868 : 8591             [ 3] 	sta df_ifnest
e86a : a687             [ 3] 	ldx df_nextlin
e86c : a588             [ 3] 	lda df_nextlin+1
e86e : a47e             [ 3] 	ldy df_curstidx
e870 : 2082e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e873 : b010             [ 3] 	bcs df_rt_wend_end
                             	; need to update nxtstidx to transfer control
e875 : 8687             [ 3] 	stx df_nextlin
e877 : 8588             [ 3] 	sta df_nextlin+1
e879 : 847d             [ 3] 	sty df_nxtstidx	
e87b : 60               [ 6] 	rts
e87c :                       df_rt_check_while
                             	; check for while
e87c : c990             [ 2] 	cmp #DFRT_WHILE
AS65 Assembler for R6502 [1.42].                                     Page  202
-------------------------------- bank\bank0.s --------------------------------

e87e : d0c9             [ 3] 	bne df_rt_findwend
                             	; if while found then increment nest
e880 : e691             [ 5] 	inc df_ifnest
e882 : 4c49e8           [ 3] 	jmp df_rt_findwend
e885 :                       df_rt_wend_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
e887 :                       df_rt_wend
e887 : 20c9f6           [ 6] 	jsr df_rst_popByte
e88a : c990             [ 2] 	cmp #DFRT_WHILE
e88c : d00d             [ 3] 	bne df_rt_wend_err
                             	; pop the stat and continue
e88e : 20e6f6           [ 6] 	jsr df_rst_popWord
e891 : 8687             [ 3] 	stx	df_nextlin
e893 : 8588             [ 3] 	sta df_nextlin+1
e895 : 20c9f6           [ 6] 	jsr df_rst_popByte
e898 : 857d             [ 3] 	sta df_nxtstidx
e89a : 60               [ 6] 	rts
e89b :                       df_rt_wend_err
                             	SWBRK DFERR_WEND
                             
                             
                             ;move to next statement during if/else matching
                             ;end of program is an error
e89d :                       df_rt_if_stat
e89d : a687             [ 3] 	ldx df_nextlin
e89f : a588             [ 3] 	lda df_nextlin+1
e8a1 : a47e             [ 3] 	ldy df_curstidx
e8a3 : 2082e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e8a6 : b009             [ 3] 	bcs df_rt_if_stat_err
e8a8 : 8687             [ 3] 	stx df_nextlin
e8aa : 8588             [ 3] 	sta df_nextlin+1
e8ac : 847e             [ 3] 	sty df_curstidx
e8ae : 847d             [ 3] 	sty df_nxtstidx
e8b0 : 60               [ 6] 	rts
                             ; program ended with no match
e8b1 :                       df_rt_if_stat_err
                             	SWBRK DFERR_UNCLOSEDIF
                             
                             	
                             ; find matching else/elseif/endif
                             ; C = 0 match else/elseif/endif
                             ; C = 1 match endif only
                             ; endif is always matched
                             ; ** MAKE SURE NEXTLIN IS POPULATED! **
e8b3 :                       df_rt_if_match
                             	; save the current if nest level
e8b3 : a591             [ 3] 	lda df_ifnest
e8b5 : 48               [ 3] 	pha
                             	; local if nest level is zero to start with
e8b6 : a900             [ 2] 	lda #0
e8b8 : 8591             [ 3] 	sta df_ifnest	
                             	; save match pref
e8ba : 08               [ 3] 	php
                             	; find the matching else/elseif/endif
                             	; start from df_nextlin, df_curstidx
e8bb :                       df_rt_findelseendif
e8bb : 209de8           [ 6] 	jsr df_rt_if_stat
                             	; find command
e8be :                       df_rt_ifcmd
AS65 Assembler for R6502 [1.42].                                     Page  203
-------------------------------- bank\bank0.s --------------------------------

e8be : c8               [ 2] 	iny
e8bf : b187             [ 5] 	lda (df_nextlin),y
e8c1 : 10fb             [ 3] 	bpl df_rt_ifcmd
                             	; check for endif
e8c3 : c994             [ 2] 	cmp #DFRT_ENDIF
e8c5 : f015             [ 3] 	beq df_rt_ifelse
                             
e8c7 : 28               [ 4] 	plp
e8c8 : 08               [ 3] 	php
                             	
e8c9 : b008             [ 3] 	bcs df_rt_ifskipelseif
e8cb : c993             [ 2] 	cmp #DFRT_ELSE
e8cd : f00d             [ 3] 	beq df_rt_ifelse
e8cf : c995             [ 2] 	cmp #DFRT_ELSEIF
e8d1 : f009             [ 3] 	beq df_rt_ifelse
e8d3 :                       df_rt_ifskipelseif
                             	; another if token found - increment lcoal if ne
e8d3 : c992             [ 2] 	cmp #DFRT_IF
e8d5 : d002             [ 3] 	bne df_rt_skipnestif
e8d7 : e691             [ 5] 	inc df_ifnest
e8d9 :                       df_rt_skipnestif
                             	; no tokens of interest found, so next statement
e8d9 : 4cbbe8           [ 3] 	jmp df_rt_findelseendif
                             	
                             	; found else/elseif/endif
                             	; but check if this is nested
e8dc :                       df_rt_ifelse
                             	; nest counter zero then found matching else/els
e8dc : a691             [ 3] 	ldx df_ifnest
e8de : f009             [ 3] 	beq df_rt_if_found
                             	; endif token found so decrement local nest
e8e0 : c994             [ 2] 	cmp #DFRT_ENDIF
e8e2 : d002             [ 3] 	bne df_rt_skipnestendif
e8e4 : c691             [ 5] 	dec df_ifnest
e8e6 :                       df_rt_skipnestendif	
                             	; continue to search for else/endif
e8e6 : 4cbbe8           [ 3] 	jmp df_rt_findelseendif
                             	; ok got a match
e8e9 :                       df_rt_if_found
                             	; remove pref
e8e9 : 28               [ 4] 	plp
                             	; restore global if nest
e8ea : 8536             [ 3] 	sta tmp_d			; Using as a temp place!
e8ec : 68               [ 4] 	pla					; Get nest from stack
e8ed : aa               [ 2] 	tax					; And put in X
e8ee : a536             [ 3] 	lda tmp_d			; Get a back from temp!
e8f0 : 8691             [ 3] 	stx df_ifnest		; Now restore the nest counter
                             
                             	;A contains the token found, Y is index in to df
                             ;	clc
e8f2 : 60               [ 6] 	rts
                             
e8f3 :                       df_rt_endif
                             	; decrement if next level
e8f3 : c691             [ 5] 	dec df_ifnest
e8f5 : 3011             [ 4] 	bmi df_rt_noif_err
                             ;	clc
e8f7 : 60               [ 6] 	rts
                             	
                             	; else and ifelse encountered in a normal sequen
                             	; only happens when the clause has been executed
                             	; so we only now need to find the endif
AS65 Assembler for R6502 [1.42].                                     Page  204
-------------------------------- bank\bank0.s --------------------------------

e8f8 :                       df_rt_elseif
e8f8 :                       df_rt_else
                             	; not in if mode then error
e8f8 : a591             [ 3] 	lda df_ifnest
e8fa : f00c             [ 4] 	beq df_rt_noif_err
                             	; find endif only
                             	; starting from current line and curstidx
                             	_cpyZPWord df_currlin,df_nextlin
                             
e904 : 38               [ 2] 	sec
e905 : 4cb3e8           [ 3] 	jmp df_rt_if_match
                             
                             ; endif/else/elseif encountered outside of an if	
e908 :                       df_rt_noif_err
                             	SWBRK DFERR_NOIF
                             
                             	
                             	; when if is encountered, the job of this routin
                             	; to determine which clause to execute, then tra
                             	; program control to that point.  in normal prog
                             	; sequence else/elseif statements will signify t
                             	; of an if construct.
e90a :                       df_rt_if
                             	; increment global if nest counter
e90a : e691             [ 5] 	inc df_ifnest
e90c :                       df_rt_ifeval
                             	; get value
e90c : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 if is successful then continue nor
e90f : c900             [ 2] 	cmp #0
e911 : d03a             [ 3] 	bne df_rt_if_done
e913 : e000             [ 2] 	cpx #0
e915 : d036             [ 3] 	bne df_rt_if_done
                             	; got here then if clause evaluated to false
                             	; match with else/elseif/endif
                             	; df_nextlin is used to find the clause to execu
                             	_cpyZPWord df_currlin,df_nextlin
                             
e91f : 18               [ 2] 	clc						
e920 : 20b3e8           [ 6] 	jsr df_rt_if_match
                             	; A contains the token found, Y is index of this
                             
e923 : c993             [ 2] 	cmp #DFRT_ELSE
                             	; else: df_nextlin and df_nxtstidx points to the
e925 : f023             [ 3] 	beq df_rt_do_else
                             
e927 : c994             [ 2] 	cmp #DFRT_ENDIF
                             	; else: df_nextlin and df_nxtstidx points to the
e929 : f022             [ 3] 	beq df_rt_if_done
                             
                             	; elif detected - increment past the token and e
                             	; make this the current line and token index
                             	_cpyZPWord df_nextlin,df_currlin
                             
                             	; move past the token and save position
e933 : c8               [ 2] 	iny
e934 : 98               [ 2] 	tya
e935 : 48               [ 3] 	pha
                             	; initialise statement pointer
e936 : a47e             [ 3] 	ldy df_curstidx
e938 : a684             [ 3] 	ldx df_currlin
e93a : a585             [ 3] 	lda df_currlin+1
AS65 Assembler for R6502 [1.42].                                     Page  205
-------------------------------- bank\bank0.s --------------------------------

e93c : 20eee3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; restore Y (one byte past the token) and save i
e93f : 68               [ 4] 	pla
e940 : a8               [ 2] 	tay
e941 : 8486             [ 3] 	sty df_exeoff
                             	; don't force a jump as we've initalised all var
e943 : a900             [ 2] 	lda #0
e945 : 8588             [ 3] 	sta df_nextlin+1
                             	; now everyting is set up to evaluate the elif c
e947 : 4c0ce9           [ 3] 	jmp df_rt_ifeval
                             	
e94a :                       df_rt_do_else
                             	; we need to point to the next statement not thi
e94a : 209de8           [ 6] 	jsr df_rt_if_stat
e94d :                       df_rt_if_done
                             ;	clc
e94d : 60               [ 6] 	rts
                             	
e94e :                       df_rt_for
                             	; push statement address to rt stack
e94e : 20b4e4           [ 6] 	jsr df_rt_push_stat
                             	; get lvar
e951 : 203be5           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer, A is fine to trample
e954 : 48               [ 3] 	pha
e955 : 8a               [ 2] 	txa
e956 : 48               [ 3] 	pha
                             	
                             
                             	; find starting value
                             	; evaluate the starting value
                             	; can't use df_rt_getnval as need to use A,X fir
e957 : e686             [ 5] 	inc df_exeoff
e959 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; get ready to update the counter using pointer
e95c : 68               [ 4] 	pla
e95d : aa               [ 2] 	tax
e95e : 869f             [ 3] 	stx df_tmpptra
e960 : 68               [ 4] 	pla
e961 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; But remember lvar pointer for later A is ok to
e963 : 48               [ 3] 	pha
e964 : 8a               [ 2] 	txa
e965 : 48               [ 3] 	pha
                             
                             	; get the starting value from op stack
e966 : 2042f7           [ 6] 	jsr df_ost_popInt
                             	; save it to counter slot
e969 : a001             [ 2] 	ldy #1
e96b : 919f             [ 5] 	sta (df_tmpptra),y
e96d : 8a               [ 2] 	txa
e96e : 88               [ 2] 	dey
e96f : 919f             [ 5] 	sta (df_tmpptra),y
                             
                             	; find end value
                             	; evaluate the end value
e971 : e686             [ 5] 	inc df_exeoff
e973 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; and put on rt stack
e976 : 20d8f6           [ 6] 	jsr df_rst_pushWord
                             
                             	; find step value
AS65 Assembler for R6502 [1.42].                                     Page  206
-------------------------------- bank\bank0.s --------------------------------

                             	; evaluate the end value
e979 : e686             [ 5] 	inc df_exeoff
e97b : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; and push on rt stack
e97e : 20d8f6           [ 6] 	jsr df_rst_pushWord
                             	; save the counter lvar pointer
e981 : 68               [ 4] 	pla
e982 : aa               [ 2] 	tax
e983 : 68               [ 4] 	pla
e984 : 20d8f6           [ 6] 	jsr df_rst_pushWord
                             	; all done - counter set to start
                             	; stack contains counter slot, step val, end val
                             	; now push for token
e987 : a98e             [ 2] 	lda #DFRT_FOR
e989 : 4cc0f6           [ 3] 	jmp df_rst_pushByte
                             ;	rts
                             
e98c :                       df_rt_next
                             	; remember stack position
e98c : a474             [ 3] 	ldy df_rtstop
e98e : 98               [ 2] 	tya
e98f : 48               [ 3] 	pha
e990 : 20c9f6           [ 6] 	jsr df_rst_popByte
e993 : c98e             [ 2] 	cmp #DFRT_FOR
e995 : d052             [ 3] 	bne df_rt_next_err
                             	; get the slot address
e997 : 20e6f6           [ 6] 	jsr df_rst_popWord
                             	; save address to ptrd, contents to ptra
e99a : 86a5             [ 3] 	stx df_tmpptrd
e99c : 85a6             [ 3] 	sta df_tmpptrd+1
e99e : a000             [ 2] 	ldy #0
e9a0 : b1a5             [ 5] 	lda (df_tmpptrd),y
e9a2 : 859f             [ 3] 	sta df_tmpptra
e9a4 : c8               [ 2] 	iny
e9a5 : b1a5             [ 5] 	lda (df_tmpptrd),y
e9a7 : 85a0             [ 3] 	sta df_tmpptra+1
                             	
                             	; get step value, save in ptrb
e9a9 : 20e6f6           [ 6] 	jsr df_rst_popWord
e9ac : 86a1             [ 3] 	stx df_tmpptrb
e9ae : 85a2             [ 3] 	sta df_tmpptrb+1
e9b0 : 48               [ 3] 	pha					; Push A to check for -ve step
                             
                             	; add step to counter and save back to counter
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e9be : a59f             [ 3] 	lda df_tmpptra
e9c0 : a000             [ 2] 	ldy #0
e9c2 : 91a5             [ 5] 	sta (df_tmpptrd),y
e9c4 : a5a0             [ 3] 	lda df_tmpptra+1
e9c6 : c8               [ 2] 	iny
e9c7 : 91a5             [ 5] 	sta (df_tmpptrd),y
                             	
                             	; get end value, save in ptrb
e9c9 : 20e6f6           [ 6] 	jsr df_rst_popWord
e9cc : 86a1             [ 3] 	stx df_tmpptrb
e9ce : 85a2             [ 3] 	sta df_tmpptrb+1
e9d0 : 68               [ 4] 	pla					; check if if +ve or -ve step
e9d1 : 1006             [ 3] 	bpl df_rt_check_pos
                             	; call gte operation but no need to get ints
                             	; as already in ptra and ptrb
e9d3 : 207de7           [ 6] 	jsr df_rt_gte_calc
AS65 Assembler for R6502 [1.42].                                     Page  207
-------------------------------- bank\bank0.s --------------------------------

e9d6 : 4cdce9           [ 3] 	jmp df_rt_next_check
e9d9 :                       df_rt_check_pos
                             	; call lte operation but no need to get ints
                             	; as already in ptra and ptrb
e9d9 : 2069e7           [ 6] 	jsr df_rt_lte_calc	
e9dc :                       df_rt_next_check
                             	; check if true or false
e9dc : 2042f7           [ 6] 	jsr df_ost_popInt
e9df : e000             [ 2] 	cpx #0
                             	; if false then next is done
e9e1 : f003             [ 3] 	beq df_next_done
                             	; else we continue
e9e3 : 4c57e5           [ 3] 	jmp df_rt_pop_stat_go
                             	; if done, then continue with next statement
e9e6 :                       df_next_done
e9e6 : 4c08ea           [ 3] 	jmp df_rt_untilnext_done
                             	
e9e9 :                       df_rt_next_err
                             	SWBRK DFERR_NEXTFOR
                             
                             
                             	
e9eb :                       df_rt_repeat
                             	; push statement address
e9eb : 20b4e4           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_REPEAT token
e9ee : a98c             [ 2] 	lda #DFRT_REPEAT
e9f0 : 4cc0f6           [ 3] 	jmp df_rst_pushByte
                             ;	rts
                             	
e9f3 :                       df_rt_until
                             	; remember stack position
e9f3 : a474             [ 3] 	ldy df_rtstop
e9f5 : 98               [ 2] 	tya
e9f6 : 48               [ 3] 	pha
e9f7 : 20c9f6           [ 6] 	jsr df_rst_popByte
e9fa : c98c             [ 2] 	cmp #DFRT_REPEAT
e9fc : d012             [ 4] 	bne df_rt_until_err
                             	; evaluate expression in to A,X
e9fe : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 then continue
ea01 : e000             [ 2] 	cpx #0
ea03 : d003             [ 3] 	bne df_rt_untilnext_done
                             
                             	; pop the stat and continue
ea05 : 4c57e5           [ 3] 	jmp df_rt_pop_stat_go
                             
ea08 :                       df_rt_untilnext_done
ea08 : 68               [ 4] 	pla
ea09 : a8               [ 2] 	tay
                             	; pop 2 items off stack (line address, index)
ea0a : 20e6f6           [ 6] 	jsr df_rst_popWord
ea0d : 4cc9f6           [ 3] 	jmp df_rst_popByte
                             	; and continue
                             ;	clc
                             ;	rts
                             
ea10 :                       df_rt_until_err
                             	SWBRK DFERR_UNTIL
                             
                             	
ea12 :                       df_rt_sadd
AS65 Assembler for R6502 [1.42].                                     Page  208
-------------------------------- bank\bank0.s --------------------------------

                             ;	clc
ea12 : 60               [ 6] 	rts
                             	
ea13 :                       df_rt_print_num
ea13 : 2042f7           [ 6] 	jsr df_ost_popInt
ea16 : 18               [ 2] 	clc
ea17 : 4cf6c3           [ 3] 	jmp print_a_to_d
                             ;	rts
                             	
ea1a :                       df_rt_print_str
ea1a : 2047f7           [ 6] 	jsr df_ost_popStr
ea1d : 869f             [ 3] 	stx df_tmpptra
ea1f : 85a0             [ 3] 	sta df_tmpptra+1
ea21 : a000             [ 2] 	ldy #0
ea23 :                       df_rt_print_str_ch
ea23 : b19f             [ 5] 	lda (df_tmpptra),y
ea25 : f007             [ 3] 	beq df_rt_print_str_done
ea27 : 204bc4           [ 6] 	jsr io_put_ch
ea2a : c8               [ 2] 	iny
ea2b : 4c23ea           [ 3] 	jmp df_rt_print_str_ch
ea2e :                       df_rt_print_str_done
                             ;	clc
ea2e : 60               [ 6] 	rts
                             
                             ; * Find the position of the next data item to re
ea2f :                       df_rt_nextdatum
ea2f : a200             [ 2] 	ldx #0
                             	; load data line offset
ea31 : a494             [ 3] 	ldy df_datoff 
                             	; if data pointer unitialised (because high byte
ea33 : a593             [ 3] 	lda df_currdat+1
ea35 : d030             [ 3] 	bne df_rt_skipinitdataptr
                             	; then start at program beginning
                             	_cpyZPWord df_prgstrt,df_currdat
                             
ea3f :                       df_rt_datlinstart
                             	; if end of program then error
ea3f : a192             [ 6] 	lda (df_currdat,x)
ea41 : f034             [ 3] 	beq df_rt_datumerr
                             	; index in to first line byte
ea43 : a003             [ 2] 	ldy #3
ea45 : 8494             [ 3] 	sty df_datoff
                             	; find first 'data' statement
ea47 :                       df_rt_datastatement
ea47 : c8               [ 2] 	iny
ea48 : 98               [ 2] 	tya
                             	; end of line reached?
ea49 : c192             [ 6] 	cmp (df_currdat,x)
                             	; if not find data token
ea4b : d010             [ 3] 	bne df_rt_getdatatk
ea4d :                       df_rt_datnextlin
                             	; if so then go to next line
ea4d : 18               [ 2] 	clc
ea4e : a592             [ 3] 	lda df_currdat
ea50 : 6192             [ 6] 	adc (df_currdat,x)
ea52 : 8592             [ 3] 	sta df_currdat
ea54 : a593             [ 3] 	lda df_currdat+1
ea56 : 6900             [ 2] 	adc #0
ea58 : 8593             [ 3] 	sta df_currdat+1
ea5a : 4c3fea           [ 3] 	jmp df_rt_datlinstart
ea5d :                       df_rt_getdatatk
ea5d : b192             [ 5] 	lda (df_currdat),y
AS65 Assembler for R6502 [1.42].                                     Page  209
-------------------------------- bank\bank0.s --------------------------------

ea5f : 10e6             [ 3] 	bpl df_rt_datastatement
                             	; found data statement?
ea61 : c996             [ 2] 	cmp #DFRT_DATA
                             	; if not then go to next line	
ea63 : d0e8             [ 3] 	bne df_rt_datnextlin
ea65 : 8494             [ 3] 	sty df_datoff	
ea67 :                       df_rt_skipinitdataptr
ea67 : 98               [ 2] 	tya
                             	; end of line reached?
ea68 : c192             [ 6] 	cmp (df_currdat,x)
                             	; if so go to next line
ea6a : f0e1             [ 3] 	beq df_rt_datnextlin
                             	; else see if escape value
ea6c : b192             [ 5] 	lda (df_currdat),y
ea6e : c920             [ 2] 	cmp #DFTK_ESCVAL
ea70 : c8               [ 2] 	iny
ea71 : b0f4             [ 3] 	bcs df_rt_skipinitdataptr
                             	; ok found an escape value
                             	; save position and return
ea73 : 88               [ 2] 	dey
ea74 : 8494             [ 3] 	sty df_datoff
                             ;	clc
ea76 : 60               [ 6] 	rts
ea77 :                       df_rt_datumerr
                             	SWBRK DFERR_NODATA
                             
                             
                             ; read a datum
ea79 :                       df_rt_readdatum
                             	; update data pointer to next data item
ea79 : 202fea           [ 6] 	jsr df_rt_nextdatum
                             
                             	; now get lvar X,A from current statement
ea7c : 203be5           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
ea7f : 86a1             [ 3] 	stx df_tmpptrb
ea81 : 85a2             [ 3] 	sta df_tmpptrb+1
                             		
                             	; first save save current prgoram line and offse
ea83 : a584             [ 3] 	lda df_currlin
ea85 : 48               [ 3] 	pha
ea86 : a585             [ 3] 	lda df_currlin+1
ea88 : 48               [ 3] 	pha
ea89 : a586             [ 3] 	lda df_exeoff
ea8b : 48               [ 3] 	pha
ea8c : a57c             [ 3] 	lda df_eolidx
ea8e : 48               [ 3] 	pha
ea8f : a57d             [ 3] 	lda df_nxtstidx
ea91 : 48               [ 3] 	pha
ea92 : a57e             [ 3] 	lda df_curstidx
ea94 : 48               [ 3] 	pha
                             
                             	; use data pointer as current position for evalu
                             	_cpyZPWord df_currdat,df_currlin
                             
ea9d : a594             [ 3] 	lda df_datoff
ea9f : 8586             [ 3] 	sta df_exeoff
eaa1 : a200             [ 2] 	ldx #0
eaa3 : a192             [ 6] 	lda (df_currdat,x)
eaa5 : 857c             [ 3] 	sta df_eolidx
eaa7 : a900             [ 2] 	lda #0
eaa9 : 857d             [ 3] 	sta df_nxtstidx
AS65 Assembler for R6502 [1.42].                                     Page  210
-------------------------------- bank\bank0.s --------------------------------

eaab : a903             [ 2] 	lda #3
eaad : 857e             [ 3] 	sta df_curstidx
                             	
                             	; get type from vvt ptr in tmpa
eaaf : a19f             [ 6] 	lda (df_tmpptra,x)
eab1 : a8               [ 2] 	tay
                             	; get lvar point from tmpb
eab2 : a6a1             [ 3] 	ldx df_tmpptrb
eab4 : a5a2             [ 3] 	lda df_tmpptrb+1
                             	
                             	; X,A and Y set up, now evaluate and perform ass
eab6 : 2060ed           [ 6] 	jsr df_rt_doassign
                             
                             	; update data offset as data has been consumed
eab9 : a586             [ 3] 	lda df_exeoff
eabb : 8594             [ 3] 	sta df_datoff
                             	; restore line settings
eabd : 68               [ 4] 	pla
eabe : 857e             [ 3] 	sta df_curstidx
eac0 : 68               [ 4] 	pla
eac1 : 857d             [ 3] 	sta df_nxtstidx
eac3 : 68               [ 4] 	pla
eac4 : 857c             [ 3] 	sta df_eolidx
eac6 : 68               [ 4] 	pla
eac7 : 8586             [ 3] 	sta df_exeoff
eac9 : 68               [ 4] 	pla
eaca : 8585             [ 3] 	sta df_currlin+1
eacc : 68               [ 4] 	pla
eacd : 8584             [ 3] 	sta df_currlin
eacf : 60               [ 6] 	rts
                             
                             
ead0 :                       df_rt_read
                             	; find variable to read in to from current posit
ead0 : a486             [ 3] 	ldy df_exeoff
ead2 :                       df_rt_read_find_var
ead2 : c8               [ 2] 	iny
                             	; if end of line or statement then done
ead3 : c47c             [ 3] 	cpy df_eolidx
ead5 : f012             [ 3] 	beq df_rt_read_done
ead7 : c47d             [ 3] 	cpy df_nxtstidx
ead9 : f00e             [ 3] 	beq df_rt_read_done
                             	; if not found escape then next byte
eadb : b184             [ 5] 	lda (df_currlin),y
eadd : c920             [ 2] 	cmp #DFTK_ESCVAL
eadf : b0f1             [ 3] 	bcs df_rt_read_find_var
                             	; ok found escape, save position
eae1 : 8486             [ 3] 	sty df_exeoff
                             	; go and read in the value
eae3 : 2079ea           [ 6] 	jsr df_rt_readdatum
                             	; try find another variable
eae6 : 4cd0ea           [ 3] 	jmp df_rt_read
                             
eae9 :                       df_rt_read_done
                             	; save position
eae9 : 8486             [ 3] 	sty df_exeoff
eaeb : 60               [ 6] 	rts
                             
eaec :                       df_rt_input
                             	; df_tmpptra has the vvt address, X,A is the lva
eaec : 203be5           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
AS65 Assembler for R6502 [1.42].                                     Page  211
-------------------------------- bank\bank0.s --------------------------------

eaef : 86a1             [ 3] 	stx df_tmpptrb
eaf1 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; go read a line of input
                             	; buf_lo ptr has the input, Y is size
eaf3 : 38               [ 2] 	sec
eaf4 : 2060c4           [ 6] 	jsr io_read_line
                             	; check the type
eaf7 : a200             [ 2] 	ldx #0
eaf9 : a19f             [ 6] 	lda (df_tmpptra,x)
eafb : 2904             [ 2] 	and #DFVVT_STR
eafd : d008             [ 4] 	bne df_rt_input_str
eaff : a19f             [ 6] 	lda (df_tmpptra,x)
eb01 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
eb03 : d00a             [ 3] 	bne df_rt_input_num
                             	; if not int or byte then error
eb05 : f01f             [ 3] 	beq df_rt_input_err
eb07 :                       df_rt_input_str
eb07 : b137             [ 5] 	lda (buf_lo),y
eb09 : 91a1             [ 5] 	sta (df_tmpptrb),y
eb0b : 88               [ 2] 	dey
eb0c : 10f9             [ 3] 	bpl df_rt_input_str
                             ;	clc
eb0e : 60               [ 6] 	rts
                             
eb0f :                       df_rt_input_num
                             	; X,A = address, linbuff must be on page boundar
eb0f : a538             [ 3] 	lda buf_lo+1
eb11 : a637             [ 3] 	ldx buf_lo
eb13 : a000             [ 2] 	ldy #0				; any numeric format
eb15 : 20d4c1           [ 6] 	jsr con_n_to_a
eb18 : b00c             [ 3] 	bcs df_rt_input_err
eb1a : a000             [ 2] 	ldy #0
eb1c : a53b             [ 3] 	lda num_a
eb1e : 91a1             [ 5] 	sta (df_tmpptrb),y
eb20 : c8               [ 2] 	iny
eb21 : a53c             [ 3] 	lda num_a+1
eb23 : 91a1             [ 5] 	sta (df_tmpptrb),y
                             ;	clc
eb25 : 60               [ 6] 	rts
eb26 :                       df_rt_input_err
                             	SWBRK DFERR_TYPEMISM
                             
                             	
eb28 :                       df_rt_local
                             	; get current local count off rt stack
eb28 : 20c9f6           [ 6] 	jsr df_rst_popByte
                             	; save on pc stack for incrmenting
eb2b : 48               [ 3] 	pha
eb2c : a486             [ 3] 	ldy df_exeoff
eb2e : 88               [ 2] 	dey
eb2f :                       df_rt_local_findesc
eb2f : c8               [ 2] 	iny
                             	; check end of line
eb30 : c47c             [ 3] 	cpy df_eolidx
eb32 : f020             [ 3] 	beq df_rt_local_done
eb34 : c47d             [ 3] 	cpy df_nxtstidx
eb36 : f01c             [ 3] 	beq df_rt_local_done
                             	; find a var
eb38 : b184             [ 5] 	lda (df_currlin),y
eb3a : c911             [ 2] 	cmp #DFTK_VAR
eb3c : d0f1             [ 3] 	bne df_rt_local_findesc
                             	; jump over escape value
AS65 Assembler for R6502 [1.42].                                     Page  212
-------------------------------- bank\bank0.s --------------------------------

eb3e : c8               [ 2] 	iny
                             	; get var slot in A,X
eb3f : b184             [ 5] 	lda (df_currlin),y
eb41 : aa               [ 2] 	tax
eb42 : c8               [ 2] 	iny
eb43 : b184             [ 5] 	lda (df_currlin),y
eb45 : 8486             [ 3] 	sty df_exeoff
                             	; localise this variable
eb47 : 20acf6           [ 6] 	jsr df_rt_proc_local
                             	; increment local counter
eb4a : 68               [ 4] 	pla
eb4b : 18               [ 2] 	clc
eb4c : 6901             [ 2] 	adc #1
eb4e : 48               [ 3] 	pha
eb4f : a486             [ 3] 	ldy df_exeoff
eb51 : 4c2feb           [ 3] 	jmp df_rt_local_findesc
eb54 :                       df_rt_local_done
                             	; get the local counter
                             	; put on to rt stack
eb54 : 68               [ 4] 	pla
eb55 : 4cc0f6           [ 3] 	jmp df_rst_pushByte
                             ;	clc
                             ;	rts
                             	
eb58 :                       df_rt_dim
eb58 : a486             [ 3] 	ldy df_exeoff
eb5a : 88               [ 2] 	dey
eb5b :                       df_rt_dim_findesc
                             	; check end of line
eb5b : c8               [ 2] 	iny
eb5c : c47c             [ 3] 	cpy df_eolidx
eb5e : f07e             [ 3] 	beq df_rt_dim_done
eb60 : c47d             [ 3] 	cpy df_nxtstidx
eb62 : f07a             [ 3] 	beq df_rt_dim_done
                             	; find a var
eb64 : b184             [ 5] 	lda (df_currlin),y
eb66 : c911             [ 2] 	cmp #DFTK_VAR
eb68 : d0f1             [ 3] 	bne df_rt_dim_findesc
                             	; jump over escape value
eb6a : c8               [ 2] 	iny
                             	; get var address
eb6b : b184             [ 5] 	lda (df_currlin),y
eb6d : 859f             [ 3] 	sta df_tmpptra
eb6f : c8               [ 2] 	iny
eb70 : b184             [ 5] 	lda (df_currlin),y	
eb72 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; move to open bracket
eb74 : c8               [ 2] 	iny
eb75 : 8486             [ 3] 	sty df_exeoff
                             	; check if already dim'd
eb77 : a003             [ 2] 	ldy #DFVVT_DIM1
eb79 : b19f             [ 5] 	lda (df_tmpptra),y
eb7b : d062             [ 3] 	bne df_rt_dim_err
                             	; Save slot address found earlier
eb7d : a59f             [ 3] 	lda df_tmpptra
eb7f : 48               [ 3] 	pha
eb80 : a5a0             [ 3] 	lda df_tmpptra+1
eb82 : 48               [ 3] 	pha
eb83 : 20fbe1           [ 6] 	jsr df_rt_arry_parm2
                             	; Restore slot address
eb86 : 68               [ 4] 	pla
eb87 : 85a0             [ 3] 	sta df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  213
-------------------------------- bank\bank0.s --------------------------------

eb89 : 68               [ 4] 	pla
eb8a : 859f             [ 3] 	sta df_tmpptra
                             ;	bcs df_rt_dim_err
                             	; save x,y to dim1,2
eb8c : 98               [ 2] 	tya
eb8d : 48               [ 3] 	pha
eb8e : 8a               [ 2] 	txa
eb8f : 48               [ 3] 	pha
eb90 : a003             [ 2] 	ldy #DFVVT_DIM1
eb92 : 68               [ 4] 	pla
eb93 : 919f             [ 5] 	sta (df_tmpptra),y
eb95 : c8               [ 2] 	iny
eb96 : 68               [ 4] 	pla
eb97 : 919f             [ 5] 	sta (df_tmpptra),y	
eb99 :                       df_rt_dim_alloc
                             	; ok we have up to 2 dimensions
                             	; mult dim 1 and 2 if dim 2 <> 0
eb99 : a003             [ 2] 	ldy #DFVVT_DIM1
eb9b : b19f             [ 5] 	lda (df_tmpptra),y
eb9d : 853b             [ 3] 	sta num_a
eb9f : a900             [ 2] 	lda #0
eba1 : 853c             [ 3] 	sta num_a+1
eba3 : c8               [ 2] 	iny
eba4 : b19f             [ 5] 	lda (df_tmpptra),y
eba6 : d002             [ 3] 	bne df_rt_dim2_nz
eba8 : a901             [ 2] 	lda #1
ebaa :                       df_rt_dim2_nz
ebaa : 853f             [ 3] 	sta num_b
ebac : a900             [ 2] 	lda #0
ebae : 8540             [ 3] 	sta num_b+1
ebb0 : 202bd4           [ 6] 	jsr int_fast_mult
                             	; check the type if int then mult2
ebb3 : a200             [ 2] 	ldx #0
ebb5 : a19f             [ 6] 	lda (df_tmpptra,x)
ebb7 : 2901             [ 2] 	and #DFVVT_INT
ebb9 : f004             [ 3] 	beq df_rt_dim2_mul2
ebbb : 063b             [ 5] 	asl num_a
ebbd : 263c             [ 5] 	rol num_a+1
ebbf :                       df_rt_dim2_mul2	
                             	; finally, we have a size of array
ebbf : a63b             [ 3] 	ldx num_a
ebc1 : a53c             [ 3] 	lda num_a+1
                             
                             	; get a block of that size from heap
ebc3 : 2051f7           [ 6] 	jsr df_st_malloc
                             	; save pointer to block in var
ebc6 : a002             [ 2] 	ldy #DFVVT_HI
ebc8 : 919f             [ 5] 	sta (df_tmpptra),y
ebca : 8a               [ 2] 	txa
ebcb : 88               [ 2] 	dey
ebcc : 919f             [ 5] 	sta (df_tmpptra),y
                             	; finally, update the type to indicate array
ebce : a200             [ 2] 	ldx #0
ebd0 : a19f             [ 6] 	lda (df_tmpptra,x)
ebd2 : 0980             [ 2] 	ora #DFVVT_ARRY
ebd4 : 819f             [ 6] 	sta (df_tmpptra,x)
                             	; don't increment byte again - go check for more
ebd6 : 4c58eb           [ 3] 	jmp df_rt_dim	
ebd9 :                       df_rt_dim_next_byte
ebd9 : e686             [ 5] 	inc df_exeoff
ebdb : 4c58eb           [ 3] 	jmp df_rt_dim
ebde :                       df_rt_dim_done
AS65 Assembler for R6502 [1.42].                                     Page  214
-------------------------------- bank\bank0.s --------------------------------

                             ;	clc
ebde : 60               [ 6] 	rts
ebdf :                       df_rt_dim_err
                             	SWBRK DFERR_DIM
                             
                             
ebe1 :                       df_rt_cls
ebe1 : 4c53cd           [ 3] 	jmp gr_cls
                             ;	clc
                             ;	rts
                             	
ebe4 :                       df_rt_plot
                             	; evaluate the expression
ebe4 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
ebe7 : 8a               [ 2] 	txa
ebe8 : 48               [ 3] 	pha
                             	; jump over comma
ebe9 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the expression
ebeb : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
ebee : 8a               [ 2] 	txa
ebef : 48               [ 3] 	pha
                             	; jump over comma
ebf0 : e686             [ 5] 	inc df_exeoff
                             	; evaluate the expression
ebf2 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; check the type on the stack
ebf5 : 203cf7           [ 6] 	jsr df_ost_peekType
                             	; if >=0x80 then a pointer / string
ebf8 : c980             [ 2] 	cmp #0x80
ebfa : b01b             [ 4] 	bcs df_rt_plotstr
                             	; else it is int
ebfc : 2042f7           [ 6] 	jsr df_ost_popInt
                             	; save  low byte of pop result in a temp
ebff : 869f             [ 3] 	stx df_tmpptra
ec01 : a511             [ 3] 	lda gr_scrngeom+gr_mode			; Check screen mode
ec03 : d009             [ 3] 	bne df_rt_plot_h_int
                             	; get X and Y coord in that order
                             	; but Y coord goes in X register!!!
ec05 : 68               [ 4] 	pla
ec06 : aa               [ 2] 	tax
ec07 : 68               [ 4] 	pla
ec08 : a8               [ 2] 	tay
ec09 : a59f             [ 3] 	lda df_tmpptra	; Get pop result in to A
ec0b : 4cabcd           [ 3] 	jmp gr_plot
ec0e :                       df_rt_plot_h_int
ec0e : 68               [ 4] 	pla
ec0f : a8               [ 2] 	tay
ec10 : 68               [ 4] 	pla
ec11 : aa               [ 2] 	tax
ec12 : a59f             [ 3] 	lda df_tmpptra	; Get pop result in to A
ec14 : 4c56cf           [ 3] 	jmp gr_hchar
                             
                             
ec17 :                       df_rt_plotstr
                             	; pop string pointer
ec17 : 204cf7           [ 6] 	jsr df_ost_popPtr
                             	; save pointer to tmpa
ec1a : 869f             [ 3] 	stx df_tmpptra
ec1c : 85a0             [ 3] 	sta df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  215
-------------------------------- bank\bank0.s --------------------------------

                             	; get y and x in that order
                             	; but X register is Y coord!!
ec1e : 68               [ 4] 	pla
ec1f : 85a3             [ 3] 	sta df_tmpptrc			; Y coord in C
ec21 : 68               [ 4] 	pla
ec22 : 85a1             [ 3] 	sta df_tmpptrb			; X coord in B
                             	; set cursror position
ec24 : a000             [ 2] 	ldy #0
ec26 : 84a7             [ 3] 	sty df_tmpptre
ec28 :                       df_rt_plotstrch
ec28 : a4a7             [ 3] 	ldy df_tmpptre
ec2a : b19f             [ 5] 	lda (df_tmpptra),y
ec2c : 85a5             [ 3] 	sta df_tmpptrd			; char in D
ec2e : c900             [ 2] 	cmp #0
ec30 : f025             [ 3] 	beq df_rt_plotstrdone
ec32 : e6a7             [ 5] 	inc df_tmpptre
ec34 : a511             [ 3] 	lda gr_scrngeom+gr_mode; Check screen mode
ec36 : d00d             [ 3] 	bne df_rt_plot_h_str
ec38 : a5a5             [ 3] 	lda df_tmpptrd			; Get char to plot
ec3a : a6a3             [ 3] 	ldx df_tmpptrc			; Get Y coord
ec3c : a4a1             [ 3] 	ldy df_tmpptrb			; Get X coord
ec3e : 20abcd           [ 6] 	jsr gr_plot
ec41 : e6a1             [ 5] 	inc df_tmpptrb			; Increment X coord
ec43 : d0e3             [ 3] 	bne df_rt_plotstrch		; Always - assume x is neve
ec45 :                       df_rt_plot_h_str
ec45 : a5a5             [ 3] 	lda df_tmpptrd			; Get char to plot
ec47 : a6a1             [ 3] 	ldx df_tmpptrb			; Get X coord
ec49 : a4a3             [ 3] 	ldy df_tmpptrc			; Get Y coord
ec4b : 2056cf           [ 6] 	jsr gr_hchar
ec4e : 18               [ 2] 	clc
ec4f : a5a1             [ 3] 	lda df_tmpptrb
ec51 : 6521             [ 3] 	adc gr_scrngeom+gr_pitch
ec53 : 85a1             [ 3] 	sta df_tmpptrb
ec55 : d0d1             [ 3] 	bne df_rt_plotstrch		; Always - assume adding 8 
ec57 :                       df_rt_plotstrdone
ec57 : 60               [ 6] 	rts
                             	
ec58 :                       df_rt_cursor
                             	; evaluate the expression
ec58 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; write low byte of vdp_curoff
                             	; by writing a zero then cursor on else not
ec5b : 860d             [ 3] 	stx vdp_curoff
                             ;	clc
ec5d : 60               [ 6] 	rts
                             		
ec5e :                       df_rt_himem
                             	; evaluate the expression
ec5e : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; write X,A to df_memtop
ec61 : 8e1106           [ 4] 	stx df_memtop
ec64 : 8d1206           [ 4] 	sta df_memtop+1
                             	; now clear everything down
ec67 : 4c77f7           [ 3] 	jmp df_clear
ec6a : 60               [ 6] 	rts
                             
ec6b :                       df_rt_text
ec6b : 4cbbcc           [ 3] 	jmp gr_init_screen_txt
                             ;	clc
                             ;	rts
                             
ec6e :                       df_rt_hires
AS65 Assembler for R6502 [1.42].                                     Page  216
-------------------------------- bank\bank0.s --------------------------------

ec6e : 4cd4cc           [ 3] 	jmp gr_init_hires
                             ;	clc
                             ;	rts
                             	
ec71 :                       df_rt_pixmode
                             	; evaluate the expression X = mode
ec71 : 2066e0           [ 6] 	jsr df_rt_getnval
ec74 : 8620             [ 3] 	stx gr_scrngeom+gr_pixmode
                             ;	clc
ec76 : 60               [ 6] 	rts
                             
ec77 :                       df_rt_ink
                             	; evaluate the expression X = col
ec77 : 2066e0           [ 6] 	jsr df_rt_getnval
ec7a : 8622             [ 3] 	stx gr_scrngeom+gr_ink
                             ;	clc
ec7c : 60               [ 6] 	rts
                             
ec7d :                       df_rt_paper
                             	; evaluate the expression X = col
ec7d : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; Add 16 to get paper colour
ec80 : 8a               [ 2] 	txa
ec81 : 18               [ 2] 	clc
ec82 : 6910             [ 2] 	adc #16
ec84 : 8523             [ 3] 	sta gr_scrngeom+gr_paper
                             ;	clc
ec86 : 60               [ 6] 	rts
                             
ec87 :                       df_rt_point
ec87 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
ec8a : a69f             [ 3] 	ldx df_tmpptra
ec8c : a4a1             [ 3] 	ldy df_tmpptrb
ec8e : 4c17d0           [ 3] 	jmp gr_point
                             ;	clc
                             ;	rts
                             
ec91 :                       df_rt_circle
ec91 : 2061e3           [ 6] 	jsr df_rt_parm_3ints
ec94 : a59f             [ 3] 	lda df_tmpptra				; load x0
ec96 : 853b             [ 3] 	sta num_a
ec98 : a5a1             [ 3] 	lda	df_tmpptrb				; load y0
ec9a : 853c             [ 3] 	sta num_a+1
ec9c : a5a3             [ 3] 	lda df_tmpptrc				; load r
ec9e : 853d             [ 3] 	sta num_a+2
eca0 : 4c2dd0           [ 3] 	jmp gr_circle
                             
eca3 :                       df_rt_line
eca3 : 2084e3           [ 6] 	jsr df_rt_parm_4ints
eca6 : a59f             [ 3] 	lda df_tmpptra				; load x0
eca8 : 853b             [ 3] 	sta num_a
ecaa : a5a1             [ 3] 	lda	df_tmpptrb				; load y0
ecac : 853c             [ 3] 	sta num_a+1
ecae : a5a3             [ 3] 	lda df_tmpptrc				; load x1
ecb0 : 853d             [ 3] 	sta num_a+2
ecb2 : a5a5             [ 3] 	lda df_tmpptrd				; load y1
ecb4 : 853e             [ 3] 	sta num_a+3
ecb6 : 4ce4d0           [ 3] 	jmp gr_line
                             
ecb9 :                       df_rt_wait
                             	; evaluate the expression
ecb9 : 2066e0           [ 6] 	jsr df_rt_getnval
AS65 Assembler for R6502 [1.42].                                     Page  217
-------------------------------- bank\bank0.s --------------------------------

                             	; put high byte in to Y (X,Y)=16 bits
ecbc : a8               [ 2] 	tay
ecbd :                       df_rt_wait_counter
                             	; get vdp low byte timer val in A
ecbd : a508             [ 3] 	lda vdp_cnt	
ecbf :                       df_rt_wait_tick
                             	; check if a tick has occurred (i.e. val <> A)
ecbf : c508             [ 3] 	cmp vdp_cnt
ecc1 : f0fc             [ 3] 	beq df_rt_wait_tick
                             	; countdown tick
ecc3 : ca               [ 2] 	dex
ecc4 : e0ff             [ 2] 	cpx #0xff
ecc6 : d001             [ 3] 	bne df_rt_wait_skiphi
ecc8 : 88               [ 2] 	dey
ecc9 :                       df_rt_wait_skiphi
ecc9 : e000             [ 2] 	cpx #0
eccb : d0f0             [ 3] 	bne df_rt_wait_counter
eccd : c000             [ 2] 	cpy #0
eccf : d0ec             [ 3] 	bne df_rt_wait_counter
ecd1 : 60               [ 6] 	rts
                             	
ecd2 :                       df_rt_printat
                             	; Get x,y
ecd2 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
ecd5 : a69f             [ 3] 	ldx df_tmpptra
ecd7 : a4a1             [ 3] 	ldy df_tmpptrb
                             	; Set the cursror here
ecd9 : 20c4cd           [ 6] 	jsr gr_set_cur
                             	; and continue to normal print command
ecdc :                       df_rt_print
ecdc : a486             [ 3] 	ldy df_exeoff
ecde : 88               [ 2] 	dey
ecdf :                       df_rt_print_ws
ecdf : c8               [ 2] 	iny
                             
                             	; evaluate an expression
ece0 : c47c             [ 3] 	cpy df_eolidx
ece2 : f02e             [ 4] 	beq df_rt_print_done
ece4 : c47d             [ 3] 	cpy df_nxtstidx
ece6 : f02a             [ 4] 	beq df_rt_print_done
ece8 : b184             [ 5] 	lda (df_currlin),y
ecea : c920             [ 2] 	cmp #' '
ecec : f0f1             [ 3] 	beq df_rt_print_ws
ecee : c92c             [ 2] 	cmp #','
ecf0 : f0ed             [ 3] 	beq df_rt_print_ws
                             	; save index
ecf2 : 8486             [ 3] 	sty df_exeoff
                             	
                             	; if starts with string literal then process sev
ecf4 : c910             [ 2] 	cmp #DFTK_STRLIT
ecf6 : f014             [ 4] 	beq df_rt_print_string
                             	; else evaluate a numeric
ecf8 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; check what is on the argument stack
ecfb : 203cf7           [ 6] 	jsr df_ost_peekType
ecfe : 3006             [ 4] 	bmi df_rt_print_gotstr
ed00 : 2013ea           [ 6] 	jsr df_rt_print_num
ed03 : 4cdcec           [ 3] 	jmp df_rt_print
ed06 :                       df_rt_print_gotstr
ed06 : 201aea           [ 6] 	jsr df_rt_print_str
ed09 : 4cdcec           [ 3] 	jmp df_rt_print
ed0c :                       df_rt_print_string
AS65 Assembler for R6502 [1.42].                                     Page  218
-------------------------------- bank\bank0.s --------------------------------

ed0c : 2029e1           [ 6] 	jsr df_rt_seval
ed0f : 4c06ed           [ 3] 	jmp df_rt_print_gotstr
ed12 :                       df_rt_print_done
ed12 : 8486             [ 3] 	sty df_exeoff
ed14 : 60               [ 6] 	rts
                             	
ed15 :                       df_rt_println
ed15 : 20dcec           [ 6] 	jsr df_rt_print
ed18 : a90d             [ 2] 	lda #UTF_CR
ed1a : 4c4bc4           [ 3] 	jmp io_put_ch
                             
                             
                             ; assign to a number variable
                             ; X,A must have lvar
ed1d :                       df_rt_nassign
                             	; push var address, A ok to trample
ed1d : 48               [ 3] 	pha
ed1e : 8a               [ 2] 	txa
ed1f : 48               [ 3] 	pha
                             
                             	; now go evaluate expression in to A,X
ed20 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; restore variable address to write to to df_tmp
                             	; but don't lose current A
ed23 : a8               [ 2] 	tay					; Save A in Y
ed24 : 68               [ 4] 	pla
ed25 : 859f             [ 3] 	sta df_tmpptra
ed27 : 68               [ 4] 	pla
ed28 : 85a0             [ 3] 	sta df_tmpptra+1
ed2a : 98               [ 2] 	tya					; Get A back from Y
                             
                             	; save X,A int in contents section
ed2b : a001             [ 2] 	ldy #1
ed2d : 919f             [ 5] 	sta (df_tmpptra),y
ed2f : 8a               [ 2] 	txa
ed30 : 88               [ 2] 	dey
ed31 : 919f             [ 5] 	sta (df_tmpptra),y
                             	
ed33 : 60               [ 6] 	rts
                             
                             ; assign to a string variable
                             ; X,A must have lvar
ed34 :                       df_rt_sassign
                             	; now go evaluate expression
                             	; with the destination being already in X,A
ed34 : 202de1           [ 6] 	jsr df_rt_sval
                             
                             	; get string pointer from top of runtime stack
ed37 : 4c47f7           [ 3] 	jmp df_ost_popStr
                             	
                             ;	clc
                             ;	rts
                             
                             ; generate lvar from a var token ready for assign
ed3a :                       df_rt_generate_lvar
                             	; move past escape val
ed3a : a486             [ 3] 	ldy df_exeoff
ed3c : c8               [ 2] 	iny
                             	; pointing to variable index
ed3d : b184             [ 5] 	lda (df_currlin),y
ed3f : 859f             [ 3] 	sta df_tmpptra
ed41 : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  219
-------------------------------- bank\bank0.s --------------------------------

ed42 : b184             [ 5] 	lda (df_currlin),y
ed44 : 8486             [ 3] 	sty df_exeoff
ed46 : 85a0             [ 3] 	sta df_tmpptra+1
                             	
                             	; get the type and save
ed48 : a200             [ 2] 	ldx #0
ed4a : a19f             [ 6] 	lda (df_tmpptra,x)
ed4c : 48               [ 3] 	pha
                             
                             	; set carry flag to return pointer (lvar)
ed4d : 38               [ 2] 	sec
ed4e : 201fe2           [ 6] 	jsr df_rt_eval_var
ed51 : 204cf7           [ 6] 	jsr df_ost_popPtr
                             	
                             	; pull the type previously saved into Y
ed54 : 8536             [ 3] 	sta tmp_d		; Save A
ed56 : 68               [ 4] 	pla
ed57 : a8               [ 2] 	tay
ed58 : a536             [ 3] 	lda tmp_d
                             	; move past the lvar variable index
ed5a : e686             [ 5] 	inc df_exeoff
                             ;	clc
ed5c : 60               [ 6] 	rts
                             
                             ; general assignment execution
                             ; generate lvar first
ed5d :                       df_rt_assign
ed5d : 203aed           [ 6] 	jsr df_rt_generate_lvar
                             ; X,A,Y contain lvar pointer and type
ed60 :                       df_rt_doassign
                             	; save A and put type Y in to A to check for str
ed60 : 48               [ 3] 	pha
ed61 : 98               [ 2] 	tya
ed62 : 2904             [ 2] 	and #DFVVT_STR
                             	; if a string then string expression
ed64 : d004             [ 3] 	bne df_rt_assign_str
                             	;  jump to numeric expression evaluator
                             	; remember to restore A
ed66 : 68               [ 4] 	pla
ed67 : 4c1ded           [ 3] 	jmp df_rt_nassign
ed6a :                       df_rt_assign_str
                             	; else jump to string expression evaluator
                             	; remember to restore A
ed6a : 68               [ 4] 	pla
ed6b : 4c34ed           [ 3] 	jmp df_rt_sassign
                             	
                             ; comment or data token is ignored by runtime
ed6e :                       df_rt_comment
ed6e :                       df_rt_data
ed6e : 60               [ 6] 	rts
                             
                             	
                             ; run token - future expansion
ed6f :                       df_rt_run
ed6f : 60               [ 6] 	rts
                             
                             ; end of line / statement indicator
                             ; CS = End, CC = not end
ed70 :                       df_rt_eos
ed70 : a486             [ 3] 	ldy df_exeoff
ed72 : c47c             [ 3] 	cpy df_eolidx
ed74 : f00c             [ 3] 	beq df_rt_eos_true
AS65 Assembler for R6502 [1.42].                                     Page  220
-------------------------------- bank\bank0.s --------------------------------

ed76 : b184             [ 5] 	lda (df_currlin),y
ed78 : c93a             [ 2] 	cmp #':'
ed7a : f006             [ 3] 	beq df_rt_eos_true
ed7c : c47d             [ 3] 	cpy df_nxtstidx
ed7e : f002             [ 3] 	beq df_rt_eos_true
ed80 : 18               [ 2] 	clc
ed81 : 60               [ 6] 	rts
ed82 :                       df_rt_eos_true
ed82 : 38               [ 2] 	sec
ed83 : 60               [ 6] 	rts
                             
                             ; renum startLine,newStart,increment
                             ; renumbers from the first matching line to end o
ed84 :                       df_rt_renum
ed84 : e686             [ 5] 	inc df_exeoff
ed86 : 2061e3           [ 6] 	jsr df_rt_parm_3ints
                             	; starting line number
ed89 : a69f             [ 3] 	ldx df_tmpptra
ed8b : a5a0             [ 3] 	lda df_tmpptra+1
ed8d : 206bde           [ 6] 	jsr df_pg_find_line
ed90 : 9002             [ 3] 	bcc df_rt_renum_ok
                             	SWBRK DFERR_NOLINE
                             
ed94 :                       df_rt_renum_ok
                             	; save starting position pointer in ptrd
ed94 : 86a5             [ 3] 	stx df_tmpptrd
ed96 : 85a6             [ 3] 	sta df_tmpptrd+1
ed98 :                       df_rt_renum_do
                             	; if not end of program
ed98 : a000             [ 2] 	ldy #0
ed9a : b1a5             [ 5] 	lda (df_tmpptrd),y
                             	; then renumber this line
ed9c : d001             [ 3] 	bne df_rt_renum_update
                             	; else done
ed9e : 60               [ 6] 	rts
ed9f :                       df_rt_renum_update
                             	; so set this line number to new line number
ed9f : a001             [ 2] 	ldy #DFTK_LINNUM
eda1 : a5a1             [ 3] 	lda df_tmpptrb
eda3 : 91a5             [ 5] 	sta (df_tmpptrd),y
eda5 : c8               [ 2] 	iny
eda6 : a5a2             [ 3] 	lda df_tmpptrb+1
eda8 : 91a5             [ 5] 	sta (df_tmpptrd),y
                             	; add increment to new line
                             	_addZPWord df_tmpptrb,df_tmpptrc
                             
edb7 :                       df_rt_renum_next
                             	; point ptrd to the next line
edb7 : 18               [ 2] 	clc
edb8 : a5a5             [ 3] 	lda df_tmpptrd
edba : a200             [ 2] 	ldx #0
edbc : 61a5             [ 6] 	adc (df_tmpptrd,x)
edbe : 85a5             [ 3] 	sta df_tmpptrd
edc0 : a5a6             [ 3] 	lda df_tmpptrd+1
edc2 : 6900             [ 2] 	adc #0
edc4 : 85a6             [ 3] 	sta df_tmpptrd+1
edc6 : 4c98ed           [ 3] 	jmp df_rt_renum_do
                             
                             
                             ; * List all procs in VNT
edc9 :                       df_rt_listprocnames
                             	; start at the beginning of the vnt table
AS65 Assembler for R6502 [1.42].                                     Page  221
-------------------------------- bank\bank0.s --------------------------------

                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	; start at varcnt
edd1 : a56f             [ 3] 	lda df_varcnt
edd3 : 85a1             [ 3] 	sta df_tmpptrb
edd5 :                       df_rt_listcheckvnt
                             	; If reached 0 then not found
edd5 : a5a1             [ 3] 	lda df_tmpptrb
edd7 : f03d             [ 4] 	beq df_rt_listpn_done
edd9 : a000             [ 2] 	ldy #0
eddb : b19f             [ 5] 	lda (df_tmpptra),y
eddd : c95f             [ 2] 	cmp #'_'
eddf : d01c             [ 3] 	bne df_rt_listnextvnt
ede1 :                       df_rt_listprocch
ede1 : b19f             [ 5] 	lda (df_tmpptra),y
ede3 : 204bc4           [ 6] 	jsr io_put_ch
ede6 : c900             [ 2] 	cmp #0
ede8 : f003             [ 3] 	beq df_rt_listproccr
edea : c8               [ 2] 	iny
edeb : d0f4             [ 3] 	bne df_rt_listprocch		; Always
eded :                       df_rt_listproccr
eded : a90d             [ 2] 	lda #UTF_CR
edef : 204bc4           [ 6] 	jsr io_put_ch
edf2 : 18               [ 2] 	clc
edf3 :                       df_rt_listprocpause
edf3 : 2048c4           [ 6] 	jsr io_get_ch
edf6 : c920             [ 2] 	cmp #' '
edf8 : d003             [ 3] 	bne df_rt_listnextvnt
edfa :                       df_rt_listwait
edfa : 38               [ 2] 	sec
edfb : b0f6             [ 3] 	bcs df_rt_listprocpause
edfd :                       df_rt_listnextvnt
edfd : b19f             [ 5] 	lda (df_tmpptra),y
edff : f003             [ 4] 	beq df_rt_listgotnext
ee01 : c8               [ 2] 	iny
ee02 : d0f9             [ 4] 	bne df_rt_listnextvnt		; Always
ee04 :                       df_rt_listgotnext
                             	; dec vnt #
ee04 : c6a1             [ 5] 	dec df_tmpptrb
                             	; skip past zero terminator
ee06 : c8               [ 2] 	iny
                             	; add this to vnt pointer
ee07 : 18               [ 2] 	clc
ee08 : 98               [ 2] 	tya
ee09 : 659f             [ 3] 	adc df_tmpptra
ee0b : 859f             [ 3] 	sta df_tmpptra
ee0d : a5a0             [ 3] 	lda df_tmpptra+1
ee0f : 6900             [ 2] 	adc #0
ee11 : 85a0             [ 3] 	sta df_tmpptra+1
ee13 : 4cd5ed           [ 3] 	jmp df_rt_listcheckvnt
ee16 :                       df_rt_listpn_done
ee16 : 60               [ 6] 	rts
                             
ee17 :                       df_rt_listproc
                             	; A already contains '_'
ee17 : 8d0004           [ 4] 	sta df_linbuff
ee1a : a200             [ 2] 	ldx #0
ee1c : a486             [ 3] 	ldy df_exeoff
ee1e :                       df_rt_listp_copy
ee1e : c8               [ 2] 	iny
ee1f : e8               [ 2] 	inx
ee20 : b184             [ 5] 	lda (df_currlin),y
AS65 Assembler for R6502 [1.42].                                     Page  222
-------------------------------- bank\bank0.s --------------------------------

ee22 : 9d0004           [ 5] 	sta df_linbuff,x
ee25 : 20e2d6           [ 6] 	jsr df_tk_isalphanum
ee28 : b0f4             [ 3] 	bcs df_rt_listp_copy
                             	; zero the line index
ee2a : a200             [ 2] 	ldx #0
ee2c : 867a             [ 3] 	stx df_linoff
                             	; save runtime pos
ee2e : 8486             [ 3] 	sty df_exeoff
                             	; Now try and find in VNT
ee30 : 20e2d4           [ 6] 	jsr df_var_find
ee33 : b038             [ 3] 	bcs df_rt_listp_notfound
                             	; Ok we have got a match in X,A find the proc
ee35 : 868c             [ 3] 	stx df_procptr
ee37 : 858d             [ 3] 	sta df_procptr+1
ee39 : 20d9e4           [ 6] 	jsr df_rt_findproc
                             	; Save the line pointer
ee3c : 869f             [ 3] 	stx df_tmpptra
ee3e : 85a0             [ 3] 	sta df_tmpptra+1
                             	; save statement index in to line
ee40 : 8490             [ 3] 	sty df_lineidx
                             ;	; Check if '-' option used
                             ;	ldy df_exeoff
                             ;	lda (df_currlin),y
                             ;	cmp #'-'
                             ;	; if so, list to end of program
                             ;	beq df_rt_listprgend
                             	; Now try and find the end of this procedure
                             	; enddef or another def
                             	; A,X=Line ptr, Y=line idx
                             ;	ldx df_tmpptra
                             ;	lda df_tmpptra+1
                             ;	ldy df_lineidx
ee42 :                       df_rt_listp_findend
                             	; Go to next stat
ee42 : 2082e4           [ 6] 	jsr df_rt_nextstat
ee45 : b057             [ 3] 	bcs df_rt_listprgend
                             	; save y (a,x in lineptr), A is ok to trample
ee47 : 98               [ 2] 	tya
ee48 : 48               [ 3] 	pha
                             	; find the command
ee49 :                       df_rt_listp_findcmd
ee49 : c8               [ 2] 	iny
ee4a : b18e             [ 5] 	lda (df_lineptr),y
ee4c : 10fb             [ 3] 	bpl df_rt_listp_findcmd
                             	; restore y to stat beginning
ee4e : 8536             [ 3] 	sta tmp_d
ee50 : 68               [ 4] 	pla
ee51 : a8               [ 2] 	tay
ee52 : a536             [ 3] 	lda tmp_d
                             	; check A - looking for enddef or def
ee54 : c987             [ 2] 	cmp #DFRT_ENDDEF
ee56 : f00b             [ 3] 	beq df_rt_listp_done
ee58 : c986             [ 2] 	cmp #DFRT_DEF
ee5a : f007             [ 3] 	beq df_rt_listp_done
                             	; if neither then next stat from current
ee5c : a68e             [ 3] 	ldx df_lineptr
ee5e : a58f             [ 3] 	lda df_lineptr+1
ee60 : 4c42ee           [ 3] 	jmp df_rt_listp_findend
ee63 :                       df_rt_listp_done
                             	; Push end line on to stack
ee63 : a58f             [ 3] 	lda df_lineptr+1
ee65 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page  223
-------------------------------- bank\bank0.s --------------------------------

ee66 : 8a               [ 2] 	txa
ee67 : 48               [ 3] 	pha
ee68 : a58f             [ 3] 	lda df_lineptr+1
ee6a : 4ca4ee           [ 3] 	jmp df_rt_list_line 
ee6d :                       df_rt_listp_notfound
                             	; Fatal error if proc not found
                             	SWBRK DFERR_NOPROC
                             
                             	
                             ; list token
ee6f :                       df_rt_list
ee6f : a900             [ 2] 	lda #0
ee71 : 85a7             [ 3] 	sta df_tmpptre		; Zero means in normal list mode
                             	; find non-ws
ee73 : 202ee5           [ 6] 	jsr df_rt_skip_ws
                             	; if end of statement then no line specifiers
ee76 : 2070ed           [ 6] 	jsr df_rt_eos
                             	; so list whole program
ee79 : b01b             [ 3] 	bcs df_rt_listprg
                             	
                             	;if '_' then use procnames
ee7b : c95f             [ 2] 	cmp #'_'
ee7d : d003             [ 3] 	bne df_rt_list_all
ee7f : 4c17ee           [ 3] 	jmp df_rt_listproc
ee82 :                       df_rt_list_all
                             	;if '*' then display all procnames
ee82 : c92a             [ 2] 	cmp #'*'
ee84 : d003             [ 3] 	bne df_rt_list_linno
ee86 : 4cc9ed           [ 3] 	jmp df_rt_listprocnames
ee89 :                       df_rt_list_linno
                             	; else get 1st parameter
ee89 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
ee8c : 206bde           [ 6] 	jsr df_pg_find_line
                             	; save start in ptra
ee8f : 869f             [ 3] 	stx df_tmpptra
ee91 : 85a0             [ 3] 	sta df_tmpptra+1
ee93 : 4c9eee           [ 3] 	jmp df_rt_listprgend
                             	; NO ability to choose and ending line number!
                             
                             ; Common listing routine used by LIST and SAVE
                             ; tmpe = 0 means in LIST mode else SAVE mode
                             ; can stop the listing in LIST mode with CTRL-C
ee96 :                       df_rt_listprg
                             	; program start and end as for pointer value
                             	_cpyZPWord df_prgstrt, df_tmpptra
                             
ee9e :                       df_rt_listprgend
ee9e : a566             [ 3] 	lda df_prgend+1
eea0 : 48               [ 3] 	pha
eea1 : a565             [ 3] 	lda df_prgend
eea3 : 48               [ 3] 	pha
eea4 :                       df_rt_list_line
                             	; if line length = 0 then end of program
eea4 : a000             [ 2] 	ldy #0
eea6 : b19f             [ 5] 	lda (df_tmpptra),y
eea8 : f03a             [ 3] 	beq df_rt_list_line_fin
                             	; if in list mode and CTRL-C then also stop
eeaa : a5a7             [ 3] 	lda df_tmpptre
eeac : d010             [ 3] 	bne df_rt_list_line_cont
                             	; check for break, asynch get
eeae : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  224
-------------------------------- bank\bank0.s --------------------------------

eeaf :                       df_rt_list_synckey
eeaf : a5a7             [ 3] 	lda df_tmpptre					; Ignore keys on save mode
eeb1 : d00b             [ 3] 	bne df_rt_list_line_cont
eeb3 :                       df_rt_list_pause
eeb3 : 2048c4           [ 6] 	jsr io_get_ch
eeb6 : c920             [ 2] 	cmp #' '						; Space = PAUSE
eeb8 : f0f9             [ 3] 	beq df_rt_list_pause			; C=1 for synchronouse ke
eeba : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
eebc : f026             [ 3] 	beq df_rt_list_line_fin
eebe :                       df_rt_list_line_cont
eebe : a000             [ 2] 	ldy #0
eec0 : 8486             [ 3] 	sty df_exeoff
eec2 : 20e7ee           [ 6] 	jsr df_rt_list_all_line
eec5 :                       df_rt_list_next_line
                             	; new line
eec5 : 206cc1           [ 6] 	jsr utilPrintCRLF
                             	; increment pointer to next line
eec8 : 18               [ 2] 	clc
eec9 : a59f             [ 3] 	lda df_tmpptra
eecb : a000             [ 2] 	ldy #0
eecd : 719f             [ 5] 	adc (df_tmpptra),y
eecf : 859f             [ 3] 	sta df_tmpptra
eed1 : a5a0             [ 3] 	lda df_tmpptra+1
eed3 : 6900             [ 2] 	adc #0
eed5 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; if pointer > end then listing is done
eed7 : 38               [ 2] 	sec
eed8 : 68               [ 4] 	pla
eed9 : aa               [ 2] 	tax
eeda : e59f             [ 3] 	sbc df_tmpptra
eedc : 68               [ 4] 	pla
eedd : 48               [ 3] 	pha
eede : e5a0             [ 3] 	sbc df_tmpptra+1
eee0 : 8a               [ 2] 	txa
eee1 : 48               [ 3] 	pha
eee2 : b0c0             [ 3] 	bcs df_rt_list_line
eee4 :                       df_rt_list_line_fin	
                             	; if got here then reached tmpb
eee4 : 68               [ 4] 	pla
eee5 : 68               [ 4] 	pla
eee6 : 60               [ 6] 	rts
                             
                             ;Using df_tmpptra as line pointer
                             ;Print decode an entire line
eee7 :                       df_rt_list_all_line				; Start here to include nu
eee7 : 202df0           [ 6] 	jsr df_rt_list_linnum
eeea :                       df_rt_list_line_only			; Start here for just the 
eeea : a003             [ 2] 	ldy #3
eeec : b19f             [ 5] 	lda (df_tmpptra),y
eeee : 857d             [ 3] 	sta df_nxtstidx
eef0 : c8               [ 2] 	iny
eef1 : 8486             [ 3] 	sty df_exeoff
eef3 :                       df_rt_list_decode
eef3 : a486             [ 3] 	ldy df_exeoff
eef5 : b19f             [ 5] 	lda (df_tmpptra),y
eef7 : 3010             [ 4] 	bmi df_rt_list_token
eef9 : c920             [ 2] 	cmp #DFTK_ESCVAL
eefb : 9006             [ 4] 	bcc df_rt_list_escval
                             	; normal char just print it
eefd : 204bc4           [ 6] 	jsr io_put_ch
ef00 : 4c0cef           [ 3] 	jmp df_rt_list_nexttok
ef03 :                       df_rt_list_escval
AS65 Assembler for R6502 [1.42].                                     Page  225
-------------------------------- bank\bank0.s --------------------------------

                             	; A and Y need to be valid on entry
ef03 : 2026ef           [ 6] 	jsr df_rt_list_decode_esc
ef06 : 4c0cef           [ 3] 	jmp df_rt_list_nexttok
ef09 :                       df_rt_list_token
ef09 : 203af0           [ 6] 	jsr df_rt_list_decode_token
ef0c :                       df_rt_list_nexttok	
                             	; advance the line offset
ef0c : e686             [ 5] 	inc df_exeoff
ef0e : a586             [ 3] 	lda df_exeoff
                             	; check if at end of line
ef10 : a200             [ 2] 	ldx #0
ef12 : c19f             [ 6] 	cmp (df_tmpptra,x)
ef14 : f00f             [ 3] 	beq df_rt_list_line_only_fin
                             	; check if at end of statement
ef16 : c57d             [ 3] 	cmp df_nxtstidx
ef18 : d0d9             [ 4] 	bne df_rt_list_decode
ef1a : a8               [ 2] 	tay
                             	; save the next statement offset
ef1b : b19f             [ 5] 	lda (df_tmpptra),y
ef1d : 857d             [ 3] 	sta df_nxtstidx
ef1f : c8               [ 2] 	iny
ef20 : 8486             [ 3] 	sty df_exeoff
ef22 : 4cf3ee           [ 3] 	jmp df_rt_list_decode
ef25 :                       df_rt_list_line_only_fin
ef25 : 60               [ 6] 	rts
                             	
                             	
                             ; decode escape sequences
                             ; Input: A contains the esc val and Y is char lin
ef26 :                       df_rt_list_decode_esc
                             	; jump over esc byte
ef26 : c8               [ 2] 	iny
ef27 : 8486             [ 3] 	sty df_exeoff
ef29 : 48               [ 3] 	pha
                             	; get the next two bytes in case needed
ef2a : b19f             [ 5] 	lda (df_tmpptra),y
ef2c : 85a1             [ 3] 	sta df_tmpptrb
ef2e : c8               [ 2] 	iny
ef2f : b19f             [ 5] 	lda (df_tmpptra),y
ef31 : 85a2             [ 3] 	sta df_tmpptrb+1
ef33 : 88               [ 2] 	dey				; Y is on byte after esc byte
ef34 : 68               [ 4] 	pla				
                             	; x2 to get jmp offset
ef35 : 0a               [ 2] 	asl a
ef36 : aa               [ 2] 	tax
ef37 : bd20e6           [ 4] 	lda df_rt_escjmp,x
ef3a : 85a3             [ 3] 	sta df_tmpptrc
ef3c : bd21e6           [ 4] 	lda df_rt_escjmp+1,x
ef3f : 85a4             [ 3] 	sta df_tmpptrc+1
                             	; now jump to decoder
ef41 : 6ca300           [ 6] 	jmp (df_tmpptrc)
                             
                             ; reserved
ef44 :                       df_rt_lst_reserved
ef44 : 60               [ 6] 	rts
                             
                             ; decode a byte char
ef45 :                       df_rt_lst_chr
ef45 : a927             [ 2] 	lda #0x27			; Single quote
ef47 : 204bc4           [ 6] 	jsr io_put_ch
ef4a : a5a1             [ 3] 	lda df_tmpptrb
ef4c : 204bc4           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page  226
-------------------------------- bank\bank0.s --------------------------------

ef4f : a927             [ 2] 	lda #0x27			; Single quote
ef51 : 204bc4           [ 6] 	jsr io_put_ch
ef54 : c8               [ 2] 	iny
ef55 : 8486             [ 3] 	sty df_exeoff
ef57 : 60               [ 6] 	rts
                             
                             ; Output 0x for hex chars
ef58 :                       df_rt_lst_hex_pre
ef58 : a930             [ 2] 	lda #'0'
ef5a : 204bc4           [ 6] 	jsr io_put_ch
ef5d : a978             [ 2] 	lda #'x'
ef5f : 4c4bc4           [ 3] 	jmp io_put_ch
                             ;	rts
                             
                             ; Decode a byte hex	
ef62 :                       df_rt_lst_bythex
ef62 : 2058ef           [ 6] 	jsr df_rt_lst_hex_pre
ef65 :                       df_rt_lst_lo_hex
ef65 : a5a1             [ 3] 	lda df_tmpptrb
ef67 : 2089c1           [ 6] 	jsr str_a_to_x
ef6a : 204bc4           [ 6] 	jsr io_put_ch
ef6d : 8a               [ 2] 	txa
ef6e : 204bc4           [ 6] 	jsr io_put_ch
ef71 : c8               [ 2] 	iny
ef72 : 8486             [ 3] 	sty df_exeoff
ef74 : 60               [ 6] 	rts
                             
                             ; Decode an int hex
ef75 :                       df_rt_lst_inthex
ef75 : 2058ef           [ 6] 	jsr df_rt_lst_hex_pre
ef78 : a5a2             [ 3] 	lda df_tmpptrb+1
ef7a : 2089c1           [ 6] 	jsr str_a_to_x
ef7d : 204bc4           [ 6] 	jsr io_put_ch
ef80 : 8a               [ 2] 	txa
ef81 : 204bc4           [ 6] 	jsr io_put_ch
ef84 : 4c65ef           [ 3] 	jmp df_rt_lst_lo_hex
                             
                             ; Decode a byte binary
ef87 :                       df_rt_lst_bytbin
ef87 : a208             [ 2] 	ldx #8
ef89 : a5a1             [ 3] 	lda df_tmpptrb
ef8b : 85a2             [ 3] 	sta df_tmpptrb+1
ef8d : 4c95ef           [ 3] 	jmp df_rt_lst_bin
                             
                             ; Decode a int binary
                             
ef90 :                       df_rt_lst_intbin
ef90 : a210             [ 2] 	ldx #16
ef92 : c8               [ 2] 	iny
ef93 : 8486             [ 3] 	sty df_exeoff
                             
                             ; Main 01 decoding of binary
ef95 :                       df_rt_lst_bin
ef95 : a930             [ 2] 	lda #'0'
ef97 : 204bc4           [ 6] 	jsr io_put_ch
ef9a : a962             [ 2] 	lda #'b'
ef9c : 204bc4           [ 6] 	jsr io_put_ch
ef9f :                       df_rt_lst_bit
ef9f : a930             [ 2] 	lda #'0'
efa1 : 06a1             [ 5] 	asl df_tmpptrb
efa3 : 26a2             [ 5] 	rol df_tmpptrb+1
efa5 : 9002             [ 3] 	bcc df_rt_lst_bit_skip0
AS65 Assembler for R6502 [1.42].                                     Page  227
-------------------------------- bank\bank0.s --------------------------------

efa7 : a931             [ 2] 	lda #'1'
efa9 :                       df_rt_lst_bit_skip0
efa9 : 204bc4           [ 6] 	jsr io_put_ch
efac : ca               [ 2] 	dex
efad : d0f0             [ 3] 	bne df_rt_lst_bit
efaf : c8               [ 2] 	iny
efb0 : 8486             [ 3] 	sty df_exeoff
                             ;	clc
efb2 : 60               [ 6] 	rts
                             	
                             ; Decode a decimal integer
efb3 :                       df_rt_lst_intdec	
efb3 : a6a1             [ 3] 	ldx df_tmpptrb
efb5 : a5a2             [ 3] 	lda df_tmpptrb+1
efb7 : c8               [ 2] 	iny
efb8 : 8486             [ 3] 	sty df_exeoff
efba : 18               [ 2] 	clc
efbb : 4cf6c3           [ 3] 	jmp print_a_to_d
                             ;	rts
                             
                             ; decode a variable or procedure
                             ; Slot address to decode in ptrb 
efbe :                       df_rt_lst_var
efbe :                       df_rt_lst_proc
                             	; jump over the address bytes
efbe : c8               [ 2] 	iny
efbf : 8486             [ 3] 	sty df_exeoff
                             	
                             	; ptrc starts at VNT start
                             	_cpyZPWord df_vntstrt,df_tmpptrc
                             
                             
                             	; ptrd starts at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptrd
                             
efd1 : a000             [ 2] 	ldy #0
efd3 :                       df_rt_list_findvvt
                             	; Check have we reached target addr in vvt?
efd3 : a5a5             [ 3] 	lda df_tmpptrd
efd5 : c5a1             [ 3] 	cmp df_tmpptrb
efd7 : d006             [ 3] 	bne df_rt_list_vvtend
efd9 : a5a6             [ 3] 	lda df_tmpptrd+1
efdb : c5a2             [ 3] 	cmp df_tmpptrb+1
efdd : f023             [ 4] 	beq df_rt_list_gotvvt
efdf :                       df_rt_list_vvtend
efdf : b1a3             [ 5] 	lda (df_tmpptrc),y
efe1 : f009             [ 3] 	beq df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
efe9 : 4cdfef           [ 3] 	jmp df_rt_list_vvtend
efec :                       df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
                             	; move target slot address towards top of mem
eff2 : 18               [ 2] 	clc
eff3 : a5a5             [ 3] 	lda df_tmpptrd
eff5 : 6908             [ 2] 	adc #DFVVT_SZ
eff7 : 85a5             [ 3] 	sta df_tmpptrd
eff9 : a5a6             [ 3] 	lda df_tmpptrd+1
effb : 6900             [ 2] 	adc #0
effd : 85a6             [ 3] 	sta df_tmpptrd+1
                             	; go back and check again
AS65 Assembler for R6502 [1.42].                                     Page  228
-------------------------------- bank\bank0.s --------------------------------

efff : 4cd3ef           [ 3] 	jmp df_rt_list_findvvt
f002 :                       df_rt_list_gotvvt
f002 : b1a3             [ 5] 	lda (df_tmpptrc),y
f004 : f00c             [ 3] 	beq df_rt_list_donvvt
f006 : 204bc4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrc
                             
f00f : 4c02f0           [ 3] 	jmp df_rt_list_gotvvt
f012 :                       df_rt_list_donvvt
f012 : 60               [ 6] 	rts
                             
f013 :                       df_rt_lst_strlit
f013 : a922             [ 2] 	lda #0x22
f015 : 204bc4           [ 6] 	jsr io_put_ch
f018 : a486             [ 3] 	ldy df_exeoff
f01a :                       df_rt_lst_strlitch
f01a : b19f             [ 5] 	lda (df_tmpptra),y
f01c : f007             [ 3] 	beq df_rt_lst_strlitdon
f01e : 204bc4           [ 6] 	jsr io_put_ch
f021 : c8               [ 2] 	iny
f022 : 4c1af0           [ 3] 	jmp df_rt_lst_strlitch
f025 :                       df_rt_lst_strlitdon
f025 : a922             [ 2] 	lda #0x22
f027 : 204bc4           [ 6] 	jsr io_put_ch
f02a : 8486             [ 3] 	sty df_exeoff
f02c : 60               [ 6] 	rts
                             
f02d :                       df_rt_list_linnum
f02d : a001             [ 2] 	ldy #1
f02f : b19f             [ 5] 	lda (df_tmpptra),y
f031 : aa               [ 2] 	tax
f032 : a002             [ 2] 	ldy #2
f034 : b19f             [ 5] 	lda (df_tmpptra),y
f036 : 18               [ 2] 	clc
f037 : 4cf6c3           [ 3] 	jmp print_a_to_d
                             
                             ; decode a token value with MSB set
f03a :                       df_rt_list_decode_token
                             	; if not assembler then normal listing
f03a : c997             [ 2] 	cmp #DFRT_ASM
f03c : d003             [ 3] 	bne df_rt_list_decode_token_normal
f03e : 4c79f0           [ 3] 	jmp df_rt_asm_decode_token
f041 :                       df_rt_list_decode_token_normal
f041 : 297f             [ 2] 	and #0x7f
                             	; token 0 and 1 don't get decoded they are impli
f043 : c902             [ 2] 	cmp #2
f045 : b001             [ 3] 	bcs df_rt_list_do_decode_tkn	
f047 : 60               [ 6] 	rts
f048 :                       df_rt_list_do_decode_tkn
f048 : aa               [ 2] 	tax
f049 : a988             [ 2] 	lda #lo(df_tokensyms)
f04b : 85a1             [ 3] 	sta df_tmpptrb
f04d : a9da             [ 2] 	lda #hi(df_tokensyms)
f04f : 85a2             [ 3] 	sta df_tmpptrb+1
f051 :                       df_rt_list_find_sym
f051 : e000             [ 2] 	cpx #0
f053 : f012             [ 3] 	beq df_rt_list_got_sym
f055 : a000             [ 2] 	ldy #0
f057 :                       df_rt_list_next_ch
f057 : b1a1             [ 5] 	lda (df_tmpptrb),y
f059 : 48               [ 3] 	pha
                             	_incZPWord df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  229
-------------------------------- bank\bank0.s --------------------------------

                             
f060 : 68               [ 4] 	pla
f061 : 10f4             [ 3] 	bpl df_rt_list_next_ch
f063 :                       df_rt_list_got_last_sym
                             	; ok got to the last ch
                             	; advance to next sym
f063 : ca               [ 2] 	dex
f064 : 4c51f0           [ 3] 	jmp df_rt_list_find_sym
f067 :                       df_rt_list_got_sym
f067 : a1a1             [ 6] 	lda (df_tmpptrb,x)		; Relies on X=0 from branch
f069 : 08               [ 3] 	php
f06a : 297f             [ 2] 	and #0x7f
f06c : 204bc4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
f075 : 28               [ 4] 	plp
f076 : 10ef             [ 3] 	bpl df_rt_list_got_sym
f078 : 60               [ 6] 	rts 
                             
                             ;** Decode assembler token in A **
f079 :                       df_rt_asm_decode_token
f079 : a92e             [ 2] 	lda #'.'			;Always put out the . symbol
f07b : 204bc4           [ 6] 	jsr io_put_ch
f07e : a486             [ 3] 	ldy df_exeoff		;Print out any whitespace
f080 :                       df_rt_asm_decode_token_ws
f080 : c8               [ 2] 	iny					;Point to char after the asm token
f081 : 8486             [ 3] 	sty df_exeoff
f083 : b19f             [ 5] 	lda (df_tmpptra),y	;What is the char?
f085 : 2011d7           [ 6] 	jsr df_tk_isws		;If not then found the keyword
f088 : 9006             [ 3] 	bcc df_rt_asm_decode_token_found
f08a : 204bc4           [ 6] 	jsr io_put_ch		;Print the space
f08d : 4c80f0           [ 3] 	jmp df_rt_asm_decode_token_ws
f090 :                       df_rt_asm_decode_token_found
f090 : c911             [ 2] 	cmp #DFTK_VAR		; If is a label variable?
f092 : d003             [ 3] 	bne df_rt_asm_decode_token_keyword
                             	; if so then process as normal escape handling
f094 : 4c26ef           [ 3] 	jmp df_rt_list_decode_esc
f097 :                       df_rt_asm_decode_token_keyword
f097 : 297f             [ 2] 	and #0x7f			; Mask off MSB
f099 : aa               [ 2] 	tax					;Put it in to X as the counter
                             	; Point to asm symbol table
f09a : a98d             [ 2] 	lda #lo(df_asm_tokensyms)
f09c : 85a1             [ 3] 	sta df_tmpptrb
f09e : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
f0a0 : 85a2             [ 3] 	sta df_tmpptrb+1
f0a2 :                       df_rt_list_find_asm_sym
f0a2 : e000             [ 2] 	cpx #0
f0a4 : f01d             [ 3] 	beq df_rt_list_got_asm_sym
f0a6 : a000             [ 2] 	ldy #0
f0a8 :                       df_rt_list_next_asm_ch
                             	_incZPWord df_tmpptrb
                             
f0ae : b1a1             [ 5] 	lda (df_tmpptrb),y
f0b0 : c920             [ 2] 	cmp #' '			; Skip all chars >=' '
f0b2 : b0f4             [ 3] 	bcs df_rt_list_next_asm_ch
f0b4 : 38               [ 2] 	sec					; Skip offset and mode bytes
f0b5 : 65a1             [ 3] 	adc df_tmpptrb
f0b7 : 85a1             [ 3] 	sta df_tmpptrb
f0b9 : a5a2             [ 3] 	lda df_tmpptrb+1
f0bb : 6900             [ 2] 	adc #0
f0bd : 85a2             [ 3] 	sta df_tmpptrb+1
f0bf : ca               [ 2] 	dex					; One less symbol to skip over
AS65 Assembler for R6502 [1.42].                                     Page  230
-------------------------------- bank\bank0.s --------------------------------

f0c0 : 4ca2f0           [ 3] 	jmp df_rt_list_find_asm_sym
f0c3 :                       df_rt_list_got_asm_sym
f0c3 : a1a1             [ 6] 	lda (df_tmpptrb,x)	; Relies on X=0 from branch
f0c5 : c920             [ 2] 	cmp #' '
f0c7 : 900c             [ 3] 	bcc df_rt_asm_decode_token_done
f0c9 : 204bc4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
f0d2 : 4cc3f0           [ 3] 	jmp df_rt_list_got_asm_sym
f0d5 :                       df_rt_asm_decode_token_done
f0d5 : 60               [ 6] 	rts 
                             
                             
f0d6 :                       df_rt_doke
f0d6 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f0d9 : a5a1             [ 3] 	lda df_tmpptrb
f0db : a000             [ 2] 	ldy #0
f0dd : 919f             [ 5] 	sta (df_tmpptra),y
                             	; get high byte to doke
f0df : a5a2             [ 3] 	lda df_tmpptrb+1
f0e1 : c8               [ 2] 	iny
                             	; poke hi byte
f0e2 : 919f             [ 5] 	sta (df_tmpptra),y
f0e4 : 60               [ 6] 	rts
                             	
f0e5 :                       df_rt_poke
f0e5 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f0e8 : a5a1             [ 3] 	lda df_tmpptrb
f0ea : a000             [ 2] 	ldy #0
f0ec : 919f             [ 5] 	sta (df_tmpptra),y
f0ee : 60               [ 6] 	rts
                             
f0ef :                       df_rt_snd_common
                             	; 3 inputs
                             	; tmpa = channel (1,2,3), tmpb = period, tmpc = 
f0ef : a59f             [ 3] 	lda df_tmpptra
                             	; tone channel addressing is 0 to 2
f0f1 : 38               [ 2] 	sec
f0f2 : e901             [ 2] 	sbc #1
f0f4 : 2903             [ 2] 	and #3
                             	; ok doing a tone channel, get reg index for per
f0f6 : 0a               [ 2] 	asl a
f0f7 : aa               [ 2] 	tax
                             	; get low byte of period
f0f8 : a5a1             [ 3] 	lda df_tmpptrb
f0fa : 2000c0           [ 6] 	jsr snd_set
                             	; increment reg number to high byte
f0fd : e8               [ 2] 	inx
                             	; get high byte of period
f0fe : a5a2             [ 3] 	lda df_tmpptrb+1
f100 : 290f             [ 2] 	and #0x0f
                             	; set period
f102 : 2000c0           [ 6] 	jsr snd_set
                             	; get volume register index (8 = channel 1)
f105 : 18               [ 2] 	clc
f106 : a59f             [ 3] 	lda df_tmpptra
f108 : 2903             [ 2] 	and #3
f10a : 6907             [ 2] 	adc #7
f10c : aa               [ 2] 	tax
                             	; get volume
f10d : a5a3             [ 3] 	lda df_tmpptrc
f10f : 290f             [ 2] 	and #0x0f
AS65 Assembler for R6502 [1.42].                                     Page  231
-------------------------------- bank\bank0.s --------------------------------

f111 : d002             [ 3] 	bne df_rt_sound_env_skip
                             	; envelope mode
f113 : 0910             [ 2] 	ora #0x10
f115 :                       df_rt_sound_env_skip
f115 : 4c00c0           [ 3] 	jmp snd_set
                             ;	rts
                             
                             ; sound chan,period,volume	
f118 :                       df_rt_sound
f118 : 2061e3           [ 6] 	jsr df_rt_parm_3ints
f11b :                       df_rt_dosound
                             	; check which channel (0 = noise)
f11b : a59f             [ 3] 	lda df_tmpptra
f11d : f003             [ 3] 	beq df_rt_sound_noise
f11f : 4ceff0           [ 3] 	jmp df_rt_snd_common
f122 :                       df_rt_sound_noise
                             	; ok update the noise channel, volume is irrelev
f122 : a206             [ 2] 	ldx #6
f124 : a5a1             [ 3] 	lda df_tmpptrb
f126 : 291f             [ 2] 	and #0x1f
f128 : 4c00c0           [ 3] 	jmp snd_set
                             ;	clc
                             ;	rts
                             
                             ; music chan,octave,note,volume
f12b :                       df_rt_music
f12b : 2084e3           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 2 = octave, need to x 12word = 24
                             	; get period A,X (hi/lo)
                             	; pass in octave # in X and note # in Y
f12e : a6a1             [ 3] 	ldx df_tmpptrb
f130 : a4a3             [ 3] 	ldy df_tmpptrc
f132 : 20b3d3           [ 6] 	jsr snd_get_note
                             	; store note period in b
f135 : 86a1             [ 3] 	stx df_tmpptrb
f137 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; put vol in tmpc
f139 : a5a5             [ 3] 	lda df_tmpptrd
f13b : 85a3             [ 3] 	sta df_tmpptrc
                             	; tmpa,b,c contain chan,per,vol
f13d : 4c1bf1           [ 3] 	jmp df_rt_dosound
                             	
                             	
                             ; play tonemask,noisemask,envelope,period
f140 :                       df_rt_play
f140 : 2084e3           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 1 = tone enable
f143 : a59f             [ 3] 	lda df_tmpptra
f145 : 2907             [ 2] 	and #7
f147 : 859f             [ 3] 	sta df_tmpptra
                             	; parm 2 = noise enable
f149 : a5a1             [ 3] 	lda df_tmpptrb
f14b : 2907             [ 2] 	and #7
f14d : 0a               [ 2] 	asl a
f14e : 0a               [ 2] 	asl a
f14f : 0a               [ 2] 	asl a
f150 : 059f             [ 3] 	ora df_tmpptra
                             	; we now have bits set for channels to enable
                             	; but need to invert for the 8910
                             	; top 2 bits are 0 and 1 as these are port b (in
f152 : 497f             [ 2] 	eor #0x7f
                             	; reg 7 is control register
AS65 Assembler for R6502 [1.42].                                     Page  232
-------------------------------- bank\bank0.s --------------------------------

f154 : a207             [ 2] 	ldx #7
f156 : 2000c0           [ 6] 	jsr snd_set
                             	; parm 3 = envelope mode
f159 : a5a3             [ 3] 	lda df_tmpptrc
f15b : 290f             [ 2] 	and #0xf
                             	; 13 is envelope shape register
f15d : a20d             [ 2] 	ldx #13
f15f : 2000c0           [ 6] 	jsr snd_set
                             	; parm 4 = envelope period
                             	; 11 is envelope period register
f162 : a20b             [ 2] 	ldx #11
                             	; get low
f164 : a5a5             [ 3] 	lda df_tmpptrd
f166 : 2000c0           [ 6] 	jsr snd_set
                             	; get high
f169 : e8               [ 2] 	inx
f16a : a5a6             [ 3] 	lda df_tmpptrd+1
f16c : 4c00c0           [ 3] 	jmp snd_set
                             ;	clc
                             ;	rts
                             
                             ;* common filename procesing routine
                             ;* 
f16f :                       df_rt_init_filename
                             	; evaluate string
f16f : 206ce0           [ 6] 	jsr df_rt_neval
f172 : 2047f7           [ 6] 	jsr df_ost_popStr
                             
                             	; save string address
f175 : 86a3             [ 3] 	stx df_tmpptrc
f177 : 85a4             [ 3] 	sta df_tmpptrc+1
                             	
                             	; copy string to fhandle
f179 : a000             [ 2] 	ldy #0
f17b :                       df_rt_copy_fn
f17b : b1a3             [ 5] 	lda (df_tmpptrc),y
f17d :                       df_rt_fname_case	
f17d : 990004           [ 5] 	sta df_linbuff,y				; Put filename in line buffe
f180 : c8               [ 2] 	iny
f181 : c900             [ 2] 	cmp #0
f183 : d0f6             [ 3] 	bne df_rt_copy_fn
f185 : 60               [ 6] 	rts
                             	
                             ;* common file parsing routine
f186 :                       df_rt_parse_file
                             	; now process filename
f186 : 206ff1           [ 6] 	jsr df_rt_init_filename
f189 : a900             [ 2] 	lda #0						; Initialise tape system
f18b : 2024c4           [ 6] 	jsr io_active_device
f18e : 60               [ 6] 	rts
f18f :                       df_rt_file_errc
                             	SWBRK DFERR_FNAME
                             
                             
                             ; save "file" as text
f191 :                       df_rt_tsave
f191 : 2086f1           [ 6] 	jsr df_rt_parse_file
f194 : 2051c4           [ 6] 	jsr io_open_write
f197 : b0f6             [ 3] 	bcs df_rt_file_errc
                             	; ok now have redirected output to device
                             	; go and list the program in save mode
f199 : a901             [ 2] 	lda #1
AS65 Assembler for R6502 [1.42].                                     Page  233
-------------------------------- bank\bank0.s --------------------------------

f19b : 85a7             [ 3] 	sta df_tmpptre
f19d : 2096ee           [ 6] 	jsr df_rt_listprg
                             	; final CR to end the save
f1a0 : a90d             [ 2] 	lda #UTF_CR
f1a2 : 204bc4           [ 6] 	jsr io_put_ch
f1a5 :                       df_rt_file_cleanup
                             	; close the file
f1a5 : 2054c4           [ 6] 	jsr io_close
f1a8 : 18               [ 2] 	clc
                             	; restore to default device io
f1a9 : 4c21c4           [ 3] 	jmp io_set_default
                             ;	clc
                             ;	rts
                             
                             ; load "file" from text
f1ac :                       df_rt_tload
f1ac : 2086f1           [ 6] 	jsr df_rt_parse_file
f1af : 204ec4           [ 6] 	jsr io_open_read
f1b2 : b0db             [ 3] 	bcs df_rt_file_errc
                             	; no echo - very important
                             	; else might try and write to a device
                             	; only open for reading (i.e. SD CARD)
f1b4 :                       df_rt_loadline
f1b4 : 18               [ 2] 	clc
f1b5 : 203bdf           [ 6] 	jsr df_pg_inputline
                             	; if C clear then tokenise line
f1b8 : 9014             [ 3] 	bcc df_rt_ldtokenise
                             	; else done
                             	; clear dflat runtime else will try to execute
                             	; the last tokenised line!
f1ba : a900             [ 2] 	lda #0
f1bc : 8d8004           [ 4] 	sta df_tokbuff			; Offset to next line
f1bf : 8d8104           [ 4] 	sta df_tokbuff+1		; Clear line low
f1c2 : 8d8204           [ 4] 	sta df_tokbuff+2		; Clear line high
f1c5 : 857d             [ 3] 	sta df_nxtstidx			; Clear next statement
f1c7 : a901             [ 2] 	lda #1					; Set immediate mode
f1c9 : 855c             [ 3] 	sta df_immed
f1cb : 4ca5f1           [ 3] 	jmp df_rt_file_cleanup	; Ok now can close and do
f1ce :                       df_rt_ldtokenise
f1ce : 208fdf           [ 6] 	jsr df_pg_tokenise		; Tokenise loaded string
f1d1 : 4cb4f1           [ 3] 	jmp df_rt_loadline		; Continue with next until b
                             
                             
                             ; Utility to open in binary mode save
f1d4 :                       df_rt_openforbinsave
f1d4 : 2086f1           [ 6] 	jsr df_rt_parse_file
f1d7 : 205dc4           [ 6] 	jsr io_open_ext2		; Ext2 is binary file save
f1da : b0b3             [ 3] 	bcs df_rt_file_errc
f1dc : 60               [ 6] 	rts
                             
                             ; Utility to open in binary mode load
f1dd :                       df_rt_openforbinload
                             	; Get filename and open file for binary read
f1dd : 2086f1           [ 6] 	jsr df_rt_parse_file
f1e0 : 205ac4           [ 6] 	jsr io_open_ext1		; Ext1 is binary file read
f1e3 : b0aa             [ 3] 	bcs df_rt_file_errc
f1e5 : 60               [ 6] 	rts
                             	
                             ; bload addr,"file"
f1e6 :                       df_rt_bload
                             	; Get address but keep on stack
f1e6 : e686             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  234
-------------------------------- bank\bank0.s --------------------------------

f1e8 : 206ce0           [ 6] 	jsr df_rt_neval
                             
                             	; Get filename and open file for binary read
f1eb : e686             [ 5] 	inc df_exeoff
f1ed : 20ddf1           [ 6] 	jsr df_rt_openforbinload
                             
                             	; Get address from stack in to ptra
f1f0 : 2042f7           [ 6] 	jsr df_ost_popInt
f1f3 : 869f             [ 3] 	stx df_tmpptra
f1f5 : 85a0             [ 3] 	sta df_tmpptra+1
                             	
                             	; Get file address to X,Y
f1f7 : 2048c4           [ 6] 	jsr io_get_ch
f1fa : aa               [ 2] 	tax
f1fb : 2048c4           [ 6] 	jsr io_get_ch
f1fe : a8               [ 2] 	tay
                             	
                             	; Check if user address is zero
f1ff : a59f             [ 3] 	lda df_tmpptra
f201 : 05a0             [ 3] 	ora df_tmpptra+1
f203 : d004             [ 3] 	bne df_rt_bload_addr
                             	; If it is zero then use address from file
f205 : 869f             [ 3] 	stx df_tmpptra
f207 : 84a0             [ 3] 	sty df_tmpptra+1
f209 :                       df_rt_bload_addr
                             	; Get file length
f209 : 2048c4           [ 6] 	jsr io_get_ch
f20c : 85a1             [ 3] 	sta df_tmpptrb
f20e : 2048c4           [ 6] 	jsr io_get_ch
f211 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	
                             	; Go and load the bytes
f213 : 20b5f2           [ 6] 	jsr df_rt_loadbin
                             	; Close the file
f216 : 4ca5f1           [ 3] 	jmp df_rt_file_cleanup
                             
                             ; Save a binary file
                             ; addr,length,fname
f219 :                       df_rt_bsave
                             	; Get source address and length but leave on sta
                             	; evaluate 1st parm
f219 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; jump over comma
f21c : e686             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
f21e : 206ce0           [ 6] 	jsr df_rt_neval
                             	
                             	; Process file and open for binary save
f221 : e686             [ 5] 	inc df_exeoff
f223 : 20d4f1           [ 6] 	jsr df_rt_openforbinsave
                             
                             	; Get length in to ptrb
f226 : 2042f7           [ 6] 	jsr df_ost_popInt
f229 : 86a1             [ 3] 	stx df_tmpptrb
f22b : 85a2             [ 3] 	sta df_tmpptrb+1
                             
                             	; Get address in to ptra
f22d : 2042f7           [ 6] 	jsr df_ost_popInt
f230 : 869f             [ 3] 	stx df_tmpptra
f232 : 85a0             [ 3] 	sta df_tmpptra+1
                             
                             	; now save bytes
AS65 Assembler for R6502 [1.42].                                     Page  235
-------------------------------- bank\bank0.s --------------------------------

f234 : 20c7f2           [ 6] 	jsr df_rt_savebin
                             	; Close the file
f237 : 4ca5f1           [ 3] 	jmp df_rt_file_cleanup
                             
                             	
                             ; save dflat tokenised program as binary
f23a :                       df_rt_save
                             	; Process file and open for binary save
f23a : 20d4f1           [ 6] 	jsr df_rt_openforbinsave
                             
                             	; first save zero page stuff
                             	; ok this saves a bit more than needed
                             	; but it's no biggie and doesn't
                             	; clobber temp space
f23d : a959             [ 2] 	lda #lo(dflat_zp_save_s)
f23f : 859f             [ 3] 	sta df_tmpptra
f241 : a900             [ 2] 	lda #hi(dflat_zp_save_s)
f243 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; save length
f245 : 38               [ 2] 	sec
f246 : a99f             [ 2] 	lda #lo(dflat_zp_save_e)
f248 : e959             [ 2] 	sbc #lo(dflat_zp_save_s)
f24a : 85a1             [ 3] 	sta df_tmpptrb
f24c : a900             [ 2] 	lda #hi(dflat_zp_save_e)
f24e : e900             [ 2] 	sbc #hi(dflat_zp_save_s)
f250 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f252 : 20c7f2           [ 6] 	jsr df_rt_savebin
                             
                             	; now save the dflat program
f255 : a563             [ 3] 	lda df_prgstrt
f257 : 859f             [ 3] 	sta df_tmpptra
f259 : a564             [ 3] 	lda df_prgstrt+1
f25b : 85a0             [ 3] 	sta df_tmpptra+1
                             	; save length
f25d : 38               [ 2] 	sec
f25e : a565             [ 3] 	lda df_prgend
f260 : e563             [ 3] 	sbc df_prgstrt
f262 : 85a1             [ 3] 	sta df_tmpptrb
f264 : a566             [ 3] 	lda df_prgend+1
f266 : e564             [ 3] 	sbc df_prgstrt+1
f268 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f26a : 20c7f2           [ 6] 	jsr df_rt_savebin
                             
                             	; now save the variables VVT and VNT
f26d : a567             [ 3] 	lda df_vntstrt
f26f : 859f             [ 3] 	sta df_tmpptra
f271 : a568             [ 3] 	lda df_vntstrt+1
f273 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; save length
f275 : 38               [ 2] 	sec
f276 : a56b             [ 3] 	lda df_vvtstrt
f278 : e567             [ 3] 	sbc df_vntstrt
f27a : 85a1             [ 3] 	sta df_tmpptrb
f27c : a56c             [ 3] 	lda df_vvtstrt+1
f27e : e568             [ 3] 	sbc df_vntstrt+1
f280 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f282 : 20c7f2           [ 6] 	jsr df_rt_savebin
                             	
                             	; close the file
AS65 Assembler for R6502 [1.42].                                     Page  236
-------------------------------- bank\bank0.s --------------------------------

f285 : 2054c4           [ 6] 	jsr io_close
f288 : 18               [ 2] 	clc
                             	; Close the file
f289 : 4ca5f1           [ 3] 	jmp df_rt_file_cleanup
                             
                             
                             ; load dflat tokenised program as binary
f28c :                       df_rt_load
f28c : 20ddf1           [ 6] 	jsr df_rt_openforbinload
                             
                             	; Get zero page header
f28f : 20a8f2           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f292 : 20b5f2           [ 6] 	jsr df_rt_loadbin
                             	
                             	; Get program header
f295 : 20a8f2           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f298 : 20b5f2           [ 6] 	jsr df_rt_loadbin
                             	
                             	; Get variables header
f29b : 20a8f2           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f29e : 20b5f2           [ 6] 	jsr df_rt_loadbin
                             	
                             	; close the file
f2a1 : 2054c4           [ 6] 	jsr io_close
f2a4 : 18               [ 2] 	clc
                             	; Close the file
f2a5 : 4ca5f1           [ 3] 	jmp df_rt_file_cleanup
                             
                             
                             ; Utility to get 4 parms from binary header
f2a8 :                       df_rt_getbin_parms
f2a8 : a200             [ 2] 	ldx #0
f2aa :                       df_rt_getbin_parms_loop
f2aa : 2048c4           [ 6] 	jsr io_get_ch
f2ad : 959f             [ 4] 	sta df_tmpptra,x
f2af : e8               [ 2] 	inx
f2b0 : e004             [ 2] 	cpx #4
f2b2 : d0f6             [ 3] 	bne df_rt_getbin_parms_loop
f2b4 : 60               [ 6] 	rts
                             
                             ; Utility to load a bin file in address ptra
                             ; Length in ptr b
f2b5 :                       df_rt_loadbin
                             	; Now load all bytes
f2b5 : a000             [ 2] 	ldy #0
f2b7 :                       df_rt_loadbin_byte
                             	; Get a byte from tape
f2b7 : 2048c4           [ 6] 	jsr io_get_ch
                             	; Save it to destination
f2ba : 919f             [ 5] 	sta (df_tmpptra),y
                             	; Increment destination
f2bc : c8               [ 2] 	iny
f2bd : d002             [ 3] 	bne df_rt_loadbin_inc
f2bf : e6a0             [ 5] 	inc df_tmpptra+1
f2c1 :                       df_rt_loadbin_inc
                             	; Decrement length remaining
f2c1 : 20e5f2           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f2c4 : d0f1             [ 3] 	bne df_rt_loadbin_byte
AS65 Assembler for R6502 [1.42].                                     Page  237
-------------------------------- bank\bank0.s --------------------------------

                             	; Yes the close the file
f2c6 : 60               [ 6] 	rts
                             
                             ; Utility to save a bin file from address ptra
                             ; Length in ptr b
f2c7 :                       df_rt_savebin
                             	; Save dest and length to tape
f2c7 : a200             [ 2] 	ldx #0
f2c9 :                       df_rt_bsave_parms
f2c9 : b59f             [ 4] 	lda df_tmpptra,x
f2cb : 204bc4           [ 6] 	jsr io_put_ch
f2ce : e8               [ 2] 	inx
f2cf : e004             [ 2] 	cpx #4
f2d1 : d0f6             [ 3] 	bne df_rt_bsave_parms
                             
                             	; Now save all bytes
f2d3 : a000             [ 2] 	ldy #0
f2d5 :                       df_rt_savebin_byte
                             	; Get byte from memory
f2d5 : b19f             [ 5] 	lda (df_tmpptra),y
                             	; Put byte to tape
f2d7 : 204bc4           [ 6] 	jsr io_put_ch
                             	; Increment destination
f2da : c8               [ 2] 	iny
f2db : d002             [ 3] 	bne df_rt_savebin_inc
f2dd : e6a0             [ 5] 	inc df_tmpptra+1
f2df :                       df_rt_savebin_inc
                             	; Decrement length remaining
f2df : 20e5f2           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f2e2 : d0f1             [ 3] 	bne df_rt_savebin_byte
f2e4 : 60               [ 6] 	rts
                             
                             ; Decrement length in ptrb
f2e5 :                       df_rt_dec_binlen
                             	; Decrement length remaining
f2e5 : a5a1             [ 3] 	lda df_tmpptrb
f2e7 : d002             [ 3] 	bne df_rt_binlen_skip
f2e9 : c6a2             [ 5] 	dec df_tmpptrb+1
f2eb :                       df_rt_binlen_skip	
f2eb : c6a1             [ 5] 	dec df_tmpptrb
                             	; Reached zero?
f2ed : a5a1             [ 3] 	lda df_tmpptrb
f2ef : 05a2             [ 3] 	ora df_tmpptrb+1
f2f1 : 60               [ 6] 	rts
                             
                             
                             ; reset var
f2f2 :                       df_rt_reset
                             	; now get lvar X,A from current statement
f2f2 : 203be5           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
f2f5 : 86a1             [ 3] 	stx df_tmpptrb
f2f7 : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; load the vdp count as the reset value of timer
                             	; turn off interrupts while reading vdp lo,hi
f2f9 : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
                             	; clear interrupts to access 3 byte vdp counter 
f2fb : 78               [ 2] 	sei
f2fc : a508             [ 3] 	lda vdp_cnt
f2fe : 91a1             [ 5] 	sta (df_tmpptrb),y
f300 : a509             [ 3] 	lda vdp_cnt+1
AS65 Assembler for R6502 [1.42].                                     Page  238
-------------------------------- bank\bank0.s --------------------------------

f302 : c8               [ 2] 	iny
f303 : 91a1             [ 5] 	sta (df_tmpptrb),y
                             	; restore interrupts asap
f305 : 58               [ 2] 	cli
f306 : 60               [ 6] 	rts
                             
                             ;***** FUNCTIONS *****
                             
f307 :                       df_rt_deek
f307 : 38               [ 2] 	sec
f308 : b001             [ 3] 	bcs df_rt_readbyte
f30a :                       df_rt_peek
f30a : 18               [ 2] 	clc
f30b :                       df_rt_readbyte
f30b : 08               [ 3] 	php
f30c : e686             [ 5] 	inc df_exeoff
f30e : 2066e0           [ 6] 	jsr df_rt_getnval
f311 : 869f             [ 3] 	stx df_tmpptra
f313 : 85a0             [ 3] 	sta df_tmpptra+1
f315 : a000             [ 2] 	ldy #0
f317 : b19f             [ 5] 	lda (df_tmpptra),y
f319 : aa               [ 2] 	tax
f31a : a900             [ 2] 	lda #0
f31c : 28               [ 4] 	plp
f31d : 9003             [ 3] 	bcc df_rt_readbyte_skip
f31f : c8               [ 2] 	iny
f320 : b19f             [ 5] 	lda (df_tmpptra),y
f322 :                       df_rt_readbyte_skip
f322 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ; Random number generator
                             ; rnd(0) = get next number
                             ; rnd(>0) = set seed
f325 :                       df_rt_rnd
f325 : e686             [ 5] 	inc df_exeoff
f327 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; if input is 0 then generate next random number
f32a : e000             [ 2] 	cpx #0
f32c : d014             [ 3] 	bne df_rt_rnd_set
f32e : c900             [ 2] 	cmp #0
f330 : d010             [ 3] 	bne df_rt_rnd_set
                             	; generate next number
f332 : a596             [ 3] 	lda df_rnd+1
f334 : 4a               [ 2] 	lsr a
f335 : 2695             [ 5] 	rol df_rnd
f337 : 9002             [ 3] 	bcc df_rt_rnd_noeor
f339 : 49b4             [ 2] 	eor #0xb4
f33b :                       df_rt_rnd_noeor
f33b : 8596             [ 3] 	sta df_rnd+1
f33d : 4595             [ 3] 	eor df_rnd
f33f : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             	; else set the seed to that number and done
f342 :                       df_rt_rnd_set
f342 : 8695             [ 3] 	stx df_rnd
f344 : 8596             [ 3] 	sta df_rnd+1
f346 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             
                             ;* Return memory footprint as follows:
                             ;* 0	Return free memory (start of vvt - end of he
                             ;* 1	Return program size (end of prg - start of p
                             ;* 2	Return size of vars (end of vnt - start of v
AS65 Assembler for R6502 [1.42].                                     Page  239
-------------------------------- bank\bank0.s --------------------------------

f349 :                       df_rt_mem
f349 : e686             [ 5] 	inc df_exeoff
f34b : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
f34e : e001             [ 2] 	cpx #1
f350 : f017             [ 3] 	beq df_rt_mem_prg
f352 : e002             [ 2] 	cpx #2
f354 : f026             [ 3] 	beq df_rt_mem_var
                             	; default is free memory
f356 :                       df_rt_mem_free
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_starend,df_tmpptrb
                             
f366 : 4c8cf3           [ 3] 	jmp df_rt_mem_calc
f369 :                       df_rt_mem_prg
                             	_cpyZPWord df_prgend,df_tmpptra
                             
                             	_cpyZPWord df_prgstrt,df_tmpptrb
                             
f379 : 4c8cf3           [ 3] 	jmp df_rt_mem_calc
f37c :                       df_rt_mem_var
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
f38c :                       df_rt_mem_calc
                             	; tmpa-tmpb result in X,A
f38c : 38               [ 2] 	sec
f38d : a59f             [ 3] 	lda df_tmpptra
f38f : e5a1             [ 3] 	sbc df_tmpptrb
f391 : aa               [ 2] 	tax
f392 : a5a0             [ 3] 	lda df_tmpptra+1
f394 : e5a2             [ 3] 	sbc df_tmpptrb+1
f396 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             ;* a=stick()
                             ;* returns bit condition of joystick positions
                             ;* no actual joystick support so this is
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
f399 :                       df_rt_stick
f399 : e686             [ 5] 	inc df_exeoff
f39b : 206fc7           [ 6] 	jsr kb_stick				; Get pos in to A
f39e : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; k=get(sync) sync>=1 means sync
f3a1 :                       df_rt_get
f3a1 : e686             [ 5] 	inc df_exeoff
f3a3 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used, check for sync or async
                             	; c=0 if x<1 else x>=1 makes c=1
f3a6 : e001             [ 2] 	cpx #1
f3a8 :                       df_rt_get_sync
f3a8 : 08               [ 3] 	php
f3a9 : 2048c4           [ 6] 	jsr io_get_ch				; Return in A, C=0 is good
f3ac : 9005             [ 3] 	bcc df_rt_get_pushp			; Push A (and do plp)
f3ae : 28               [ 4] 	plp
f3af : b0f7             [ 3] 	bcs df_rt_get_sync			; If sync then check again
f3b1 : 9001             [ 3] 	bcc df_rt_get_push			; Else push zero (no plp)
f3b3 :                       df_rt_get_pushp
f3b3 : 28               [ 4] 	plp
AS65 Assembler for R6502 [1.42].                                     Page  240
-------------------------------- bank\bank0.s --------------------------------

f3b4 :                       df_rt_get_push
f3b4 : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             	
                             ; s = scrn(x,y)
f3b7 :                       df_rt_scrn
f3b7 : e686             [ 5] 	inc df_exeoff
f3b9 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f3bc : a49f             [ 3] 	ldy df_tmpptra			; Y is the x coord!
f3be : a6a1             [ 3] 	ldx df_tmpptrb			; X is the y coord!
f3c0 : 20becd           [ 6] 	jsr gr_get
f3c3 : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; p = pixel(x,y)
f3c6 :                       df_rt_pixel
f3c6 : e686             [ 5] 	inc df_exeoff
f3c8 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f3cb : a69f             [ 3] 	ldx df_tmpptra
f3cd : a4a1             [ 3] 	ldy df_tmpptrb
f3cf : 200fd0           [ 6] 	jsr gr_pixel
f3d2 : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             
                             ; %e=elapsed(%var)
f3d5 :                       df_rt_elapsed
                             	; now get lvar X,A from current statement
f3d5 : 203be5           [ 6] 	jsr df_rt_getlvar
f3d8 : e686             [ 5] 	inc df_exeoff
                             	; save lvar in tmpb, vvt ptr in tmpa
f3da : 86a1             [ 3] 	stx df_tmpptrb
f3dc : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; subtract vdp counter from value
                             	; turn off interrupts while reading vdp lo,hi
f3de : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
f3e0 : 38               [ 2] 	sec
                             	; disable interrupts to access vdp counter
f3e1 : 78               [ 2] 	sei
f3e2 : a508             [ 3] 	lda vdp_cnt
f3e4 : f1a1             [ 5] 	sbc (df_tmpptrb),y
f3e6 : aa               [ 2] 	tax
f3e7 : a509             [ 3] 	lda vdp_cnt+1
                             	; restore interrupts asap
f3e9 : 58               [ 2] 	cli
f3ea : c8               [ 2] 	iny
f3eb : f1a1             [ 5] 	sbc (df_tmpptrb),y
f3ed : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
f3f0 :                       df_rt_call
f3f0 : e686             [ 5] 	inc df_exeoff
f3f2 : 2084e3           [ 6] 	jsr df_rt_parm_4ints
f3f5 : a5a1             [ 3] 	lda df_tmpptrb				; load A
f3f7 : a6a3             [ 3] 	ldx	df_tmpptrc				; load X
f3f9 : a4a5             [ 3] 	ldy df_tmpptrd				; load Y
f3fb : 2001f4           [ 6] 	jsr df_rt_calljsr
f3fe : 4c0af7           [ 3] 	jmp df_ost_pushInt			; A,X pair is return value	
f401 :                       df_rt_calljsr
f401 : 6c9f00           [ 6] 	jmp (df_tmpptra)			; tmpptra is address, return 
                             
                             ; string length calculator
                             ; X,A = source
                             ; A = length not including zero
f404 :                       df_rt_strlen_common
f404 : 869f             [ 3] 	stx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  241
-------------------------------- bank\bank0.s --------------------------------

f406 : 85a0             [ 3] 	sta df_tmpptra+1
f408 : a0ff             [ 2] 	ldy #0xff
f40a :                       df_rt_strlen_count
f40a : c8               [ 2] 	iny
f40b : b19f             [ 5] 	lda (df_tmpptra),y
f40d : d0fb             [ 3] 	bne df_rt_strlen_count
f40f : 98               [ 2] 	tya
f410 : 60               [ 6] 	rts
                             	
                             	
                             ; common routine to extract a string
                             ; tmpa = source string
                             ; tmpb = dest string
                             ; tmpc = start pos
                             ; tmpd = endpos	
f411 :                       df_rt_str_extract
                             	; source string
f411 : 2047f7           [ 6] 	jsr df_ost_popStr
f414 : 869f             [ 3] 	stx df_tmpptra
f416 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; destination is string accumulator
f418 : a578             [ 3] 	lda df_sevalptr
f41a : 85a1             [ 3] 	sta df_tmpptrb
f41c : a579             [ 3] 	lda df_sevalptr+1
f41e : 85a2             [ 3] 	sta df_tmpptrb+1
                             	; start pos
f420 : a4a3             [ 3] 	ldy df_tmpptrc
f422 : a200             [ 2] 	ldx #0
f424 :                       df_rt_str_cpy_ch
f424 : c4a5             [ 3] 	cpy df_tmpptrd
f426 : f011             [ 3] 	beq df_str_src_end
f428 : b19f             [ 5] 	lda (df_tmpptra),y
f42a : f00d             [ 3] 	beq df_str_src_end
f42c : 81a1             [ 6] 	sta (df_tmpptrb,x)
                             	_incZPWord df_tmpptrb
                             
f434 : c8               [ 2] 	iny
f435 : d0ed             [ 3] 	bne df_rt_str_cpy_ch
                             	SWBRK DFERR_STRLONG
                             
f439 :                       df_str_src_end
f439 : a900             [ 2] 	lda #0
f43b : 81a1             [ 6] 	sta (df_tmpptrb,x)
f43d : a678             [ 3] 	ldx df_sevalptr
f43f : a579             [ 3] 	lda df_sevalptr+1
f441 : 4c17f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = chr(x)
f444 :                       df_rt_chr
f444 : e686             [ 5] 	inc df_exeoff
                             	; get char in X
f446 : 2066e0           [ 6] 	jsr df_rt_getnval
f449 : a000             [ 2] 	ldy #0
                             	; transfer lo byte to A
f44b : 8a               [ 2] 	txa
f44c : 9178             [ 5] 	sta (df_sevalptr),y
f44e : c8               [ 2] 	iny
                             	; zero terminator
f44f : a900             [ 2] 	lda #0
f451 : 9178             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f453 : a678             [ 3] 	ldx df_sevalptr
AS65 Assembler for R6502 [1.42].                                     Page  242
-------------------------------- bank\bank0.s --------------------------------

f455 : a579             [ 3] 	lda df_sevalptr+1
f457 : 4c17f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = hex(x)
f45a :                       df_rt_hex
f45a : e686             [ 5] 	inc df_exeoff
                             	; create hex digits
f45c : 2066e0           [ 6] 	jsr df_rt_getnval
f45f : 859f             [ 3] 	sta df_tmpptra	; Save the high byte
f461 : 8a               [ 2] 	txa				; Convert low byte first
f462 : 2089c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
f465 : 85a1             [ 3] 	sta df_tmpptrb
f467 : 8a               [ 2] 	txa				; Push low digit of low byte from X
f468 : 48               [ 3] 	pha
f469 : a5a1             [ 3] 	lda df_tmpptrb	; Get A back from temp
f46b : 48               [ 3] 	pha				; Push high digit of low byte
f46c : a59f             [ 3] 	lda df_tmpptra	; Get the high byte
f46e : 2089c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
                             	; create string
f471 : a000             [ 2] 	ldy #0			; Index in to string temp area
                             	; hi/hi
f473 : 9178             [ 5] 	sta (df_sevalptr),y
f475 : c8               [ 2] 	iny
                             	; hi/lo
f476 : 8a               [ 2] 	txa
f477 : 9178             [ 5] 	sta (df_sevalptr),y
f479 : c8               [ 2] 	iny
                             	; lo/hi
f47a : 68               [ 4] 	pla
f47b : 9178             [ 5] 	sta (df_sevalptr),y
f47d : c8               [ 2] 	iny
                             	; lo/lo
f47e : 68               [ 4] 	pla
f47f : 9178             [ 5] 	sta (df_sevalptr),y
f481 : c8               [ 2] 	iny
                             	; zero terminator
f482 : a900             [ 2] 	lda #0
f484 : 9178             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f486 : a678             [ 3] 	ldx df_sevalptr
f488 : a579             [ 3] 	lda df_sevalptr+1
f48a : 4c17f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $l = left($s, x)
f48d :                       df_rt_left
f48d : e686             [ 5] 	inc df_exeoff
                             	
                             	; first get the string to act on
                             	; point to string accumulator
f48f : 2029e1           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars
f492 : e686             [ 5] 	inc df_exeoff
f494 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract
f497 : 86a5             [ 3] 	stx df_tmpptrd
                             	; start position
f499 : a000             [ 2] 	ldy #0
f49b : 84a3             [ 3] 	sty df_tmpptrc
f49d : 4c11f4           [ 3] 	jmp df_rt_str_extract
                             
                             ; $r = right($s, x)
f4a0 :                       df_rt_right
AS65 Assembler for R6502 [1.42].                                     Page  243
-------------------------------- bank\bank0.s --------------------------------

f4a0 : e686             [ 5] 	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f4a2 : 2029e1           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars from the right
f4a5 : e686             [ 5] 	inc df_exeoff
f4a7 : 2066e0           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract from the right
f4aa : 86a3             [ 3] 	stx df_tmpptrc
                             	; end pos = len
f4ac : a678             [ 3] 	ldx df_sevalptr
f4ae : a579             [ 3] 	lda df_sevalptr+1
f4b0 : 2004f4           [ 6] 	jsr df_rt_strlen_common
f4b3 : 85a5             [ 3] 	sta df_tmpptrd
                             	; subtract num chars to extract to get start pos
f4b5 : 38               [ 2] 	sec
f4b6 : e5a3             [ 3] 	sbc df_tmpptrc
f4b8 : 85a3             [ 3] 	sta df_tmpptrc
f4ba : 4c11f4           [ 3] 	jmp df_rt_str_extract
                             
                             ; $m = mid($s, x, y)
f4bd :                       df_rt_mid
f4bd : e686             [ 5] 	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f4bf : 2029e1           [ 6] 	jsr df_rt_seval
                             	; now get start of string segment
f4c2 : e686             [ 5] 	inc df_exeoff
f4c4 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; number of chars to extract
f4c7 : e686             [ 5] 	inc df_exeoff
f4c9 : 2066e0           [ 6] 	jsr df_rt_getnval
f4cc : 86a5             [ 3] 	stx df_tmpptrd
                             	; start position
f4ce : 2042f7           [ 6] 	jsr df_ost_popInt
f4d1 : ca               [ 2] 	dex					; zero offset rather than 1
f4d2 : 86a3             [ 3] 	stx df_tmpptrc
                             	; update end pos by adding start pos
f4d4 : 8a               [ 2] 	txa
f4d5 : 18               [ 2] 	clc
f4d6 : 65a5             [ 3] 	adc df_tmpptrd
f4d8 : 85a5             [ 3] 	sta df_tmpptrd
f4da : 4c11f4           [ 3] 	jmp df_rt_str_extract
                             
                             ; %l = len($s)
f4dd :                       df_rt_len
f4dd : e686             [ 5] 	inc df_exeoff
                             	; evaluate the string in the string accumulator
f4df : 2029e1           [ 6] 	jsr df_rt_seval
f4e2 : 2047f7           [ 6] 	jsr df_ost_popStr
                             	; now calculate the length of this string
f4e5 : 2004f4           [ 6] 	jsr df_rt_strlen_common
f4e8 : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = asc($s)
f4eb :                       df_rt_asc
f4eb : e686             [ 5] 	inc df_exeoff
                             	; Evaluate string in the string accumulator
f4ed : 2029e1           [ 6] 	jsr df_rt_seval
f4f0 : 2047f7           [ 6] 	jsr df_ost_popStr
                             	; Store point in ZP
f4f3 : 869f             [ 3] 	stx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  244
-------------------------------- bank\bank0.s --------------------------------

f4f5 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; Find the character at beginning
f4f7 : a200             [ 2] 	ldx #0
f4f9 : a19f             [ 6] 	lda (df_tmpptra,x)
f4fb : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = val($s)
f4fe :                       df_rt_val
f4fe : e686             [ 5] 	inc df_exeoff
                             	; evaluate the string
f500 : 2029e1           [ 6] 	jsr df_rt_seval
f503 : 2047f7           [ 6] 	jsr df_ost_popStr
f506 : a000             [ 2] 	ldy #0				; any numeric format
f508 : 20d4c1           [ 6] 	jsr con_n_to_a		; result in num_a
f50b : b007             [ 3] 	bcs df_rt_val_err
f50d : a63b             [ 3] 	ldx num_a
f50f : a53c             [ 3] 	lda num_a+1
                             	; Save as an int
f511 : 4c0af7           [ 3] 	jmp df_ost_pushInt
f514 :                       df_rt_val_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ; stop execution
f516 :                       df_rt_abort
                             	SWBRK DFERR_ABORT
                             
                             
f518 :                       df_rt_sprchar
f518 : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f51b : a59f             [ 3] 	lda df_tmpptra
f51d : a6a1             [ 3] 	ldx df_tmpptrb
f51f : 4c61d2           [ 3] 	jmp gr_spr_char
                             
f522 :                       df_rt_sprpos
f522 : 2061e3           [ 6] 	jsr df_rt_parm_3ints
f525 : a59f             [ 3] 	lda df_tmpptra
f527 : a6a1             [ 3] 	ldx df_tmpptrb
f529 : a4a3             [ 3] 	ldy df_tmpptrc
f52b : 4c71d2           [ 3] 	jmp gr_spr_pos
                             
f52e :                       df_rt_sprupd
f52e : 20f6d1           [ 6] 	jsr gr_spr_erase
f531 : 2009d2           [ 6] 	jsr gr_spr_new
f534 : 4c3dd2           [ 3] 	jmp gr_spr_draw
                             
f537 :                       df_rt_sprinit
f537 : 4ce8d1           [ 3] 	jmp gr_spr_init
                             
f53a :                       df_rt_sprmulti
f53a : 204ae3           [ 6] 	jsr df_rt_parm_2ints
f53d : 4c7ed2           [ 3] 	jmp gr_spr_multi_pos
                             
f540 :                       df_rt_sprhit
f540 : e686             [ 5] 	inc df_exeoff
f542 : 2066e0           [ 6] 	jsr df_rt_getnval
f545 : 8a               [ 2] 	txa
f546 : 2067d2           [ 6] 	jsr gr_spr_hit
f549 : b003             [ 3] 	bcs df_rt_sprhit_inactive
                             	; Active sprite hit = background
f54b : 4c0ff7           [ 3] 	jmp df_ost_pushIntA
f54e :                       df_rt_sprhit_inactive
AS65 Assembler for R6502 [1.42].                                     Page  245
-------------------------------- bank\bank0.s --------------------------------

                             	; Inactive sprite hit = -1
f54e : a2ff             [ 2] 	ldx #0xff
f550 : 8a               [ 2] 	txa
f551 : 4c0af7           [ 3] 	jmp df_ost_pushInt
                             
                             	
f554 :                       mod_sz_rtsubs_e
                             
                             
                             	include "dflat\proc.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROC.S
                             ;*  dflat module to handle procedures:
                             ;*  - executing a procedure
                             ;*  - find a proc, pass local and non-local param
                             ;*  - return from a proc, unload locals
                             ;*  - save the definition of a proc in the VNT an
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f554 :                       mod_sz_proc_s
                             
                             ; executing a procedure in VVT slot A,X
f554 :                       df_rt_exec_proc
                             	; save slot address
f554 : 869f             [ 3] 	stx df_tmpptra
f556 : 85a0             [ 3] 	sta df_tmpptra+1
                             	
                             	; need to save all important vars
f558 : a584             [ 3] 	lda df_currlin
f55a : 48               [ 3] 	pha
f55b : a585             [ 3] 	lda df_currlin+1
f55d : 48               [ 3] 	pha
f55e : a586             [ 3] 	lda df_exeoff
f560 : 48               [ 3] 	pha
f561 : a57d             [ 3] 	lda df_nxtstidx
f563 : 48               [ 3] 	pha
f564 : a57e             [ 3] 	lda df_curstidx
f566 : 48               [ 3] 	pha
f567 : a57c             [ 3] 	lda df_eolidx
f569 : 48               [ 3] 	pha
f56a : a591             [ 3] 	lda df_ifnest
f56c : 48               [ 3] 	pha
                             
                             	; now initialise the data
f56d : a001             [ 2] 	ldy #DFVVT_LO
f56f : b19f             [ 5] 	lda (df_tmpptra),y
f571 : 8584             [ 3] 	sta df_currlin
f573 : c8               [ 2] 	iny
f574 : b19f             [ 5] 	lda (df_tmpptra),y
f576 : 8585             [ 3] 	sta df_currlin+1
f578 : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  246
-------------------------------- bank\bank0.s --------------------------------

f579 : b19f             [ 5] 	lda (df_tmpptra),y
f57b : 8586             [ 3] 	sta df_exeoff
f57d : 857e             [ 3] 	sta df_curstidx
f57f : a000             [ 2] 	ldy #0
f581 : b184             [ 5] 	lda (df_currlin),y
f583 : 857d             [ 3] 	sta df_nxtstidx
                             	; now execute statements
f585 : 2003e4           [ 6] 	jsr df_rt_exec_stat
                             ;	bcs df_rt_exec_proc_err
                             	; now restore the position
f588 : 68               [ 4] 	pla
f589 : 8591             [ 3] 	sta df_ifnest
f58b : 68               [ 4] 	pla
f58c : 857c             [ 3] 	sta df_eolidx
f58e : 68               [ 4] 	pla
f58f : 857e             [ 3] 	sta df_curstidx
f591 : 68               [ 4] 	pla
f592 : 857d             [ 3] 	sta df_nxtstidx
f594 : 68               [ 4] 	pla
f595 : 8586             [ 3] 	sta df_exeoff
f597 : 68               [ 4] 	pla
f598 : 8585             [ 3] 	sta df_currlin+1
f59a : 68               [ 4] 	pla
f59b : 8584             [ 3] 	sta df_currlin
                             	; should be all restored, so return
f59d : 60               [ 6] 	rts
                             
                             ; call procedure
f59e :                       df_rt_proc
                             	; move past escape token
f59e : a486             [ 3] 	ldy df_exeoff
f5a0 : c8               [ 2] 	iny
                             	; Get VVT address X,A and procptr
f5a1 : b184             [ 5] 	lda (df_currlin),y
f5a3 : aa               [ 2] 	tax
f5a4 : c8               [ 2] 	iny
f5a5 : b184             [ 5] 	lda (df_currlin),y
f5a7 : c8               [ 2] 	iny
f5a8 : 8486             [ 3] 	sty df_exeoff
f5aa : 868c             [ 3] 	stx df_procptr
f5ac : 858d             [ 3] 	sta df_procptr+1
                             	
                             	; is index 0 (held in dim1)
                             	; then need to find the procedure
f5ae : a003             [ 2] 	ldy #DFVVT_DIM1
f5b0 : b18c             [ 5] 	lda (df_procptr),y
f5b2 : d014             [ 3] 	bne df_rt_proc_addr
                             	; find proc
f5b4 : 20d9e4           [ 6] 	jsr df_rt_findproc
                             	; save y (line index)
f5b7 : 8436             [ 3] 	sty tmp_d
                             	; now go and update the proc vvt address
f5b9 : a002             [ 2] 	ldy #DFVVT_HI
f5bb : 918c             [ 5] 	sta (df_procptr),y
f5bd : a001             [ 2] 	ldy #DFVVT_LO
f5bf : 8a               [ 2] 	txa
f5c0 : 918c             [ 5] 	sta (df_procptr),y
f5c2 : a003             [ 2] 	ldy #DFVVT_DIM1
                             	; get back line index in to A
f5c4 : a536             [ 3] 	lda tmp_d
f5c6 : 918c             [ 5] 	sta (df_procptr),y
f5c8 :                       df_rt_proc_addr
AS65 Assembler for R6502 [1.42].                                     Page  247
-------------------------------- bank\bank0.s --------------------------------

                             	; move past first open bracket
f5c8 : e686             [ 5] 	inc df_exeoff
                             	
                             	; get parm count
f5ca : a004             [ 2] 	ldy #DFVVT_DIM2
f5cc : b18c             [ 5] 	lda (df_procptr),y
f5ce : f016             [ 3] 	beq df_rt_proc_parm_none
                             	; push the right number of parms on
f5d0 : 48               [ 3] 	pha
                             
f5d1 :                       df_rt_proc_push_parm
f5d1 : 206ce0           [ 6] 	jsr df_rt_neval
                             ;	bcs df_rt_proc_parmother
f5d4 : a486             [ 3] 	ldy df_exeoff
f5d6 : b184             [ 5] 	lda (df_currlin),y
f5d8 : c929             [ 2] 	cmp #')'
f5da : f009             [ 3] 	beq df_rt_proc_parm_done
                             	; move past comma
f5dc : e686             [ 5] 	inc df_exeoff
                             	; get parm count off stack
f5de : 68               [ 4] 	pla
                             	; decrement
f5df : 38               [ 2] 	sec
f5e0 : e901             [ 2] 	sbc #1
                             	; and put back on stack
f5e2 : 48               [ 3] 	pha
                             	; go back and do all required parms
f5e3 : d0ec             [ 3] 	bne df_rt_proc_push_parm
                             	; remove parm counter from stack
f5e5 :                       df_rt_proc_parm_done
f5e5 : 68               [ 4] 	pla
f5e6 :                       df_rt_proc_parm_none
                             	; should be at close bracket
f5e6 : a486             [ 3] 	ldy df_exeoff
f5e8 : b184             [ 5] 	lda (df_currlin),y
f5ea : c929             [ 2] 	cmp #')'
f5ec : d007             [ 3] 	bne df_rt_proc_parmerr
                             	; should be no more parms
                             	; ok, finally we have all parms on rt stack
                             	; now execute the procedure
                             	; get back the proc address
f5ee : a68c             [ 3] 	ldx df_procptr
f5f0 : a58d             [ 3] 	lda df_procptr+1
f5f2 : 4c54f5           [ 3] 	jmp df_rt_exec_proc
                             	
f5f5 :                       df_rt_proc_parmerr
                             	SWBRK DFERR_PROCPARM
                             
                             
                             
f5f7 :                       df_rt_def
                             	; line offset pointing at DFTK_PROC
                             	; skip over PROC address and open bracket
f5f7 : e686             [ 5] 	inc df_exeoff
f5f9 : e686             [ 5] 	inc df_exeoff
f5fb : e686             [ 5] 	inc df_exeoff
                             	; parms on stack in reverse order to parm list
                             	; so get each parm and type and save to scratch
f5fd : a201             [ 2] 	ldx #1									; index in to scratch
f5ff : 868a             [ 3] 	stx df_procargs							; Proc args is the #args-1
f601 : a486             [ 3] 	ldy df_exeoff
f603 :                       df_rt_def_find_var
AS65 Assembler for R6502 [1.42].                                     Page  248
-------------------------------- bank\bank0.s --------------------------------

f603 : c8               [ 2] 	iny
f604 : b184             [ 5] 	lda (df_currlin),y
                             	; check if end of parm list
f606 : c929             [ 2] 	cmp #')'
f608 : f023             [ 3] 	beq df_rt_def_parm_done
                             	; else check if found a variable escape token (<
f60a : c911             [ 2] 	cmp #DFTK_VAR
f60c : f009             [ 3] 	beq df_rt_def_got_var
                             	; else check if non-local specifier
f60e : c926             [ 2] 	cmp #DFTK_VARPARM						; This is a regular ASCII
f610 : f002             [ 3] 	beq df_rt_def_got_varparm
f612 : d0ef             [ 3] 	bne df_rt_def_find_var
f614 :                       df_rt_def_got_varparm
                             	; set high bit
f614 : 0980             [ 2] 	ora #0x80
                             	; advance over non-local specifier
f616 : c8               [ 2] 	iny
f617 :                       df_rt_def_got_var
f617 : 4980             [ 2] 	eor #0x80			; If was set by '&' qualifier then w
f619 : 9d1306           [ 5] 	sta scratch,x		; Save parm type (by value or ref
                             	; get address and save in scratch
f61c : c8               [ 2] 	iny
f61d : b184             [ 5] 	lda (df_currlin),y
f61f : 9d3306           [ 5] 	sta scratch+32,x	; Hope 32 params is enough! :-)
f622 : c8               [ 2] 	iny
f623 : b184             [ 5] 	lda (df_currlin),y
f625 : 9d5306           [ 5] 	sta scratch+64,x
f628 : e8               [ 2] 	inx
f629 : e68a             [ 5] 	inc df_procargs
f62b : d0d6             [ 3] 	bne df_rt_def_find_var  ; always - relies not ze
f62d :                       df_rt_def_parm_done
                             	; save index that we got to
f62d : 8486             [ 3] 	sty df_exeoff
                             	; save def param list position in temp
f62f : 8689             [ 3] 	stx df_procmode
                             	; all var indices on the operator stack
                             	; now load up variables with parameters
                             	; initially assume no locals
f631 : a900             [ 2] 	lda #0
f633 : 858b             [ 3] 	sta df_procloc
f635 :                       df_rt_def_load_var
f635 : c68a             [ 5] 	dec df_procargs
f637 : f039             [ 3] 	beq df_rt_def_load_var_done
                             	; get var address
f639 : a689             [ 3] 	ldx df_procmode
f63b : ca               [ 2] 	dex
f63c : bd3306           [ 4] 	lda scratch+32,x
f63f : 859f             [ 3] 	sta df_tmpptra
f641 : bd5306           [ 4] 	lda scratch+64,x
f644 : 85a0             [ 3] 	sta df_tmpptra+1
f646 : 8689             [ 3] 	stx df_procmode
                             	
f648 : bd1306           [ 4] 	lda scratch,x
                             	; if MSB is clear then this is not a local varia
                             	; so just go an initialise with stacking
f64b : 1009             [ 3] 	bpl df_rt_def_initialise_parm
                             	; else call the local handling code to 
                             	; push the var address on to the runtime stack
f64d : a69f             [ 3] 	ldx df_tmpptra
f64f : a5a0             [ 3] 	lda df_tmpptra+1
f651 : 20acf6           [ 6] 	jsr df_rt_proc_local
                             	; increment number of locals
AS65 Assembler for R6502 [1.42].                                     Page  249
-------------------------------- bank\bank0.s --------------------------------

f654 : e68b             [ 5] 	inc df_procloc
f656 :                       df_rt_def_initialise_parm
                             	; load type
f656 : a000             [ 2] 	ldy #DFVVT_TYPE
f658 : b19f             [ 5] 	lda (df_tmpptra),y
                             	; if array or string type then pop pointer from 
f65a : 2984             [ 2] 	and #DFVVT_STR|DFVVT_ARRY
f65c : f006             [ 3] 	beq df_rt_def_load_var_int
f65e : 204cf7           [ 6] 	jsr df_ost_popPtr
f661 : 4c67f6           [ 3] 	jmp df_rt_def_load_var_int_skip
f664 :                       df_rt_def_load_var_int
                             	; must be int pop it from operator stack
f664 : 2042f7           [ 6] 	jsr df_ost_popInt
f667 :                       df_rt_def_load_var_int_skip
                             	; update the variable
f667 : a002             [ 2] 	ldy #DFVVT_HI
f669 : 919f             [ 5] 	sta (df_tmpptra),y
f66b : 88               [ 2] 	dey
f66c : 8a               [ 2] 	txa
f66d : 919f             [ 5] 	sta (df_tmpptra),y
                             	
f66f : 4c35f6           [ 3] 	jmp df_rt_def_load_var
f672 :                       df_rt_def_load_var_done
                             	; save the number of local parameters found so t
                             	; be unloaded when the proc ends
f672 : a58b             [ 3] 	lda df_procloc
f674 : 20c0f6           [ 6] 	jsr df_rst_pushByte
                             	; continue with next statement
f677 : 18               [ 2] 	clc
f678 : 60               [ 6] 	rts
                             
                             	
                             ; end def for a proc
f679 :                       df_rt_enddef
                             	; unload any locals
f679 : 2085f6           [ 6] 	jsr df_rt_proc_unlocal
                             	; nothing to do - main loop will terminate
f67c : 18               [ 2] 	clc
f67d : 60               [ 6] 	rts
                             	
                             ; return a value
f67e :                       df_rt_return
                             	; evaluate the return and put on the parameter s
f67e : 206ce0           [ 6] 	jsr df_rt_neval
                             	; process this like an end of procedure
f681 : 2079f6           [ 6] 	jsr df_rt_enddef
f684 : 60               [ 6] 	rts
                             	
                             	
                             ; unload any local variables from runtime stack
f685 :                       df_rt_proc_unlocal
f685 : 20c9f6           [ 6] 	jsr df_rst_popByte
f688 : aa               [ 2] 	tax
f689 : f020             [ 3] 	beq df_rt_proc_unload_done
f68b :                       df_rt_proc_unloadvar
f68b : 8a               [ 2] 	txa
f68c : 48               [ 3] 	pha
                             	; var value is popped first then index
                             	; get a word and put in tmpb
f68d : 20e6f6           [ 6] 	jsr df_rst_popWord
f690 : 86a1             [ 3] 	stx df_tmpptrb
f692 : 85a2             [ 3] 	sta df_tmpptrb+1
AS65 Assembler for R6502 [1.42].                                     Page  250
-------------------------------- bank\bank0.s --------------------------------

                             	; get the var address
f694 : 20e6f6           [ 6] 	jsr df_rst_popWord
f697 : 869f             [ 3] 	stx df_tmpptra
f699 : 85a0             [ 3] 	sta df_tmpptra+1
                             	; store lo byte first
f69b : a001             [ 2] 	ldy #DFVVT_LO
f69d : a5a1             [ 3] 	lda df_tmpptrb
f69f : 919f             [ 5] 	sta (df_tmpptra),y
                             	; then hi
f6a1 : c8               [ 2] 	iny
f6a2 : a5a2             [ 3] 	lda df_tmpptrb+1
f6a4 : 919f             [ 5] 	sta (df_tmpptra),y
                             	; restore counter
f6a6 : 68               [ 4] 	pla
f6a7 : aa               [ 2] 	tax
f6a8 : ca               [ 2] 	dex
f6a9 : d0e0             [ 3] 	bne df_rt_proc_unloadvar
f6ab :                       df_rt_proc_unload_done
f6ab : 60               [ 6] 	rts
                             	
                             ; push a local variable to the runtime stack
                             ; X,A = var slot
f6ac :                       df_rt_proc_local
                             	; save address
f6ac : 869f             [ 3] 	stx df_tmpptra
f6ae : 85a0             [ 3] 	sta df_tmpptra+1
                             	; push var slot on rt stack
f6b0 : 20d8f6           [ 6] 	jsr df_rst_pushWord
f6b3 :                       df_rt_proc_local_load	
                             	; load x,a with var value lo,hi
f6b3 : a001             [ 2] 	ldy #DFVVT_LO
f6b5 : b19f             [ 5] 	lda (df_tmpptra),y
f6b7 : aa               [ 2] 	tax
f6b8 : c8               [ 2] 	iny
f6b9 : b19f             [ 5] 	lda (df_tmpptra),y
                             	; push word on to rt stack
f6bb : 20d8f6           [ 6] 	jsr df_rst_pushWord
f6be : 18               [ 2] 	clc
f6bf : 60               [ 6] 	rts
                             		
f6c0 :                       mod_sz_proc_e
                             
                             	
f6c0 :                       mod_sz_runtime_e
                             
                             
                             
                             	include "dflat\stack.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  STACK.S
                             ;*  This module implements the dflat software sta
                             ;*  needs a few stacks:
                             ;*  - 6502 stack for expression parsing and reent
                             ;*  - dflat runtime stack for things like for/nex
                             ;*  - dflat parameter stack for passing parameter
AS65 Assembler for R6502 [1.42].                                     Page  251
-------------------------------- bank\bank0.s --------------------------------

                             ;*  The two software stacks are implemented in th
                             ;*  with the runtime stack growing up from 0 and 
                             ;*  operator stack growing down from 255.  Hopefu
                             ;*  don't meet as there are no checks for this at
                             ;*  purely because I want speed over friendliness
                             ;*  I may come to regret this.
                             ;*  I have also added the only runtime memory all
                             ;*  needed by dflat here.  Humourously I have cal
                             ;*  which is taken from the C language, but it on
                             ;*  grab some memory after the of dflat program c
                             ;*  arrays - which of course cannot have storage 
                             ;*  tokenisation time (e.g. because I dimension a
                             ;*  a size from a variable).
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Push a byte on to runtime stack
                             ;* A = byte
                             ;****************************************
f6c0 :                       df_rst_pushByte
f6c0 : a474             [ 3] 	ldy df_rtstop
f6c2 : 990005           [ 5] 	sta df_rtstck,y
f6c5 : 88               [ 2] 	dey
f6c6 : 8474             [ 3] 	sty df_rtstop
f6c8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f6c9 :                       df_rst_popByte
f6c9 : a474             [ 3] 	ldy df_rtstop
f6cb : c8               [ 2] 	iny
f6cc : b90005           [ 4] 	lda df_rtstck,y
f6cf : 8474             [ 3] 	sty df_rtstop
f6d1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Peek a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f6d2 :                       df_rst_peekByte
f6d2 : a474             [ 3] 	ldy df_rtstop
                             	; Look at what is below top of stack
                             	; below means the next address up as
                             	; this stack grows downwards like 6502
f6d4 : b90105           [ 4] 	lda df_rtstck+1,y
f6d7 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Push a word on to runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f6d8 :                       df_rst_pushWord
f6d8 : a474             [ 3] 	ldy df_rtstop
f6da : 990005           [ 5] 	sta df_rtstck,y
f6dd : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page  252
-------------------------------- bank\bank0.s --------------------------------

f6de : 8a               [ 2] 	txa
f6df : 990005           [ 5] 	sta df_rtstck,y
f6e2 : 88               [ 2] 	dey
f6e3 : 8474             [ 3] 	sty df_rtstop
f6e5 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a word off runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f6e6 :                       df_rst_popWord
f6e6 : a474             [ 3] 	ldy df_rtstop
f6e8 : c8               [ 2] 	iny
f6e9 : b90005           [ 4] 	lda df_rtstck,y
f6ec : aa               [ 2] 	tax
f6ed : c8               [ 2] 	iny
f6ee : b90005           [ 4] 	lda df_rtstck,y
f6f1 : 8474             [ 3] 	sty df_rtstop
f6f3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push a parameter on to parm stack
                             ;* X,A - int
                             ;* Y - type
                             ;****************************************
f6f4 :                       df_ost_pushParmX
f6f4 : 8436             [ 3] 	sty tmp_d		; Save Type
f6f6 : a475             [ 3] 	ldy df_parmtop	; Get stack index
                             	; push high byte first (A)
f6f8 : 990005           [ 5] 	sta df_rtstck,y
f6fb : c8               [ 2] 	iny
                             	; push low byte next (X)
f6fc : 8a               [ 2] 	txa
f6fd : 990005           [ 5] 	sta df_rtstck,y
f700 : c8               [ 2] 	iny
f701 : a536             [ 3] 	lda tmp_d		; get Type
f703 : 990005           [ 5] 	sta df_rtstck,y
f706 : c8               [ 2] 	iny
                             	; save new top of stack
f707 : 8475             [ 3] 	sty df_parmtop
f709 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push an int on to parm stack
                             ;* X,A - int
                             ;****************************************
f70a :                       df_ost_pushInt
f70a : a001             [ 2] 	ldy #DFST_INT
f70c : 4cf4f6           [ 3] 	jmp df_ost_pushParmX
                             
                             ;****************************************
                             ;* Push A on to parm stack
                             ;* X,A - int
                             ;****************************************
f70f :                       df_ost_pushIntA
f70f : a001             [ 2] 	ldy #DFST_INT
f711 : aa               [ 2] 	tax
f712 : a900             [ 2] 	lda #0
f714 : 4cf4f6           [ 3] 	jmp df_ost_pushParmX
                             
                             ;****************************************
                             ;* Push a string pointer on to parm stack
AS65 Assembler for R6502 [1.42].                                     Page  253
-------------------------------- bank\bank0.s --------------------------------

                             ;* X,A - int
                             ;****************************************
f717 :                       df_ost_pushStr
f717 : a080             [ 2] 	ldy #DFST_STR
f719 : 4cf4f6           [ 3] 	jmp df_ost_pushParmX
                             
                             ;****************************************
                             ;* Push a general pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f71c :                       df_ost_pushPtr
f71c : a0ff             [ 2] 	ldy #0xff
f71e : 4cf4f6           [ 3] 	jmp df_ost_pushParmX
                             	
                             ;****************************************
                             ;* Pop parameter from the stack
                             ;* X,A - int
                             ;* Y - type expected
                             ;****************************************
f721 :                       df_ost_popParmX
f721 : 8436             [ 3] 	sty tmp_d
f723 : a475             [ 3] 	ldy df_parmtop
                             	; pull type first
f725 : a536             [ 3] 	lda tmp_d
f727 : 88               [ 2] 	dey
f728 : 390005           [ 4] 	and df_rtstck,y
f72b : f00d             [ 3] 	beq df_st_typemismatcherr
                             	; pull low byte first
f72d : 88               [ 2] 	dey
f72e : b90005           [ 4] 	lda df_rtstck,y
f731 : aa               [ 2] 	tax
                             	; pull high byte next
f732 : 88               [ 2] 	dey
f733 : b90005           [ 4] 	lda df_rtstck,y
                             	; save new top of stack
f736 : 8475             [ 3] 	sty df_parmtop
f738 : 18               [ 2] 	clc
f739 : 60               [ 6] 	rts
f73a :                       df_st_typemismatcherr
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ;****************************************
                             ;* Return type on top of stack
                             ;* Y - type
                             ;****************************************
f73c :                       df_ost_peekType
f73c : a475             [ 3] 	ldy df_parmtop
f73e : b9ff04           [ 4] 	lda df_rtstck-1,y
                             ;	tay NO LONGER NEEDED - EVERYWHERE USES A
f741 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop an int off parm stack
                             ;* X,A - int
                             ;****************************************
f742 :                       df_ost_popInt
f742 : a001             [ 2] 	ldy #DFST_INT
f744 : 4c21f7           [ 3] 	jmp df_ost_popParmX
                             
                             ;****************************************
                             ;* Pop a string pointer off parm stack
AS65 Assembler for R6502 [1.42].                                     Page  254
-------------------------------- bank\bank0.s --------------------------------

                             ;* X,A - int
                             ;****************************************
f747 :                       df_ost_popStr
f747 : a080             [ 2] 	ldy #DFST_STR
f749 : 4c21f7           [ 3] 	jmp df_ost_popParmX
                             	
                             ;****************************************
                             ;* Pop a general pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f74c :                       df_ost_popPtr
f74c : a0ff             [ 2] 	ldy #0xff
f74e : 4c21f7           [ 3] 	jmp df_ost_popParmX
                             	
                             	
                             ;****************************************
                             ;* Allocate space on the heap
                             ;* X, A = Number of bytes to allocate
                             ;* X, A return address of allocated space
                             ;****************************************
f751 :                       df_st_malloc
                             	; save A in Y
f751 : a8               [ 2] 	tay
                             	; save old starend
f752 : a573             [ 3] 	lda df_starend+1
f754 : 48               [ 3] 	pha
f755 : a572             [ 3] 	lda df_starend
f757 : 48               [ 3] 	pha
                             	; restore A from Y
f758 : 98               [ 2] 	tya
                             	; add X,A to starend
f759 : 48               [ 3] 	pha
f75a : 8a               [ 2] 	txa
f75b : 18               [ 2] 	clc
f75c : 6572             [ 3] 	adc df_starend
f75e : 8572             [ 3] 	sta df_starend
f760 : 68               [ 4] 	pla
f761 : 6573             [ 3] 	adc df_starend+1
f763 : 8573             [ 3] 	sta df_starend+1
                             	; return old starend as start of space
f765 : 68               [ 4] 	pla
f766 : aa               [ 2] 	tax
f767 : 68               [ 4] 	pla
f768 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* df_init
                             ;* Initialise dflat language settings
                             ;****************************************
f769 :                       df_init
                             	; Initialise top of memory to default
                             	; This can be overridden by himem command
f769 : a900             [ 2] 	lda #lo(DF_MEMTOP)
f76b : 8d1106           [ 4] 	sta df_memtop
f76e : a998             [ 2] 	lda #hi(DF_MEMTOP)
f770 : 8d1206           [ 4] 	sta df_memtop+1
                             	
                             	; Init program space
f773 : 2077f7           [ 6] 	jsr df_clear
                             	
                             	; Initialise assembler
AS65 Assembler for R6502 [1.42].                                     Page  255
-------------------------------- bank\bank0.s --------------------------------

                             ;	jsr asm_init
                             
f776 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* df_clear
                             ;* Initialise program space
                             ;****************************************
f777 :                       df_clear
                             	; Start of program space
f777 : a913             [ 2] 	lda #lo(DF_PROGSTART)
f779 : 8563             [ 3] 	sta df_prgstrt
f77b : 8565             [ 3] 	sta df_prgend
f77d : a907             [ 2] 	lda #hi(DF_PROGSTART)
f77f : 8564             [ 3] 	sta df_prgstrt+1
f781 : 8566             [ 3] 	sta df_prgend+1
                             	; Terminal value in prog space
f783 : a900             [ 2] 	lda #0
f785 : a000             [ 2] 	ldy #0
f787 : 9163             [ 5] 	sta (df_prgstrt),y
                             	; No variables - zero the count
f789 : 856f             [ 3] 	sta df_varcnt
                             	
                             	; Variable value table
                             	; Grows down from mem top
f78b : ad1106           [ 4] 	lda df_memtop
f78e : 856b             [ 3] 	sta df_vvtstrt
f790 : 856d             [ 3] 	sta df_vvtend
f792 : ad1206           [ 4] 	lda df_memtop+1
f795 : 856c             [ 3] 	sta df_vvtstrt+1
f797 : 856e             [ 3] 	sta df_vvtend+1
                             	
                             	; Variable name table
                             	; Grows down from mem top
f799 : a56b             [ 3] 	lda df_vvtstrt
f79b : 8567             [ 3] 	sta df_vntstrt
f79d : 8569             [ 3] 	sta df_vntend
f79f : a56c             [ 3] 	lda df_vvtstrt+1
f7a1 : 8568             [ 3] 	sta df_vntstrt+1
f7a3 : 856a             [ 3] 	sta df_vntend+1
                             
                             	; String accumulator
f7a5 : a900             [ 2] 	lda #lo(df_raw)
f7a7 : 8578             [ 3] 	sta df_sevalptr
f7a9 : a904             [ 2] 	lda #hi(df_raw)
f7ab : 8579             [ 3] 	sta df_sevalptr+1
                             
f7ad : 60               [ 6] 	rts
                             	
f7ae :                       mod_sz_dflat_e
                             
                             	include "dflat\error.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.S
AS65 Assembler for R6502 [1.42].                                     Page  256
-------------------------------- bank\bank0.s --------------------------------

                             ;*  Error handling module.
                             ;*  Whan an error is thrown using BRK, this modul
                             ;*  displaying the error plus any associated line
                             ;*  if it was running a program.  It then resets 
                             ;*  settings and takes the system back to program
                             ;*  mode.  The message uses the general IO handle
                             ;*  output must be set to the right place else fo
                             ;*	the error message will be written to tape!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             	include "dflat\error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             	
                             	
AS65 Assembler for R6502 [1.42].                                     Page  257
-------------------------------- bank\bank0.s --------------------------------

                             ; Error message table, each msg null terminated
f7ae :                       df_tk_errortab
f7ae : 4f6b00                	db	"Ok", 0
f7b1 : 53796e74617800        	db	"Syntax", 0
f7b8 : 5479706500            	db	"Type", 0
f7bd : 52652d64696d00        	db	"Re-dim", 0
f7c4 : 4e6f2072657065..      	db	"No repeat", 0
f7ce : 4e6f206465666e00      	db	"No defn", 0
f7d6 : 5061726d00            	db	"Parm", 0
f7db : 456e64656400          	db	"Ended", 0
f7e1 : 4e6f20656e6469..      	db	"No endif", 0
f7ea : 4e6f20696600          	db	"No if", 0
f7f0 : 4e6f20666f7200        	db	"No for", 0
f7f7 : 4e6f7420666f75..      	db	"Not found", 0
f801 : 546f6f206c6f6e..      	db	"Too long", 0
f80a : 427265616b00          	db	"Break", 0
f810 : 4e6f206461746100      	db	"No data", 0
f818 : 4e6f207768696c..      	db	"No while", 0
f821 : 4e6f206c696e6500      	db	"No line", 0
f829 : 4e6f2072657475..      	db	"No return ", 0
f834 : 41626f7274656400      	db	"Aborted", 0
f83c : 426f756e647300        	db	"Bounds", 0
f843 : 4e6f206f726700        	db	"No org", 0
f84a : 00                    	db	0
                             
f84b :                       df_tk_error_inline
f84b : 20696e206c696e..      	db	" in line ", 0
f855 :                       df_tk_error_atpos
f855 : 20706f732000          	db	" pos ", 0
f85b :                       df_tk_error_error
f85b : 206572726f7200        	db	" error", 0
                             
                             ;****************************************
                             ;* df_trap_error
                             ;* Show an error message
                             ;* errno is error number
                             ;* currlin = Line number
                             ;* exeoff = offset
                             ;* at the end jump to program editor
                             ;****************************************
f862 :                       df_trap_error
                             	; reset SP
f862 : a65d             [ 3] 	ldx df_sp
f864 : 9a               [ 2] 	txs
                             	; set IO back to normal
f865 : 201cc5           [ 6] 	jsr init_via0
f868 : 2021c4           [ 6] 	jsr io_set_default
f86b : 58               [ 2] 	cli
                             	
f86c : a9ae             [ 2] 	lda #lo(df_tk_errortab)
f86e : 859f             [ 3] 	sta df_tmpptra
f870 : a9f7             [ 2] 	lda #hi(df_tk_errortab)
f872 : 85a0             [ 3] 	sta df_tmpptra+1
f874 : a65b             [ 3] 	ldx errno				; 0 or >=128 goes to monitor
f876 : f004             [ 3] 	beq df_trap_go_monitor
f878 : 3002             [ 3] 	bmi df_trap_go_monitor
f87a : 1003             [ 3] 	bpl df_trap_normal
f87c :                       df_trap_go_monitor
f87c : 4c00f9           [ 3] 	jmp df_trap_monitor
f87f :                       df_trap_normal
f87f : a000             [ 2] 	ldy #0
f881 :                       df_show_err_find
AS65 Assembler for R6502 [1.42].                                     Page  258
-------------------------------- bank\bank0.s --------------------------------

f881 : e000             [ 2] 	cpx #0
f883 : f018             [ 3] 	beq df_show_err_found
                             	; If on a zero, then error table exhausted
                             	; so drop in to the monitor
f885 : b19f             [ 5] 	lda (df_tmpptra),y
f887 : f077             [ 4] 	beq df_trap_monitor
f889 :                       df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f88f : b19f             [ 5] 	lda (df_tmpptra),y
f891 : d0f6             [ 3] 	bne df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f899 : ca               [ 2] 	dex
f89a : 4c81f8           [ 3] 	jmp df_show_err_find
f89d :                       df_show_err_found
f89d : a69f             [ 3] 	ldx df_tmpptra
f89f : a5a0             [ 3] 	lda df_tmpptra+1
f8a1 : 2099c4           [ 6] 	jsr io_print_line
f8a4 : a25b             [ 2] 	ldx #lo(df_tk_error_error)
f8a6 : a9f8             [ 2] 	lda #hi(df_tk_error_error)
f8a8 : 2099c4           [ 6] 	jsr io_print_line
                             	; if line number <> 0 then print it
f8ab : a001             [ 2] 	ldy #DFTK_LINNUM
f8ad : b184             [ 5] 	lda (df_currlin),y
f8af : aa               [ 2] 	tax
f8b0 : c8               [ 2] 	iny
f8b1 : b184             [ 5] 	lda (df_currlin),y
f8b3 : c900             [ 2] 	cmp #0x00
f8b5 : d006             [ 3] 	bne df_show_err_linnum
f8b7 : e000             [ 2] 	cpx #0x00
f8b9 : d002             [ 3] 	bne df_show_err_linnum
f8bb : f019             [ 3] 	beq df_show_err_fin
f8bd :                       df_show_err_linnum
                             	_println df_tk_error_inline
                             
f8d2 : 18               [ 2] 	clc
f8d3 : 20f6c3           [ 6] 	jsr print_a_to_d
f8d6 :                       df_show_err_fin
f8d6 : a486             [ 3] 	ldy df_exeoff
f8d8 : f01d             [ 3] 	beq df_show_err_done
                             	_println df_tk_error_atpos
                             
f8ef : 98               [ 2] 	tya
f8f0 : aa               [ 2] 	tax
f8f1 : a900             [ 2] 	lda #0
f8f3 : 18               [ 2] 	clc
f8f4 : 20f6c3           [ 6] 	jsr print_a_to_d	
f8f7 :                       df_show_err_done
f8f7 : a90d             [ 2] 	lda #UTF_CR
f8f9 : 204bc4           [ 6] 	jsr io_put_ch
f8fc : 18               [ 2] 	clc
                             	; back to editor
f8fd : 4c4edf           [ 3] 	jmp df_pg_dflat
                             
                             
                             ; For unknown errors, jump to monitor
f900 :                       df_trap_monitor
                             	; Print PC
                             	_println_low df_msg_pc
                             
f907 : a561             [ 3] 	lda df_brkpc+1
AS65 Assembler for R6502 [1.42].                                     Page  259
-------------------------------- bank\bank0.s --------------------------------

f909 : 2074c1           [ 6] 	jsr utilPrintA
f90c : a560             [ 3] 	lda df_brkpc
f90e : 2074c1           [ 6] 	jsr utilPrintA
f911 : 2064c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print A
                             	_println_low df_msg_acc
                             
f91b : a53b             [ 3] 	lda num_a
f91d : 2074c1           [ 6] 	jsr utilPrintA
f920 : 2064c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print X
                             	_println_low df_msg_xreg
                             
f92a : a53c             [ 3] 	lda num_a+1
f92c : 2074c1           [ 6] 	jsr utilPrintA
f92f : 2064c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print Y
                             	_println_low df_msg_yreg
                             
f939 : a53d             [ 3] 	lda num_a+2
f93b : 2074c1           [ 6] 	jsr utilPrintA
f93e : 206cc1           [ 6] 	jsr utilPrintCRLF
                             	
f941 : 201de8           [ 6] 	jsr df_rt_monitor
                             	; back to editor
f944 : 4c4edf           [ 3] 	jmp df_pg_dflat
                             
f947 :                       df_msg_pc
f947 : 50433a00              	db "PC:\x0"
f94b :                       df_msg_acc
f94b : 413a00                	db "A:\x0"
f94e :                       df_msg_xreg
f94e : 583a00                	db "X:\x0"
f951 :                       df_msg_yreg
f951 : 593a00                	db "Y:\x0"
                             
                             	include	"dflat\asm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*  This is the main controller code file for the
                             ;*  This file includes all the required source fi
                             ;*	in addition to dflat.s
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f954 :                       mod_sz_asm_s
                             
                             	;	dflat.s is already included, so just the addit
                             	include "dflat\asm.i"
AS65 Assembler for R6502 [1.42].                                     Page  260
-------------------------------- bank\bank0.s --------------------------------

                             ;* Addressing modes - 15 in total, 16 with direct
                             ;*  0   Nothing
                             ;*	1 	Absolute			XXX <word>
                             ;*	2 	Absolute,X			XXX <word>,x
                             ;*	3 	Absolute,Y			XXX <word>,y
                             ;*	4	Zeropage			XXX	<byte>
                             ;*	5	Zeropage,X			XXX	<byte>,x
                             ;*	6	Zeropage,Y			XXX	<byte>,y
                             ;*	7	Indirect			XXX	(<byte>)
                             ;*	8	Indirect,X			XXX	(<byte>,x)
                             ;*	9	Indirect,Y			XXX	(<byte>),y
                             ;*	A	Absolute indirect	XXX	(<word>)
                             ;*	B	Absolute indirect,x	XXX	(<word>,x)
                             ;*	C	Immediate			XXX #<byte>
                             ;*	D	Accumulator			XXX (same as implied)
                             ;*	E	Implied				XXX
                             ;*	F	Relative			XXX	<byte>
                             ;*	10	Assembler directive	XXX .......
                             
0000 =                       AM_NONE		= 0
0001 =                       AM_ABS	 	= 1
0002 =                       AM_ABSX		= 2
0003 =                       AM_ABSY		= 3
0004 =                       AM_ZP		= 4
0005 =                       AM_ZPX		= 5
0006 =                       AM_ZPY		= 6
0007 =                       AM_ZPIND	= 7
0008 =                       AM_ZPINDX	= 8
0009 =                       AM_ZPINDY	= 9
000a =                       AM_ABSIND	= 10
000b =                       AM_ABSINDX	= 11
000c =                       AM_IMM		= 12
000d =                       AM_ACC		= 13
000d =                       AM_IMP		= AM_ACC
000f =                       AM_REL		= 15
0010 =                       AM_DIR		= 16
                             
                             
                             
                             	include "dflat\tkasm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*	Module that implements tokenisation of the ass
                             ;* 	The assembler is an extension to dflat, almos
                             ;*	almost a language within a language, as it has
                             ;*	own symbol tables to allow adding new keywords
                             ;*	running out of space in the main symtol table 
                             ;*	for normal 6502 asembler syntax which is at od
                             ;*	regular dflat.
                             ;*	Hence, this module has to do its own additiona
                             ;*	to tokenise the assembly.
                             ;*
                             ;************************************************
                             
                             	; ROM code
AS65 Assembler for R6502 [1.42].                                     Page  261
-------------------------------- bank\bank0.s --------------------------------

                             	code  
                             
f954 :                       mod_sz_tkasm_s
                             
                             	; if didn't find regular keywords then try assen
f954 :                       df_tk_asm_parse_command
                             	; skip the white space after the dot
f954 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; find the assembler symbol
f957 : 2083f9           [ 6] 	jsr df_tk_asm_matchtok
                             	; if not found then must be a label assignment
f95a : b021             [ 3] 	bcs df_tk_asm_parse_command_symbol
                             	; Get the assembler symbol and put the token
f95c : a581             [ 3] 	lda df_symoff
                             	; Set the MSB
f95e : 0980             [ 2] 	ora #0x80
f960 : 209fd6           [ 6] 	jsr df_tk_put_tok
                             	; check the first addressing mode code
                             	; remember to jump over the offset byte
f963 : a001             [ 2] 	ldy #1
f965 : b17f             [ 5] 	lda (df_symtab),y
                             	; Directive?
f967 : c910             [ 2] 	cmp #AM_DIR
f969 : d00c             [ 3] 	bne df_tk_asm_mnemonic
                             	; if directive then process it
f96b : a581             [ 3] 	lda df_symoff
f96d : 20daf9           [ 6] 	jsr df_tk_asm_exec_parser
f970 : b004             [ 3] 	bcs df_tk_asm_parse_command_err
                             	; [1] ignore white space but keep it
f972 : 20f3d6           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
f975 : 18               [ 2] 	clc
f976 :                       df_tk_asm_parse_command_err
f976 : 60               [ 6] 	rts
f977 :                       df_tk_asm_mnemonic
                             	; for all nmemonics, work out the addressing mod
f977 : 20e9f9           [ 6] 	jsr df_tk_asm_addr_mode
f97a : b0fa             [ 3] 	bcs df_tk_asm_parse_command_err
f97c : 60               [ 6] 	rts
f97d :                       df_tk_asm_parse_command_symbol
                             	; No mask
f97d : a900             [ 2] 	lda #0
f97f : 20e5d7           [ 6] 	jsr df_tk_var
f982 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_tk_asm_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
f983 :                       df_tk_asm_matchtok
                             	; Start at token symbols beginning
f983 : a98d             [ 2] 	lda #lo(df_asm_tokensyms)
f985 : 857f             [ 3] 	sta df_symtab
f987 : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
f989 : 8580             [ 3] 	sta df_symtab+1
f98b : a900             [ 2] 	lda #0
f98d : 8581             [ 3] 	sta df_symoff
AS65 Assembler for R6502 [1.42].                                     Page  262
-------------------------------- bank\bank0.s --------------------------------

f98f : a200             [ 2] 	ldx #0
f991 :                       df_tk_asm_checknexttok
                             	; From the line buffer current pointer
                             	; Check for a token match
f991 : a47a             [ 3] 	ldy df_linoff
f993 :                       df_tk_asm_checktokch
                             	; Get symtable char
f993 : a17f             [ 6] 	lda (df_symtab,x)
                             	; if less than ascii ' ' then reached end of
                             	; this symbol and everything matched so found!
f995 : c920             [ 2] 	cmp #' '
f997 : 9033             [ 3] 	bcc df_tk_asm_symfound
                             	; Else compare with current line buffer char
f999 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
f99c : d00a             [ 3] 	bne df_tk_asm_symnomatch
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
f9a4 : c8               [ 2] 	iny
f9a5 : 4c93f9           [ 3] 	jmp df_tk_asm_checktokch
f9a8 :                       df_tk_asm_symnomatch
                             	; Increment symbol counter to next symbol
f9a8 : e681             [ 5] 	inc df_symoff
f9aa :                       df_tk_asm_symnextentry
f9aa : a17f             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is < ' '
f9ac : c920             [ 2] 	cmp #' '
f9ae : 9009             [ 3] 	bcc  df_tk_asm_foundsymend
                             	_incZPWord df_symtab
                             
f9b6 : 4caaf9           [ 3] 	jmp df_tk_asm_symnextentry
f9b9 :                       df_tk_asm_foundsymend
                             	; Now at the offset to jump over addressing
                             	; mode and opcode values. Add offset to ptr
                             	; remember than C is clear and A has offset
                             	; set C so always jump over the offset
f9b9 : 38               [ 2] 	sec
f9ba : 657f             [ 3] 	adc df_symtab
f9bc : 857f             [ 3] 	sta df_symtab
f9be : a580             [ 3] 	lda df_symtab+1
f9c0 : 6900             [ 2] 	adc #0
f9c2 : 8580             [ 3] 	sta df_symtab+1
                             	; If next char is not zero then
                             	; try and match with line buffer
f9c4 : a17f             [ 6] 	lda (df_symtab,x)
f9c6 : d0c9             [ 3] 	bne df_tk_asm_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
f9c8 : 8581             [ 3] 	sta df_symoff		; Relies on A=0
                             	; Set C to indicate error (no match)
f9ca : 38               [ 2] 	sec
f9cb : 60               [ 6] 	rts
f9cc :                       df_tk_asm_symfound
                             	; Full match with keyword in symtable but
                             	; check the next buffer char is not alphanum
                             	; as this could be part of a symbol
                             	; Point to next buffer char in any case
                             	; y already points to char after keyword
f9cc : b90004           [ 4] 	lda df_linbuff,y
AS65 Assembler for R6502 [1.42].                                     Page  263
-------------------------------- bank\bank0.s --------------------------------

                             	; if it is an alphanum then
f9cf : 20e2d6           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
f9d2 : b0d4             [ 3] 	bcs df_tk_asm_symnomatch
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
f9d4 : 847a             [ 3] 	sty df_linoff
f9d6 : a581             [ 3] 	lda df_symoff
                             	; df_symtab points to the offset
f9d8 : 18               [ 2] 	clc
f9d9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_asm_exec_parser
                             ;* Execute parse routine for this statement
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f9da :                       df_tk_asm_exec_parser
f9da : 0a               [ 2] 	asl a
f9db : aa               [ 2] 	tax
f9dc : bdb9ff           [ 4] 	lda df_tk_asm_tokenjmp,x
f9df : 859f             [ 3] 	sta df_tmpptra
f9e1 : bdbaff           [ 4] 	lda df_tk_asm_tokenjmp+1,x
f9e4 : 85a0             [ 3] 	sta df_tmpptra+1
f9e6 : 6c9f00           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* df_tk_asm_addr_mode
                             ;* Tokenise the addressing mode
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f9e9 :                       df_tk_asm_addr_mode
f9e9 : 20f3d6           [ 6] 	jsr df_tk_skip_ws		;Skip whitespace
f9ec : c900             [ 2] 	cmp #0					;End of line?
f9ee : f02e             [ 4] 	beq df_tk_asm_addr_mode_ok
f9f0 : c93a             [ 2] 	cmp #':'				;End of statement?
f9f2 : f02a             [ 4] 	beq df_tk_asm_addr_mode_ok
f9f4 : a923             [ 2] 	lda #'#'				; Check for immediate
f9f6 : 2028d7           [ 6] 	jsr df_tk_expect_tok
f9f9 : b003             [ 3] 	bcs df_tk_asm_addr_mode_1
f9fb : 4c20fa           [ 3] 	jmp df_tk_imm		; Process immediate
f9fe :                       df_tk_asm_addr_mode_1
f9fe : a928             [ 2] 	lda #'('				; One of indirect modes?
fa00 : 2028d7           [ 6] 	jsr df_tk_expect_tok
fa03 : b003             [ 3] 	bcs df_tk_asm_addr_mode_2
fa05 : 4c25fa           [ 3] 	jmp df_tk_indirect
fa08 :                       df_tk_asm_addr_mode_2
                             	; here just a regular address
                             	; Just one expression expected
fa08 : 2027d9           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
fa0b : a92c             [ 2] 	lda #','
fa0d : 2028d7           [ 6] 	jsr df_tk_expect_tok
fa10 : b00c             [ 3] 	bcs df_tk_asm_addr_mode_ok
                             	; must be x or y
fa12 : a978             [ 2] 	lda #'x'
fa14 : 2028d7           [ 6] 	jsr df_tk_expect_tok
fa17 : 9005             [ 3] 	bcc df_tk_asm_addr_mode_ok
                             	; got to here, must be y
AS65 Assembler for R6502 [1.42].                                     Page  264
-------------------------------- bank\bank0.s --------------------------------

fa19 : a979             [ 2] 	lda #'y'
fa1b : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
fa1e :                       df_tk_asm_addr_mode_ok
fa1e : 18               [ 2] 	clc
fa1f : 60               [ 6] 	rts
                             	
                             	
                             ;* Toeknise immediate addressing mode	
fa20 :                       df_tk_imm
                             	; Just one expression expected
fa20 : 2027d9           [ 6] 	jsr df_tk_expression
fa23 : 18               [ 2] 	clc
fa24 : 60               [ 6] 	rts
                             	
                             ;* Tokenise indirect
fa25 :                       df_tk_indirect
                             	; Just one expression expected
fa25 : 2027d9           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
fa28 : a92c             [ 2] 	lda #','
fa2a : 2028d7           [ 6] 	jsr df_tk_expect_tok
                             	; if not then might be indirect Y
fa2d : b00c             [ 3] 	bcs df_tk_indirect_y
                             	; Else must have be indirect "x)"
fa2f : a978             [ 2] 	lda #'x'
fa31 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
fa34 : a929             [ 2] 	lda #')'
fa36 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
fa39 : 18               [ 2] 	clc
fa3a : 60               [ 6] 	rts
                             	
fa3b :                       df_tk_indirect_y
                             	; Definitely has a close bracket
fa3b : a929             [ 2] 	lda #')'
fa3d : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; Is there a comma after the expression
fa40 : a92c             [ 2] 	lda #','
fa42 : 2028d7           [ 6] 	jsr df_tk_expect_tok
fa45 : b007             [ 3] 	bcs df_tk_indirect_done
                             	; if comma then must be indirect y
fa47 : a979             [ 2] 	lda #'y'
fa49 : 2035d7           [ 6] 	jsr df_tk_expect_tok_err
fa4c : 18               [ 2] 	clc
fa4d : 60               [ 6] 	rts
                             
fa4e :                       df_tk_indirect_done
fa4e : 18               [ 2] 	clc
fa4f : 60               [ 6] 	rts
                             	
                             
                             	
                             
                             
                             ;************************************************
                             ;*           TOKENISATION SUBROUTINES
                             ;************************************************
                             
                             
                             ;* HANDLE DIRECTIVES
                             
                             ;* All tokenisation is part of regular toksub rou
                             
AS65 Assembler for R6502 [1.42].                                     Page  265
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
fa50 :                       mod_sz_tkasm_e
                             
                             
                             	include "dflat\rtasm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTASM.S
                             ;*  Module that implements the runtime execution 
                             ;*  assembler.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
fa50 :                       mod_sz_rtasm_s
                             
fa50 :                       df_rt_asm_assemble
                             	; check if >=0x80 (directive or mnemonic)
fa50 : a486             [ 3] 	ldy df_exeoff
fa52 : b184             [ 5] 	lda (df_currlin),y
fa54 : c980             [ 2] 	cmp #0x80
fa56 : 9009             [ 3] 	bcc df_rt_asm_do_label
fa58 : 2065fa           [ 6] 	jsr df_rt_asm_command
fa5b : 206bfc           [ 6] 	jsr df_rt_asm_printCR
fa5e : 4c64fa           [ 3] 	jmp df_rt_asm_assemble_done
fa61 :                       df_rt_asm_do_label
fa61 : 2089fa           [ 6] 	jsr df_rt_asm_label
fa64 :                       df_rt_asm_assemble_done
AS65 Assembler for R6502 [1.42].                                     Page  266
-------------------------------- bank\bank0.s --------------------------------

                             	; any clean up here
fa64 : 60               [ 6] 	rts
                             
                             ; Jump to mnemonic or 
                             ; directive with index in A ignoring MSB
fa65 :                       df_rt_asm_command
fa65 : 297f             [ 2] 	and #0x7f
fa67 : 48               [ 3] 	pha
fa68 : aa               [ 2] 	tax
                             	; Point to Xth symtable entry of addr modes and 
fa69 : 203bfd           [ 6] 	jsr df_rt_asm_skip_to_sym
                             
                             	; Get first addressing mode (ignoring offset byt
fa6c : a001             [ 2] 	ldy #1
fa6e : b17f             [ 5] 	lda (df_symtab),y
                             	; is it a directive?
fa70 : c910             [ 2] 	cmp #AM_DIR
                             	; if directive
fa72 : f003             [ 3] 	beq df_rt_asm_dir
                             	; Else must be a normal mnemonic
fa74 : 4c55fb           [ 3] 	jmp df_rt_asm_mnem
                             
                             ; Jump to the appropriate directive
fa77 :                       df_rt_asm_dir
                             	; Get the index and *2
                             	; to get jump vector
fa77 : 68               [ 4] 	pla
fa78 : 0a               [ 2] 	asl a
fa79 : aa               [ 2] 	tax
                             	; jump over directive code
fa7a : e686             [ 5] 	inc df_exeoff
                             	; jump to directive handler
fa7c : bdc3ff           [ 4] 	lda df_rt_asm_tokenjmp,x
fa7f : 859f             [ 3] 	sta df_tmpptra
fa81 : bdc4ff           [ 4] 	lda df_rt_asm_tokenjmp+1,x
fa84 : 85a0             [ 3] 	sta df_tmpptra+1
fa86 : 6c9f00           [ 6] 	jmp (df_tmpptra)
                             
                             ; Process label
                             ; Set the label to the PC
fa89 :                       df_rt_asm_label
                             	; Get the address of the variable in A,X
fa89 : 203aed           [ 6] 	jsr df_rt_generate_lvar
fa8c : 869c             [ 3] 	stx df_asmoprnd
fa8e : 859d             [ 3] 	sta df_asmoprnd+1
                             	; Assign to value of PC
fa90 : a000             [ 2] 	ldy #0
fa92 : a597             [ 3] 	lda df_asmpc
fa94 : 919c             [ 5] 	sta (df_asmoprnd),y
fa96 : a598             [ 3] 	lda df_asmpc+1
fa98 : c8               [ 2] 	iny
fa99 : 919c             [ 5] 	sta (df_asmoprnd),y
fa9b : 60               [ 6] 	rts	
                             
                             ;* Set the code origin
fa9c :                       df_rt_asm_org
                             	; Get the address from expression
fa9c : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to PC
fa9f : a59c             [ 3] 	lda df_asmoprnd
faa1 : 8597             [ 3] 	sta df_asmpc
faa3 : a59d             [ 3] 	lda df_asmoprnd+1
AS65 Assembler for R6502 [1.42].                                     Page  267
-------------------------------- bank\bank0.s --------------------------------

faa5 : 8598             [ 3] 	sta df_asmpc+1
faa7 : a903             [ 2] 	lda #3
faa9 : 859e             [ 3] 	sta df_asmlen
faab : 2029fc           [ 6] 	jsr df_rt_asm_printPC
faae : 60               [ 6] 	rts
                             
                             ; Set the assembly option
                             ; Bit 0 set = Print code to console
                             ; But 1 set = Write code to memory
                             ; Be sure to run 2 non-write passes
                             ; before a write pass
                             ; First pass may result in ZP used a lot
                             ; Second pass resolves forward refs to ABS
                             ; Final write pass then stores the code
faaf :                       df_rt_asm_opt
                             	; Get the value from expression
faaf : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to OPT
fab2 : a59c             [ 3] 	lda df_asmoprnd
fab4 : 8599             [ 3] 	sta df_asmopt
fab6 : 60               [ 6] 	rts
                             
                             ; dw and db handled here
                             ; keep going through comma separated
                             ; list and write bytes or words
                             ; string expansion also handled
fab7 :                       df_rt_asm_db
fab7 : a902             [ 2] 	lda #2
fab9 : 859e             [ 3] 	sta df_asmlen
fabb : d004             [ 3] 	bne df_rt_asm_db_start	; Relies on A<>0
fabd :                       df_rt_asm_dw
fabd : a903             [ 2] 	lda #3
fabf : 859e             [ 3] 	sta df_asmlen
fac1 :                       df_rt_asm_db_start
fac1 : 2029fc           [ 6] 	jsr df_rt_asm_printPC
fac4 : 2046fc           [ 6] 	jsr df_rt_asm_printSPC
fac7 :                       df_rt_asm_data
fac7 : 206ce0           [ 6] 	jsr df_rt_neval		; Evaluate expression
faca : 203cf7           [ 6] 	jsr df_ost_peekType	; What is the type
facd : c980             [ 2] 	cmp #0x80			; If string
facf : b00d             [ 3] 	bcs df_rt_asm_string
fad1 : 2042f7           [ 6] 	jsr df_ost_popInt	; else get number in A,X
fad4 : 869c             [ 3] 	stx df_asmoprnd		; store low value
fad6 : 859d             [ 3] 	sta df_asmoprnd+1	; store high value
fad8 : 2006fb           [ 6] 	jsr df_rt_asm_data_write
fadb : 4cfbfa           [ 3] 	jmp df_rt_asm_data_next
fade :                       df_rt_asm_string
fade : 204cf7           [ 6] 	jsr df_ost_popPtr	; pop string pointer
fae1 : 869f             [ 3] 	stx df_tmpptra		; save pointer to tmpa
fae3 : 85a0             [ 3] 	sta df_tmpptra+1
fae5 :                       df_rt_asm_string_ch
fae5 : a000             [ 2] 	ldy #0
fae7 : b19f             [ 5] 	lda (df_tmpptra),y	; Get string char, 0=done
fae9 : f010             [ 3] 	beq df_rt_asm_data_next
faeb : 859c             [ 3] 	sta df_asmoprnd		; Save as operand
faed : 869d             [ 3] 	stx df_asmoprnd+1	; High is always zero
faef : 2006fb           [ 6] 	jsr df_rt_asm_data_write
                             	_incZPWord df_tmpptra
                             
faf8 : 4ce5fa           [ 3] 	jmp df_rt_asm_string_ch
fafb :                       df_rt_asm_data_next
fafb : 2070ed           [ 6] 	jsr df_rt_eos		; End?
AS65 Assembler for R6502 [1.42].                                     Page  268
-------------------------------- bank\bank0.s --------------------------------

fafe : b005             [ 4] 	bcs df_rt_asm_data_done
fb00 : e686             [ 5] 	inc df_exeoff		; Jump over ','
fb02 : 4cc7fa           [ 3] 	jmp df_rt_asm_data
fb05 :                       df_rt_asm_data_done
fb05 : 60               [ 6] 	rts	
                             
                             ; Write one db or dw value
                             ; Check for value too big for db
                             ; Advance PC by df_asmlen
fb06 :                       df_rt_asm_data_write
fb06 : 2050fc           [ 6] 	jsr df_rt_asm_printOPR
fb09 :                       df_rt_asm_data_write_skip1
fb09 : a902             [ 2] 	lda #2
fb0b : 2599             [ 3] 	and df_asmopt
fb0d : f015             [ 3] 	beq df_rt_asm_data_write_skip2
fb0f : a59c             [ 3] 	lda df_asmoprnd
fb11 : a000             [ 2] 	ldy #0
fb13 : 9197             [ 5] 	sta (df_asmpc),y
fb15 : c8               [ 2] 	iny
fb16 : a902             [ 2] 	lda #2
fb18 : c59e             [ 3] 	cmp df_asmlen
fb1a : f004             [ 3] 	beq df_rt_asm_data_write_hi
fb1c : a59d             [ 3] 	lda df_asmoprnd+1
fb1e : d015             [ 3] 	bne df_rt_asm_data_write_err
fb20 :                       df_rt_asm_data_write_hi
fb20 : a59d             [ 3] 	lda df_asmoprnd+1
fb22 : 9197             [ 5] 	sta (df_asmpc),y
fb24 :                       df_rt_asm_data_write_skip2
fb24 : a59e             [ 3] 	lda df_asmlen
fb26 : 38               [ 2] 	sec					; Add 1 less!
fb27 : e901             [ 2] 	sbc #1
fb29 : 18               [ 2] 	clc
fb2a : 6597             [ 3] 	adc df_asmpc
fb2c : 8597             [ 3] 	sta df_asmpc
fb2e : a598             [ 3] 	lda df_asmpc+1
fb30 : 6900             [ 2] 	adc #0
fb32 : 8598             [ 3] 	sta df_asmpc+1
fb34 : 60               [ 6] 	rts
fb35 :                       df_rt_asm_data_write_err	
                             	SWBRK DFERR_QUANTITY
                             
                             	
                             	
fb37 :                       df_rt_asm_ds
fb37 : 2029fc           [ 6] 	jsr df_rt_asm_printPC
fb3a : 2046fc           [ 6] 	jsr df_rt_asm_printSPC
                             	; Get the address from expression
fb3d : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
                             	; ADD this in to PC
fb40 : 18               [ 2] 	clc
fb41 : a59c             [ 3] 	lda df_asmoprnd
fb43 : 6597             [ 3] 	adc df_asmpc
fb45 : 8597             [ 3] 	sta df_asmpc
fb47 : a59d             [ 3] 	lda df_asmoprnd+1
fb49 : 6598             [ 3] 	adc df_asmpc+1
fb4b : 8598             [ 3] 	sta df_asmpc+1
                             	; len=1 for printing
fb4d : a903             [ 2] 	lda #3
fb4f : 859e             [ 3] 	sta df_asmlen
fb51 : 2050fc           [ 6] 	jsr df_rt_asm_printOPR
fb54 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  269
-------------------------------- bank\bank0.s --------------------------------

                             
                             ; Process a normal assembler mnemonic
fb55 :                       df_rt_asm_mnem
fb55 : 68               [ 4] 	pla				; Throw away previous temp variable
                             	; jump over mnemonic code
fb56 : e686             [ 5] 	inc df_exeoff
                             	; work out the addressing mode and get operand
fb58 : 209bfc           [ 6] 	jsr df_rt_asm_addrmode
                             
fb5b :                       df_rt_asm_mnem_try
fb5b : a59a             [ 3] 	lda df_asmadmd					; With the addressing mode
fb5d : 2023fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Find it for this 
fb60 : c900             [ 2] 	cmp #AM_NONE					; Exists?
fb62 : d014             [ 3] 	bne	df_rt_asm_mnem_chk			; If does then check it
fb64 :                       df_rt_asm_check_alt
fb64 : a69a             [ 3] 	ldx df_asmadmd					; Use ad mode as an index
fb66 : bd7cfd           [ 4] 	lda df_asm_altaddrmode,x		; Else get alternate
fb69 : c900             [ 2] 	cmp #AM_NONE					; Is there an alternate?
fb6b : f02e             [ 3] 	beq df_rt_asm_mnem_err			; If no then error
fb6d : 2023fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Check does mode e
fb70 : c900             [ 2] 	cmp #AM_NONE					; this instruction
fb72 : f027             [ 3] 	beq df_rt_asm_mnem_err			; if no then error
fb74 : c59a             [ 3] 	cmp df_asmadmd					; Same as the original?
fb76 : f00e             [ 3] 	beq df_rt_asm_mnem_done			; if so then done
fb78 :                       df_rt_asm_mnem_chk
fb78 : 859a             [ 3] 	sta df_asmadmd					; This is the final mode
fb7a : aa               [ 2] 	tax								; Get the length
fb7b : bd6bfd           [ 4] 	lda df_asm_length,x
fb7e : a69d             [ 3] 	ldx df_asmoprnd+1				; Is operand hi non-zero?
fb80 : f004             [ 3] 	beq df_rt_asm_mnem_done			; If zero then done
fb82 : c903             [ 2] 	cmp #3							; Else must be len 3?
fb84 : d0de             [ 3] 	bne df_rt_asm_check_alt			; Try an alternate
fb86 :                       df_rt_asm_mnem_done
fb86 : a69a             [ 3] 	ldx df_asmadmd					; Get the final mode index
fb88 : bd6bfd           [ 4] 	lda df_asm_length,x				; Get the length
fb8b : 859e             [ 3] 	sta df_asmlen
fb8d : a59a             [ 3] 	lda df_asmadmd					; Get the final mode
fb8f : 2023fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Get the Y index o
                             	; Ok now get the opcode
fb92 : c8               [ 2] 	iny
fb93 : b17f             [ 5] 	lda (df_symtab),y
fb95 : 859b             [ 3] 	sta df_asmopcde
                             	; Now have all information to assemble
fb97 : 209dfb           [ 6] 	jsr df_rt_asm_encode
                             	
fb9a : 60               [ 6] 	rts
fb9b :                       df_rt_asm_mnem_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ; Take assembler data and encode it
                             ; depending on the current option
                             ; Option 0 = No write
                             ; Option 1 = No write, Print
                             ; Option 2 = Write
                             ; Option 3 = Write, Print
fb9d :                       df_rt_asm_encode
                             	; If relative then need to calculate offset
fb9d : a59a             [ 3] 	lda df_asmadmd
fb9f : c90f             [ 2] 	cmp #AM_REL
fba1 : d036             [ 3] 	bne df_rt_asm_encode_skiprel
                             	; If high byte is 0 then do nothing
AS65 Assembler for R6502 [1.42].                                     Page  270
-------------------------------- bank\bank0.s --------------------------------

fba3 : a59d             [ 3] 	lda df_asmoprnd+1
fba5 : f032             [ 3] 	beq df_rt_asm_encode_skiprel
                             	; else calculate distance from PC
                             	; first take 2 off operand
fba7 : 38               [ 2] 	sec
fba8 : a59c             [ 3] 	lda df_asmoprnd
fbaa : e902             [ 2] 	sbc #2
fbac : 859c             [ 3] 	sta df_asmoprnd
fbae : a59d             [ 3] 	lda df_asmoprnd+1
fbb0 : e900             [ 2] 	sbc #0
fbb2 : 859d             [ 3] 	sta df_asmoprnd+1
                             	; now calculate current operand-PC
fbb4 : 38               [ 2] 	sec
fbb5 : a59c             [ 3] 	lda df_asmoprnd
fbb7 : e597             [ 3] 	sbc df_asmpc
fbb9 : 859c             [ 3] 	sta df_asmoprnd
fbbb : a59d             [ 3] 	lda df_asmoprnd+1
fbbd : e598             [ 3] 	sbc df_asmpc+1
                             	; put 0 in high operand storage
                             	; but A contains result of subtraction
                             	; so check that for out of range
fbbf : a000             [ 2] 	ldy #0
fbc1 : 849d             [ 3] 	sty df_asmoprnd+1
                             	; detect too far; high byte is either 0 or 255
                             	; else it's an error
fbc3 : c900             [ 2] 	cmp #0
fbc5 : f00a             [ 3] 	beq df_rt_asm_encode_relpos
fbc7 : c9ff             [ 2] 	cmp #0xff
fbc9 : d00a             [ 3] 	bne df_rt_asm_encode_relfar
                             	; if high is ff then low must be same -ve
fbcb : a59c             [ 3] 	lda df_asmoprnd
fbcd : 300a             [ 3] 	bmi df_rt_asm_encode_skiprel
                             	; else error
fbcf : 1004             [ 3] 	bpl df_rt_asm_encode_relfar
fbd1 :                       df_rt_asm_encode_relpos
                             	; if high is 00 then low must be same +ve
fbd1 : a59c             [ 3] 	lda df_asmoprnd
fbd3 : 1004             [ 3] 	bpl df_rt_asm_encode_skiprel
                             	; else error
fbd5 :                       df_rt_asm_encode_relfar
                             	; set to non-zero value
fbd5 : a9ff             [ 2] 	lda #0xff
fbd7 : 859d             [ 3] 	sta df_asmoprnd+1
fbd9 :                       df_rt_asm_encode_skiprel
                             	; Only write the code if bit 1=1
fbd9 : a902             [ 2] 	lda #0x02
fbdb : 2599             [ 3] 	and df_asmopt
fbdd : f028             [ 4] 	beq df_rt_asm_encode_print
fbdf : a000             [ 2] 	ldy #0
fbe1 : a59b             [ 3] 	lda df_asmopcde
fbe3 : 9197             [ 5] 	sta (df_asmpc),y
fbe5 : a59e             [ 3] 	lda df_asmlen
fbe7 : c901             [ 2] 	cmp #1						; No operand
fbe9 : f01c             [ 4] 	beq df_rt_asm_encode_print
fbeb : c903             [ 2] 	cmp #3						; Word operand
fbed : f00e             [ 3] 	beq df_rt_asm_encode_writeword
                             	; byte operand, high byte must be zero
fbef : a59d             [ 3] 	lda df_asmoprnd+1
fbf1 : f002             [ 3] 	beq df_rt_asm_encode_writebyte
                             	SWBRK DFERR_QUANTITY
                             
fbf5 :                       df_rt_asm_encode_writebyte
AS65 Assembler for R6502 [1.42].                                     Page  271
-------------------------------- bank\bank0.s --------------------------------

fbf5 : c8               [ 2] 	iny 
fbf6 : a59c             [ 3] 	lda df_asmoprnd
fbf8 : 9197             [ 5] 	sta (df_asmpc),y
fbfa : 4c07fc           [ 3] 	jmp df_rt_asm_encode_print
fbfd :                       df_rt_asm_encode_writeword
fbfd : c8               [ 2] 	iny 
fbfe : a59c             [ 3] 	lda df_asmoprnd
fc00 : 9197             [ 5] 	sta (df_asmpc),y
fc02 : c8               [ 2] 	iny 
fc03 : a59d             [ 3] 	lda df_asmoprnd+1
fc05 : 9197             [ 5] 	sta (df_asmpc),y	
fc07 :                       df_rt_asm_encode_print
fc07 : 2019fc           [ 6] 	jsr df_rt_asm_print_mmen
                             	; advance pc
fc0a : 18               [ 2] 	clc
fc0b : a597             [ 3] 	lda df_asmpc
fc0d : 659e             [ 3] 	adc df_asmlen
fc0f : 8597             [ 3] 	sta df_asmpc
fc11 : a598             [ 3] 	lda df_asmpc+1
fc13 : 6900             [ 2] 	adc #0
fc15 : 8598             [ 3] 	sta df_asmpc+1
fc17 : 18               [ 2] 	clc
fc18 : 60               [ 6] 	rts
                             
                             
                             ; Print the full 1,2,3 byte instruction
                             ; depends on df_asmopt
fc19 :                       df_rt_asm_print_mmen
fc19 : 2029fc           [ 6] 	jsr df_rt_asm_printPC
fc1c : 2046fc           [ 6] 	jsr df_rt_asm_printSPC
fc1f : 203afc           [ 6] 	jsr df_rt_asm_printOPC
fc22 : 2046fc           [ 6] 	jsr df_rt_asm_printSPC
fc25 : 2050fc           [ 6] 	jsr df_rt_asm_printOPR
fc28 :                       df_rt_asm_print_rts			; Hopefull subs can get her
fc28 : 60               [ 6] 	rts
                             
fc29 :                       df_rt_asm_printPC
                             	; Check the option bit 0 (Print)
fc29 : a901             [ 2] 	lda #0x01
fc2b : 2599             [ 3] 	and df_asmopt
fc2d : f0f9             [ 3] 	beq df_rt_asm_print_rts
                             	; Print current PC
fc2f : a598             [ 3] 	lda df_asmpc+1
fc31 : 2074c1           [ 6] 	jsr utilPrintA
fc34 : a597             [ 3] 	lda df_asmpc
fc36 : 2074c1           [ 6] 	jsr utilPrintA
fc39 : 60               [ 6] 	rts
                             
fc3a :                       df_rt_asm_printOPC
                             	; Check the option bit 0 (Print)
fc3a : a901             [ 2] 	lda #0x01
fc3c : 2599             [ 3] 	and df_asmopt
fc3e : f0e8             [ 3] 	beq df_rt_asm_print_rts
fc40 : a59b             [ 3] 	lda df_asmopcde
fc42 : 2074c1           [ 6] 	jsr utilPrintA
fc45 : 60               [ 6] 	rts
                             
fc46 :                       df_rt_asm_printSPC
                             	; Check the option bit 0 (Print)
fc46 : a901             [ 2] 	lda #0x01
fc48 : 2599             [ 3] 	and df_asmopt
fc4a : f0dc             [ 3] 	beq df_rt_asm_print_rts
AS65 Assembler for R6502 [1.42].                                     Page  272
-------------------------------- bank\bank0.s --------------------------------

fc4c : 2064c1           [ 6] 	jsr utilPrintSPC
fc4f : 60               [ 6] 	rts
                             	
                             	
fc50 :                       df_rt_asm_printOPR
                             	; Check the option bit 0 (Print)
fc50 : a901             [ 2] 	lda #0x01
fc52 : 2599             [ 3] 	and df_asmopt
fc54 : f0d2             [ 3] 	beq df_rt_asm_print_rts	
fc56 : a59e             [ 3] 	lda df_asmlen				; check how may operand bytes
fc58 : c901             [ 2] 	cmp #1						; if only opcode, done
fc5a : f0cc             [ 3] 	beq df_rt_asm_print_rts	
fc5c : c902             [ 2] 	cmp #2
fc5e : f005             [ 3] 	beq df_rt_asm_printOPR_1	; if only 2 do low byte
fc60 : a59d             [ 3] 	lda df_asmoprnd+1
fc62 : 2074c1           [ 6] 	jsr utilPrintA
fc65 :                       df_rt_asm_printOPR_1
fc65 : a59c             [ 3] 	lda df_asmoprnd
fc67 : 2074c1           [ 6] 	jsr utilPrintA
fc6a : 60               [ 6] 	rts
                             
fc6b :                       df_rt_asm_printCR
                             	; Check the option bit 0 (Print)
fc6b : a901             [ 2] 	lda #0x01
fc6d : 2599             [ 3] 	and df_asmopt
fc6f : f0b7             [ 3] 	beq df_rt_asm_print_rts
fc71 : 206cc1           [ 6] 	jsr utilPrintCRLF
fc74 : 60               [ 6] 	rts
                             
fc75 :                       df_rt_asm_printCH
fc75 : 8536             [ 3] 	sta tmp_d
                             	; Check the option bit 0 (Print)
fc77 : a901             [ 2] 	lda #0x01
fc79 : 2599             [ 3] 	and df_asmopt
fc7b : f0ab             [ 3] 	beq df_rt_asm_print_rts
fc7d : a536             [ 3] 	lda tmp_d
fc7f : 4c4bc4           [ 3] 	jmp io_put_ch
fc82 : 60               [ 6] 	rts
                             
                             ; Print an entire line, but save df_exeoff
fc83 :                       df_rt_asm_printline
                             	; Check the option bit 0 (Print)
fc83 : a901             [ 2] 	lda #0x01
fc85 : 2599             [ 3] 	and df_asmopt
fc87 : f09f             [ 3] 	beq df_rt_asm_print_rts
fc89 : a586             [ 3] 	lda df_exeoff
fc8b : 48               [ 3] 	pha
                             	; use df_tmpptra
                             	_cpyZPWord df_currlin, df_tmpptra
                             
fc94 : 20eaee           [ 6] 	jsr df_rt_list_line_only
fc97 : 68               [ 4] 	pla
fc98 : 8586             [ 3] 	sta df_exeoff
fc9a : 60               [ 6] 	rts
                             
                             
                             ; Calculate the addressing mode
                             ; Populate the operand as needed
                             ; A and df_asmadmd contain Addressing Mode
fc9b :                       df_rt_asm_addrmode	
                             	; Store nothing in address mode
fc9b : a900             [ 2] 	lda #AM_NONE
AS65 Assembler for R6502 [1.42].                                     Page  273
-------------------------------- bank\bank0.s --------------------------------

fc9d : 859a             [ 3] 	sta df_asmadmd
                             	; zero out the operand
fc9f : a900             [ 2] 	lda #0
fca1 : 859c             [ 3] 	sta df_asmoprnd
fca3 : 859d             [ 3] 	sta df_asmoprnd+1
                             	; jump over whitespace
fca5 : 202ee5           [ 6] 	jsr df_rt_skip_ws
fca8 : 2070ed           [ 6] 	jsr df_rt_eos			; End of statement?
fcab : b00a             [ 3] 	bcs df_rt_asm_AM_IMP
                             	; Check what it is
fcad : c923             [ 2] 	cmp #'#'				; Immediate?
fcaf : f034             [ 3] 	beq df_rt_asm_AM_IMM
fcb1 : c928             [ 2] 	cmp #'('				; Indirect something?
fcb3 : f03a             [ 3] 	beq df_rt_asm_AM_INDIRECT
                             	; Must be ABS,ZP or REL
fcb5 : d005             [ 3] 	bne df_rt_asm_ABSREL
                             ; Process IMP/ACC
fcb7 :                       df_rt_asm_AM_IMP
fcb7 : a90d             [ 2] 	lda #AM_IMP
fcb9 : 859a             [ 3] 	sta df_asmadmd
fcbb : 60               [ 6] 	rts
                             ; Process ABS or REL
fcbc :                       df_rt_asm_ABSREL	
                             	; Evaluate operand
fcbc : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
fcbf : 2070ed           [ 6] 	jsr df_rt_eos			; End of statement?
fcc2 : b00f             [ 3] 	bcs df_rt_asm_AM_ABS
fcc4 : c8               [ 2] 	iny						; Jump over ","
fcc5 : b184             [ 5] 	lda (df_currlin),y		; Load X or Y
fcc7 : c8               [ 2] 	iny						; Jump over index reg
fcc8 : 8586             [ 3] 	sta df_exeoff			; Save exe offset
fcca : c978             [ 2] 	cmp #'x'				; Indirect X?
fccc : f012             [ 3] 	beq df_rt_asm_AM_ABSX
                             ; Process ABSY
fcce :                       df_rt_asm_AM_ABSY
fcce : a906             [ 2] 	lda #AM_ZPY				; Go for smallest modes
fcd0 : 859a             [ 3] 	sta df_asmadmd
fcd2 : 60               [ 6] 	rts
                             ; Process what looks like pure ABS, could be REL
fcd3 :                       df_rt_asm_AM_ABS
fcd3 : a001             [ 2] 	ldy #1					; Check first addressing mode
fcd5 : b17f             [ 5] 	lda (df_symtab),y
fcd7 : c90f             [ 2] 	cmp #AM_REL
fcd9 : f002             [ 3] 	beq df_rt_asm_AM_REL
fcdb : a904             [ 2] 	lda #AM_ZP				; Go for smallest modes
fcdd :                       df_rt_asm_AM_REL
fcdd : 859a             [ 3] 	sta df_asmadmd
fcdf : 60               [ 6] 	rts
                             ; Process ABSX
fce0 :                       df_rt_asm_AM_ABSX
fce0 : a905             [ 2] 	lda #AM_ZPX				; Go for smallest modes
fce2 : 859a             [ 3] 	sta df_asmadmd
fce4 : 60               [ 6] 	rts
                             ; Process Immediate
fce5 :                       df_rt_asm_AM_IMM
                             	; skip over #
fce5 : e686             [ 5] 	inc df_exeoff
                             	; Get operand
fce7 : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Mark as immediate
fcea : a90c             [ 2] 	lda #AM_IMM
fcec : 859a             [ 3] 	sta df_asmadmd
AS65 Assembler for R6502 [1.42].                                     Page  274
-------------------------------- bank\bank0.s --------------------------------

fcee : 60               [ 6] 	rts
                             ; Process indirect
fcef :                       df_rt_asm_AM_INDIRECT
                             	; skip over (
fcef : e686             [ 5] 	inc df_exeoff
                             	; Calculate the operand
fcf1 : 2018fd           [ 6] 	jsr df_rt_asm_get_operand
                             	; what is next char?
fcf4 : a486             [ 3] 	ldy df_exeoff
fcf6 : b184             [ 5] 	lda (df_currlin),y
fcf8 : c929             [ 2] 	cmp #')'			; Could be IND or INDY
fcfa : f009             [ 4] 	beq df_rt_asm_AM_ZPINDORY
                             	; else must be INDX
                             	; skip 'x)'
fcfc : c8               [ 2] 	iny
fcfd : c8               [ 2] 	iny
fcfe : 8486             [ 3] 	sty df_exeoff
fd00 : a908             [ 2] 	lda #AM_ZPINDX
fd02 : 859a             [ 3] 	sta df_asmadmd
fd04 : 60               [ 6] 	rts
                             ; Pure indirect mode found
fd05 :                       df_rt_asm_AM_ZPINDORY
fd05 : a907             [ 2] 	lda #AM_ZPIND			; Assume ZPIND
fd07 : c8               [ 2] 	iny
fd08 : 8486             [ 3] 	sty df_exeoff
                             	; if at end of line/statement then pure indirect
fd0a : 2070ed           [ 6] 	jsr df_rt_eos			; End of statement?
fd0d : b006             [ 3] 	bcs df_rt_asm_AM_ZPIND
                             	; else must be INDY
fd0f : a909             [ 2] 	lda #AM_ZPINDY
                             	; skip ',Y'
fd11 : c8               [ 2] 	iny
fd12 : c8               [ 2] 	iny
fd13 : 8486             [ 3] 	sty df_exeoff
fd15 :                       df_rt_asm_AM_ZPIND
fd15 : 859a             [ 3] 	sta df_asmadmd
fd17 : 60               [ 6] 	rts
                             
                             ; Get and save the operand
                             ; df_asmoprnd contains the result
fd18 :                       df_rt_asm_get_operand
                             	; evaluate
fd18 : 206ce0           [ 6] 	jsr df_rt_neval
                             	; Get the parameter from stack
fd1b : 2042f7           [ 6] 	jsr df_ost_popInt
                             	; put in the operand
fd1e : 869c             [ 3] 	stx df_asmoprnd
fd20 : 859d             [ 3] 	sta df_asmoprnd+1
fd22 : 60               [ 6] 	rts
                             	
                             ; From current symtab entry, find addressing
                             ; mode in A.  AM_NONE=Not found, Y=index
fd23 :                       df_rt_asm_find_addr_mode
                             	; save A in tmp
fd23 : 8536             [ 3] 	sta tmp_d
                             	; Start first entry (1) - 2 = 0xff
fd25 : a0ff             [ 2] 	ldy #0xff
fd27 : a200             [ 2] 	ldx #0
fd29 :                       df_rt_asm_find_addr_mode_loop
                             	; next entry
fd29 : c8               [ 2] 	iny
fd2a : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  275
-------------------------------- bank\bank0.s --------------------------------

                             	; if current index > num entries then error
fd2b : 98               [ 2] 	tya
fd2c : 38               [ 2] 	sec
fd2d : e17f             [ 6] 	sbc (df_symtab,x)
fd2f : b007             [ 3] 	bcs df_rt_asm_find_addr_mode_err
                             	; is symtab addressing mode what we want?
fd31 : b17f             [ 5] 	lda (df_symtab),y
fd33 : c536             [ 3] 	cmp tmp_d
fd35 : d0f2             [ 3] 	bne df_rt_asm_find_addr_mode_loop
                             	; done A=mode, y=index in to df_symtab
fd37 : 60               [ 6] 	rts
fd38 :                       df_rt_asm_find_addr_mode_err
fd38 : a900             [ 2] 	lda #AM_NONE
fd3a : 60               [ 6] 	rts
                             
                             
                             ; Skip X amount of symbols in table
                             ; A contains how many addr mode and op code bytes
                             ; df_symtab points to offset byte
fd3b :                       df_rt_asm_skip_to_sym
fd3b : e8               [ 2] 	inx				; so done when X=0
                             	; Start at token symbols beginning
fd3c : a98d             [ 2] 	lda #lo(df_asm_tokensyms)
fd3e : 857f             [ 3] 	sta df_symtab
fd40 : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
fd42 : 8580             [ 3] 	sta df_symtab+1
fd44 : a900             [ 2] 	lda #0
fd46 : 8581             [ 3] 	sta df_symoff
fd48 : a000             [ 2] 	ldy #0
fd4a :                       df_rt_asm_skip_to_sym_next
                             	; Get symtable char
fd4a : b17f             [ 5] 	lda (df_symtab),y
                             	; if < ' ' then jumped over symbol chars
fd4c : c920             [ 2] 	cmp #' '
fd4e : 9009             [ 3] 	bcc df_rt_asm_skip_to_sym_end
                             	;else next smy tab char
                             	_incZPWord df_symtab
                             
fd56 : 4c4afd           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             	; Found end of symbol
fd59 :                       df_rt_asm_skip_to_sym_end
                             	;if done then return
fd59 : ca               [ 2] 	dex
fd5a : f00e             [ 3] 	beq df_rt_asm_skip_to_sym_done
                             	;jump over addr and op code by A bytes
fd5c : 38               [ 2] 	sec
fd5d : 657f             [ 3] 	adc df_symtab
fd5f : 857f             [ 3] 	sta df_symtab
fd61 : a580             [ 3] 	lda df_symtab+1
fd63 : 6900             [ 2] 	adc #0
fd65 : 8580             [ 3] 	sta df_symtab+1
fd67 : 4c4afd           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             	
fd6a :                       df_rt_asm_skip_to_sym_done
fd6a : 60               [ 6] 	rts
                             
fd6b :                       mod_sz_rtasm_e
                             
                             
                             	include "dflat\asmsymtab.s"
                             ;************************************************
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  276
-------------------------------- bank\bank0.s --------------------------------

                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMSYMTAB.S
                             ;*	Mainly this contains the symbol table for asse
                             ;*	mnemonics but also meta data like what address
                             ;*	and the length of opcodes.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             	;* Length of each addressing mode
                             	;* ORDER significant!
fd6b :                       df_asm_length
fd6b : 00030303020202..      	db	0,3,3,3,2,2,2,2,2,2,3,3,2,1,1,2,0
                             
                             	; Always try for lowest addressing mode, but
                             	; this table maps to alternative
fd7c :                       df_asm_altaddrmode
fd7c : 00                    	db AM_NONE		;AM_NONE	= 0
fd7d : 00                    	db AM_NONE		;AM_ABS	 	= 1
fd7e : 00                    	db AM_NONE		;AM_ABSX	= 2
fd7f : 00                    	db AM_NONE		;AM_ABSY	= 3
fd80 : 01                    	db AM_ABS		;AM_ZP		= 4
fd81 : 02                    	db AM_ABSX		;AM_ZPX		= 5
fd82 : 03                    	db AM_ABSY		;AM_ZPY		= 6
fd83 : 0a                    	db AM_ABSIND	;AM_ZPIND	= 7
fd84 : 0b                    	db AM_ABSINDX	;AM_ZPINDX	= 8
fd85 : 09                    	db AM_ZPINDY	;AM_ZPINDY	= 9
fd86 : 00                    	db AM_NONE		;AM_ABSIND	= 10
fd87 : 00                    	db AM_NONE		;AM_ABSINDX	= 11
fd88 : 00                    	db AM_NONE		;AM_IMM		= 12
fd89 : 00                    	db AM_NONE		;AM_ACC		= 13
fd8a : 00                    	db AM_NONE		;AM_IMP		= AM_ACC
fd8b : 0f                    	db AM_REL		;AM_REL		= 15
fd8c : 00                    	db AM_NONE		;AM_DIR		= 16
                             
                             
                             	;*	Mnemonic/	How many addressing modes /
                             	;* 	Mode		Opcode for mode
fd8d :                       df_asm_tokensyms
                             	;* Start with directives
fd8d : 6f726702              	db	"org",		1*2
fd91 : 1000                  	db	AM_DIR,		0x00
fd93 : 6f707402              	db	"opt",		1*2
fd97 : 1000                  	db	AM_DIR,		0x00
fd99 : 646202                	db	"db",		1*2
fd9c : 1000                  	db	AM_DIR,		0x00
fd9e : 647702                	db	"dw",		1*2
fda1 : 1000                  	db	AM_DIR,		0x00
fda3 : 647302                	db	"ds",		1*2
fda6 : 1000                  	db	AM_DIR,		0x00	
                             
fda8 : 61646310              	db	"adc",		8*2
fdac : 0c69                  	db	AM_IMM,		0x69
fdae : 0465                  	db	AM_ZP,		0x65
fdb0 : 0575                  	db	AM_ZPX,		0x75
AS65 Assembler for R6502 [1.42].                                     Page  277
-------------------------------- bank\bank0.s --------------------------------

fdb2 : 016d                  	db	AM_ABS,		0x6d
fdb4 : 027d                  	db	AM_ABSX,	0x7d
fdb6 : 0379                  	db	AM_ABSY,	0x79
fdb8 : 0861                  	db	AM_ZPINDX,	0x61
fdba : 0971                  	db	AM_ZPINDY,	0x71
                             	
fdbc : 616e6410              	db	"and",		8*2
fdc0 : 0c29                  	db	AM_IMM,		0x29
fdc2 : 0425                  	db	AM_ZP,		0x25
fdc4 : 0535                  	db	AM_ZPX,		0x35
fdc6 : 012d                  	db	AM_ABS,		0x2d
fdc8 : 023d                  	db	AM_ABSX,	0x3d
fdca : 0339                  	db	AM_ABSY,	0x39
fdcc : 0821                  	db	AM_ZPINDX,	0x21
fdce : 0931                  	db	AM_ZPINDY,	0x31
                             
fdd0 : 636d7010              	db	"cmp",		8*2
fdd4 : 0cc9                  	db	AM_IMM,		0xc9
fdd6 : 04c5                  	db	AM_ZP,		0xc5
fdd8 : 05d5                  	db	AM_ZPX,		0xd5
fdda : 01cd                  	db	AM_ABS,		0xcd
fddc : 02dd                  	db	AM_ABSX,	0xdd
fdde : 03d9                  	db	AM_ABSY,	0xd9
fde0 : 08c1                  	db	AM_ZPINDX,	0xc1
fde2 : 09d1                  	db	AM_ZPINDY,	0xd1
                             
fde4 : 656f7210              	db	"eor",		8*2
fde8 : 0c49                  	db	AM_IMM,		0x49
fdea : 0445                  	db	AM_ZP,		0x45
fdec : 0555                  	db	AM_ZPX,		0x55
fdee : 014d                  	db	AM_ABS,		0x4d
fdf0 : 025d                  	db	AM_ABSX,	0x5d
fdf2 : 0359                  	db	AM_ABSY,	0x59
fdf4 : 0841                  	db	AM_ZPINDX,	0x41
fdf6 : 0951                  	db	AM_ZPINDY,	0x51
                             
fdf8 : 6c646110              	db	"lda",		8*2
fdfc : 0ca9                  	db	AM_IMM,		0xa9
fdfe : 04a5                  	db	AM_ZP,		0xa5
fe00 : 05b5                  	db	AM_ZPX,		0xb5
fe02 : 01ad                  	db	AM_ABS,		0xad
fe04 : 02bd                  	db	AM_ABSX,	0xbd
fe06 : 03b9                  	db	AM_ABSY,	0xb9
fe08 : 08a1                  	db	AM_ZPINDX,	0xa1
fe0a : 09b1                  	db	AM_ZPINDY,	0xb1
                             
fe0c : 6f726110              	db	"ora",		8*2
fe10 : 0c09                  	db	AM_IMM,		0x09
fe12 : 0405                  	db	AM_ZP,		0x05
fe14 : 0515                  	db	AM_ZPX,		0x15
fe16 : 010d                  	db	AM_ABS,		0x0d
fe18 : 021d                  	db	AM_ABSX,	0x1d
fe1a : 0319                  	db	AM_ABSY,	0x19
fe1c : 0801                  	db	AM_ZPINDX,	0x01
fe1e : 0911                  	db	AM_ZPINDY,	0x11
                             
fe20 : 73626310              	db	"sbc",		8*2
fe24 : 0ce9                  	db	AM_IMM,		0xe9
fe26 : 04e5                  	db	AM_ZP,		0xe5
fe28 : 05f5                  	db	AM_ZPX,		0xf5
fe2a : 01ed                  	db	AM_ABS,		0xed
fe2c : 02fd                  	db	AM_ABSX,	0xfd
AS65 Assembler for R6502 [1.42].                                     Page  278
-------------------------------- bank\bank0.s --------------------------------

fe2e : 03f9                  	db	AM_ABSY,	0xf9
fe30 : 08e1                  	db	AM_ZPINDX,	0xe1
fe32 : 09f1                  	db	AM_ZPINDY,	0xf1
                             
fe34 : 73746110              	db	"sta",		8*2
fe38 : 0485                  	db	AM_ZP,		0x85
fe3a : 0585                  	db	AM_ZPX,		0x85
fe3c : 018d                  	db	AM_ABS,		0x8d
fe3e : 029d                  	db	AM_ABSX,	0x9d
fe40 : 0399                  	db	AM_ABSY,	0x99
fe42 : 0881                  	db	AM_ZPINDX,	0x81
fe44 : 0991                  	db	AM_ZPINDY,	0x91
fe46 : 0792                  	db	AM_ZPIND,	0x92
                             
fe48 : 61736c0a              	db	"asl",		5*2
fe4c : 0d0a                  	db	AM_IMP,		0x0a
fe4e : 0406                  	db	AM_ZP,		0x06
fe50 : 0516                  	db	AM_ZPX,		0x16
fe52 : 010e                  	db	AM_ABS,		0x0e
fe54 : 021e                  	db	AM_ABSX,	0x1e
fe56 : 64656308              	db	"dec",		4*2
fe5a : 04c6                  	db	AM_ZP,		0xc6
fe5c : 05d6                  	db	AM_ZPX,		0xd6
fe5e : 01ce                  	db	AM_ABS,		0xce
fe60 : 02de                  	db	AM_ABSX,	0xde
fe62 : 696e6308              	db	"inc",		4*2
fe66 : 04e6                  	db	AM_ZP,		0xe6
fe68 : 05f6                  	db	AM_ZPX,		0xf6
fe6a : 01ee                  	db	AM_ABS,		0xee
fe6c : 02fe                  	db	AM_ABSX,	0xfe
fe6e : 6c73720a              	db	"lsr",		5*2
fe72 : 0d4a                  	db	AM_IMP,		0x4a
fe74 : 0446                  	db	AM_ZP,		0x46
fe76 : 0556                  	db	AM_ZPX,		0x56
fe78 : 014e                  	db	AM_ABS,		0x4e
fe7a : 025e                  	db	AM_ABSX,	0x5e
fe7c : 726f6c0a              	db	"rol",		5*2
fe80 : 0d2a                  	db	AM_IMP,		0x2a
fe82 : 0426                  	db	AM_ZP,		0x26
fe84 : 0536                  	db	AM_ZPX,		0x36
fe86 : 012e                  	db	AM_ABS,		0x2e
fe88 : 023e                  	db	AM_ABSX,	0x3e
fe8a : 726f720a              	db	"ror",		5*2
fe8e : 0d6a                  	db	AM_IMP,		0x6a
fe90 : 0466                  	db	AM_ZP,		0x66
fe92 : 0576                  	db	AM_ZPX,		0x76
fe94 : 016e                  	db	AM_ABS,		0x6e
fe96 : 027e                  	db	AM_ABSX,	0x7e
                             
fe98 : 62697404              	db	"bit",		2*2
fe9c : 0424                  	db	AM_ZP,		0x24
fe9e : 012c                  	db	AM_ABS,		0x2c
                             	
fea0 : 62726b02              	db	"brk",		1*2
fea4 : 0d00                  	db	AM_IMP,		0x00
                             	
fea6 : 636c6302              	db	"clc",		1*2
feaa : 0d18                  	db	AM_IMP,		0x18
feac : 636c6402              	db	"cld",		1*2
feb0 : 0dd8                  	db	AM_IMP,		0xd8
feb2 : 636c6902              	db	"cli",		1*2
feb6 : 0d58                  	db	AM_IMP,		0x58
AS65 Assembler for R6502 [1.42].                                     Page  279
-------------------------------- bank\bank0.s --------------------------------

feb8 : 636c7602              	db	"clv",		1*2
febc : 0db8                  	db	AM_IMP,		0xb8
febe : 73656302              	db	"sec",		1*2
fec2 : 0d38                  	db	AM_IMP,		0x38
fec4 : 73656402              	db	"sed",		1*2
fec8 : 0df8                  	db	AM_IMP,		0xf8
feca : 73656902              	db	"sei",		1*2
fece : 0d78                  	db	AM_IMP,		0x78
                             	
fed0 : 63707806              	db	"cpx",		3*2
fed4 : 0ce0                  	db	AM_IMM,		0xe0
fed6 : 04e4                  	db	AM_ZP,		0xe4
fed8 : 01ec                  	db	AM_ABS,		0xec
feda : 63707906              	db	"cpy",		3*2
fede : 0cc0                  	db	AM_IMM,		0xc0
fee0 : 04c4                  	db	AM_ZP,		0xc4
fee2 : 01cc                  	db	AM_ABS,		0xcc
fee4 : 64657802              	db	"dex",		1*2
fee8 : 0dca                  	db	AM_IMP,		0xca
feea : 64657902              	db	"dey",		1*2
feee : 0d88                  	db	AM_IMP,		0x88
fef0 : 696e7802              	db	"inx",		1*2
fef4 : 0de8                  	db	AM_IMP,		0xe8
fef6 : 696e7902              	db	"iny",		1*2
fefa : 0dc8                  	db	AM_IMP,		0xc8
fefc : 6c64780a              	db	"ldx",		5*2
ff00 : 0ca2                  	db	AM_IMM,		0xa2
ff02 : 04a6                  	db	AM_ZP,		0xa6
ff04 : 06b6                  	db	AM_ZPY,		0xb6
ff06 : 01ae                  	db	AM_ABS,		0xae
ff08 : 03be                  	db	AM_ABSY,	0xbe
ff0a : 6c64790a              	db	"ldy",		5*2
ff0e : 0ca0                  	db	AM_IMM,		0xa0
ff10 : 04a4                  	db	AM_ZP,		0xa4
ff12 : 05b4                  	db	AM_ZPX,		0xb4
ff14 : 01ac                  	db	AM_ABS,		0xac
ff16 : 02bc                  	db	AM_ABSX,	0xbc
ff18 : 73747806              	db	"stx",		3*2
ff1c : 0486                  	db	AM_ZP,		0x86
ff1e : 0696                  	db	AM_ZPY,		0x96
ff20 : 018e                  	db	AM_ABS,		0x8e
ff22 : 73747906              	db	"sty",		3*2
ff26 : 0484                  	db	AM_ZP,		0x84
ff28 : 0594                  	db	AM_ZPX,		0x94
ff2a : 018c                  	db	AM_ABS,		0x8c
                             
ff2c : 62636302              	db	"bcc",		1*2
ff30 : 0f90                  	db	AM_REL,		0x90
ff32 : 62637302              	db	"bcs",		1*2
ff36 : 0fb0                  	db	AM_REL,		0xb0
ff38 : 62657102              	db	"beq",		1*2
ff3c : 0ff0                  	db	AM_REL,		0xf0
ff3e : 626d6902              	db	"bmi",		1*2
ff42 : 0f30                  	db	AM_REL,		0x30
ff44 : 626e6502              	db	"bne",		1*2
ff48 : 0fd0                  	db	AM_REL,		0xd0
ff4a : 62706c02              	db	"bpl",		1*2
ff4e : 0f10                  	db	AM_REL,		0x10
ff50 : 62766302              	db	"bvc",		1*2
ff54 : 0f50                  	db	AM_REL,		0x50
ff56 : 62767302              	db	"bvs",		1*2
ff5a : 0f70                  	db	AM_REL,		0x70
AS65 Assembler for R6502 [1.42].                                     Page  280
-------------------------------- bank\bank0.s --------------------------------

ff5c : 6a6d7004              	db	"jmp",		2*2
ff60 : 014c                  	db	AM_ABS,		0x4c
ff62 : 0a6c                  	db	AM_ABSIND,	0x6c
ff64 : 6a737202              	db	"jsr",		1*2
ff68 : 0120                  	db	AM_ABS,		0x20
                             	
ff6a : 6e6f7002              	db	"nop",		1*2
ff6e : 0dea                  	db	AM_IMP,		0xea
ff70 : 70686102              	db	"pha",		1*2
ff74 : 0d48                  	db	AM_IMP,		0x48
ff76 : 70687002              	db	"php",		1*2
ff7a : 0d08                  	db	AM_IMP,		0x08
ff7c : 706c6102              	db	"pla",		1*2
ff80 : 0d68                  	db	AM_IMP,		0x68
ff82 : 706c7002              	db	"plp",		1*2
ff86 : 0d28                  	db	AM_IMP,		0x28
ff88 : 72746902              	db	"rti",		1*2
ff8c : 0d40                  	db	AM_IMP,		0x40
ff8e : 72747302              	db	"rts",		1*2
ff92 : 0d60                  	db	AM_IMP,		0x60
ff94 : 74617802              	db	"tax",		1*2
ff98 : 0daa                  	db	AM_IMP,		0xaa
ff9a : 74617902              	db	"tay",		1*2
ff9e : 0da8                  	db	AM_IMP,		0xa8
ffa0 : 74737802              	db	"tsx",		1*2
ffa4 : 0dba                  	db	AM_IMP,		0xba
ffa6 : 74786102              	db	"txa",		1*2
ffaa : 0d8a                  	db	AM_IMP,		0x8a
ffac : 74787302              	db	"txs",		1*2
ffb0 : 0d9a                  	db	AM_IMP,		0x9a
ffb2 : 74796102              	db	"tya",		1*2
ffb6 : 0d98                  	db	AM_IMP,		0x98	
                             	
                             	;* Terminates with a zero
ffb8 : 00                    	db	0
                             
                             	include	"dflat\asmjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMJUMPTAB.S
                             ;*  Runtime token jump table for assembler.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
AS65 Assembler for R6502 [1.42].                                     Page  281
-------------------------------- bank\bank0.s --------------------------------

                             
                             ; Tokeniser jump table
                             ; Only directives needed as all opcodes are handl
                             ; through a single routine
ffb9 :                       df_tk_asm_tokenjmp
ffb9 : 49de                  	dw	df_tk_asm_org
ffbb : 49de                  	dw	df_tk_asm_opt
ffbd : b6dd                  	dw	df_tk_asm_db
ffbf : b6dd                  	dw	df_tk_asm_dw
ffc1 : 49de                  	dw	df_tk_asm_ds
                             
ffc3 :                       df_rt_asm_tokenjmp
ffc3 : 9cfa                  	dw	df_rt_asm_org
ffc5 : affa                  	dw	df_rt_asm_opt
ffc7 : b7fa                  	dw	df_rt_asm_db
ffc9 : bdfa                  	dw	df_rt_asm_dw
ffcb : 37fb                  	dw	df_rt_asm_ds
                             
                             
                             ;****************************************
                             ;* as_init
                             ;* Initialise assembler settings
                             ;****************************************
ffcd :                       asm_init
                             	; Zero the PC
ffcd : a900             [ 2] 	lda #0
ffcf : 8597             [ 3] 	sta df_asmpc
ffd1 : 8598             [ 3] 	sta df_asmpc+1
                             	; Zero the option
ffd3 : 8599             [ 3] 	sta df_asmopt
ffd5 : 60               [ 6] 	rts
                             	
ffd6 :                       mod_sz_asm_e
                             
ffd6 :                       mod_sz_language_e
                             	; End of Code
ffd6 :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
