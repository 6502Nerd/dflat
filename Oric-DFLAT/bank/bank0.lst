AS65 Assembler for R6502 [1.42].                                     Page    1
-------------------------------- bank\bank0.s --------------------------------

-------------------------------- Symbol Table --------------------------------

              Symbol   Value        Decimal

                 ACR : $000b             11   *
              AM_ABS : $0001              1   *
           AM_ABSIND : $000a             10   *
          AM_ABSINDX : $000b             11   *
             AM_ABSX : $0002              2   *
             AM_ABSY : $0003              3   *
              AM_ACC : $000d             13   *
              AM_DIR : $0010             16   *
              AM_IMM : $000c             12   *
              AM_IMP : $000d             13   *
             AM_NONE : $0000              0   *
              AM_REL : $000f             15   *
               AM_ZP : $0004              4   *
            AM_ZPIND : $0007              7   *
           AM_ZPINDX : $0008              8   *
           AM_ZPINDY : $0009              9   *
              AM_ZPX : $0005              5   *
              AM_ZPY : $0006              6   *
            asm_init : $fed5          65237
               BANK0 : $0001              1
             bcd_str : $c3ad          50093
          bcd_to_str : $c3a0          50080
      bin_to_bcd_bit : $c382          50050
              buf_ef : $003c             60
              buf_hi : $003a             58
              buf_lo : $0039             57
              buf_sz : $003b             59
     CMD_ERR_NOERROR : $0000              0   *
    CMD_ERR_NOTFOUND : $0001              1   *
        CMD_ERR_PARM : $0002              2   *
         CMD_ERR_VAL : $0003              3   *
           CRSR_DOWN : $000a             10   *
           CRSR_LEFT : $0008              8   *
          CRSR_RIGHT : $0009              9   *
             CRSR_UP : $000b             11   *
           CTRL_CAPS : $0014             20   *
        call_irq_brk : $c0e9          49385
     call_irq_master : $c0e6          49382
   call_irq_usercia0 : $c0ec          49388
       cmd_check_cmd : $d31c          54044
         cmd_check_d : $d32f          54063
         cmd_check_s : $d333          54067
         cmd_dumpmem : $d363          54115
    cmd_dumpmemASCII : $d387          54151
      cmd_dumpmemFin : $d3bc          54204
   cmd_dumpmem_ascii : $d399          54169
   cmd_dumpmem_block : $d369          54121
    cmd_dumpmem_byte : $d378          54136
  cmd_dump_skip_ctrl : $d3a3          54179
   cmd_dump_skip_del : $d3a8          54184
           cmd_error : $d324          54052
       cmd_find_parm : $d407          54279
              cmd_hi : $0095            149   *
          cmd_incmem : $d3c3          54211
              cmd_lo : $0094            148   *
   cmd_next_parm_err : $d411          54289
       cmd_not_found : $d337          54071
           cmd_parse : $d32e          54062
AS65 Assembler for R6502 [1.42].                                     Page    2
-------------------------------- bank\bank0.s --------------------------------

      cmd_parse_byte : $d3d8          54232
  cmd_parse_byte_err : $d3f2          54258
 cmd_parse_byte_errp : $d3f1          54257
 cmd_parse_next_parm : $d406          54278
      cmd_parse_word : $d3f4          54260
            cmd_peek : $d3ca          54218
            cmd_poke : $d3cf          54223
           cmd_ready : $d308          54024
          cmd_setmem : $d33d          54077
     cmd_setmem_byte : $d342          54082
      cmd_setmem_err : $d361          54113
        cmd_word_err : $d404          54276
        command_line : $d308          54024
       con_bin_digit : $c260          49760
        con_bin_done : $c276          49782
         con_bin_err : $c280          49792
         con_bin_jmp : $c1fe          49662
        con_bin_to_a : $c258          49752
    con_bin_to_a_int : $c25c          49756
         con_dec_jmp : $c1f2          49650
        con_dec_to_a : $c282          49794
    con_dec_to_a_int : $c286          49798
       con_hex_digit : $c221          49697
        con_hex_done : $c24e          49742
         con_hex_err : $c24c          49740
         con_hex_jmp : $c1f8          49656
  con_hex_skip_x_f_1 : $c22e          49710
        con_hex_to_a : $c219          49689
    con_hex_to_a_int : $c21d          49693
           con_n_err : $c201          49665
       con_n_not_dec : $c1f5          49653
       con_n_not_hex : $c1fb          49659
          con_n_to_a : $c1e1          49633
   con_n_to_a_detect : $c203          49667
                DDRA : $0003              3   *
                DDRB : $0002              2   *
         DFERR_ABORT : $0012             18   *
         DFERR_BREAK : $000d             13   *
           DFERR_DIM : $0003              3   *
         DFERR_FNAME : $000b             11   *
     DFERR_IMMEDIATE : $0007              7   *
       DFERR_NEXTFOR : $000a             10   *
        DFERR_NODATA : $000e             14   *
          DFERR_NOIF : $0009              9   *
        DFERR_NOLINE : $0010             16   *
         DFERR_NOORG : $0014             20   *
        DFERR_NOPROC : $0005              5   *
            DFERR_OK : $0000              0   *
      DFERR_PROCPARM : $0006              6   *
      DFERR_QUANTITY : $0013             19   *
        DFERR_RETURN : $0011             17   *
       DFERR_STRLONG : $000c             12   *
        DFERR_SYNTAX : $0001              1   *
      DFERR_TYPEMISM : $0002              2   *
    DFERR_UNCLOSEDIF : $0008              8   *
         DFERR_UNTIL : $0004              4   *
          DFERR_WEND : $000f             15   *
          DFRT_ABORT : $0089            137   *
            DFRT_ASM : $0097            151   *
           DFRT_DATA : $0096            150   *
            DFRT_DEF : $0086            134   *
           DFRT_ELSE : $0093            147   *
AS65 Assembler for R6502 [1.42].                                     Page    3
-------------------------------- bank\bank0.s --------------------------------

         DFRT_ELSEIF : $0095            149   *
         DFRT_ENDDEF : $0087            135   *
          DFRT_ENDIF : $0094            148   *
            DFRT_FOR : $008e            142   *
             DFRT_IF : $0092            146   *
           DFRT_NEXT : $008f            143   *
         DFRT_REPEAT : $008c            140   *
         DFRT_RETURN : $0088            136   *
           DFRT_WEND : $0091            145   *
          DFRT_WHILE : $0090            144   *
            DFST_INT : $0001              1   *
            DFST_STR : $0080            128   *
            DFTK_BYT : $0020             32   *
         DFTK_BYTBIN : $0007              7   *
         DFTK_BYTDEC : $0005              5   *
         DFTK_BYTHEX : $0006              6   *
            DFTK_CHR : $0000              0   *
            DFTK_EOL : $0000              0   *
         DFTK_ESCVAL : $0020             32   *
            DFTK_FLT : $0080            128   *
             DFTK_FN : $0002              2   *
            DFTK_INT : $0010             16   *
         DFTK_INTBIN : $000b             11   *
         DFTK_INTDEC : $0009              9   *
         DFTK_INTHEX : $000a             10   *
             DFTK_KW : $0001              1   *
         DFTK_LINLEN : $0000              0   *
         DFTK_LINNUM : $0001              1   *
             DFTK_OP : $0008              8   *
          DFTK_OPMSK : $0007              7   *
           DFTK_PROC : $0012             18   *
          DFTK_RESVC : $000c             12   *
          DFTK_RESVD : $000d             13   *
          DFTK_RESVE : $000e             14   *
          DFTK_RESVF : $000f             15   *
          DFTK_RESV1 : $0001              1   *
          DFTK_RESV2 : $0002              2   *
          DFTK_RESV3 : $0003              3   *
          DFTK_RESV4 : $0004              4   *
          DFTK_RESV8 : $0008              8   *
          DFTK_RTMSK : $00f8            248   *
          DFTK_STEND : $001f             31   *
            DFTK_STR : $0040             64   *
         DFTK_STRLIT : $0010             16   *
          DFTK_STROP : $0004              4   *
          DFTK_TOKEN : $0080            128   *
            DFTK_VAR : $0011             17   *
        DFTK_VARPARM : $0026             38   *
          DFVVT_ARRY : $0080            128   *
           DFVVT_BYT : $0002              2   *
          DFVVT_DIM1 : $0003              3   *
          DFVVT_DIM2 : $0004              4   *
           DFVVT_FLT : $0008              8   *
            DFVVT_HI : $0002              2   *
           DFVVT_INT : $0001              1   *
            DFVVT_LO : $0001              1   *
          DFVVT_PROC : $0040             64   *
           DFVVT_STR : $0004              4   *
            DFVVT_SZ : $0008              8   *
          DFVVT_TYPE : $0000              0   *
           DF_MEMTOP : $9800          38912   *
        DF_PROGSTART : $0713           1811   *
AS65 Assembler for R6502 [1.42].                                     Page    4
-------------------------------- bank\bank0.s --------------------------------

          dflat_zp_e : $00ab            171
          dflat_zp_s : $005b             91
     dflat_zp_save_e : $00a1            161
     dflat_zp_save_s : $005b             91
          df_asmadmd : $009c            156
           df_asmlen : $00a0            160
         df_asmopcde : $009d            157
         df_asmoprnd : $009e            158
           df_asmopt : $009b            155
            df_asmpc : $0099            153
  df_asm_altaddrmode : $fc84          64644
       df_asm_length : $fc73          64627
    df_asm_tokensyms : $fc95          64661
            df_brkpc : $0062             98
           df_brkval : $0064            100
         df_checkkey : $005b             91
         df_checkmsk : $005c             92
            df_clear : $f6b2          63154
          df_currdat : $0094            148
          df_currlin : $0086            134
         df_curstidx : $0080            128
           df_datoff : $0096            150
           df_eolidx : $007e            126
           df_exeoff : $0088            136
           df_ifnest : $0093            147
            df_immed : $005e             94
             df_init : $f6a5          63141
          df_initrun : $e003          57347
       df_lexer_line : $d96d          55661
  df_lexer_skip_lnum : $d98e          55694
          df_linbuff : $0400           1024
          df_lineidx : $0092            146
          df_lineptr : $0090            144
           df_linoff : $007c            124
           df_memtop : $0611           1553
          df_msg_acc : $f875          63605
           df_msg_pc : $f871          63601
         df_msg_xreg : $f878          63608
         df_msg_yreg : $f87b          63611
          df_nextlin : $0089            137
         df_nxtstidx : $007f            127
     df_ost_peekType : $f67b          63099
       df_ost_popInt : $f681          63105
     df_ost_popParmX : $f664          63076
       df_ost_popPtr : $f689          63113
       df_ost_popStr : $f685          63109
      df_ost_pushInt : $f651          63057
     df_ost_pushIntA : $f655          63061
    df_ost_pushParmX : $f63b          63035
      df_ost_pushPtr : $f660          63072
      df_ost_pushStr : $f65c          63068
          df_parmtop : $0077            119
               df_pc : $0060             96
    df_pg_check_line : $deb5          57013
df_pg_check_next_line : $de9e          56990
df_pg_copyinputtolinbuff : $df50          57168
  df_pg_delete_block : $df18          57112
   df_pg_delete_byte : $df1e          57118
df_pg_delete_next_byte : $df3f          57151
         df_pg_dflat : $df5a          57178
     df_pg_find_line : $de92          56978
    df_pg_getcommand : $df70          57200
AS65 Assembler for R6502 [1.42].                                     Page    5
-------------------------------- bank\bank0.s --------------------------------

     df_pg_inputline : $df48          57160
  df_pg_inputline_ok : $df50          57168
 df_pg_insertlinbyte : $dff3          57331
    df_pg_insertline : $dfd4          57300
  df_pg_insert_block : $dee3          57059
   df_pg_insert_byte : $deef          57071
df_pg_insert_next_byte : $df0d          57101
   df_pg_line_number : $dfb4          57268
       df_pg_nothing : $dfb3          57267
        df_pg_prompt : $df65          57189
    df_pg_prompt_msg : $dffc          57340
 df_pg_skip_del_line : $dfca          57290
      df_pg_tokenise : $df99          57241
           df_prgend : $0067            103
          df_prgstrt : $0065            101
         df_procargs : $008c            140
          df_procloc : $008d            141
         df_procmode : $008b            139
          df_procptr : $008e            142
df_pr_line_gt_target : $deaa          57002
    df_pr_line_match : $ded8          57048
              df_raw : $0400           1024
              df_rnd : $0097            151
     df_rst_peekByte : $f61a          63002
      df_rst_popByte : $f611          62993
      df_rst_popWord : $f62e          63022
     df_rst_pushByte : $f608          62984
     df_rst_pushWord : $f620          63008
          df_rtspace : $0500           1280
           df_rtstck : $0500           1280
           df_rtstop : $0076            118
         df_rt_abort : $f469          62569
           df_rt_add : $e5d0          58832
          df_rt_addr : $f35f          62303
         df_rt_aequb : $e6ac          59052
      df_rt_aequbFin : $e6b6          59062
           df_rt_and : $e67f          59007
  df_rt_array_exists : $e2e2          58082
     df_rt_arry_parm : $e1f0          57840
    df_rt_arry_parm2 : $e1f7          57847
df_rt_arry_parm2_arry2 : $e20f          57871
df_rt_arry_parm2_skiparry2 : $e216          57878
df_rt_arry_parm2_term : $e1ff          57855
           df_rt_asc : $f442          62530
           df_rt_asl : $e659          58969
        df_rt_aslbit : $e65f          58975
       df_rt_asldone : $e669          58985
    df_rt_asm_ABSREL : $fbc8          64456
    df_rt_asm_AM_ABS : $fbdf          64479
   df_rt_asm_AM_ABSX : $fbec          64492
   df_rt_asm_AM_ABSY : $fbda          64474
    df_rt_asm_AM_IMM : $fbf1          64497
    df_rt_asm_AM_IMP : $fbc3          64451
df_rt_asm_AM_INDIRECT : $fbfb          64507
    df_rt_asm_AM_REL : $fbe9          64489
  df_rt_asm_AM_ZPIND : $fc21          64545
df_rt_asm_AM_ZPINDORY : $fc11          64529
  df_rt_asm_addrmode : $fba7          64423
  df_rt_asm_assemble : $f971          63857
df_rt_asm_assemble_done : $f983          63875
 df_rt_asm_check_alt : $fa7c          64124
   df_rt_asm_command : $f984          63876
AS65 Assembler for R6502 [1.42].                                     Page    6
-------------------------------- bank\bank0.s --------------------------------

      df_rt_asm_data : $f9e2          63970
 df_rt_asm_data_done : $fa1f          64031
 df_rt_asm_data_next : $fa15          64021
df_rt_asm_data_write : $fa20          64032
df_rt_asm_data_write_err : $fa4e          64078
df_rt_asm_data_write_hi : $fa3c          64060
df_rt_asm_data_write_skip1 : $fa23          64035
df_rt_asm_data_write_skip2 : $fa40          64064
        df_rt_asm_db : $f9d5          63957
  df_rt_asm_db_start : $f9da          63962
df_rt_asm_decode_token : $efcd          61389
df_rt_asm_decode_token_done : $f026          61478
df_rt_asm_decode_token_found : $efe4          61412
df_rt_asm_decode_token_keyword : $efeb          61419
df_rt_asm_decode_token_ws : $efd4          61396
       df_rt_asm_dir : $f996          63894
  df_rt_asm_do_label : $f980          63872
        df_rt_asm_ds : $fa50          64080
        df_rt_asm_dw : $f9d8          63960
    df_rt_asm_encode : $fab4          64180
df_rt_asm_encode_print : $fb1b          64283
df_rt_asm_encode_relfar : $faeb          64235
df_rt_asm_encode_relpos : $fae7          64231
df_rt_asm_encode_skiprel : $faed          64237
df_rt_asm_encode_writebyte : $fb09          64265
df_rt_asm_encode_writeword : $fb11          64273
df_rt_asm_find_addr_mode : $fc2f          64559
df_rt_asm_find_addr_mode_err : $fc44          64580
df_rt_asm_find_addr_mode_loop : $fc35          64565
df_rt_asm_get_operand : $fc24          64548
     df_rt_asm_label : $f9a8          63912
      df_rt_asm_mnem : $fa6d          64109
  df_rt_asm_mnem_chk : $fa90          64144
 df_rt_asm_mnem_done : $fa9e          64158
  df_rt_asm_mnem_err : $fab2          64178
  df_rt_asm_mnem_try : $fa73          64115
       df_rt_asm_opt : $f9cd          63949
       df_rt_asm_org : $f9bb          63931
   df_rt_asm_printCH : $fb82          64386
   df_rt_asm_printCR : $fb79          64377
 df_rt_asm_printline : $fb8f          64399
  df_rt_asm_printOPC : $fb4b          64331
  df_rt_asm_printOPR : $fb5f          64351
df_rt_asm_printOPR_1 : $fb74          64372
   df_rt_asm_printPC : $fb3b          64315
  df_rt_asm_printSPC : $fb56          64342
df_rt_asm_print_mmen : $fb2b          64299
 df_rt_asm_print_rts : $fb3a          64314
df_rt_asm_skip_to_sym : $fc47          64583
df_rt_asm_skip_to_sym_done : $fc46          64582
df_rt_asm_skip_to_sym_end : $fc64          64612
df_rt_asm_skip_to_sym_next : $fc55          64597
    df_rt_asm_string : $f9f8          63992
 df_rt_asm_string_ch : $f9ff          63999
  df_rt_asm_tokenjmp : $fecb          65227
        df_rt_assign : $ecc7          60615
    df_rt_assign_str : $ecd4          60628
         df_rt_asubb : $e6b7          59063
      df_rt_asubbFin : $e6c4          59076
   df_rt_binlen_skip : $f23a          62010
         df_rt_bload : $f135          61749
    df_rt_bload_addr : $f158          61784
AS65 Assembler for R6502 [1.42].                                     Page    7
-------------------------------- bank\bank0.s --------------------------------

         df_rt_bsave : $f168          61800
   df_rt_bsave_parms : $f218          61976
         df_rt_bsuba : $e6c5          59077
      df_rt_bsubaFin : $e6d2          59090
          df_rt_call : $f330          62256
       df_rt_calljsr : $f33f          62271
     df_rt_check_pos : $e958          59736
   df_rt_check_while : $e7fe          59390
           df_rt_chr : $f3a7          62375
        df_rt_circle : $ebf5          60405
           df_rt_cls : $eb49          60233
         df_rt_comeq : $e72d          59181
         df_rt_comgt : $e724          59172
        df_rt_comgte : $e73f          59199
         df_rt_comlt : $e71b          59163
        df_rt_comlte : $e736          59190
       df_rt_comment : $ecd8          60632
         df_rt_comne : $e748          59208
       df_rt_copyStr : $e1b2          57778
    df_rt_copyStr_ch : $e1b4          57780
  df_rt_copyStr_done : $e1bd          57789
       df_rt_copy_fn : $f0cc          61644
        df_rt_cursor : $ebbd          60349
          df_rt_data : $ecd8          60632
 df_rt_datastatement : $e9bf          59839
   df_rt_datlinstart : $e9b7          59831
    df_rt_datnextlin : $e9c5          59845
      df_rt_datumerr : $e9ed          59885
    df_rt_dec_binlen : $f234          62004
          df_rt_deek : $f256          62038
           df_rt_def : $f547          62791
        df_rt_deferr : $f4a5          62629
  df_rt_def_find_var : $f554          62804
   df_rt_def_got_var : $f566          62822
df_rt_def_got_varparm : $f563          62819
df_rt_def_initialise_parm : $f5a4          62884
  df_rt_def_load_var : $f584          62852
df_rt_def_load_var_done : $f5c0          62912
df_rt_def_load_var_int : $f5b2          62898
df_rt_def_load_var_int_skip : $f5b5          62901
 df_rt_def_parm_done : $f57c          62844
           df_rt_dim : $eac4          60100
     df_rt_dim2_mul2 : $eb27          60199
       df_rt_dim2_nz : $eb12          60178
     df_rt_dim_alloc : $eb01          60161
      df_rt_dim_done : $eb46          60230
       df_rt_dim_err : $eb47          60231
   df_rt_dim_findesc : $eac7          60103
 df_rt_dim_next_byte : $eb41          60225
           df_rt_div : $e617          58903
      df_rt_doassign : $ecca          60618
          df_rt_doke : $f027          61479
        df_rt_doline : $ec0e          60430
       df_rt_dosound : $f06c          61548
       df_rt_do_else : $e8ca          59594
       df_rt_elapsed : $f315          62229
          df_rt_else : $e87a          59514
        df_rt_elseif : $e87a          59514
        df_rt_enddef : $f5ca          62922
         df_rt_endif : $e875          59509
           df_rt_eor : $e69d          59037
           df_rt_eos : $ecda          60634
AS65 Assembler for R6502 [1.42].                                     Page    8
-------------------------------- bank\bank0.s --------------------------------

      df_rt_eos_true : $ece8          60648
            df_rt_eq : $e707          59143
        df_rt_escjmp : $e5a3          58787
      df_rt_eval_byt : $e2fd          58109
   df_rt_eval_bytbin : $e1c8          57800
   df_rt_eval_bytdec : $e1c8          57800
   df_rt_eval_bythex : $e1c8          57800
      df_rt_eval_chr : $e1c8          57800
      df_rt_eval_esc : $e0fc          57596
  df_rt_eval_esc_tab : $e10b          57611
   df_rt_eval_intbin : $e1c8          57800
   df_rt_eval_intdec : $e1c8          57800
   df_rt_eval_inthex : $e1c8          57800
     df_rt_eval_lvar : $e250          57936
   df_rt_eval_lvskip : $e22e          57902
     df_rt_eval_proc : $e30e          58126
 df_rt_eval_proc_err : $e31b          58139
      df_rt_eval_ptr : $e307          58119
 df_rt_eval_reserved : $e1d4          57812
   df_rt_eval_strlit : $e1d6          57814
df_rt_eval_strlit_ch : $e1e6          57830
df_rt_eval_strlit_done : $e1ed          57837
      df_rt_eval_var : $e21b          57883
df_rt_eval_var_dim2adj : $e296          58006
df_rt_eval_var_dim2adjx : $e2a2          58018
df_rt_eval_var_dim2adjy : $e29d          58013
df_rt_eval_var_do_arry : $e26b          57963
df_rt_eval_var_nomult : $e2b9          58041
df_rt_eval_var_notarry : $e240          57920
 df_rt_eval_var_push : $e2d1          58065
df_rt_eval_var_simple : $e25d          57949
  df_rt_eval_var_str : $e306          58118
df_rt_exec_check_key : $e3db          58331
   df_rt_exec_ctrl_c : $e3e3          58339
   df_rt_exec_ctrl_z : $e3e5          58341
      df_rt_exec_end : $e3d9          58329
 df_rt_exec_find_tok : $e399          58265
df_rt_exec_found_tok : $e39e          58270
 df_rt_exec_init_ptr : $e392          58258
     df_rt_exec_jump : $e3e9          58345
   df_rt_exec_no_key : $e3b2          58290
     df_rt_exec_proc : $f4fd          62717
     df_rt_exec_stat : $e38c          58252
         df_rt_false : $e6d9          59097
  df_rt_file_cleanup : $f0f4          61684
     df_rt_file_errc : $f0de          61662
 df_rt_findelseendif : $e83d          59453
    df_rt_findescval : $e49e          58526
df_rt_findescval_loop : $e4a1          58529
      df_rt_findproc : $e456          58454
  df_rt_findproc_cmd : $e468          58472
  df_rt_findproc_err : $e49c          58524
df_rt_findproc_nextstat : $e488          58504
      df_rt_findwend : $e7cb          59339
    df_rt_fname_case : $f0ce          61646
           df_rt_for : $e8cd          59597
 df_rt_generate_lvar : $eca4          60580
           df_rt_get : $f2e7          62183
  df_rt_getbin_parms : $f1f7          61943
df_rt_getbin_parms_loop : $f1f9          61945
     df_rt_getdatatk : $e9d3          59859
       df_rt_getlvar : $e4b8          58552
AS65 Assembler for R6502 [1.42].                                     Page    9
-------------------------------- bank\bank0.s --------------------------------

       df_rt_getnval : $e071          57457
      df_rt_get2Ints : $e31d          58141
      df_rt_get2Strs : $e32c          58156
      df_rt_get_push : $f2f8          62200
     df_rt_get_pushp : $f2f7          62199
      df_rt_get_sync : $f2ec          62188
            df_rt_gt : $e6f3          59123
           df_rt_gte : $e6fd          59133
      df_rt_gte_calc : $e700          59136
           df_rt_hex : $f3bb          62395
         df_rt_himem : $ebc3          60355
         df_rt_hires : $ebd2          60370
            df_rt_if : $e88c          59532
         df_rt_ifcmd : $e840          59456
        df_rt_ifelse : $e85e          59486
        df_rt_ifeval : $e88e          59534
  df_rt_ifskipelseif : $e855          59477
       df_rt_if_done : $e879          59513
      df_rt_if_found : $e86b          59499
      df_rt_if_match : $e835          59445
       df_rt_if_stat : $e81f          59423
   df_rt_if_stat_err : $e833          59443
     df_rt_init_done : $e070          57456
 df_rt_init_filename : $f0c0          61632
 df_rt_init_stat_ptr : $e379          58233
      df_rt_init_vvt : $e02e          57390
 df_rt_init_vvt_skip : $e062          57442
 df_rt_init_vvt_slot : $e038          57400
df_rt_init_vvt_slot_undim : $e044          57412
           df_rt_ink : $ebdb          60379
         df_rt_input : $ea5c          59996
     df_rt_input_err : $ea96          60054
     df_rt_input_num : $ea7f          60031
     df_rt_input_str : $ea77          60023
    df_rt_ldtokenise : $f11d          61725
          df_rt_left : $f3ec          62444
           df_rt_len : $f436          62518
          df_rt_line : $ec15          60437
        df_rt_lineto : $ec07          60423
          df_rt_list : $edce          60878
  df_rt_listcheckvnt : $ed39          60729
   df_rt_listgotnext : $ed67          60775
   df_rt_listnextvnt : $ed60          60768
   df_rt_listpn_done : $ed77          60791
       df_rt_listprg : $edf5          60917
    df_rt_listprgend : $edfd          60925
      df_rt_listproc : $ed78          60792
    df_rt_listprocch : $ed45          60741
    df_rt_listproccr : $ed50          60752
 df_rt_listprocnames : $ed2d          60717
 df_rt_listprocpause : $ed56          60758
    df_rt_listp_copy : $ed7f          60799
    df_rt_listp_done : $edc2          60866
 df_rt_listp_findcmd : $eda8          60840
 df_rt_listp_findend : $eda1          60833
df_rt_listp_notfound : $edcc          60876
      df_rt_listwait : $ed5d          60765
      df_rt_list_all : $ede1          60897
 df_rt_list_all_line : $ee44          60996
   df_rt_list_decode : $ee50          61008
df_rt_list_decode_esc : $ee82          61058
df_rt_list_decode_token : $ef8f          61327
AS65 Assembler for R6502 [1.42].                                     Page   10
-------------------------------- bank\bank0.s --------------------------------

df_rt_list_decode_token_normal : $ef96          61334
   df_rt_list_donvvt : $ef7d          61309
df_rt_list_do_decode_tkn : $ef9d          61341
   df_rt_list_escval : $ee60          61024
  df_rt_list_findvvt : $ef27          61223
df_rt_list_find_asm_sym : $eff6          61430
 df_rt_list_find_sym : $efa6          61350
   df_rt_list_gotvvt : $ef54          61268
df_rt_list_gotvvtend : $ef40          61248
df_rt_list_got_asm_sym : $f014          61460
df_rt_list_got_last_sym : $efb7          61367
  df_rt_list_got_sym : $efbb          61371
     df_rt_list_line : $ee03          60931
df_rt_list_line_cont : $ee1d          60957
 df_rt_list_line_fin : $ee41          60993
df_rt_list_line_only : $ee47          60999
df_rt_list_line_only_fin : $ee43          60995
    df_rt_list_linno : $ede8          60904
   df_rt_list_linnum : $ef7e          61310
  df_rt_list_nexttok : $ee69          61033
df_rt_list_next_asm_ch : $effb          61435
  df_rt_list_next_ch : $efab          61355
df_rt_list_next_line : $ee24          60964
    df_rt_list_pause : $ee12          60946
  df_rt_list_synckey : $ee0e          60942
    df_rt_list_token : $ee66          61030
   df_rt_list_vvtend : $ef33          61235
          df_rt_load : $f1db          61915
       df_rt_loadbin : $f204          61956
  df_rt_loadbin_byte : $f206          61958
   df_rt_loadbin_inc : $f210          61968
      df_rt_loadline : $f102          61698
         df_rt_local : $ea98          60056
    df_rt_local_done : $eac0          60096
 df_rt_local_findesc : $ea9f          60063
           df_rt_lsr : $e66c          58988
        df_rt_lsrbit : $e672          58994
       df_rt_lsrdone : $e67c          59004
       df_rt_lst_bin : $eeed          61165
       df_rt_lst_bit : $eef7          61175
 df_rt_lst_bit_skip0 : $eeff          61183
    df_rt_lst_bytbin : $eee3          61155
    df_rt_lst_bythex : $eebe          61118
       df_rt_lst_chr : $eea1          61089
df_rt_lst_const_done : $eecd          61133
   df_rt_lst_hex_pre : $eeb4          61108
    df_rt_lst_intbin : $eeeb          61163
    df_rt_lst_intdec : $ef07          61191
    df_rt_lst_inthex : $eed1          61137
    df_rt_lst_lo_hex : $eec1          61121
      df_rt_lst_proc : $ef12          61202
  df_rt_lst_reserved : $eea0          61088
    df_rt_lst_strlit : $ef64          61284
  df_rt_lst_strlitch : $ef6b          61291
 df_rt_lst_strlitdon : $ef76          61302
       df_rt_lst_var : $ef12          61202
            df_rt_lt : $e6df          59103
           df_rt_lte : $e6e9          59113
      df_rt_lte_calc : $e6ec          59116
           df_rt_mem : $f293          62099
      df_rt_mem_calc : $f2d4          62164
      df_rt_mem_free : $f29e          62110
AS65 Assembler for R6502 [1.42].                                     Page   11
-------------------------------- bank\bank0.s --------------------------------

       df_rt_mem_prg : $f2b1          62129
       df_rt_mem_var : $f2c4          62148
           df_rt_mid : $f418          62488
           df_rt_mod : $e638          58936
       df_rt_monitor : $e7a0          59296
          df_rt_mult : $e5f6          58870
         df_rt_music : $f07c          61564
       df_rt_nassign : $ec87          60551
            df_rt_ne : $e711          59153
         df_rt_neval : $e077          57463
    df_rt_neval_done : $e0c3          57539
   df_rt_neval_donow : $e0e6          57574
     df_rt_neval_esc : $e0a1          57505
df_rt_neval_nextbyte : $e0cb          57547
    df_rt_neval_optk : $e07a          57466
 df_rt_neval_process : $e0ba          57530
  df_rt_neval_pushOp : $e0f7          57591
      df_rt_neval_tk : $e0a8          57512
   df_rt_neval_tk_fn : $e0c4          57540
   df_rt_neval_tk_op : $e0d0          57552
  df_rt_neval_tk_opp : $e0cf          57551
           df_rt_new : $e7a3          59299
          df_rt_next : $e90b          59659
     df_rt_nextdatum : $e9a7          59815
      df_rt_nextstat : $e401          58369
  df_rt_nextstat_err : $e42d          58413
   df_rt_nextstat_ln : $e418          58392
    df_rt_next_check : $e95b          59739
      df_rt_next_err : $e964          59748
      df_rt_noif_err : $e88a          59530
df_rt_openforbinload : $f12c          61740
df_rt_openforbinsave : $f123          61731
            df_rt_or : $e68e          59022
         df_rt_paper : $ebe1          60385
     df_rt_parm_pop3 : $e353          58195
    df_rt_parm_2ints : $e33b          58171
    df_rt_parm_3ints : $e346          58182
    df_rt_parm_4ints : $e35d          58205
    df_rt_parse_file : $f0d6          61654
          df_rt_peek : $f258          62040
         df_rt_pixel : $f308          62216
       df_rt_pixmode : $ebd5          60373
          df_rt_play : $f091          61585
          df_rt_plot : $eb4c          60236
       df_rt_plotstr : $eb7e          60286
     df_rt_plotstrch : $eb8f          60303
   df_rt_plotstrdone : $ebbc          60348
    df_rt_plot_h_int : $eb75          60277
    df_rt_plot_h_str : $ebaa          60330
         df_rt_point : $ebeb          60395
          df_rt_poke : $f036          61494
      df_rt_pop_stat : $e43d          58429
   df_rt_pop_stat_go : $e4d4          58580
         df_rt_print : $ec46          60486
       df_rt_printat : $ec3c          60476
       df_rt_println : $ec7f          60543
    df_rt_print_done : $ec7c          60540
  df_rt_print_gotstr : $ec70          60528
     df_rt_print_num : $e98c          59788
     df_rt_print_str : $e993          59795
  df_rt_print_string : $ec76          60534
  df_rt_print_str_ch : $e99c          59804
AS65 Assembler for R6502 [1.42].                                     Page   12
-------------------------------- bank\bank0.s --------------------------------

df_rt_print_str_done : $e9a6          59814
      df_rt_print_ws : $ec49          60489
          df_rt_proc : $f4a7          62631
     df_rt_proc_addr : $f4d1          62673
    df_rt_proc_local : $f5f4          62964
df_rt_proc_local_load : $f5fb          62971
  df_rt_proc_parmerr : $f4a5          62629
df_rt_proc_parm_done : $f4f0          62704
df_rt_proc_parm_none : $f4f1          62705
df_rt_proc_push_parm : $f4dc          62684
df_rt_proc_unloadvar : $f5d0          62928
df_rt_proc_unload_done : $f5f0          62960
     df_rt_push_int1 : $f33c          62268
     df_rt_push_stat : $e431          58417
     df_rt_putintres : $e5c9          58825
          df_rt_read : $ea44          59972
      df_rt_readbyte : $f259          62041
 df_rt_readbyte_skip : $f26e          62062
     df_rt_readdatum : $e9ef          59887
     df_rt_read_done : $ea59          59993
 df_rt_read_find_var : $ea46          59974
         df_rt_renum : $ecea          60650
      df_rt_renum_do : $ecfe          60670
    df_rt_renum_next : $ed1d          60701
      df_rt_renum_ok : $ecfa          60666
  df_rt_renum_update : $ed05          60677
        df_rt_repeat : $e966          59750
         df_rt_reset : $f241          62017
        df_rt_return : $f5c7          62919
         df_rt_right : $f3fd          62461
           df_rt_rnd : $f271          62065
     df_rt_rnd_noeor : $f285          62085
       df_rt_rnd_set : $f28c          62092
           df_rt_run : $ecd9          60633
     df_rt_run_token : $e3f2          58354
          df_rt_sadd : $e98b          59787
       df_rt_sassign : $ec9e          60574
          df_rt_save : $f189          61833
       df_rt_savebin : $f216          61974
  df_rt_savebin_byte : $f224          61988
   df_rt_savebin_inc : $f22e          61998
          df_rt_scrn : $f2fb          62203
           df_rt_seq : $e77c          59260
         df_rt_seval : $e131          57649
    df_rt_seval_copy : $e18b          57739
    df_rt_seval_done : $e1ae          57774
     df_rt_seval_esc : $e157          57687
df_rt_seval_esc_proc : $e1ac          57772
df_rt_seval_esc_strlit : $e1a6          57766
 df_rt_seval_esc_var : $e187          57735
df_rt_seval_nextbyte : $e1a1          57761
    df_rt_seval_optk : $e13f          57663
      df_rt_seval_tk : $e165          57701
   df_rt_seval_tk_fn : $e17e          57726
   df_rt_seval_tk_op : $e17a          57722
           df_rt_sgn : $f342          62274
         df_rt_sgn_n : $f355          62293
         df_rt_sgn_z : $f35a          62298
           df_rt_sgt : $e773          59251
          df_rt_sgte : $e75e          59230
df_rt_skipinitdataptr : $e9dd          59869
 df_rt_skipnestendif : $e868          59496
AS65 Assembler for R6502 [1.42].                                     Page   13
-------------------------------- bank\bank0.s --------------------------------

    df_rt_skipnestif : $e85b          59483
       df_rt_skip_ws : $e4ab          58539
  df_rt_skip_ws_loop : $e4ae          58542
           df_rt_slt : $e76c          59244
          df_rt_slte : $e751          59217
    df_rt_snd_common : $f040          61504
           df_rt_sne : $e765          59237
         df_rt_sound : $f069          61545
df_rt_sound_env_skip : $f066          61542
   df_rt_sound_noise : $f073          61555
       df_rt_sprchar : $f46b          62571
        df_rt_sprhit : $f493          62611
df_rt_sprhit_inactive : $f49f          62623
       df_rt_sprinit : $f48a          62602
      df_rt_sprmulti : $f48d          62605
        df_rt_sprpos : $f475          62581
        df_rt_sprupd : $f481          62593
         df_rt_stick : $f2e1          62177
 df_rt_strlen_common : $f367          62311
  df_rt_strlen_count : $f36d          62317
      df_rt_str_comp : $e783          59267
 df_rt_str_comp_byte : $e788          59272
   df_rt_str_comp_eq : $e79d          59293
df_rt_str_comp_false : $e758          59224
   df_rt_str_comp_gt : $e79a          59290
   df_rt_str_comp_lt : $e797          59287
 df_rt_str_comp_true : $e75b          59227
    df_rt_str_cpy_ch : $f387          62343
   df_rt_str_extract : $f374          62324
           df_rt_sub : $e5e3          58851
          df_rt_sval : $e135          57653
          df_rt_text : $ebcf          60367
         df_rt_tload : $f0fa          61690
      df_rt_tokenjmp : $e4dd          58589
          df_rt_true : $e6d3          59091
         df_rt_tsave : $f0e0          61664
df_rt_unexpected_end : $e3e7          58343
         df_rt_until : $e96e          59758
df_rt_untilnext_done : $e981          59777
     df_rt_until_err : $e989          59785
           df_rt_val : $f453          62547
       df_rt_val_err : $f467          62567
          df_rt_wait : $ec26          60454
  df_rt_wait_counter : $ec2a          60458
     df_rt_wait_done : $ec3b          60475
   df_rt_wait_skiphi : $ec34          60468
     df_rt_wait_tick : $ec2c          60460
          df_rt_wend : $e809          59401
      df_rt_wend_end : $e807          59399
      df_rt_wend_err : $e81d          59421
         df_rt_while : $e7a6          59302
     df_rt_while_cmd : $e7dc          59356
    df_rt_while_done : $e7b6          59318
         df_sevalptr : $007a            122
    df_show_err_done : $f823          63523
     df_show_err_fin : $f802          63490
    df_show_err_find : $f7b6          63414
  df_show_err_linnum : $f7e9          63465
    df_show_err_skip : $f7ba          63418
               df_sp : $005f             95
          df_starend : $0074            116
         df_starstrt : $0072            114
AS65 Assembler for R6502 [1.42].                                     Page   14
-------------------------------- bank\bank0.s --------------------------------

         df_strbuffz : $0078            120
          df_stridxz : $0079            121
      df_str_src_end : $f39c          62364
        df_st_malloc : $f68d          63117
df_st_typemismatcherr : $f679          63097
          df_syminiz : $0084            132
           df_symoff : $0083            131
           df_symtab : $0081            129
         df_tk_abort : $de6a          56938
           df_tk_add : $de6a          56938
          df_tk_addr : $de47          56903
           df_tk_and : $de6a          56938
        df_tk_arrvar : $d82a          55338
           df_tk_asc : $de3d          56893
           df_tk_asl : $de6a          56938
 df_tk_asm_addr_mode : $f912          63762
df_tk_asm_addr_mode_ok : $f901          63745
df_tk_asm_addr_mode_1 : $f927          63783
df_tk_asm_addr_mode_2 : $f931          63793
df_tk_asm_checknexttok : $f8ba          63674
df_tk_asm_checktokch : $f8bc          63676
        df_tk_asm_db : $ddd1          56785
        df_tk_asm_ds : $de6f          56943
        df_tk_asm_dw : $ddd1          56785
df_tk_asm_exec_parser : $f903          63747
df_tk_asm_foundsymend : $f8e2          63714
  df_tk_asm_matchtok : $f8ac          63660
  df_tk_asm_mnemonic : $f8a1          63649
       df_tk_asm_opt : $de6f          56943
       df_tk_asm_org : $de6f          56943
df_tk_asm_parse_command : $f87e          63614
df_tk_asm_parse_command_err : $f8a0          63648
df_tk_asm_parse_command_symbol : $f8a7          63655
  df_tk_asm_symfound : $f8f5          63733
df_tk_asm_symnextentry : $f8d3          63699
df_tk_asm_symnomatch : $f8d1          63697
  df_tk_asm_tokenjmp : $fec1          65217
        df_tk_assign : $dd7a          56698
         df_tk_bload : $de75          56949
          df_tk_body : $d996          55702
         df_tk_bsave : $de7f          56959
          df_tk_call : $de5c          56924
      df_tk_callproc : $de31          56881
          df_tk_char : $d782          55170
      df_tk_char_err : $d72a          55082
         df_tk_chdir : $de6f          56943
  df_tk_checknexttok : $da22          55842
    df_tk_checktokch : $da3f          55871
           df_tk_chr : $de3d          56893
        df_tk_circle : $de7f          56959
     df_tk_closebrkt : $de42          56898
           df_tk_cls : $de6a          56938
        df_tk_colour : $de7f          56959
       df_tk_comment : $dd83          56707
  df_tk_comment_done : $dd8e          56718
         df_tk_const : $d7c0          55232
     df_tk_const_err : $d7e0          55264
df_tk_const_try_char : $d7d9          55257
 df_tk_const_try_num : $d7cf          55247
 df_tk_const_try_str : $d7d2          55250
        df_tk_cursor : $de6f          56943
          df_tk_data : $ddd1          56785
AS65 Assembler for R6502 [1.42].                                     Page   15
-------------------------------- bank\bank0.s --------------------------------

     df_tk_data_done : $ddcf          56783
          df_tk_deek : $de3d          56893
           df_tk_def : $de15          56853
           df_tk_del : $de6f          56943
           df_tk_dim : $ddf7          56823
           df_tk_dir : $de6a          56938
           df_tk_div : $de6a          56938
          df_tk_doke : $de75          56949
          df_tk_done : $d9c5          55749
       df_tk_elapsed : $de47          56903
          df_tk_else : $de6a          56938
        df_tk_elseif : $de6f          56943
        df_tk_enddef : $de6a          56938
         df_tk_endif : $de6a          56938
           df_tk_eor : $de6a          56938
            df_tk_eq : $de6a          56938
         df_tk_error : $dd78          56696
      df_tk_errortab : $f6e8          63208
        df_tk_error2 : $de3b          56891
   df_tk_error_atpos : $f78f          63375
   df_tk_error_error : $f795          63381
  df_tk_error_inline : $f785          63365
   df_tk_exec_parser : $d9e7          55783
        df_tk_expect : $d71e          55070
      df_tk_expectok : $d71c          55068
    df_tk_expect_tok : $d72c          55084
df_tk_expect_tok_err : $d737          55095
df_tk_expect_tok_fatal : $d73c          55100
    df_tk_expression : $d929          55593
     df_tk_expre_err : $d934          55604
     df_tk_expr_more : $ddd6          56790
           df_tk_for : $de1a          56858
   df_tk_foundsymend : $da6e          55918
           df_tk_get : $de3d          56893
       df_tk_get_buf : $d6ac          54956
  df_tk_get_buf_null : $d6b6          54966
            df_tk_gt : $de6a          56938
           df_tk_gte : $de6a          56938
         df_tk_hchar : $de7f          56959
           df_tk_hex : $de3d          56893
         df_tk_himem : $de6f          56943
         df_tk_hires : $de6a          56938
            df_tk_if : $de6f          56943
           df_tk_imm : $f947          63815
      df_tk_indirect : $f94a          63818
 df_tk_indirect_done : $f96f          63855
    df_tk_indirect_y : $f95e          63838
           df_tk_ink : $de6f          56943
         df_tk_input : $dddf          56799
       df_tk_isalpha : $d6ef          55023
    df_tk_isalphanum : $d6fc          55036
 df_tk_isalpha_false : $d6ec          55020
         df_tk_isbin : $d6d0          54992
    df_tk_isbin_true : $d6d9          55001
       df_tk_isdigit : $d6c5          54981
 df_tk_isdigit_false : $d6ce          54990
         df_tk_isEOS : $d93b          55611
         df_tk_ishex : $d6da          55002
   df_tk_ishex_false : $d6ec          55020
   df_tk_ishex_truep : $d6ea          55018
        df_tk_isproc : $d702          55042
   df_tk_isproc_true : $d707          55047
AS65 Assembler for R6502 [1.42].                                     Page   16
-------------------------------- bank\bank0.s --------------------------------

          df_tk_isws : $d717          55063
    df_tk_isws_false : $d71c          55068
          df_tk_left : $de50          56912
           df_tk_len : $de3d          56893
          df_tk_line : $de87          56967
       df_tk_linenum : $d9f6          55798
        df_tk_lineto : $de75          56949
    df_tk_line_empty : $d9e3          55779
          df_tk_list : $ddb3          56755
df_tk_listp_procname : $dd90          56720
df_tk_listp_procname_ch : $dd9f          56735
df_tk_listp_procname_err : $ddb1          56753
df_tk_listp_procname_ok : $ddb0          56752
     df_tk_list_done : $ddc3          56771
     df_tk_list_line : $ddbf          56767
    df_tk_list_procs : $ddb8          56760
          df_tk_load : $de6f          56943
         df_tk_local : $de06          56838
      df_tk_localvar : $d814          55316
 df_tk_localvar_cont : $d81a          55322
           df_tk_lsr : $de6a          56938
            df_tk_lt : $de6a          56938
           df_tk_lte : $de6a          56938
      df_tk_matchtok : $da15          55829
df_tk_matchtok_skip_op : $da3b          55867
           df_tk_mem : $de3d          56893
           df_tk_mid : $de56          56918
           df_tk_mod : $de6a          56938
       df_tk_monitor : $de6a          56938
          df_tk_mult : $de6a          56938
         df_tk_music : $de87          56967
         df_tk_narry : $d8a9          55465
     df_tk_narry_end : $d8b6          55478
         df_tk_nbrkt : $d8bb          55483
            df_tk_ne : $de6a          56938
           df_tk_new : $de6a          56938
          df_tk_next : $de6a          56938
     df_tk_next_expr : $ddd1          56785
           df_tk_nop : $d914          55572
     df_tk_nop_false : $d8d3          55507
       df_tk_not_eos : $d933          55603
         df_tk_nterm : $d8c8          55496
    df_tk_nterm_cont : $d8d5          55509
    df_tk_nterm_done : $d8d3          55507
     df_tk_nterm_err : $d912          55570
    df_tk_nterm_proc : $d8c3          55491
   df_tk_nterm_tryfn : $d8e2          55522
df_tk_nterm_try_const : $d90c          55564
df_tk_nterm_try_proc : $d8f8          55544
 df_tk_nterm_try_var : $d904          55556
           df_tk_num : $d73e          55102
       df_tk_num_bin : $d76d          55149
       df_tk_num_err : $d72a          55082
    df_tk_num_hexbin : $d75f          55135
       df_tk_num_put : $d775          55157
            df_tk_or : $de6a          56938
         df_tk_paper : $de6f          56943
          df_tk_parm : $d802          55298
 df_tk_parm_skip_var : $d80f          55311
    df_tk_parseerror : $d9e5          55781
 df_tk_parse_command : $d955          55637
df_tk_parse_command_done : $d96b          55659
AS65 Assembler for R6502 [1.42].                                     Page   17
-------------------------------- bank\bank0.s --------------------------------

df_tk_parse_command_err : $d96c          55660
df_tk_parse_user_proc : $d94b          55627
          df_tk_peek : $de3d          56893
      df_tk_peek_buf : $d6a6          54950
         df_tk_pixel : $de50          56912
       df_tk_pixmode : $de6f          56943
          df_tk_play : $de87          56967
          df_tk_plot : $de7f          56959
         df_tk_point : $de75          56949
          df_tk_poke : $de75          56949
     df_tk_preassign : $dd68          56680
         df_tk_print : $ddca          56778
       df_tk_printat : $ddc4          56772
       df_tk_println : $ddca          56778
    df_tk_print_done : $ddcf          56783
          df_tk_proc : $d835          55349
     df_tk_proc_call : $d871          55409
    df_tk_proc_comma : $d88b          55435
      df_tk_proc_err : $d8a7          55463
     df_tk_proc_errp : $d8a6          55462
   df_tk_proc_noparm : $d894          55444
    df_tk_proc_parms : $d864          55396
df_tk_proc_skip_args : $d8a4          55460
df_tk_proc_skip_call : $d87a          55418
  df_tk_put_overflow : $d6c3          54979
       df_tk_put_tok : $d6b7          54967
          df_tk_read : $dde8          56808
         df_tk_renum : $de7f          56959
        df_tk_repeat : $de6a          56938
         df_tk_reset : $de33          56883
        df_tk_return : $de6c          56940
         df_tk_right : $de50          56912
           df_tk_rnd : $de3d          56893
          df_tk_rts1 : $d701          55041
           df_tk_run : $de6a          56938
          df_tk_save : $de6f          56943
          df_tk_scrn : $de50          56912
           df_tk_sgn : $de3d          56893
       df_tk_skip_ws : $d708          55048
    df_tk_skip_1_spc : $d9a9          55721
         df_tk_sound : $de7f          56959
       df_tk_sprchar : $de75          56949
        df_tk_sprhit : $de3d          56893
       df_tk_sprinit : $de6a          56938
     df_tk_spritepos : $de7f          56959
      df_tk_sprmulti : $de75          56949
        df_tk_sprpos : $de7f          56959
        df_tk_sprupd : $de6a          56938
         df_tk_stick : $de42          56898
           df_tk_str : $d79e          55198
        df_tk_str_ch : $d7a6          55206
       df_tk_str_don : $d7b7          55223
       df_tk_str_err : $d7be          55230
           df_tk_sub : $de6a          56938
      df_tk_symfound : $da7f          55935
df_tk_symfound_final : $da8f          55951
  df_tk_symnextentry : $da5f          55903
    df_tk_symnomatch : $da5d          55901
   df_tk_symnomatchp : $da5c          55900
          df_tk_text : $de6a          56938
         df_tk_tload : $de6f          56943
      df_tk_tokenjmp : $dc31          56369
AS65 Assembler for R6502 [1.42].                                     Page   18
-------------------------------- bank\bank0.s --------------------------------

     df_tk_tokentype : $dcf7          56567
df_tk_tok_expression : $d935          55605
    df_tk_try_assign : $d9c0          55744
   df_tk_try_command : $d9bb          55739
         df_tk_tsave : $de6f          56943
         df_tk_until : $de6f          56943
           df_tk_val : $de3d          56893
           df_tk_var : $d7e2          55266
      df_tk_variable : $dd5a          56666
        df_tk_var_ck : $d7f8          55288
      df_tk_var_cont : $d7e8          55272
    df_tk_var_noarry : $d7bc          55228
         df_tk_vpeek : $de3d          56893
          df_tk_wait : $de6f          56943
          df_tk_wend : $de6a          56938
         df_tk_while : $de6f          56943
      df_tk_ws_loop1 : $d708          55048
        df_tk_2parms : $de75          56949
        df_tk_3parms : $de7f          56959
        df_tk_4parms : $de87          56967
          df_tmpptra : $00a1            161
          df_tmpptrb : $00a3            163
          df_tmpptrc : $00a5            165
          df_tmpptrd : $00a7            167
          df_tmpptre : $00a9            169
              df_tok : $0480           1152
          df_tokbuff : $0480           1152
        df_tokensyms : $da97          55959
           df_tokoff : $007d            125
       df_trap_error : $f79c          63388
  df_trap_go_monitor : $f7b1          63409
     df_trap_monitor : $f82a          63530
      df_trap_normal : $f7b4          63412
           df_varcnt : $0071            113
      df_var_analyse : $d5e0          54752
df_var_analyse_chk_arry : $d627          54823
df_var_analyse_chk_dollar : $d618          54808
df_var_analyse_chk_post : $d618          54808
  df_var_analyse_err : $d60e          54798
df_var_analyse_fatal_err : $d616          54806
   df_var_analyse_ok : $d66d          54893
   df_var_check_type : $d555          54613
         df_var_find : $d51b          54555
   df_var_findcreate : $d641          54849
df_var_findcreate_copy : $d68f          54927
df_var_findcreate_create : $d65a          54874
df_var_findcreate_err : $d66b          54891
df_var_findcreate_errp : $d66a          54890
df_var_findcreate_found : $d653          54867
  df_var_find_no_vnt : $d579          54649
    df_var_find_true : $d57e          54654
df_var_initialise_var : $d67a          54906
 df_var_insert_space : $d586          54662
    df_var_match_vnt : $d52b          54571
 df_var_match_vnt_do : $d537          54583
df_var_match_vnt_sym : $d53b          54587
    df_var_move_byte : $d5a8          54696
 df_var_move_byte_do : $d5b4          54708
df_var_move_byte_fin : $d5c5          54725
     df_var_not_arry : $d638          54840
     df_var_not_proc : $d5f2          54770
df_var_type_countlen : $d5f5          54773
AS65 Assembler for R6502 [1.42].                                     Page   19
-------------------------------- bank\bank0.s --------------------------------

df_var_type_countlen_alphanum : $d605          54789
df_var_type_countlen_done : $d60a          54794
df_var_vnt_entry_end : $d566          54630
df_var_vnt_sym_nomatch : $d559          54617
     df_var_zero_vnt : $d686          54918
           df_vntend : $006b            107
          df_vntstrt : $0069            105
           df_vvtend : $006f            111
          df_vvtstrt : $006d            109
               errno : $005d             93
 fd_cload_getname_pc : $c58c          50572
 fd_csave_getname_pc : $c5e1          50657
     fd_getname_addr : $0400           1024
               grc_d : $0043             67   *
               grc_r : $003f             63   *
               grc_x : $0040             64   *
              grc_x0 : $003d             61   *
               grc_y : $0042             66   *
              grc_y0 : $003e             62   *
              grl_dx : $0041             65   *
              grl_dy : $0042             66   *
               grl_p : $004b             75   *
            grl_sinx : $004a             74   *
            grl_siny : $004d             77   *
            grl_xyyx : $0043             67   *
              grl_x0 : $003d             61   *
              grl_x1 : $003f             63   *
              grl_y0 : $003e             62   *
              grl_y1 : $0040             64   *
             grl_2dx : $0044             68   *
            grl_2dxy : $0048             72   *
             grl_2dy : $0046             70   *
             gr_char : $0003              3
  gr_check_font_copy : $ccac          52396
gr_check_font_copy_done : $ccc3          52419
           gr_circle : $d09b          53403
      gr_circle_done : $d0d8          53464
    gr_circle_d_lte0 : $d0cb          53451
      gr_circle_plot : $d0a8          53416
    gr_circle_points : $d0d9          53465
              gr_cls : $cd97          52631
          gr_cls_col : $cdb7          52663
          gr_cls_row : $cda3          52643
    gr_cls_skip_marg : $cdb3          52659
        gr_copy_byte : $cc83          52355
         gr_copy_mem : $cc79          52345
         gr_cur_down : $cedc          52956
         gr_cur_left : $cebe          52926
          gr_cur_ptr : $000c             12
        gr_cur_right : $ceac          52908
  gr_cur_skip_at_bot : $cee8          52968
 gr_cur_skip_at_left : $cecd          52941
   gr_cur_skip_at_tl : $ced1          52945
           gr_cur_up : $ced2          52946
            gr_cur_x : $000a             10
            gr_cur_y : $000b             11
              gr_del : $cee9          52969
       gr_geom_fill1 : $0007              7
         gr_geom_tmp : $0015             21
        gr_geom_tmp2 : $0017             23
              gr_get : $cdfe          52734
       gr_getXY_base : $cddb          52699
AS65 Assembler for R6502 [1.42].                                     Page   20
-------------------------------- bank\bank0.s --------------------------------

          gr_get_key : $cef1          52977
        gr_get_key_2 : $cef5          52981
            gr_hchar : $cfaa          53162
   gr_hchar_copyline : $d002          53250
gr_hchar_copyline_eor : $d018          53272
gr_hchar_copyline_erase : $d028          53288
gr_hchar_copyline_nx : $d03d          53309
    gr_hchar_getfont : $cfdd          53213
       gr_hchar_mask : $cfd5          53205
    gr_hchar_rot1bit : $cfe7          53223
gr_hchar_rot1bit_bcc : $cff2          53234
 gr_hchar_rot1bit_nx : $cff7          53239
            gr_hcode : $cf90          53136
       gr_hcode_loop : $cf96          53142
          gr_hires_x : $0010             16
          gr_hires_y : $0011             17
         gr_hi_start : $0001              1
             gr_init : $cc93          52371
        gr_init_font : $cc63          52323
        gr_init_geom : $ccc4          52420
   gr_init_geom_done : $ccc3          52419
       gr_init_hires : $cd1a          52506
gr_init_hires_tables : $cd53          52563
  gr_init_screen_txt : $cd01          52481
     gr_init_tab_col : $cd7f          52607
gr_init_tab_col_skip : $cd91          52625
     gr_init_tab_row : $cd5d          52573
              gr_ink : $0012             18
    gr_key_check_key : $cf01          52993
      gr_key_got_key : $cf18          53016
       gr_key_no_key : $cf23          53027
    gr_key_skip_copy : $cf09          53001
      gr_key_tidy_up : $cf1a          53018
             gr_line : $d151          53585
        gr_line_done : $d22b          53803
       gr_line_neg_p : $d21b          53787
       gr_line_pixel : $d1e4          53732
 gr_line_skip_dx_neg : $d16f          53615
 gr_line_skip_dy_neg : $d17c          53628
   gr_line_skip_left : $d1ac          53676
gr_line_skip_xy_swap : $d19c          53660
   gr_line_skip_y_up : $d1b4          53684
     gr_line_yx_skip : $d1f0          53744
           gr_margin : $0014             20
             gr_mode : $0000              0
           gr_new_ln : $ce94          52884
       gr_nl_skip_nl : $cea9          52905
       gr_no_special : $cf38          53048
      gr_offset_40hi : $d248          53832
      gr_offset_40lo : $d22c          53804
            gr_paper : $0013             19
            gr_pitch : $000f             15
            gr_pixel : $d064          53348
          gr_pixmode : $000e             14
             gr_plot : $cdeb          52715
            gr_point : $d06a          53354
       gr_point_done : $d09a          53402
        gr_point_eor : $d096          53398
      gr_point_setup : $d04c          53324
  gr_point_skip_attr : $d08c          53388
      gr_point_write : $d098          53400
        gr_printable : $cf5c          53084
AS65 Assembler for R6502 [1.42].                                     Page   21
-------------------------------- bank\bank0.s --------------------------------

        gr_print_msg : $cf7b          53115
   gr_print_msg_done : $cf8b          53131
   gr_print_msg_loop : $cf81          53121
  gr_process_special : $cf41          53057
              gr_put : $cdf3          52723
         gr_put_byte : $cf27          53031
     gr_put_byte_low : $cf39          53049
           gr_screen : $0018             24
         gr_scrngeom : $0011             17
    gr_scrngeom_base : $ccd3          52435
   gr_scrngeom_hires : $cce8          52456
    gr_scrngeom_text : $ccd9          52441
      gr_scroll_char : $ce56          52822
    gr_scroll_cpy_ln : $ce53          52819
  gr_scroll_erase_ln : $ce8a          52874
      gr_scroll_marg : $ce86          52870
   gr_scroll_routine : $ce9d          52893
        gr_scroll_up : $ce37          52791
          gr_set_cur : $ce04          52740
     gr_set_cur_init : $ce05          52741
     gr_set_cur_skip : $ce17          52759
    gr_set_hires_cur : $d05f          53343
       gr_special_ch : $cf62          53090
    gr_special_fn_hi : $cf73          53107
    gr_special_fn_lo : $cf6b          53099
     gr_special_loop : $cf45          53061
         gr_spr_char : $d2d7          53975
         gr_spr_draw : $d2b6          53942
    gr_spr_draw_loop : $d2b8          53944
    gr_spr_draw_next : $d2c4          53956
        gr_spr_erase : $d272          53874
     gr_spr_erase_do : $d27a          53882
   gr_spr_erase_loop : $d274          53876
   gr_spr_erase_next : $d280          53888
          gr_spr_hit : $d2dd          53981
         gr_spr_init : $d264          53860
    gr_spr_init_loop : $d266          53862
   gr_spr_multi_loop : $d2f8          54008
    gr_spr_multi_pos : $d2f4          54004
          gr_spr_new : $d284          53892
     gr_spr_new_loop : $d286          53894
     gr_spr_new_next : $d2b2          53938
          gr_spr_pos : $d2e7          53991
          gr_spr_put : $d2c8          53960
           gr_text_h : $0009              9
       gr_text_start : $0005              5
           gr_text_w : $0008              8
              HICHAR : $9800          38912   *
              HISCRN : $a000          40960   *
              HITEXT : $bf68          49000   *
          hex_to_bcd : $c364          50020
 hex_to_bcd_skip_neg : $c375          50037
           hires_col : $9d90          40336   *
          hires_mask : $9e80          40576   *
        hires_row_hi : $9cc8          40136   *
       hires_row_low : $9c00          39936   *
                 IER : $000e             14   *
                 IFR : $000d             13   *
             IFR_CA1 : $0002              2   *
             IFR_CA2 : $0001              1   *
             IFR_CB1 : $0010             16   *
                IO_0 : $0300            768   *
AS65 Assembler for R6502 [1.42].                                     Page   22
-------------------------------- bank\bank0.s --------------------------------

       inc_kb_timers : $c166          49510
            infinity : $c07e          49278
                init : $c4d9          50393
            init_irq : $c0cd          49357
       init_keyboard : $c767          51047
            init_ram : $c505          50437
       init_ram_fill : $c512          50450
       init_ram_skip : $c517          50455
          init_ram_1 : $c50e          50446
            init_snd : $d42e          54318
       init_snd_regs : $d430          54320
       init_tape_tab : $c54f          50511
           init_via0 : $c525          50469
      init_via0_done : $c537          50487
      init_via0_loop : $c527          50471
       init_via0_tab : $c538          50488
      init_via0_tape : $c522          50466
              init_2 : $c4de          50398
             int_div : $d4b8          54456
       int_div_cycle : $d4ea          54506
      int_div_noflip : $d51a          54554
        int_div_skip : $d504          54532
   int_div_skip_negA : $d4cf          54479
   int_div_skip_negB : $d4e2          54498
       int_fast_mult : $d464          54372
 int_fast_mult_cycle : $d474          54388
  int_fast_mult_next : $d485          54405
            int_mult : $d48d          54413
      int_mult_cycle : $d49d          54429
       int_mult_next : $d4b0          54448
         int_vdp_fin : $c15b          49499
     int_vdp_handler : $c140          49472
    io_active_device : $c42b          50219
          io_address : $0300            768
            io_block : $0601           1537
           io_buf_sz : $c4b7          50359
            io_close : $c45d          50269
          io_close_f : $0008              8
        io_copy_data : $c438          50232
          io_default : $0600           1536
           io_delete : $c460          50272
            io_del_f : $000a             10
          io_devices : $c4b9          50361
          io_device0 : $c4b9          50361
          io_device1 : $c4c9          50377
          io_do_echo : $c480          50304
             io_ext1 : $000c             12
             io_ext2 : $000e             14
         io_get_byte : $0000              0
           io_get_ch : $c451          50257
    io_get_line_byte : $c46d          50285
    io_get_line_done : $c49a          50330
             io_init : $c420          50208
          io_null_op : $c4b5          50357
        io_open_ext1 : $c463          50275
        io_open_ext2 : $c466          50278
           io_open_r : $0004              4
        io_open_read : $c457          50263
           io_open_w : $0006              6
       io_open_write : $c45a          50266
       io_print_done : $c4b3          50355
       io_print_line : $c4a2          50338
AS65 Assembler for R6502 [1.42].                                     Page   23
-------------------------------- bank\bank0.s --------------------------------

  io_print_line_byte : $c4a9          50345
         io_put_byte : $0002              2
           io_put_ch : $c454          50260
        io_read_line : $c469          50281
      io_set_default : $c428          50216
        io_skip_echo : $c483          50307
     io_skip_special : $c48e          50318
           io_struct : $0010             16
                 irq : $c0f1          49393
             irq_brk : $c113          49427
             irq_fin : $c10d          49421
           KB_CAPSLK : $0001              1   *
         KB_DEBOUNCE : $0001              1   *
              KB_PRB : $00b0            176   *
          KB_REP_DEL : $0014             20   *
          KB_REP_TIM : $0003              3   *
            KB_SENSE : $0008              8   *
          kb_any_key : $c7a0          51104
     kb_any_key_none : $c7c0          51136
  kb_any_key_pressed : $c7c2          51138
      kb_any_key_row : $c7a7          51111
              kb_brk : $c8b6          51382
 kb_check_matrix_col : $c7dc          51164
 kb_check_matrix_row : $c7de          51166
      kb_check_skip4 : $c804          51204
             kb_code : $002b             43
         kb_col_mask : $c956          51542
              kb_deb : $002d             45
          kb_deb_tim : $002e             46
        kb_do_repeat : $c8a6          51366
          kb_get_key : $c8b8          51384
          kb_get_try : $c8bc          51388
        kb_in_repeat : $c8b2          51378
             kb_last : $002a             42
          kb_no_scan : $c839          51257
      kb_process_new : $c847          51271
              kb_raw : $0029             41
         kb_rdel_tim : $0031             49
         kb_read_got : $c7c2          51138
     kb_read_noshift : $c874          51316
     kb_read_nothing : $c80f          51215
         kb_read_raw : $c7c4          51140
   kb_read_raw_force : $c7c9          51145
     kb_read_raw_got : $c813          51219
              kb_rep : $002f             47
          kb_rep_tim : $0030             48
      kb_scan_decode : $c83d          51261
     kb_scan_got_key : $c8cd          51405
         kb_scan_key : $c822          51234
        kb_skip_ctrl : $c890          51344
             kb_stat : $002c             44
            kb_stick : $c778          51064
       kb_stick_mask : $c95e          51550
        kb_stick_pos : $c787          51079
       kb_store_last : $c8ae          51374
      kb_table_shift : $c916          51478
        kb_table_std : $c8d6          51414
         kernel_init : $c4e7          50407
         kernel_test : $c504          50436
                main : $c077          49271
           mem_start : $0713           1811
        mod_sz_asm_e : $fede          65246
AS65 Assembler for R6502 [1.42].                                     Page   24
-------------------------------- bank\bank0.s --------------------------------

        mod_sz_asm_s : $f87e          63614
       mod_sz_bios_e : $d464          54372
       mod_sz_bios_s : $c000          49152
        mod_sz_cia_e : $c55e          50526
        mod_sz_cia_s : $c522          50466
      mod_sz_dflat_e : $f6e8          63208
      mod_sz_dflat_s : $d51b          54555
      mod_sz_graph_e : $d308          54024
      mod_sz_graph_s : $c963          51555
         mod_sz_io_e : $c4d9          50393
         mod_sz_io_s : $c420          50208
     mod_sz_kernel_e : $c522          50466
     mod_sz_kernel_s : $c000          49152
   mod_sz_language_e : $fede          65246
   mod_sz_language_s : $d464          54372
       mod_sz_proc_e : $f608          62984
       mod_sz_proc_s : $f4a5          62629
   mod_sz_progedit_e : $e003          57347
   mod_sz_progedit_s : $de92          56978
      mod_sz_rtasm_e : $fc73          64627
      mod_sz_rtasm_s : $f971          63857
     mod_sz_rtsubs_e : $f4a5          62629
     mod_sz_rtsubs_s : $e5c9          58825
    mod_sz_runtime_e : $f608          62984
    mod_sz_runtime_s : $e003          57347
      mod_sz_sound_e : $d464          54372
      mod_sz_sound_s : $d417          54295
     mod_sz_sprite_e : $d308          54024
     mod_sz_sprite_s : $d264          53860
      mod_sz_tkasm_e : $f971          63857
      mod_sz_tkasm_s : $f87e          63614
   mod_sz_tokenise_e : $de92          56978
   mod_sz_tokenise_s : $d6a6          54950
    mod_sz_toksubs_e : $de92          56978
    mod_sz_toksubs_s : $dd5a          56666
        mod_sz_var_e : $d6a6          54950
        mod_sz_var_s : $d51b          54555
          msg_errmsg : $d414          54292
     msg_hello_world : $c081          49281
           msg_ready : $d412          54290
             NUM_ANY : $0000              0   *
             NUM_BIN : $0003              3   *
             NUM_DEC : $0001              1   *
             NUM_HEX : $0002              2   *
                 nmi : $c521          50465
        null_handler : $c0f0          49392
            null_irq : $c0ef          49391
               num_a : $003d             61
               num_b : $0041             65
             num_buf : $004d             77
             num_tmp : $0049             73
               num_x : $0045             69
             out_bcd : $c3cf          50127
       out_bcd_digit : $c3d7          50135
         out_bcd_fin : $c3f7          50167
        out_bcd_next : $c3e9          50153
       out_bcd_print : $c3e5          50149
                 PCR : $000c             12   *
                 PRA : $0001              1   *
                PRAH : $000f             15   *
                 PRB : $0000              0   *
        print_a_to_d : $c3fd          50173
AS65 Assembler for R6502 [1.42].                                     Page   25
-------------------------------- bank\bank0.s --------------------------------

print_a_to_d_skip_neg : $c416          50198
           SND_ADBUS : $030f            783   *
        SND_DESELECT : $00dd            221   *
            SND_MODE : $030c            780   *
       SND_REG_CHAPH : $0001              1   *
       SND_REG_CHAPL : $0000              0   *
      SND_REG_CHAVOL : $0008              8   *
       SND_REG_CHBPH : $0003              3   *
       SND_REG_CHBPL : $0002              2   *
      SND_REG_CHBVOL : $000a             10   *
       SND_REG_CHCPH : $0005              5   *
       SND_REG_CHCPL : $0004              4   *
        SND_REG_CHNP : $0006              6   *
         SND_REG_CTL : $0007              7   *
      SND_REG_ENVCYC : $000d             13   *
       SND_REG_ENVPH : $000c             12   *
       SND_REG_ENVPL : $000b             11   *
         SND_REG_IOA : $000e             14   *
         SND_REG_IOB : $000f             15   *
         SND_SELREAD : $00df            223   *
      SND_SELSETADDR : $00ff            255   *
        SND_SELWRITE : $00fd            253   *
                  SR : $000a             10   *
               SWBRK : <macro>
             scratch : $0613           1555
          skip_a_f_1 : $c1a4          49572
          skip_a_f_2 : $c1b3          49587
         skip_kb_deb : $c16c          49516
         skip_kb_rep : $c172          49522
          skip_x_f_1 : $c1bf          49599
          skip_x_f_2 : $c1d4          49620
        snd_get_note : $d417          54295
    snd_get_note_oct : $d422          54306
        snd_init_tab : $d43a          54330
       snd_music_tab : $d44a          54346
       snd_note_done : $d42b          54315
         snd_sel_reg : $c04e          49230
             snd_set : $c06e          49262
         snd_set_reg : $c05e          49246
        spr_baseadrh : $b4e0          46304   *
        spr_baseadrl : $b4c0          46272   *
            spr_bgnd : $b4a0          46240   *
             spr_chr : $b480          46208   *
            spr_curX : $b400          46080   *
            spr_curY : $b440          46144   *
            spr_newX : $b420          46112   *
            spr_newY : $b460          46176   *
          str_a_to_x : $c198          49560
   str_d_digits_done : $c2d4          49876
         str_d_error : $c280          49792
      str_d_find_end : $c28f          49807
     str_d_found_end : $c29c          49820
        str_d_powers : $c2f1          49905
 str_d_process_digit : $c2aa          49834
      str_d_skip_neg : $c2eb          49899
          str_x_to_a : $c1b4          49588
      str_x_to_a_err : $c1df          49631
     str_x_to_a_errl : $c1de          49630
           TAPE_RATE : $00d0            208   *
            TEXTCHAR : $b400          46080   *
            TEXTSCRN : $bb80          48000   *
         TIMER1_RATE : $4e20          20000   *
AS65 Assembler for R6502 [1.42].                                     Page   26
-------------------------------- bank\bank0.s --------------------------------

                T1CH : $0005              5   *
                T1CL : $0004              4   *
                T1LH : $0007              7   *
                T1LL : $0006              6   *
                T2CH : $0009              9   *
                T2CL : $0008              8   *
             tmp_ahi : $0033             51
             tmp_alo : $0032             50
           tmp_bank1 : $0000              0
           tmp_bank2 : $0001              1
             tmp_bhi : $0035             53
             tmp_blo : $0034             52
             tmp_chi : $0037             55
             tmp_clo : $0036             54
               tmp_d : $0038             56
            tp_back4 : $c56f          50543
            tp_block : $0055             85
        tp_block_gap : $c699          50841
      tp_block_gap_1 : $c69d          50845
              tp_buf : $0200            512
            tp_close : $c5bf          50623
   tp_close_no_flush : $c5c8          50632
            tp_delay : $0059             89
             tp_flag : $0058             88
        tp_get_block : $c719          50969
  tp_get_block_bytes : $c72a          50986
         tp_get_byte : $c6fc          50940
     tp_get_byte_buf : $c709          50953
        tp_get_fname : $c5a5          50597
  tp_get_fname_start : $c596          50582
       tp_get_header : $c59f          50591
              tp_idx : $0057             87
             tp_init : $c574          50548
         tp_io_error : $c765          51045
       tp_open_bread : $c58c          50572
      tp_open_bwrite : $c5d7          50647
      tp_open_common : $c57c          50556
         tp_open_msg : $c55e          50526
        tp_open_read : $c58c          50572
       tp_open_write : $c5dd          50653
 tp_open_write_start : $c5e1          50657
      tp_print_block : $c679          50809
        tp_put_block : $c655          50773
  tp_put_block_bytes : $c66b          50795
         tp_put_byte : $c623          50723
    tp_put_byte_done : $c646          50758
        tp_put_delay : $c64d          50765
         tp_read_bit : $c74c          51020
     tp_read_bit_cb1 : $c750          51024
        tp_read_byte : $c738          51000
   tp_read_byte_bits : $c744          51012
     tp_read_byte_st : $c738          51000
         tp_save_msg : $c567          50535
        tp_write_bit : $c6c7          50887
   tp_write_bit_chk1 : $c6d8          50904
   tp_write_bit_chk2 : $c6f0          50928
     tp_write_bit_t1 : $c6e7          50919
       tp_write_byte : $c6a4          50852
   tp_write_byte_bit : $c6b0          50864
tp_write_byte_nodelay : $c6c5          50885
      tp_write_fname : $c615          50709
     tp_write_header : $c60c          50700
AS65 Assembler for R6502 [1.42].                                     Page   27
-------------------------------- bank\bank0.s --------------------------------

     tt_csave_end_pc : $c5d5          50645
   tt_getsync_end_pc : $c5be          50622
  tt_getsync_loop_pc : $c750          51024
       tt_getsync_pc : $c5be          50622
   tt_putbyte_end_pc : $c6c6          50886
       tt_putbyte_pc : $c6a4          50852
  tt_readbyte_end_pc : $c74b          51019
      tt_readbyte_pc : $c738          51000
tt_writeleader_end_pc : $c5fd          50685
   tt_writeleader_pc : $c5fd          50685
     twos_complement : $c355          50005
twos_complement_skip_X : $c363          50019
             UTF_ACK : $0001              1   *
             UTF_BEL : $0007              7   *
             UTF_BRK : $001a             26   *
              UTF_CR : $000d             13   *
             UTF_DEL : $007f            127   *
             UTF_ETX : $0003              3   *
              UTF_FF : $000c             12   *
         UTF_SPECIAL : $0020             32   *
       update_timers : $c15c          49500
          utilPrintA : $c183          49539
       utilPrintCRLF : $c17b          49531
        utilPrintSPC : $c173          49523
           VDP_FLASH : $0010             16   *
           vdp_blank : $0010             16
             vdp_cnt : $0008              8
          vdp_cnt_hi : $0009              9
         vdp_cnt_hi2 : $000a             10
          vdp_curcnt : $000c             12
          vdp_curoff : $000d             13
         vdp_curstat : $000e             14
          vdp_curtim : $000b             11
          vdp_curval : $000f             15
  vdp_fill_vram_loop : $cd3b          52539
 vdp_fill_vram_noinc : $cd43          52547
            vdp_font : $c963          51555
          vdp_font_a : $ca6b          51819
             vec_brk : $0004              4
             vec_irq : $0002              2
        vec_usercia0 : $0006              6
             zp_tmp1 : $00ab            171
             zp_tmp2 : $00ac            172
             zp_tmp3 : $00ad            173
             zp_tmp4 : $00ae            174
             ztmp_24 : $003d             61
          _adcZPByte : <macro>
          _addZPWord : <macro>
                _bcc : <macro>
                _bcs : <macro>
           _code_end : $fede          65246
         _code_start : $c000          49152
          _cpu_stack : $0100            256
          _cpyZPWord : <macro>
              _debug : <macro>
          _decZPWord : <macro>
         _decZPWordA : <macro>
      _end_zero_page : $00af            175
          _incZPWord : <macro>
       _mod_sz_cmd_e : $d417          54295
       _mod_sz_cmd_s : $d308          54024
       _PushFalseJmp : <macro>
AS65 Assembler for R6502 [1.42].                                     Page   28
-------------------------------- bank\bank0.s --------------------------------

        _PushTrueJmp : <macro>
             _printA : <macro>
             _printC : <macro>
            _printCA : <macro>
          _printCRLF : <macro>
            _println : <macro>
        _println_low : <macro>
          _printmsgA : <macro>
            _pullAXY : <macro>
            _pushAXY : <macro>
         _rom_vec_0a : $c01e          49182
         _rom_vec_0b : $c021          49185
         _rom_vec_0c : $c024          49188
         _rom_vec_0d : $c027          49191
         _rom_vec_0e : $c02a          49194
         _rom_vec_0f : $c02d          49197
         _rom_vec_00 : $c000          49152
         _rom_vec_01 : $c003          49155
         _rom_vec_02 : $c006          49158
         _rom_vec_03 : $c009          49161
         _rom_vec_04 : $c00c          49164
         _rom_vec_05 : $c00f          49167
         _rom_vec_06 : $c012          49170
         _rom_vec_07 : $c015          49173
         _rom_vec_08 : $c018          49176
         _rom_vec_09 : $c01b          49179
         _rom_vec_10 : $c030          49200
         _rom_vec_11 : $c033          49203
         _rom_vec_12 : $c036          49206
         _rom_vec_13 : $c039          49209
         _rom_vec_14 : $c03c          49212
         _rom_vec_15 : $c03f          49215
         _rom_vec_16 : $c042          49218
         _rom_vec_17 : $c045          49221
         _rom_vec_18 : $c048          49224
         _rom_vec_19 : $c04b          49227
          _sbcZPByte : <macro>
            _sendcmd : <macro>
          _subZPWord : <macro>
            __6502__ : $0001              1

1686 labels used

15680 lines read, no errors in pass 1.
AS65 Assembler for R6502 [1.42].                                     Page   29
-------------------------------- bank\bank0.s --------------------------------

c000 =                       	org 0xc000
c000 :                       mod_sz_bios_s
                             	include "kernel/kernel.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	Lol, I thought this would become more sophisti
                             ;*	hence the name 'kernel'. But no, it just initi
                             ;*	memory, VIA, sound and screen, before passing 
                             ;*	to main.
                             ;*	References to banks etc. are from ported code 
                             ;*	did do more stuff, namely helping with ROM ban
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc/includes.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  and ACIA registers.
                             ;*	Of course the Oric doesn't have a VDP or an AC
                             ;*	so this file could be optimised.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x0300
0300 =                       IO_0		= 0x0300
                             
0010 =                       VDP_FLASH	= 16				;* 32/50 second flash
                             
4e20 =                       TIMER1_RATE	= 1000000 / 50		;* 50 times per secon
00d0 =                       TAPE_RATE	= 0xd0				;* Assumed required FM freque
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
AS65 Assembler for R6502 [1.42].                                     Page   30
-------------------------------- bank\bank0.s --------------------------------

000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
0010 =                       IFR_CB1		= 0x10
                             
                             ;* AY-3-8912 definitions
                             ;* The sound chip is accessed through VIA Port A
030f =                       SND_ADBUS	= IO_0+PRAH
030c =                       SND_MODE	= IO_0+PCR
                             
                             ; Values for the PCR register - always enable CB1
00df =                       SND_SELREAD			= 0b11011111
00fd =                       SND_SELWRITE		= 0b11111101
00ff =                       SND_SELSETADDR		= 0b11111111
00dd =                       SND_DESELECT		= 0b11011101
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             
                             ;* Port B
00b0 =                       KB_PRB		= 0xb0			; Upper nibble of PRB default st
0008 =                       KB_SENSE	= 0x08			; Input - Bit 3 port A
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock - maps to Le
                             
0003 =                       KB_REP_TIM	= 3 			; Number of VB periods for the 
0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0001 =                       KB_DEBOUNCE	= 1				; Number of VB periods before 
                             
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0014 =                       CTRL_CAPS	= 0x14			; CTRL-T to toggle caps
0001 =                       UTF_ACK		= 0x01			; Used for the CTRL-A copy in t
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
007f =                       UTF_DEL		= 0x7f
AS65 Assembler for R6502 [1.42].                                     Page   31
-------------------------------- bank\bank0.s --------------------------------

0020 =                       UTF_SPECIAL = 0x20
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	sta tmp_d
                             	txa
                             	pha
                             	tya
                             	pha
                             	lda tmp_d
                             	endm
                             
                             _pullAXY macro
                             	pla
                             	tay
                             	pla
                             	tax
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
AS65 Assembler for R6502 [1.42].                                     Page   32
-------------------------------- bank\bank0.s --------------------------------

                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	_pullAXY
                             	endm
                             
                             _printA macro
                             	_pushAXY
                             	jsr str_a_to_x
                             	jsr io_put_ch
                             	txa
                             	jsr io_put_ch
                             	_pullAXY
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr io_put_ch
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWordA macro wordp
                             	lda wordp
                             	db	0xd0, 0x02
                             	dec wordp+1
                             	dec wordp
                             	endm
                             	
                             _decZPWord macro wordp
AS65 Assembler for R6502 [1.42].                                     Page   33
-------------------------------- bank\bank0.s --------------------------------

                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
                             	endm
                             
                             _bcs macro skip
                             	db 0xb0, skip
AS65 Assembler for R6502 [1.42].                                     Page   34
-------------------------------- bank\bank0.s --------------------------------

                             	endm
                             
                             _debug macro ch
                             	pha
                             	lda #ch
                             	sta 48000
                             	pla
                             	endm
                             	
                             
                             
                             	include "inc/graph.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*	This was needed in the previous code due to 32
                             ;*	byte width screens, but Oric only  has 40, so 
                             ;*	could be optimised a little.
                             ;*
                             ;************************************************
                             
                             ; Important screen addresses for the Oric ULA
bb80 =                       TEXTSCRN	=	0xbb80
b400 =                       TEXTCHAR	=	0xb400
a000 =                       HISCRN		=	0xa000
9800 =                       HICHAR		=	0x9800
bf68 =                       HITEXT		=	0xbf68
                             
0000 =                       	struct gr_screen
0000 =                       	db gr_mode					; Text or Hires mode
0001 =                       	dw gr_hi_start				; Address fo hires screen
0003 =                       	dw gr_char					; Start address of charset
0005 =                       	dw gr_text_start			; Start of text memory
0007 =                       	db gr_geom_fill1			; (Not used, maintained for a
0008 =                       	db gr_text_w				; Number of columns
0009 =                       	db gr_text_h				; Number of rows
000a =                       	db gr_cur_x					; Current X position of cursor
000b =                       	db gr_cur_y					; Current Y position of cursor
000c =                       	dw gr_cur_ptr				; VDP address of cursor
000e =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000f =                       	db gr_pitch					; Pixel pitch for char plotting
0010 =                       	db gr_hires_x				; X pos of hires cursor
0011 =                       	db gr_hires_y				; Y pos of hires cursor
0012 =                       	db gr_ink					; Ink colour
0013 =                       	db gr_paper					; Paper colour
0014 =                       	db gr_margin				; Left margin
0015 =                       	dw gr_geom_tmp				; One word of temp storage for
0017 =                       	db gr_geom_tmp2				; One byte of temp storage fo
                             	end struct
                             	
                             ; Sprite data stored in free 256 in font space
b400 =                       spr_curX	= TEXTCHAR			; Sprite current X pos
AS65 Assembler for R6502 [1.42].                                     Page   35
-------------------------------- bank\bank0.s --------------------------------

b420 =                       spr_newX	= TEXTCHAR+32		; Sprite new X pos
b440 =                       spr_curY	= TEXTCHAR+64		; Sprite current Y pos
b460 =                       spr_newY	= TEXTCHAR+96		; Sprite new Y pos
b480 =                       spr_chr		= TEXTCHAR+128		; Sprite character
b4a0 =                       spr_bgnd	= TEXTCHAR+160		; Background character u
b4c0 =                       spr_baseadrl= TEXTCHAR+192		; Y low address of sp
b4e0 =                       spr_baseadrh= TEXTCHAR+224		; Y high address of s
                             
                             ; Tables stored in alternate character set area
                             ; only used for high-resolution screen handling
9c00 =                       hires_row_low	=	HICHAR+0x400		; Low byte of row p
9cc8 =                       hires_row_hi	=	hires_row_low+200	; High byte of r
9d90 =                       hires_col		=	hires_row_hi+200	; Pixel to byte col
9e80 =                       hires_mask		=	hires_col+240		; Pixel column to pi
                             
                             
                             	include "io/io.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*	Some over-engineering here for future possibil
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             	include "dflat/dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
AS65 Assembler for R6502 [1.42].                                     Page   36
-------------------------------- bank\bank0.s --------------------------------

0713 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
AS65 Assembler for R6502 [1.42].                                     Page   37
-------------------------------- bank\bank0.s --------------------------------

0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
AS65 Assembler for R6502 [1.42].                                     Page   38
-------------------------------- bank\bank0.s --------------------------------

                             	endm
                             
                             	include "kernel/zeropage.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple uses across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       vec_irq		 ds	2		; Master IRQ handler
0004 =                       vec_brk		 ds	2		; Master BRK handler
0006 =                       vec_usercia0 ds	2		; Where to jump for CIA0 inter
                             
                             ; VDP parameters
0008 =                       vdp_cnt		ds	1		; VDP interrupt counter
0009 =                       vdp_cnt_hi 	ds	1		; VDP counter high
000a =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000b =                       vdp_curtim	ds	1		; Cursor blink speed
000c =                       vdp_curcnt	ds	1		; Cursor blink countdown
000d =                       vdp_curoff	ds	1		; Cursor off (0 = On)
000e =                       vdp_curstat	ds	1		; Cursor status
000f =                       vdp_curval	ds	1		; Cursor value on screen
0010 =                       vdp_blank	ds	1		; Screen blank value normally 32
                             
                             ; Screen geometry
0011 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0029 =                       kb_raw  	ds	1		; Raw keyboard code
002a =                       kb_last		ds	1		; Code of last key
002b =                       kb_code 	ds	1		; Converted keyboard code
002c =                       kb_stat		ds	1		; Keyboard status for caps and shi
002d =                       kb_deb		ds	1		; Debounce timer
002e =                       kb_deb_tim  ds	1		; Default debounce delay
002f =                       kb_rep		ds	1		; Keyboard repeat speed timer
0030 =                       kb_rep_tim 	ds	1		; Default repeat speed
AS65 Assembler for R6502 [1.42].                                     Page   39
-------------------------------- bank\bank0.s --------------------------------

0031 =                       kb_rdel_tim	ds	1		; Default repeat delay (until s
                             
0032 =                       tmp_alo 	ds	1		; VDP addresses lo
0033 =                       tmp_ahi 	ds	1		; VDP addresses hi
0034 =                       tmp_blo 	ds	1		; Temp address lo
0035 =                       tmp_bhi		ds	1		; Temp address hi
0036 =                       tmp_clo		ds	1		; Temp address lo
0037 =                       tmp_chi		ds	1		; Temp address hi
0038 =                       tmp_d		ds	1		; Temp storage d
                             
                             ; Raw input/output parameters
0039 =                       buf_lo		ds	1		; Line buffer address low
003a =                       buf_hi		ds	1		; Line buffer address high
003b =                       buf_sz		ds	1		; Buffer size
003c =                       buf_ef		ds	1		; End file / line marker
                             
                             
                             ; ** Integer function storage **
003d =                       ztmp_24					; Start of 24 byte scratch area (all 
003d =                       num_a		ds	4		; 4 byte primary accumulator
0041 =                       num_b		ds	4		; 4 byte secondary accumulator
0045 =                       num_x		ds	4		; 4 byte x register
0049 =                       num_tmp		ds	4		; 4 byte temp space
004d =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ; ** Tape function storage **
0055 =                       tp_block	ds	2		; Block number (int)
0057 =                       tp_idx		ds	1		; Current buffer index
0058 =                       tp_flag		ds	1		; zero = closed, 1=read, 2=write
0059 =                       tp_delay	ds	2		; Interblock delay
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
005b =                       dflat_zp_s
005b =                       dflat_zp_save_s			; ZP save dflat from here
005b =                       df_checkkey	ds	1		; Key check interval counter
005c =                       df_checkmsk	ds	1		; Mask for check key
005d =                       errno		ds	1		; General error condition status
005e =                       df_immed	ds	1		; Immediate mode (0 = not immediat
005f =                       df_sp		ds	1		; Stack pointer after error to resto
0060 =                       df_pc		ds	2		; PC after error to return to
0062 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
0064 =                       df_brkval	ds	1		; Byte after BRK instruction
0065 =                       df_prgstrt	ds	2		; Start of program code
0067 =                       df_prgend	ds	2		; End of program code
0069 =                       df_vntstrt	ds	2		; Variable name table start
006b =                       df_vntend	ds	2		; Variable name table end
006d =                       df_vvtstrt	ds	2		; Variable value table start
006f =                       df_vvtend	ds	2		; Variable value table end
0071 =                       df_varcnt	ds	1		; Variable counter
0072 =                       df_starstrt	ds	2		; String and array table start
0074 =                       df_starend	ds	2		; String and array table end
0076 =                       df_rtstop	ds	1		; Runtime stack pointer
0077 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
0078 =                       df_strbuffz	ds	1		; String expression buffer (*un
0079 =                       df_stridxz	ds	1		; Top of string buffer (grows do
007a =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
007c =                       df_linoff	ds	1		; Offset in to line buffer
007d =                       df_tokoff	ds	1		; Offset in to tokenised buffer
007e =                       df_eolidx	ds	1		; End of line index (i.e length)
AS65 Assembler for R6502 [1.42].                                     Page   40
-------------------------------- bank\bank0.s --------------------------------

007f =                       df_nxtstidx	ds	1		; Offset to the next statement 
0080 =                       df_curstidx	ds	1		; Offset to the start of curren
0081 =                       df_symtab	ds	2		; Pointer to next free symtab ent
0083 =                       df_symoff	ds	1		; Offset in to token table
0084 =                       df_syminiz	ds	2		; Start of symtab (*unused*)
0086 =                       df_currlin	ds	2		; Execution current line pointer
0088 =                       df_exeoff	ds	1		; Execution line buffer offset
0089 =                       df_nextlin	ds	2		; Next line to execute
008b =                       df_procmode	ds	1		; Only used during tokenisation
008c =                       df_procargs	ds	1		; Only used during tokenisation
008d =                       df_procloc	ds	1		; Counts the number of local par
008e =                       df_procptr	ds	2		; Pointer to proc vvt slot
0090 =                       df_lineptr	ds	2		; Pointer to line during searche
0092 =                       df_lineidx	ds	1		; Pointer to line index during s
0093 =                       df_ifnest	ds	1		; Global nested if counter
0094 =                       df_currdat	ds	2		; Data current line pointer
0096 =                       df_datoff	ds	1		; Data line buffer offset
0097 =                       df_rnd		ds	2		; Random number seed
                             
0099 =                       df_asmpc	ds	2		; Assembler program counter
009b =                       df_asmopt	ds	1		; Assembler current option
009c =                       df_asmadmd	ds	1		; Addressing mode
009d =                       df_asmopcde	ds	1		; Current opcode
009e =                       df_asmoprnd	ds	2		; Current operand
00a0 =                       df_asmlen	ds	1		; Instruction length
                             
00a1 =                       dflat_zp_save_e			; Save up to this place
                             
                             ; Temp space for dflat
00a1 =                       df_tmpptra	ds	2		; Temp pointer a
00a3 =                       df_tmpptrb	ds	2		; Temp pointer b
00a5 =                       df_tmpptrc	ds	2		; Temp pointer c
00a7 =                       df_tmpptrd	ds	2		; Temp pointer d
00a9 =                       df_tmpptre	ds	2		; Temp pointer e
                             
00ab =                       dflat_zp_e
                             
00ab =                       zp_tmp1		ds	1		; General zero page temporary
00ac =                       zp_tmp2		ds	1		; General zero page temporary
00ad =                       zp_tmp3		ds	1		; General zero page temporary
00ae =                       zp_tmp4		ds	1		; General zero page temporary
                             
                             ;***** END OF ZERO PAGE *****
00af =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 is tape buffer *****
0200 =                       	org 0x0200
0200 =                       tp_buf		ds	256		; Serial input / output line buff
                             
                             ;***** 3 is IO *****
0300 =                       	org 0x0300			; IO mapped to Page 3 on Oric
0300 =                       io_address	ds	256
                             
0400 =                       	org 0x0400			; Page 4 = dflat space
0400 =                       fd_getname_addr			; ** FOR ORICUTRON EMULATOR **
0400 =                       df_linbuff
0400 =                       df_raw		ds	128		; untokenised input line
AS65 Assembler for R6502 [1.42].                                     Page   41
-------------------------------- bank\bank0.s --------------------------------

0480 =                       df_tokbuff
0480 =                       df_tok		ds 	128		; tokenised output line
                             
0500 =                       	org 0x0500			; Page 5 = fixed space for interpre
0500 =                       df_rtstck				; operator stack grow up, runtime gr
0500 =                       df_rtspace	ds	256
                             
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Acticve IO device settings
0600 =                       io_default	ds	1		; The default device number
0601 =                       io_block	ds	io_struct
                             
                             
                             ; Dflat top of memory+1 - initialised at boot tim
0611 =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
0613 =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
0713 =                       mem_start
                             
                             
                             	include "dflat/dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
0713 =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
AS65 Assembler for R6502 [1.42].                                     Page   42
-------------------------------- bank\bank0.s --------------------------------

                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_ARRY	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
AS65 Assembler for R6502 [1.42].                                     Page   43
-------------------------------- bank\bank0.s --------------------------------

0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0001 =                       DFST_INT	=	0x01
0080 =                       DFST_STR	=	0x80
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "dflat/error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   44
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors are at these addresses
fffa : 21c5                  	fcw nmi				; 0xfffa : NMI Vector
fffc : d9c4                  	fcw init			; 0xfffc : Reset Vector
fffe : e6c0                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             
                             	; ROM code
                             	code				;
c000 =                       	org 0xc000			; Start of ROM
                             
c000 :                       _code_start
                             	; Restore current bank always at address c001 * 
c000 :                       mod_sz_kernel_s
                             	; include OS ROM calls - must be from 0xc000
                             	include "kernel/osromvec.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2021
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  OSROMVEC.I
                             ;*	This include file sets up the OS ROM vectors w
                             ;*	be invoked by user programs to access ROM func
                             ;*	will be maintained across versions of dflat to
                             ;*	backward and forward compatibility.
AS65 Assembler for R6502 [1.42].                                     Page   45
-------------------------------- bank\bank0.s --------------------------------

                             ;*	Make sure these vectors are set up from 0xc000
                             ;*	what user programs will rely on!
                             ;*
                             ;************************************************
                             	
                             	; Common OS ROM calls - user programs should JMP
                             	; through these routines where possible to maint
                             	; compatibility with ROM changes as these calls 
                             	; always be in the same position
c000 : 4c01cd           [ 3] _rom_vec_00	jmp	gr_init_screen_txt			; Go in to t
c003 : 4c97cd           [ 3] _rom_vec_01	jmp gr_cls						; Clear text screen
c006 : 4c04ce           [ 3] _rom_vec_02	jmp	gr_set_cur					; Set text cursor 
c009 : 4c1acd           [ 3] _rom_vec_03	jmp	gr_init_hires				; Go in to hires
c00c : 6c0106           [ 6] _rom_vec_04	jmp (io_block+io_get_byte)		; Get byt
c00f : 6c0306           [ 6] _rom_vec_05	jmp (io_block+io_put_byte)		; Put byt
c012 : 4c69c4           [ 3] _rom_vec_06 jmp io_read_line				; Read a line
c015 : 4ca2c4           [ 3] _rom_vec_07	jmp io_print_line				; Print a line
c018 : 4c6ec0           [ 3] _rom_vec_08	jmp snd_set						; Set sound register
c01b : 4c78c7           [ 3] _rom_vec_09	jmp kb_stick					; Get joystick statu
c01e : 4cebcd           [ 3] _rom_vec_0a	jmp gr_plot						; Plot a lores chara
c021 : 4caacf           [ 3] _rom_vec_0b	jmp	gr_hchar					; Plot a hires chara
c024 : 4c4cd0           [ 3] _rom_vec_0c	jmp gr_point_setup				; Get address, 
c027 : 4c6ad0           [ 3] _rom_vec_0d	jmp gr_point					; Plot a hires pixel
c02a : 4c81f4           [ 3] _rom_vec_0e	jmp df_rt_sprupd				; Refresh sprites
c02d : 4cdbcd           [ 3] _rom_vec_0f	jmp	gr_getXY_base				; Get row addres
c030 : 4c64d0           [ 3] _rom_vec_10	jmp gr_pixel					; Get a pixel value 
c033 : 4cfecd           [ 3] _rom_vec_11 jmp gr_get						; Get screen at coord
c036 : 4c2bc4           [ 3] _rom_vec_12 jmp io_active_device			; Set the acti
c039 : 6c0506           [ 6] _rom_vec_13	jmp (io_block+io_open_r)		; Open file
c03c : 6c0706           [ 6] _rom_vec_14	jmp (io_block+io_open_w)		; Open file
c03f : 6c0906           [ 6] _rom_vec_15	jmp (io_block+io_close_f)		; Close fi
c042 : 6c0b06           [ 6] _rom_vec_16	jmp (io_block+io_del_f)			; Delete fi
c045 : 6c0d06           [ 6] _rom_vec_17	jmp (io_block+io_ext1)			; Extended o
c048 : 6c0f06           [ 6] _rom_vec_18	jmp (io_block+io_ext2)			; Extended o
c04b : 4c17d4           [ 3] _rom_vec_19 jmp snd_get_note				; Get for an octa
                             
                             
                             ;* Include all core code in the right order
                             	include "kernel/snd-low.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*	Routines to access the AY-3-8912, which is don
                             ;*	lines of the VIA - CB2 and CA2 for chip select
                             ;*	Port A for data interface. This makes accessin
                             ;*	8912 a bit slow..
                             ;*
                             ;* 	CB2		CA2		Function		CB2=BDIR, CA2=BC1
                             ;*	0		0		Not selected
                             ;*	0		1		Read register in to Port A
                             ;*	1		0		Write register from Port A
                             ;*	1		1		Select register # from Port A
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_sel_reg
AS65 Assembler for R6502 [1.42].                                     Page   46
-------------------------------- bank\bank0.s --------------------------------

                             ;* Select AY register from A
                             ;* Input : A = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c04e :                       snd_sel_reg
c04e : 48               [ 3] 	pha
c04f : 8d0f03           [ 4] 	sta SND_ADBUS			; Put reg # on Port A (sound bus
                             
c052 : a9ff             [ 2] 	lda #SND_SELSETADDR		; Get ready to select the r
c054 : 8d0c03           [ 4] 	sta SND_MODE			; Latch the reg # on Port A
                             
c057 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c059 : 8d0c03           [ 4] 	sta SND_MODE
                             
c05c : 68               [ 4] 	pla
c05d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_set_reg
                             ;* Set previosuly selected AY register
                             ;* Input : A = Value to set
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c05e :                       snd_set_reg
c05e : 48               [ 3] 	pha
                             
c05f : 8d0f03           [ 4] 	sta SND_ADBUS			; Put reg value on Port A (sound
c062 : a9fd             [ 2] 	lda #SND_SELWRITE		; Select mode for writing dat
c064 : 8d0c03           [ 4] 	sta SND_MODE			; Latch reg value on Port A	
c067 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c069 : 8d0c03           [ 4] 	sta SND_MODE
                             
c06c : 68               [ 4] 	pla
c06d : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* snd_set
                             ;* Set reg X to value A
                             ;* Input : X=Reg, A = Value to set
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c06e :                       snd_set
c06e : 48               [ 3] 	pha
c06f : 8a               [ 2] 	txa
c070 : 204ec0           [ 6] 	jsr snd_sel_reg
c073 : 68               [ 4] 	pla
c074 : 4c5ec0           [ 3] 	jmp snd_set_reg
                             
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X value
                             ;* Input : X = Reg no
                             ;* Output : A = Value
                             ;* Regs affected : None
                             ;****************************************
                             ;snd_get
                             ;
                             ;	lda #0xff				; Set Port A to output
AS65 Assembler for R6502 [1.42].                                     Page   47
-------------------------------- bank\bank0.s --------------------------------

                             ;	sta IO_0+DDRA
                             ;
                             ;	stx SND_ADBUS			; Put X on the sound bus (X = r
                             ;
                             ;	lda #SND_SELSETADDR		; Get ready to select the 
                             ;	sta SND_MODE			; Latch the reg # on Port A
                             ;
                             ;	lda #SND_DESELECT		; Deselect AY
                             ;	sta SND_MODE
                             ;
                             ;	lda #0x00				; Set Port A to input
                             ;	sta IO_0+DDRA
                             ;
                             ;	lda #SND_SELREAD		; Select mode for reading dat
                             ;	sta SND_MODE			; Set read mode on AY
                             ;
                             ;	lda SND_ADBUS			; Get value in to Y from Port A
                             ;	pha						; Save it to stack
                             ;	
                             ;	lda #SND_DESELECT		; Deselect AY
                             ;	sta SND_MODE
                             ;
                             ;	lda #0xff				; Set Port A back to output
                             ;	sta IO_0+DDRA
                             ;
                             ;	pla						; Get the value off stack
                             ;	
                             ;	rts
                             
                             
                             	include "kernel/main.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c077 :                       main
c077 : a281             [ 2] 	ldx #lo(msg_hello_world)
c079 : a9c0             [ 2] 	lda #hi(msg_hello_world)
c07b : 20a2c4           [ 6] 	jsr io_print_line
                             
c07e :                       infinity
c07e : 4c5adf           [ 3] 	jmp df_pg_dflat
                             
c081 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
AS65 Assembler for R6502 [1.42].                                     Page   48
-------------------------------- bank\bank0.s --------------------------------

                             	include "kernel/build.s"
c081 : 4f726963206466..       db "Oric dflat custom ROM\r" 
c097 : 42792040363530..       db "By @6502Nerd\r" 
c0a4 : 4275696c64203a..       db "Build : 0.16 [BETA]\r" 
c0b8 : 436f7079726967..       db "Copyright (c) 2023\r\r",0 
                             
                             
                             	include "kernel/irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler
                             ;*	There is only one regular interrupt source whi
                             ;*	T1 timeout on a 50Hz cycle, whose main job is 
                             ;*	flash the cursor and decrement some timers.
                             ;*	But there are handlers for BRK, user and VIA s
                             ;*	By default the user and VIA do nothing, but ca
                             ;*	redirected to user routines.
                             ;*
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c0cd :                       init_irq
                             	; Core IRQ handler
c0cd : a9f1             [ 2] 	lda #lo(irq)
c0cf : 8502             [ 3] 	sta vec_irq
c0d1 : a9c0             [ 2] 	lda #hi(irq)
c0d3 : 8503             [ 3] 	sta vec_irq+1
                             	
                             	; Core BRK handler
c0d5 : a913             [ 2] 	lda #lo(irq_brk)
c0d7 : 8504             [ 3] 	sta vec_brk
c0d9 : a9c1             [ 2] 	lda #hi(irq_brk)
c0db : 8505             [ 3] 	sta vec_brk+1
                             
                             	; User handlers VIA0 interrupts
c0dd : a9f0             [ 2] 	lda #lo(null_handler)
c0df : 8506             [ 3] 	sta vec_usercia0
c0e1 : a9c0             [ 2] 	lda #hi(null_handler)
c0e3 : 8507             [ 3] 	sta vec_usercia0+1
                             
c0e5 : 60               [ 6] 	rts
                             
                             
                             ;* Calls the master IRQ handler - from the ROM
c0e6 :                       call_irq_master
c0e6 : 6c0200           [ 6] 	jmp (vec_irq)
                             	
                             ;* Calls the BRK handler
c0e9 :                       call_irq_brk
c0e9 : 6c0400           [ 6] 	jmp (vec_brk)
                             
                             ;* Call the user CIA0 handler
c0ec :                       call_irq_usercia0
AS65 Assembler for R6502 [1.42].                                     Page   49
-------------------------------- bank\bank0.s --------------------------------

c0ec : 6c0600           [ 6] 	jmp (vec_usercia0)
                             
                             ;* null interrupt
c0ef :                       null_irq
c0ef : 40               [ 6] 	rti
                             
                             ;* null handler
c0f0 :                       null_handler
c0f0 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c0f1 :                       irq
                             	; Don't use _pushAXY as it uses a temp location!
c0f1 : 48               [ 3] 	pha
c0f2 : 8a               [ 2] 	txa
c0f3 : 48               [ 3] 	pha
c0f4 : 98               [ 2] 	tya
c0f5 : 48               [ 3] 	pha
                             
c0f6 : d8               [ 2] 	cld						; Just in case!
c0f7 : 18               [ 2] 	clc						; Standard behaviour
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c0f8 : ba               [ 2] 	tsx
c0f9 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c0fc : 2910             [ 2] 	and #0x10
c0fe : d0e9             [ 3] 	bne call_irq_brk
                             	
                             	;* Primary interrupt is timer 1
c100 : ad0d03           [ 4] 	lda IO_0 + IFR
c103 : 2940             [ 2] 	and #0x40				; Bit 6 = Timer 1 interrupt
c105 : f006             [ 3] 	beq irq_fin				; If nothing then end
                             
                             	; Service the timer 1 interrupt
c107 : 8d0d03           [ 4] 	sta IO_0 + IFR			; Clear the interrupt
c10a : 2040c1           [ 6] 	jsr int_vdp_handler
                             
c10d :                       irq_fin
                             	_pullAXY
                             
c112 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c113 :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c113 : 38               [ 2] 	sec
c114 : bd0501           [ 4] 	lda 0x0105,x
c117 : e902             [ 2] 	sbc #2
c119 : 8562             [ 3] 	sta df_brkpc
c11b : bd0601           [ 4] 	lda 0x0106,x
c11e : e900             [ 2] 	sbc #0
c120 : 8563             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c122 : a001             [ 2] 	ldy #1
c124 : b162             [ 5] 	lda (df_brkpc),y
c126 : 8564             [ 3] 	sta df_brkval
c128 : 855d             [ 3] 	sta errno
AS65 Assembler for R6502 [1.42].                                     Page   50
-------------------------------- bank\bank0.s --------------------------------

                             	; now update the return address
c12a : a560             [ 3] 	lda df_pc
c12c : 9d0501           [ 5] 	sta 0x105,x
c12f : a561             [ 3] 	lda df_pc+1
c131 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c139 : 853d             [ 3] 	sta num_a
c13b : 863e             [ 3] 	stx num_a+1
c13d : 843f             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c13f : 40               [ 6] 	rti
                             	
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c140 :                       int_vdp_handler
c140 : 205cc1           [ 6] 	jsr update_timers	; If it is then update system 
c143 : a50d             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c145 : d014             [ 3] 	bne int_vdp_fin		; Skip if disabled
                             
c147 : c60c             [ 5] 	dec vdp_curcnt		; Decrement countdown
c149 : d010             [ 3] 	bne int_vdp_fin		; If not expired, do nothing
c14b : a50b             [ 3] 	lda vdp_curtim		; Reset cursor countdown
c14d : 850c             [ 3] 	sta vdp_curcnt
c14f : a50e             [ 3] 	lda vdp_curstat		; Get the flash status
c151 : 4980             [ 2] 	eor #0x80			; Invert top bit
c153 : 850e             [ 3] 	sta vdp_curstat
c155 : 450f             [ 3] 	eor vdp_curval		; EOR with whats under cursor
                             	; Use cursor address, write to screen
                             	; ptr is base, offset with X coord in Y register
c157 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
c159 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
c15b :                       int_vdp_fin	
c15b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c15c :                       update_timers
c15c : e608             [ 5] 	inc vdp_cnt
c15e : d006             [ 3] 	bne inc_kb_timers
c160 : e609             [ 5] 	inc vdp_cnt_hi
c162 : d002             [ 3] 	bne inc_kb_timers
c164 : e60a             [ 5] 	inc vdp_cnt_hi2
c166 :                       inc_kb_timers
c166 : a62d             [ 3] 	ldx kb_deb			; Is debounce 0?
c168 : f002             [ 3] 	beq skip_kb_deb
c16a : c62d             [ 5] 	dec kb_deb
c16c :                       skip_kb_deb
c16c : a62f             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c16e : f002             [ 3] 	beq skip_kb_rep
c170 : c62f             [ 5] 	dec kb_rep
AS65 Assembler for R6502 [1.42].                                     Page   51
-------------------------------- bank\bank0.s --------------------------------

c172 :                       skip_kb_rep
c172 : 60               [ 6] 	rts
                             	
                             
                             	include "utils/utils.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c173 :                       utilPrintSPC
c173 : 48               [ 3] 	pha
c174 : a920             [ 2] 	lda #' '
c176 : 2054c4           [ 6] 	jsr io_put_ch
c179 : 68               [ 4] 	pla
c17a : 60               [ 6] 	rts
                             
c17b :                       utilPrintCRLF
c17b : 48               [ 3] 	pha
c17c : a90d             [ 2] 	lda #UTF_CR
c17e : 2054c4           [ 6] 	jsr io_put_ch
c181 : 68               [ 4] 	pla
c182 : 60               [ 6] 	rts
                             
c183 :                       utilPrintA
c183 : 8538             [ 3] 	sta tmp_d
c185 : 48               [ 3] 	pha
c186 : 8a               [ 2] 	txa
c187 : 48               [ 3] 	pha
c188 : a538             [ 3] 	lda tmp_d
c18a : 2098c1           [ 6] 	jsr str_a_to_x
c18d : 2054c4           [ 6] 	jsr io_put_ch
c190 : 8a               [ 2] 	txa
c191 : 2054c4           [ 6] 	jsr io_put_ch
c194 : 68               [ 4] 	pla
c195 : aa               [ 2] 	tax
c196 : 68               [ 4] 	pla
c197 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c198 :                       str_a_to_x
AS65 Assembler for R6502 [1.42].                                     Page   52
-------------------------------- bank\bank0.s --------------------------------

c198 : 48               [ 3] 	pha					; Save the byte using later on
c199 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c19b : 18               [ 2] 	clc
c19c : 6930             [ 2] 	adc #'0'			; Convert to UTF
c19e : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c1a0 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c1a2 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c1a4 :                       skip_a_f_1
c1a4 : aa               [ 2] 	tax					; Low char is in X
c1a5 : 68               [ 4] 	pla					; Get byte back
c1a6 : 4a               [ 2] 	lsr a				; Make high nibble low
c1a7 : 4a               [ 2] 	lsr a
c1a8 : 4a               [ 2] 	lsr a
c1a9 : 4a               [ 2] 	lsr a
c1aa : 18               [ 2] 	clc
c1ab : 6930             [ 2] 	adc #'0'			; Convert to UTF
c1ad : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c1af : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c1b1 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c1b3 :                       skip_a_f_2
c1b3 : 60               [ 6] 	rts					; A high nibble, C=0
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c1b4 :                       str_x_to_a
c1b4 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1b6 : 38               [ 2] 	sec					; Process high char in A
c1b7 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1b9 : c90a             [ 2] 	cmp #10				; If A < 10 then
c1bb : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c1bd : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1bf :                       skip_x_f_1
c1bf : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c1c1 : b01c             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c1c3 : 0a               [ 2] 	asl a				; This is the high nibble
c1c4 : 0a               [ 2] 	asl a
c1c5 : 0a               [ 2] 	asl a
c1c6 : 0a               [ 2] 	asl a
c1c7 : 48               [ 3] 	pha					; Save the high nibble
c1c8 : 8a               [ 2] 	txa					; Now process the low char in X
c1c9 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1cb : 38               [ 2] 	sec
c1cc : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1ce : c90a             [ 2] 	cmp #10				; If A < 10 then
c1d0 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c1d2 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1d4 :                       skip_x_f_2
c1d4 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c1d6 : b006             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c1d8 : 853d             [ 3] 	sta num_a			; Store low nibble in temp
c1da : 68               [ 4] 	pla					; Get high nibble
c1db : 053d             [ 3] 	ora num_a			; OR with low nibble
                             
c1dd : 60               [ 6] 	rts					; A contains value, C=0
                             
AS65 Assembler for R6502 [1.42].                                     Page   53
-------------------------------- bank\bank0.s --------------------------------

c1de :                       str_x_to_a_errl
c1de : 68               [ 4] 	pla
c1df :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c1e1 :                       con_n_to_a
c1e1 : 8649             [ 3] 	stx num_tmp
c1e3 : 854a             [ 3] 	sta num_tmp+1
c1e5 : a900             [ 2] 	lda #0
c1e7 : 853d             [ 3] 	sta num_a
c1e9 : 853e             [ 3] 	sta num_a+1
c1eb : c000             [ 2] 	cpy #NUM_ANY
c1ed : f014             [ 4] 	beq con_n_to_a_detect
c1ef : 88               [ 2] 	dey
c1f0 : d003             [ 3] 	bne con_n_not_dec
c1f2 :                       con_dec_jmp
c1f2 : 4c86c2           [ 3] 	jmp con_dec_to_a_int
c1f5 :                       con_n_not_dec
c1f5 : 88               [ 2] 	dey
c1f6 : d003             [ 3] 	bne con_n_not_hex
c1f8 :                       con_hex_jmp
c1f8 : 4c1dc2           [ 3] 	jmp con_hex_to_a_int
c1fb :                       con_n_not_hex
c1fb : 88               [ 2] 	dey
c1fc : d003             [ 4] 	bne con_n_err
c1fe :                       con_bin_jmp
c1fe : 4c5cc2           [ 3] 	jmp con_bin_to_a_int
c201 :                       con_n_err
c201 : 38               [ 2] 	sec
c202 : 60               [ 6] 	rts
c203 :                       con_n_to_a_detect		; Y is zero on entry
c203 : b149             [ 5] 	lda (num_tmp),y
c205 : c930             [ 2] 	cmp #'0'
c207 : d0e9             [ 4] 	bne con_dec_jmp
c209 : a001             [ 2] 	ldy #1
c20b : b149             [ 5] 	lda (num_tmp),y
c20d : 0920             [ 2] 	ora #0x20
c20f : c978             [ 2] 	cmp #'x'
c211 : f0e5             [ 4] 	beq con_hex_jmp
c213 : c962             [ 2] 	cmp #'b'
c215 : f0e7             [ 4] 	beq con_bin_jmp
c217 : d0d9             [ 4] 	bne con_dec_jmp		; Always branches
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c219 :                       con_hex_to_a
c219 : 8649             [ 3] 	stx num_tmp
c21b : 854a             [ 3] 	sta num_tmp+1
AS65 Assembler for R6502 [1.42].                                     Page   54
-------------------------------- bank\bank0.s --------------------------------

c21d :                       con_hex_to_a_int
c21d : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c21f : a002             [ 2] 	ldy #2			; start at first digit
c221 :                       con_hex_digit
c221 : b149             [ 5] 	lda (num_tmp),y
c223 : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c225 : 38               [ 2] 	sec							; Process high char in A
c226 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c228 : c90a             [ 2] 	cmp #10						; If A < 10 then
c22a : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c22c : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c22e :                       con_hex_skip_x_f_1
c22e : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c230 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c232 : 48               [ 3] 	pha
c233 : a53d             [ 3] 	lda num_a
                             	; make room for lo nibble
c235 : 0a               [ 2] 	asl a
c236 : 263e             [ 5] 	rol num_a+1
c238 : 0a               [ 2] 	asl a
c239 : 263e             [ 5] 	rol num_a+1
c23b : 0a               [ 2] 	asl a
c23c : 263e             [ 5] 	rol num_a+1
c23e : 0a               [ 2] 	asl a
c23f : 263e             [ 5] 	rol num_a+1
c241 : 853d             [ 3] 	sta num_a
                             	; save in low nibble
c243 : 68               [ 4] 	pla
c244 : 053d             [ 3] 	ora num_a
c246 : 853d             [ 3] 	sta num_a
c248 : c8               [ 2] 	iny
c249 : ca               [ 2] 	dex
c24a : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c24c :                       con_hex_err
c24c : 38               [ 2] 	sec
c24d : 60               [ 6] 	rts
                             	; found a non-hex digit
c24e :                       con_hex_done
                             	; if no digits processed then error
c24e : c002             [ 2] 	cpy #2
c250 : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c252 : 98               [ 2] 	tya
c253 : aa               [ 2] 	tax
c254 : a902             [ 2] 	lda #NUM_HEX
c256 : 18               [ 2] 	clc
c257 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert bin string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c258 :                       con_bin_to_a
c258 : 8649             [ 3] 	stx num_tmp
c25a : 854a             [ 3] 	sta num_tmp+1
c25c :                       con_bin_to_a_int
c25c : a002             [ 2] 	ldy #2
c25e : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
AS65 Assembler for R6502 [1.42].                                     Page   55
-------------------------------- bank\bank0.s --------------------------------

c260 :                       con_bin_digit
c260 : b149             [ 5] 	lda (num_tmp),y
c262 : c930             [ 2] 	cmp #'0'
c264 : 9010             [ 3] 	bcc con_bin_done
c266 : c932             [ 2] 	cmp #'1'+1
c268 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c26a : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c26c : 263d             [ 5] 	rol num_a
c26e : 263e             [ 5] 	rol num_a+1
c270 : c8               [ 2] 	iny
c271 : ca               [ 2] 	dex
c272 : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c274 : f00a             [ 3] 	beq con_bin_err
c276 :                       con_bin_done
                             	; didn't process any digit = error
c276 : c002             [ 2] 	cpy #2
c278 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c27a : 98               [ 2] 	tya
c27b : aa               [ 2] 	tax
c27c : a903             [ 2] 	lda #NUM_BIN
c27e : 18               [ 2] 	clc
c27f : 60               [ 6] 	rts
c280 :                       con_bin_err
c280 :                       str_d_error
c280 : 38               [ 2] 	sec
c281 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c282 :                       con_dec_to_a
c282 : 8649             [ 3] 	stx num_tmp
c284 : 854a             [ 3] 	sta num_tmp+1
c286 :                       con_dec_to_a_int
c286 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c288 : b149             [ 5] 	lda (num_tmp),y
c28a : c92d             [ 2] 	cmp #'-'
c28c : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c28e : c8               [ 2] 	iny
c28f :                       str_d_find_end
c28f : b149             [ 5] 	lda (num_tmp),y
c291 : c930             [ 2] 	cmp #'0'
c293 : 9007             [ 3] 	bcc str_d_found_end
c295 : c93a             [ 2] 	cmp #'9'+1
c297 : b003             [ 3] 	bcs str_d_found_end
c299 : c8               [ 2] 	iny
c29a : d0f3             [ 3] 	bne str_d_find_end	; Possble wraparound but shou
c29c :                       str_d_found_end
c29c : c007             [ 2] 	cpy #7				; Biggest int is 6 chars
c29e : b0e0             [ 3] 	bcs str_d_error		; e.g. -32767
c2a0 : 844c             [ 3] 	sty num_tmp+3
c2a2 : a900             [ 2] 	lda #0
AS65 Assembler for R6502 [1.42].                                     Page   56
-------------------------------- bank\bank0.s --------------------------------

c2a4 : 854b             [ 3] 	sta num_tmp+2
c2a6 : 853d             [ 3] 	sta num_a
c2a8 : 853e             [ 3] 	sta num_a+1
c2aa :                       str_d_process_digit
c2aa : 88               [ 2] 	dey
c2ab : 3027             [ 3] 	bmi str_d_digits_done
                             
c2ad : b149             [ 5] 	lda (num_tmp),y
                             
c2af : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c2b1 : f021             [ 3] 	beq str_d_digits_done ; also done
                             
c2b3 : 38               [ 2] 	sec
c2b4 : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c2b6 : 18               [ 2] 	clc
c2b7 : 0a               [ 2] 	asl a
c2b8 : 654b             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c2ba : aa               [ 2] 	tax
c2bb : a53d             [ 3] 	lda num_a
c2bd : 7df1c2           [ 4] 	adc str_d_powers,x
c2c0 : 853d             [ 3] 	sta num_a
c2c2 : a53e             [ 3] 	lda num_a+1
c2c4 : 7df2c2           [ 4] 	adc str_d_powers+1,x
c2c7 : 853e             [ 3] 	sta num_a+1
c2c9 : b0b5             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c2cb : a54b             [ 3] 	lda num_tmp+2
c2cd : 6914             [ 2] 	adc #20
c2cf : 854b             [ 3] 	sta num_tmp+2
c2d1 : 4caac2           [ 3] 	jmp str_d_process_digit
c2d4 :                       str_d_digits_done
                             	; check if minus
c2d4 : b149             [ 5] 	lda (num_tmp),y
c2d6 : c92d             [ 2] 	cmp #'-'
c2d8 : d011             [ 3] 	bne str_d_skip_neg
c2da : a64c             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c2dc : e002             [ 2] 	cpx #2				; else it's an error
c2de : 90a0             [ 3] 	bcc str_d_error
c2e0 : a63d             [ 3] 	ldx num_a
c2e2 : a53e             [ 3] 	lda num_a+1
c2e4 : 2055c3           [ 6] 	jsr twos_complement
c2e7 : 863d             [ 3] 	stx num_a
c2e9 : 853e             [ 3] 	sta num_a+1
c2eb :                       str_d_skip_neg
c2eb : a64c             [ 3] 	ldx num_tmp+3
c2ed : a901             [ 2] 	lda #NUM_DEC
c2ef : 18               [ 2] 	clc
c2f0 : 60               [ 6] 	rts
                             
c2f1 :                       str_d_powers
c2f1 : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c305 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c319 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c32d : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c341 : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   57
-------------------------------- bank\bank0.s --------------------------------

                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c355 :                       twos_complement
c355 : 49ff             [ 2] 	eor #0xff
c357 : 48               [ 3] 	pha
c358 : 8a               [ 2] 	txa
c359 : 49ff             [ 2] 	eor #0xff
c35b : aa               [ 2] 	tax
c35c : 68               [ 4] 	pla
c35d : e8               [ 2] 	inx
c35e : d003             [ 3] 	bne twos_complement_skip_X
c360 : 38               [ 2] 	sec			; Add 1 to A
c361 : 6900             [ 2] 	adc #0
c363 :                       twos_complement_skip_X
c363 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c364 :                       hex_to_bcd
c364 : 08               [ 3] 	php
c365 : 48               [ 3] 	pha
c366 : 8538             [ 3] 	sta tmp_d
c368 : 8a               [ 2] 	txa
c369 : 48               [ 3] 	pha
c36a : a538             [ 3] 	lda tmp_d
                             
c36c : 8649             [ 3] 	stx num_tmp
c36e : 854a             [ 3] 	sta num_tmp+1
                             	
c370 : 3003             [ 3] 	bmi hex_to_bcd_skip_neg	; A is negative?
c372 : 2055c3           [ 6] 	jsr twos_complement
c375 :                       hex_to_bcd_skip_neg
c375 : a200             [ 2] 	ldx #0
c377 : 863d             [ 3] 	stx num_a
c379 : 863e             [ 3] 	stx num_a+1
c37b : 863f             [ 3] 	stx num_a+2
c37d : 8640             [ 3] 	stx num_a+3
c37f : a210             [ 2] 	ldx #16
c381 : f8               [ 2] 	sed
c382 :                       bin_to_bcd_bit
c382 : 0649             [ 5] 	asl num_tmp
c384 : 264a             [ 5] 	rol num_tmp+1
c386 : a53d             [ 3] 	lda num_a
c388 : 653d             [ 3] 	adc num_a
c38a : 853d             [ 3] 	sta num_a
c38c : a53e             [ 3] 	lda num_a+1
c38e : 653e             [ 3] 	adc num_a+1
c390 : 853e             [ 3] 	sta num_a+1
c392 : a53f             [ 3] 	lda num_a+2
c394 : 653f             [ 3] 	adc num_a+2
c396 : 853f             [ 3] 	sta num_a+2
c398 : ca               [ 2] 	dex
AS65 Assembler for R6502 [1.42].                                     Page   58
-------------------------------- bank\bank0.s --------------------------------

c399 : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c39b : 68               [ 4] 	pla
c39c : aa               [ 2] 	tax
c39d : 68               [ 4] 	pla
c39e : 28               [ 4] 	plp
c39f : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c3a0 :                       bcd_to_str
                             	_pushAXY
                             
                             
c3a9 : a205             [ 2] 	ldx #5						; Index in to string
c3ab : a000             [ 2] 	ldy #0						; Current BCD digit
c3ad :                       bcd_str
c3ad : b93d00           [ 4] 	lda num_a,y
                             	; Convert 1s digit of byte
c3b0 : 48               [ 3] 	pha
c3b1 : 290f             [ 2] 	and #0xf
c3b3 : 18               [ 2] 	clc
c3b4 : 6930             [ 2] 	adc #0x30
c3b6 : 954d             [ 4] 	sta num_buf,x
                             	; Convert 10s digit of byte
c3b8 : 68               [ 4] 	pla
c3b9 : 4a               [ 2] 	lsr a
c3ba : 4a               [ 2] 	lsr a
c3bb : 4a               [ 2] 	lsr a
c3bc : 4a               [ 2] 	lsr a
c3bd : 18               [ 2] 	clc
c3be : 6930             [ 2] 	adc #0x30					; Convert to ASCII
c3c0 : 954c             [ 4] 	sta num_buf-1,x
c3c2 : ca               [ 2] 	dex
c3c3 : ca               [ 2] 	dex
c3c4 : c8               [ 2] 	iny
c3c5 : c003             [ 2] 	cpy #3						; 3 BCD digits max
c3c7 : d0e4             [ 3] 	bne bcd_str
                             
                             	_pullAXY
                             
c3ce : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
c3cf :                       out_bcd
c3cf : 48               [ 3] 	pha
c3d0 : 8a               [ 2] 	txa
c3d1 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page   59
-------------------------------- bank\bank0.s --------------------------------

c3d2 : 08               [ 3] 	php
c3d3 : a000             [ 2] 	ldy #0						; How many digits printed
c3d5 : a200             [ 2] 	ldx #0						; Index in to string
c3d7 :                       out_bcd_digit
c3d7 : b54d             [ 4] 	lda num_buf,x
c3d9 : c000             [ 2] 	cpy #0						; If not in leading zero mode
c3db : d008             [ 3] 	bne out_bcd_print			; No then go print
                             
c3dd : c930             [ 2] 	cmp #'0'					; else check if zero
c3df : d004             [ 3] 	bne out_bcd_print			; No then go print
                             
c3e1 : 28               [ 4] 	plp
c3e2 : 08               [ 3] 	php
c3e3 : 9004             [ 3] 	bcc out_bcd_next			; If C=0 go to next digit, el
c3e5 :                       out_bcd_print
c3e5 : c8               [ 2] 	iny
c3e6 : 2054c4           [ 6] 	jsr io_put_ch
c3e9 :                       out_bcd_next
c3e9 : e8               [ 2] 	inx
c3ea : e006             [ 2] 	cpx #6
c3ec : d0e9             [ 3] 	bne out_bcd_digit
c3ee : 98               [ 2] 	tya							; If nothing printed
c3ef : d006             [ 3] 	bne out_bcd_fin
c3f1 : a930             [ 2] 	lda #'0'					; Need to put out 1 zero
c3f3 : 2054c4           [ 6] 	jsr io_put_ch
c3f6 : c8               [ 2] 	iny
c3f7 :                       out_bcd_fin
c3f7 : 28               [ 4] 	plp
c3f8 : 68               [ 4] 	pla
c3f9 : aa               [ 2] 	tax
c3fa : 68               [ 4] 	pla
c3fb : 18               [ 2] 	clc
c3fc : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c3fd :                       print_a_to_d
c3fd : 08               [ 3] 	php
c3fe : c980             [ 2] 	cmp #0x80					; Check if sign bit is set
c400 : 9014             [ 3] 	bcc print_a_to_d_skip_neg	; Skip if not (postive
c402 : 2055c3           [ 6] 	jsr twos_complement			; Flip from 2s complement
c405 : 2064c3           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c408 : 20a0c3           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c40b : a92d             [ 2] 	lda #'-'
c40d : 2054c4           [ 6] 	jsr io_put_ch
c410 : 28               [ 4] 	plp							; Leading zeros preference
c411 : 20cfc3           [ 6] 	jsr out_bcd
c414 : c8               [ 2] 	iny							; Account for sign
c415 : 60               [ 6] 	rts
c416 :                       print_a_to_d_skip_neg
c416 : 2064c3           [ 6] 	jsr hex_to_bcd				; Convert to BCD
c419 : 20a0c3           [ 6] 	jsr bcd_to_str				; Convert BCD to string
c41c : 28               [ 4] 	plp							; Leading zeros preference
AS65 Assembler for R6502 [1.42].                                     Page   60
-------------------------------- bank\bank0.s --------------------------------

c41d : 4ccfc3           [ 3] 	jmp out_bcd					; Print +ve string
                             	
                             	include "io/io.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.
                             ;*	On startup, the kernel defaults to keyboard an
                             ;*  examines the BBC DIP switch to decide whether
                             ;*	but when saving and loading points to tape rou
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c420 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c420 :                       io_init
c420 : a901             [ 2] 	lda #1				; Default = KB/VDP
c422 : 8d0006           [ 4] 	sta io_default
c425 : 4c2bc4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c428 :                       io_set_default			; Entry point for default
c428 : ad0006           [ 4] 	lda io_default
c42b :                       io_active_device		; Entry point for A set
c42b : aa               [ 2] 	tax					; X=buf size index
c42c : 0a               [ 2] 	asl	a				; x16 the Block number
c42d : 0a               [ 2] 	asl a
c42e : 0a               [ 2] 	asl a
c42f : 0a               [ 2] 	asl a
c430 : a8               [ 2] 	tay					; Y=index in to device table
c431 : bdb7c4           [ 4] 	lda io_buf_sz,x
c434 : 853b             [ 3] 	sta buf_sz
AS65 Assembler for R6502 [1.42].                                     Page   61
-------------------------------- bank\bank0.s --------------------------------

c436 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c438 :                       io_copy_data
c438 : b9b9c4           [ 4] 	lda io_devices,y
c43b : 9d0106           [ 5] 	sta io_block,x
c43e : c8               [ 2] 	iny
c43f : e8               [ 2] 	inx
c440 : e010             [ 2] 	cpx #16
c442 : d0f4             [ 3] 	bne io_copy_data
                             	
c444 : a913             [ 2] 	lda #lo(scratch)	; Initialise IO buffer and size
c446 : 8539             [ 3] 	sta buf_lo
c448 : a906             [ 2] 	lda #hi(scratch)
c44a : 853a             [ 3] 	sta buf_hi
c44c : a90d             [ 2] 	lda #UTF_CR			; Line terminator is CR
c44e : 853c             [ 3] 	sta buf_ef
c450 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 1 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c451 :                       io_get_ch
c451 : 6c0106           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c454 :                       io_put_ch
c454 : 6c0306           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c457 :                       io_open_read
c457 : 6c0506           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c45a :                       io_open_write
c45a : 6c0706           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
AS65 Assembler for R6502 [1.42].                                     Page   62
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c45d :                       io_close
c45d : 6c0906           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c460 :                       io_delete
c460 : 6c0b06           [ 6] 	jmp (io_block+io_del_f)
                             
                             ;****************************************
                             ;* io_open_ext1
                             ;* Extended function 1
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c463 :                       io_open_ext1
c463 : 6c0d06           [ 6] 	jmp (io_block+io_ext1)
                             	
                             ;****************************************
                             ;* io_open_ext2
                             ;* Extended function 2
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c466 :                       io_open_ext2
c466 : 6c0f06           [ 6] 	jmp (io_block+io_ext2)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c469 :                       io_read_line
c469 : 48               [ 3] 	pha
                             
c46a : 08               [ 3] 	php					; Save echo state
                             	
c46b : a000             [ 2] 	ldy #0x00			; Starting at first byte
c46d :                       io_get_line_byte
c46d : 38               [ 2] 	sec					; Getting bytes synchronously
c46e : 2051c4           [ 6] 	jsr io_get_ch		; Get a byte
c471 : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c473 : 28               [ 4] 	plp					; Get echo state
c474 : 08               [ 3] 	php					; Instantly save it back
c475 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c477 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c479 : d005             [ 3] 	bne io_do_echo
c47b : c000             [ 2] 	cpy #0				; Already at beginning?
c47d : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c47f : 88               [ 2] 	dey					; Else decrement length
c480 :                       io_do_echo
AS65 Assembler for R6502 [1.42].                                     Page   63
-------------------------------- bank\bank0.s --------------------------------

c480 : 2054c4           [ 6] 	jsr io_put_ch		; Echo it
c483 :                       io_skip_echo
c483 : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c485 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c487 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c489 : f003             [ 3] 	beq io_skip_special
c48b : 9139             [ 5] 	sta (buf_lo),y		; Save it
c48d : c8               [ 2] 	iny					; Increase length
c48e :                       io_skip_special
c48e : c53c             [ 3] 	cmp buf_ef			; Is it the terminating char?
c490 : f008             [ 3] 	beq io_get_line_done	; If yes then done
c492 : c43b             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c494 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c496 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c497 : 38               [ 2] 	sec					; Yes, set carry flag
c498 : 68               [ 4] 	pla
c499 : 60               [ 6] 	rts					; And done
c49a :                       io_get_line_done
c49a : a900             [ 2] 	lda #0
c49c : 9139             [ 5] 	sta (buf_lo),y		; Terminate with 0
c49e : 28               [ 4] 	plp					; Remember to pull echo state off stack
c49f : 18               [ 2] 	clc					; Clear carry flag
c4a0 : 68               [ 4] 	pla
c4a1 : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c4a2 :                       io_print_line
c4a2 : 48               [ 3] 	pha
                             
c4a3 : 8636             [ 3] 	stx tmp_clo					; Store the string pointer
c4a5 : 8537             [ 3] 	sta tmp_chi					; lo and hi
c4a7 : a000             [ 2] 	ldy #0						; Start at the beginning!
c4a9 :                       io_print_line_byte
c4a9 : b136             [ 5] 	lda (tmp_clo),y				; Copy byte to
c4ab : f006             [ 3] 	beq io_print_done			; If zero then done - print
c4ad : 2054c4           [ 6] 	jsr io_put_ch				; Transmit
c4b0 : c8               [ 2] 	iny
c4b1 : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c4b3 :                       io_print_done
c4b3 : 68               [ 4] 	pla
c4b4 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c4b5 :                       io_null_op
c4b5 : 18               [ 2] 	clc
c4b6 : 60               [ 6] 	rts
                             	
                             ;* IO buffer sizes
c4b7 :                       io_buf_sz
c4b7 : ff                    	db 255					; Device 0 = Tape
c4b8 : 7f                    	db 127					; Device 1 = keyboard/screen
                             
                             ;* IO devices defined here
c4b9 :                       io_devices
                             ;* Device zero is the tape system
AS65 Assembler for R6502 [1.42].                                     Page   64
-------------------------------- bank\bank0.s --------------------------------

                             ;* only offers get and put
                             ;* This is a block based device
c4b9 :                       io_device0					; Tape device, input = Tape, outpu
c4b9 : fcc6                  	dw	tp_get_byte			; io_get_ch
c4bb : 23c6                  	dw	tp_put_byte			; io_put_ch
c4bd : 8cc5                  	dw	tp_open_read		; io_open_r
c4bf : ddc5                  	dw	tp_open_write		; io_open_w
c4c1 : bfc5                  	dw	tp_close			; io_close_f
c4c3 : b5c4                  	dw	io_null_op			; io_del_f
c4c5 : 8cc5                  	dw	tp_open_bread		; io_ext1 - open for binary re
c4c7 : d7c5                  	dw	tp_open_bwrite		; io_ext2 - open for binary w
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
                             ;* This is a char based device
c4c9 :                       io_device1					; Default device, input = screen e
c4c9 : f1ce                  	dw	gr_get_key			; io_get_ch
c4cb : 27cf                  	dw	gr_put_byte			; io_put_ch
c4cd : b5c4                  	dw	io_null_op			; io_open_r
c4cf : b5c4                  	dw	io_null_op			; io_open_w
c4d1 : b5c4                  	dw	io_null_op			; io_close_f
c4d3 : b5c4                  	dw	io_null_op			; io_del_f
c4d5 : b5c4                  	dw	io_null_op			; io_ext1
c4d7 : b5c4                  	dw	io_null_op			; io_ext2
                             ;* Serial device using printer port ACK (input) a
                             ;* This is a char based device
                             ;io_device2					; Serial device, input = Ser, out
                             ;	dw	ser_get_byte		; io_get_ch
                             ;	dw	ser_put_byte		; io_put_ch
                             ;	dw	ser_open			; io_open_r
                             ;	dw	ser_open			; io_open_w
                             ;	dw	ser_close			; io_close_f
                             ;	dw	io_null_op			; io_del_f
                             ;	dw	io_null_op			; io_ext1
                             ;	dw	io_null_op			; io_ext2
                             
c4d9 :                       mod_sz_io_e
                             
                             
                             
                             ;* Reset vector points here - 6502 starts here
c4d9 :                       init
                             ;	jmp init_test
                             	; First clear ram
c4d9 : 78               [ 2] 	sei					; Need this for MOS 6502
c4da : d8               [ 2] 	cld					; Need this for MOS 6502
c4db : 4c05c5           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c4de :                       init_2					; init_ram will jump back to here
c4de : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c4e0 : 9a               [ 2] 	txs
                             
c4e1 : 20e7c4           [ 6] 	jsr kernel_init
                             
c4e4 : 4c77c0           [ 3] 	jmp main
                             
c4e7 :                       kernel_init
c4e7 : 20cdc0           [ 6] 	jsr init_irq		; Initialise IRQ handling
                             
c4ea : 2025c5           [ 6] 	jsr init_via0		; initialise cia 0 - tape inactiv
c4ed : 2074c5           [ 6] 	jsr tp_init			; Initialise tape handling
                             
c4f0 : 202ed4           [ 6] 	jsr init_snd		; initialise the sound chip
                             
AS65 Assembler for R6502 [1.42].                                     Page   65
-------------------------------- bank\bank0.s --------------------------------

c4f3 : 2093cc           [ 6] 	jsr gr_init			; Initialise graphics, default is 
                             
c4f6 : 2067c7           [ 6] 	jsr init_keyboard	; initialise keyboard timer se
c4f9 : 2020c4           [ 6] 	jsr io_init			; Set default input/output device
                             
c4fc : a900             [ 2] 	lda #0
c4fe : 8508             [ 3] 	sta vdp_cnt
                             
c500 : 20a5f6           [ 6] 	jsr df_init			; Initialise interpreter
                             
c503 : 58               [ 2] 	cli					; irq interrupts enable
                             
c504 :                       kernel_test
                             ;	jsr kb_read_raw
                             ;	jsr utilPrintA
                             ;	jsr utilPrintCRLF
                             ;	jmp kernel_test
                             	
c504 : 60               [ 6] 	rts
                             
                             
                             ;* Initialises RAM, skipping page 3 which is for 
                             ;* Zeroes all addressable RAM in the default bank
c505 :                       init_ram
c505 : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c507 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c509 : aa               [ 2] 	tax 				; Page counter starts at zero
c50a : 8600             [ 3] 	stx 0x00			; Start at page 0
c50c : 8601             [ 3] 	stx 0x01
c50e :                       init_ram_1
c50e : e003             [ 2] 	cpx	#3				; Ignore page 3 (IO page)
c510 : f005             [ 3] 	beq init_ram_skip
c512 :                       init_ram_fill
c512 : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c514 : c8               [ 2] 	iny
c515 : d0f7             [ 3] 	bne init_ram_1		; Do a whole page
c517 :                       init_ram_skip
c517 : e601             [ 5] 	inc 0x01			; Increase page pointer
c519 : e8               [ 2] 	inx					; Reduce page count
c51a : e0c0             [ 2] 	cpx #0xc0			; Do all pages until page until we g
c51c : d0f0             [ 3] 	bne init_ram_1
                             
c51e : 4cdec4           [ 3] 	jmp init_2			; Carry on initialisation
                             
                             ; 6502 Non-maskable interrupt come here
c521 :                       nmi
c521 : 40               [ 6] 	rti
                             
c522 :                       mod_sz_kernel_e
                             
                             
                             
                             ; Bank specific code goes here
                             	include "cia/cia.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   66
-------------------------------- bank\bank0.s --------------------------------

                             ;*  CIA.S
                             ;*  Code to initialise and utilise the 6522, whic
                             ;*	for various functions on the Oric including;
                             ;*		Port A:
                             ;*			[7..0] 	Printer data bits
                             ;*			[7..0] 	Interface to AY-3-8912
                             ;*		Port B:
                             ;*			[2..0] 	Keyboard matrix row selector
                             ;*			[7]	   	Tape output
                             ;*			[6]    	Tape player motor signal
                             ;*			[4]		Printer strobe
                             ;*		CA1:		Printer ACK
                             ;*		CB1: 		Tape input
                             ;*		CA2,CB2: 	Selecting the AY-3-8912
                             ;*
                             ;*  This file is called cia.s because code was or
                             ;*  for a MOS 6526 from a CMB64, but didn't get a
                             ;*	renaming this file ;-)
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
c522 :                       mod_sz_cia_s
                             
                             
                             ;****************************************
                             ;* init_via0
                             ;* Initialise cia 0
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
c522 :                       init_via0_tape					; initialisation bytes for tap
c522 : a017             [ 2] 	ldy #init_tape_tab-init_via0_tab
c524 : 2c                    	db 0x2c						; Ignore next two bytes
c525 :                       init_via0
c525 : a000             [ 2] 	ldy #0						; Standard initialisation of VIA
c527 :                       init_via0_loop
c527 : b938c5           [ 4] 	lda init_via0_tab,y
c52a : 300b             [ 3] 	bmi init_via0_done
c52c : aa               [ 2] 	tax
c52d : c8               [ 2] 	iny
c52e : b938c5           [ 4] 	lda init_via0_tab,y
c531 : 9d0003           [ 5] 	sta IO_0,x
c534 : c8               [ 2] 	iny
c535 : d0f0             [ 3] 	bne init_via0_loop
                             
c537 :                       init_via0_done
c537 : 60               [ 6] 	rts							; return from sub
                             
c538 :                       init_via0_tab
c538 : 0e7f                  	db IER, 	0x7f
c53a : 03ff                  	db DDRA,	0xff			; Port A output by default
c53c : 02f7                  	db DDRB,	0xf7			; Tape motor + KB select
c53e : 00b7                  	db PRB,		KB_PRB+7		; Port B default (cassette mo
c540 : 0cdd                  	db PCR,		0xdd			; Ensure AY is not selected (CB1
c542 : 0420                  	db T1CL,	lo(TIMER1_RATE)	; 50Hz
c544 : 0620                  	db T1LL,	lo(TIMER1_RATE)	; 50Hz
c546 : 054e                  	db T1CH,	hi(TIMER1_RATE)	; 50Hz
AS65 Assembler for R6502 [1.42].                                     Page   67
-------------------------------- bank\bank0.s --------------------------------

c548 : 074e                  	db T1LH,	hi(TIMER1_RATE)	; 50Hz
c54a : 0b40                  	db ACR,		0x40			; Timer 1 continuous
c54c : 0ec0                  	db IER,		0xc0			; Timer 1 interrupt enabled
c54e : ff                    	db -1
c54f :                       init_tape_tab
c54f : 0e7f                  	db IER,		0x7f			; Disable all interrupts
c551 : 08f4                  	db T2CL,	0xf4			; Timer 2 used for measuring CB1
c553 : 0c10                  	db PCR,		0x10			; Interrupt on CB1 positive edge
                             ;	db DDRB,	0xff			; Set port B output
c555 : 0bc0                  	db ACR,		0xc0			; T1 continuous and toggle PB7
c557 : 04a0                  	db T1CL,	lo(TAPE_RATE*2)	; Tape rate /2 = 0
c559 : 0501                  	db T1CH,	hi(TAPE_RATE*2)	; Tape rate /2 = 0
c55b : 00f0                  	db PRB,		KB_PRB+0x40		; Tape motor ON
c55d : ff                    	db -1
                             ;init_ser_tab
                             ;	db IER,		0x7f			; Disable all interrupts
                             ;	db T2CL,	0xf4			; Timer 2 used for measuring bi
                             ;	db PCR,		0xdd			; Ensure AY is not selected (CB
                             ;	db DDRB,	0xff			; Set port B output
                             ;	db -1
                             
c55e :                       mod_sz_cia_e
                             
                             	include "tape/tape.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TAPE.S
                             ;*	These routines allow for tape input/output
                             ;*	The tape format is not compatible with a regul
                             ;*	but is a block format as follows;
                             ;*	Some zero bits (64) start a block.
                             ;*	Then two bytes of data representing the block 
                             ;*	Then 256 bytes of block data.
                             ;*	Each byte above consists of two '1' start bits
                             ;*	one '0' stop bit.
                             ;*	After each block, 1 second of 4800Hz (seen as 
                             ;*	is transmitted to allow the CPU to deal with t
                             ;*	when subsequently loading.
                             ;*	A bit is 4800Hz half cycle then 4800Hz half cy
                             ;*	'1' or 2400Hz half cycle for a '0', except for
                             ;*	block which is one second of 2400Hz.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c55e :                       tp_open_msg
c55e : 4c6f6164696e67..      	db	"Loading:",0
c567 :                       tp_save_msg
c567 : 536176696e673a00      	db	"Saving:",0
c56f :                       tp_back4
c56f : 0808080800            	db	8,8,8,8,0
                             	
                             ;* tp_init
                             ;* Basic initialisation for tape handling
AS65 Assembler for R6502 [1.42].                                     Page   68
-------------------------------- bank\bank0.s --------------------------------

c574 :                       tp_init
c574 : a900             [ 2] 	lda #0
c576 : 8558             [ 3] 	sta tp_flag
c578 : 8557             [ 3] 	sta tp_idx
c57a : 18               [ 2] 	clc
c57b : 60               [ 6] 	rts
                             
                             ;* Common function to open tape
c57c :                       tp_open_common				; Used by open write too
c57c : 78               [ 2] 	sei						; Interrupts disabled from here..
c57d : 2022c5           [ 6] 	jsr init_via0_tape		; Get ready to output (tape 
                             
                             
c580 : a200             [ 2] 	ldx #0
c582 : 8657             [ 3] 	stx tp_idx				; Initialise block
c584 : 8655             [ 3] 	stx tp_block
c586 : 8656             [ 3] 	stx tp_block+1
c588 : e8               [ 2] 	inx
c589 : 8658             [ 3] 	stx tp_flag				; assume 1 = Read mode
c58b : 60               [ 6] 	rts
                             
                             ;* tp_open_read
                             ;* Open tape settings
                             
c58c :                       fd_cload_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c58c :                       tp_open_bread
c58c :                       tp_open_read
c58c : a05e             [ 2] 	ldy #lo(tp_open_msg)
c58e : a9c5             [ 2] 	lda #hi(tp_open_msg)
c590 : 207bcf           [ 6] 	jsr gr_print_msg
                             	
c593 : 207cc5           [ 6] 	jsr tp_open_common
                             
c596 :                       tp_get_fname_start
c596 : 2038c7           [ 6] 	jsr tp_read_byte
c599 : c924             [ 2] 	cmp #'$'				; Find the $ symbol
c59b : d0f9             [ 3] 	bne tp_get_fname_start
                             	
c59d : a209             [ 2] 	ldx #9					; 9 byte header - skip
c59f :                       tp_get_header
c59f : 2038c7           [ 6] 	jsr tp_read_byte
c5a2 : ca               [ 2] 	dex
c5a3 : d0fa             [ 3] 	bne tp_get_header
                             	
                             	; X= zero here, now get null terminated filename
c5a5 :                       tp_get_fname
c5a5 : 2038c7           [ 6] 	jsr tp_read_byte
c5a8 : 9d0004           [ 5] 	sta df_linbuff,x
c5ab : e8               [ 2] 	inx
c5ac : c900             [ 2] 	cmp #0
c5ae : d0f5             [ 3] 	bne tp_get_fname
                             
c5b0 : a000             [ 2] 	ldy #lo(df_linbuff)
c5b2 : a904             [ 2] 	lda #hi(df_linbuff)
c5b4 : 207bcf           [ 6] 	jsr gr_print_msg
c5b7 : a920             [ 2] 	lda #' '
c5b9 : 2027cf           [ 6] 	jsr gr_put_byte
                             
c5bc : 18               [ 2] 	clc
c5bd : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   69
-------------------------------- bank\bank0.s --------------------------------

c5be :                       tt_getsync_pc				; ** FOR ORICUTRON EMULATOR **
c5be :                       tt_getsync_end_pc			; ** FOR ORICUTRON EMULATOR *
                             
c5be : ea               [ 2] 	nop
                             	
                             
                             ;* tp_close
                             ;* Close tape settings
c5bf :                       tp_close
c5bf : a558             [ 3] 	lda tp_flag
c5c1 : c902             [ 2] 	cmp #2					; Write mode?
c5c3 : d003             [ 3] 	bne tp_close_no_flush	; If not no need to flush
c5c5 : 2055c6           [ 6] 	jsr tp_put_block		; Flush the current block
c5c8 :                       tp_close_no_flush
c5c8 : a90d             [ 2] 	lda #0x0d				; Line feed
c5ca : 2027cf           [ 6] 	jsr gr_put_byte
                             	
c5cd : 2025c5           [ 6] 	jsr init_via0			; Back to normal
c5d0 : 58               [ 2] 	cli
c5d1 : a900             [ 2] 	lda #0					; Zero tape flag
c5d3 : 8558             [ 3] 	sta tp_flag
                             
c5d5 :                       tt_csave_end_pc				; ** FOR ORICUTRON EMULATOR **
                             
c5d5 : 18               [ 2] 	clc
c5d6 : 60               [ 6] 	rts
                             
                             ;* tp_open_write
                             ;* Open tape settings
c5d7 :                       tp_open_bwrite
c5d7 : a001             [ 2] 	ldy #hi(0x101)
c5d9 : a201             [ 2] 	ldx #lo(0x101)
c5db : d004             [ 3] 	bne tp_open_write_start
c5dd :                       tp_open_write
c5dd : a018             [ 2] 	ldy #hi(6000+0x101)
c5df : a271             [ 2] 	ldx #lo(6000+0x101)
                             
c5e1 :                       fd_csave_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c5e1 :                       tp_open_write_start
c5e1 : 845a             [ 3] 	sty tp_delay+1
c5e3 : 8659             [ 3] 	stx tp_delay
c5e5 : a067             [ 2] 	ldy #lo(tp_save_msg)
c5e7 : a9c5             [ 2] 	lda #hi(tp_save_msg)
c5e9 : 207bcf           [ 6] 	jsr gr_print_msg
c5ec : a000             [ 2] 	ldy #lo(df_linbuff)
c5ee : a904             [ 2] 	lda #hi(df_linbuff)
c5f0 : 207bcf           [ 6] 	jsr gr_print_msg
c5f3 : a920             [ 2] 	lda #' '
c5f5 : 2027cf           [ 6] 	jsr gr_put_byte
                             	
c5f8 : 207cc5           [ 6] 	jsr tp_open_common		; Same as reading but
c5fb : e658             [ 5] 	inc tp_flag				; Make flag = 2 for write mode
                             
c5fd :                       tt_writeleader_pc			; ** FOR ORICUTRON EMULATOR *
c5fd :                       tt_writeleader_end_pc		; ** FOR ORICUTRON EMULATO
c5fd : a280             [ 2] 	ldx #128				; 128 low bits
c5ff : 204dc6           [ 6] 	jsr tp_put_delay
                             
c602 : a924             [ 2] 	lda #'$'				; Start of header symbol
c604 : 38               [ 2] 	sec
c605 : 20a4c6           [ 6] 	jsr tp_write_byte
AS65 Assembler for R6502 [1.42].                                     Page   70
-------------------------------- bank\bank0.s --------------------------------

                             	
c608 : a209             [ 2] 	ldx #9					; Header, for future expansion
c60a : a9ff             [ 2] 	lda #0xff
c60c :                       tp_write_header	
c60c : 38               [ 2] 	sec
c60d : 20a4c6           [ 6] 	jsr tp_write_byte
c610 : ca               [ 2] 	dex
c611 : d0f9             [ 3] 	bne tp_write_header
                             	
c613 : a200             [ 2] 	ldx #0
c615 :                       tp_write_fname
c615 : bd0004           [ 4] 	lda df_linbuff,x		; Put the filename
c618 : 38               [ 2] 	sec
c619 : 20a4c6           [ 6] 	jsr tp_write_byte
c61c : e8               [ 2] 	inx
c61d : c900             [ 2] 	cmp #0
c61f : d0f4             [ 3] 	bne tp_write_fname
                             	
c621 : 18               [ 2] 	clc
c622 : 60               [ 6] 	rts
                             
                             
                             ;* tp_put_byte
                             ;* Put to byte to tape - if got a block then save
                             
c623 :                       tp_put_byte
c623 : 48               [ 3] 	pha
c624 : 8538             [ 3] 	sta tmp_d
c626 : 8a               [ 2] 	txa
c627 : 48               [ 3] 	pha
c628 : 98               [ 2] 	tya
c629 : 48               [ 3] 	pha
c62a : a538             [ 3] 	lda tmp_d
                             	
c62c : a457             [ 3] 	ldy tp_idx				; Save byte to buffer
c62e : 990002           [ 5] 	sta tp_buf,y
c631 : c8               [ 2] 	iny
c632 : 8457             [ 3] 	sty tp_idx
c634 : d010             [ 3] 	bne tp_put_byte_done
c636 : 2055c6           [ 6] 	jsr tp_put_block		; Flush block to tape
c639 : 18               [ 2] 	clc						; Increment block #
c63a : a555             [ 3] 	lda tp_block
c63c : 6901             [ 2] 	adc #1
c63e : 8555             [ 3] 	sta tp_block
c640 : a556             [ 3] 	lda tp_block+1
c642 : 6900             [ 2] 	adc #0
c644 : 8556             [ 3] 	sta tp_block+1
c646 :                       tp_put_byte_done
c646 : 68               [ 4] 	pla
c647 : a8               [ 2] 	tay
c648 : 68               [ 4] 	pla
c649 : aa               [ 2] 	tax
c64a : 68               [ 4] 	pla
c64b : 18               [ 2] 	clc
c64c : 60               [ 6] 	rts
                             
                             ; tp_put_delay
                             ;* X = number of zero bits to insert
c64d :                       tp_put_delay
c64d : 18               [ 2] 	clc
c64e : 20c7c6           [ 6] 	jsr tp_write_bit
c651 : ca               [ 2] 	dex
AS65 Assembler for R6502 [1.42].                                     Page   71
-------------------------------- bank\bank0.s --------------------------------

c652 : d0f9             [ 3] 	bne tp_put_delay
c654 : 60               [ 6] 	rts
                             
                             ;* tp_put_block
                             ;* flush a block to tape
c655 :                       tp_put_block
c655 : 2079c6           [ 6] 	jsr tp_print_block
                             		
c658 : a280             [ 2] 	ldx #128				; 128 low bits
c65a : 204dc6           [ 6] 	jsr tp_put_delay
                             
c65d : a555             [ 3] 	lda tp_block			; Save block number low then high
c65f : 18               [ 2] 	clc
c660 : 20a4c6           [ 6] 	jsr tp_write_byte
c663 : a556             [ 3] 	lda tp_block+1
c665 : 38               [ 2] 	sec
c666 : 20a4c6           [ 6] 	jsr tp_write_byte
                             
c669 : a200             [ 2] 	ldx #0
c66b :                       tp_put_block_bytes
c66b : bd0002           [ 4] 	lda tp_buf,x			; Then write out all bytes in blo
c66e : 18               [ 2] 	clc
c66f : 20a4c6           [ 6] 	jsr tp_write_byte
c672 : e8               [ 2] 	inx
c673 : d0f6             [ 3] 	bne tp_put_block_bytes	; Always 256 bytes
                             	
c675 : 2099c6           [ 6] 	jsr tp_block_gap		; Wait a while, still outputti
                             
c678 : 60               [ 6] 	rts
                             
                             ; tp_print_block
c679 :                       tp_print_block
c679 : a556             [ 3] 	lda tp_block+1			; Print block number hi byte
c67b : 2098c1           [ 6] 	jsr str_a_to_x
c67e : 2027cf           [ 6] 	jsr gr_put_byte
c681 : 8a               [ 2] 	txa
c682 : 2027cf           [ 6] 	jsr gr_put_byte
c685 : a555             [ 3] 	lda tp_block			; Print block number lo byte
c687 : 2098c1           [ 6] 	jsr str_a_to_x
c68a : 2027cf           [ 6] 	jsr gr_put_byte
c68d : 8a               [ 2] 	txa
c68e : 2027cf           [ 6] 	jsr gr_put_byte
c691 : a9c5             [ 2] 	lda #hi(tp_back4)		; Go back 4 characters to pri
c693 : a06f             [ 2] 	ldy #lo(tp_back4)
c695 : 207bcf           [ 6] 	jsr gr_print_msg
c698 : 60               [ 6] 	rts
                             
                             ; tp_block_gap
                             ; Send 2400 bits of zero ~ 1.5 seconds
                             ; add 0x101 due to how counters decrement
                             ; For binary mode it is just 1 bit gap
c699 :                       tp_block_gap
c699 : a45a             [ 3] 	ldy tp_delay+1
c69b : a659             [ 3] 	ldx tp_delay
c69d :                       tp_block_gap_1
c69d : 204dc6           [ 6] 	jsr tp_put_delay
c6a0 : 88               [ 2] 	dey
c6a1 : d0fa             [ 3] 	bne tp_block_gap_1
c6a3 : 60               [ 6] 	rts	
                             
                             ;* tp_write_byte
                             ;* Write a byte to tape which looks like this
AS65 Assembler for R6502 [1.42].                                     Page   72
-------------------------------- bank\bank0.s --------------------------------

                             ;* 11xxxxxxxx0
c6a4 :                       tt_putbyte_pc				; ** FOR ORICUTRON EMULATOR **
c6a4 :                       tp_write_byte
c6a4 : 48               [ 3] 	pha
c6a5 : 08               [ 3] 	php
c6a6 : 38               [ 2] 	sec					; 1 for start bit
c6a7 : 20c7c6           [ 6] 	jsr tp_write_bit
c6aa : 38               [ 2] 	sec					; 1 for start bit
c6ab : 20c7c6           [ 6] 	jsr tp_write_bit
c6ae : a008             [ 2] 	ldy #8				; 8 bits of data
c6b0 :                       tp_write_byte_bit
c6b0 : 6a               [ 2] 	ror a
c6b1 : 20c7c6           [ 6] 	jsr tp_write_bit
c6b4 : 88               [ 2] 	dey
c6b5 : d0f9             [ 3] 	bne tp_write_byte_bit
c6b7 : 18               [ 2] 	clc					; 0 for stop bit
c6b8 : 20c7c6           [ 6] 	jsr tp_write_bit
c6bb : 28               [ 4] 	plp
c6bc : 9007             [ 3] 	bcc tp_write_byte_nodelay
c6be : 8a               [ 2] 	txa
c6bf : a220             [ 2] 	ldx #32					; Delays needed
c6c1 : 204dc6           [ 6] 	jsr tp_put_delay
c6c4 : aa               [ 2] 	tax
c6c5 :                       tp_write_byte_nodelay
c6c5 : 68               [ 4] 	pla
c6c6 :                       tt_putbyte_end_pc			; ** FOR ORICUTRON EMULATOR *
c6c6 : 60               [ 6] 	rts
                             	
                             
                             ;* tp_write_bit
                             ;* Write a bit in C to tape which looks like this
                             ;* Half cycle of 4800Hz, then
                             ;*		half cycle of 4800Hz for a 1
                             ;*		half cycle of 2400Hz for a 0
c6c7 :                       tp_write_bit
c6c7 : 48               [ 3] 	pha
c6c8 : 8a               [ 2] 	txa
c6c9 : 48               [ 3] 	pha
c6ca : 08               [ 3] 	php						; Save the bit to be stored
                             
c6cb : a9d0             [ 2] 	lda #TAPE_RATE			; Half cycle first of 4800Hz
c6cd : a200             [ 2] 	ldx #0
c6cf : 8d0603           [ 4] 	sta IO_0+T1LL
c6d2 : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c6d5 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c6d8 :                       tp_write_bit_chk1
c6d8 : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c6db : 50fb             [ 3] 	bvc tp_write_bit_chk1	; V=0? Keep checking
c6dd : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
                             	
c6e0 : 28               [ 4] 	plp						; Get the bit to be stored
c6e1 : a9d0             [ 2] 	lda #TAPE_RATE			; Assume putting out a 1 in 2nd
c6e3 : b002             [ 3] 	bcs tp_write_bit_t1		; A zero is half the rate (
c6e5 : 0a               [ 2] 	asl	a					; TAPE_RATE * 2 need to inc X
c6e6 : e8               [ 2] 	inx
c6e7 :                       tp_write_bit_t1
c6e7 : 8d0603           [ 4] 	sta IO_0+T1LL
c6ea : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c6ed : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c6f0 :                       tp_write_bit_chk2
c6f0 : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c6f3 : 50fb             [ 3] 	bvc tp_write_bit_chk2	; V=0? Keep checking
AS65 Assembler for R6502 [1.42].                                     Page   73
-------------------------------- bank\bank0.s --------------------------------

c6f5 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
c6f8 : 68               [ 4] 	pla
c6f9 : aa               [ 2] 	tax
c6fa : 68               [ 4] 	pla
c6fb : 60               [ 6] 	rts
                             
                             
                             
                             ;* tp_get_byte
                             ;* Get a byte from buffer - load blocks as needed
c6fc :                       tp_get_byte
c6fc : 8a               [ 2] 	txa
c6fd : 48               [ 3] 	pha
c6fe : 98               [ 2] 	tya
c6ff : 48               [ 3] 	pha
                             	
c700 : a457             [ 3] 	ldy tp_idx				; Index in to buffer
c702 : d005             [ 3] 	bne tp_get_byte_buf		; No need to load from tape
c704 : 2019c7           [ 6] 	jsr tp_get_block		; Else load a block from tape
c707 : a000             [ 2] 	ldy #0					; 0 index is now valid
c709 :                       tp_get_byte_buf
c709 : b90002           [ 4] 	lda tp_buf,y			; Get from memory buffer
c70c : c8               [ 2] 	iny
c70d : 8457             [ 3] 	sty tp_idx				; Never zero on leaving
c70f : 8538             [ 3] 	sta tmp_d
c711 : 68               [ 4] 	pla
c712 : a8               [ 2] 	tay
c713 : 68               [ 4] 	pla
c714 : aa               [ 2] 	tax
c715 : a538             [ 3] 	lda tmp_d
c717 : 18               [ 2] 	clc
c718 : 60               [ 6] 	rts						; Except when buffer done
                             
                             ;* tp_get_block
                             ;* Load a block in to memory
c719 :                       tp_get_block
                             
c719 : 2038c7           [ 6] 	jsr tp_read_byte		; Get block number
c71c : 8555             [ 3] 	sta tp_block
c71e : 2038c7           [ 6] 	jsr tp_read_byte
c721 : 8556             [ 3] 	sta tp_block+1
                             	
c723 : 2079c6           [ 6] 	jsr tp_print_block
                             	
c726 : a000             [ 2] 	ldy #0
c728 : 8457             [ 3] 	sty tp_idx
c72a :                       tp_get_block_bytes
c72a : 2038c7           [ 6] 	jsr tp_read_byte		; Fill buffer
c72d : a457             [ 3] 	ldy tp_idx
c72f : 990002           [ 5] 	sta tp_buf,y
c732 : c8               [ 2] 	iny
c733 : 8457             [ 3] 	sty tp_idx
c735 : d0f3             [ 3] 	bne tp_get_block_bytes	; Always 256 bytes
                             
c737 : 60               [ 6] 	rts
                             	
                             
                             ;* tp_read_byte
                             ;* Read a byte from tape, always expects one '1' 
c738 :                       tt_readbyte_pc				; ** FOR ORICUTRON EMULATOR **
c738 :                       tp_read_byte
c738 :                       tp_read_byte_st
AS65 Assembler for R6502 [1.42].                                     Page   74
-------------------------------- bank\bank0.s --------------------------------

c738 : 204cc7           [ 6] 	jsr tp_read_bit			; Expecting a 1
c73b : 90fb             [ 3] 	bcc tp_read_byte_st
c73d : 204cc7           [ 6] 	jsr tp_read_bit			; Should be another 1
c740 : 90f6             [ 3] 	bcc tp_read_byte_st
                             	; Ok got 2 start
                             	
c742 : a008             [ 2] 	ldy #8				; Get 8 bits
c744 :                       tp_read_byte_bits
c744 : 204cc7           [ 6] 	jsr tp_read_bit
c747 : 6a               [ 2] 	ror a
c748 : 88               [ 2] 	dey
c749 : d0f9             [ 3] 	bne tp_read_byte_bits
                             	; Byte is in A, stop bit is not waited for..
c74b :                       tt_readbyte_end_pc			; ** FOR ORICUTRON EMULATOR 
c74b : 60               [ 6] 	rts
                             
                             ;* tp_read_bit
                             ;* Get a CB1 transition and measure the time
                             ;* The measurement indicates a 1 or 0 received
c74c :                       tp_read_bit
c74c : 48               [ 3] 	pha
c74d : ad0003           [ 4] 	lda IO_0+PRB			; Clear CB1 interrupt flag by rea
c750 :                       tp_read_bit_cb1
c750 :                       tt_getsync_loop_pc			; ** FOR ORICUTRON EMULATOR 
c750 : ad0d03           [ 4] 	lda IO_0+IFR
c753 : 2910             [ 2] 	and #IFR_CB1
c755 : f0f9             [ 3] 	beq tp_read_bit_cb1		; Keep checking until CB1 a
                             
c757 : ad0903           [ 4] 	lda IO_0+T2CH			; Get the high byte of T2 counte
c75a : 48               [ 3] 	pha
c75b : a9ff             [ 2] 	lda #0xff				; Reset T2 counter high byte
c75d : 8d0903           [ 4] 	sta IO_0+T2CH			; Reset high byte of T2 counter
c760 : 68               [ 4] 	pla						; What was previous counter?
                             ;	beq tp_io_error			; If down to zero, then some 
c761 : c9fe             [ 2] 	cmp #0xfe				; C=1 if T2 >= 0xfe else C=0
c763 : 68               [ 4] 	pla
c764 : 60               [ 6] 	rts						; Carry contains the bit received
c765 :                       tp_io_error
                             	SWBRK DFERR_BREAK		; DEFINE A NEW ERROR!
                             
                             
                             
                             
                             	include "keyboard/keyboard.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KEYBOARD.S
                             ;*	Keyboard driver code. It is very slow to scan 
                             ;*	routines here do a basic scan for any key befo
                             ;*	the specific key. Still, it has a noticeable i
                             ;*	CPU especially in dflat which checks the key a
                             ;*	keyword is executed.
                             ;*	Rather than working off interrupts these routi
                             ;*	need to be called as needed. The T1 interrupt 
                             ;*	track of keyboard timers for repeat delay and 
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   75
-------------------------------- bank\bank0.s --------------------------------

                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_keyboard
                             ;* Initialise the keyboard settings
                             ;****************************************
c767 :                       init_keyboard
c767 : a914             [ 2] 	lda #KB_REP_DEL
c769 : 8531             [ 3] 	sta kb_rdel_tim
c76b : a903             [ 2] 	lda #KB_REP_TIM
c76d : 8530             [ 3] 	sta kb_rep_tim
c76f : a901             [ 2] 	lda #KB_DEBOUNCE
c771 : 852e             [ 3] 	sta kb_deb_tim
c773 : a900             [ 2] 	lda #0
c775 : 852c             [ 3] 	sta kb_stat
                             
c777 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_stick
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
                             ;* Returns bit mask of keys pressed
                             ;****************************************
c778 :                       kb_stick
                             	; Select Row 4 only, all keys on this row
c778 : a9b4             [ 2] 	lda #4+KB_PRB			; Maintain upper nibble of PRB
c77a : 8d0003           [ 4] 	sta IO_0+PRB
c77d : a90e             [ 2] 	lda #SND_REG_IOA		; Select AY Port A for columns
c77f : 204ec0           [ 6] 	jsr snd_sel_reg
c782 : a900             [ 2] 	lda #0					; Result will be in A
c784 : 48               [ 3] 	pha
c785 : a004             [ 2] 	ldy #4					; Go through the 5 cols on row 4
c787 :                       kb_stick_pos
c787 : b95ec9           [ 4] 	lda kb_stick_mask,y		; Get the column mask
c78a : 205ec0           [ 6] 	jsr snd_set_reg			; Activate column
c78d : ea               [ 2] 	nop
c78e : ea               [ 2] 	nop
c78f : ea               [ 2] 	nop
c790 : ea               [ 2] 	nop
c791 : a908             [ 2] 	lda #KB_SENSE			; Something pressed?
c793 : 2d0003           [ 4] 	and IO_0+PRB			; Read Port B
c796 : c908             [ 2] 	cmp #KB_SENSE			; C=1 if set else 0
c798 : 68               [ 4] 	pla
c799 : 2a               [ 2] 	rol a					; Get C in to A
c79a : 48               [ 3] 	pha
c79b : 88               [ 2] 	dey
c79c : 10e9             [ 3] 	bpl kb_stick_pos		; Do all 5 positions
c79e : 68               [ 4] 	pla						; Result in A
c79f : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* kb_any_key
                             ;* Quick check for any key except shifts & ctrl
                             ;* Carry = 1 means key pressed
                             ;****************************************
c7a0 :                       kb_any_key
c7a0 : a90e             [ 2] 	lda #SND_REG_IOA		; Select Port A of AY
AS65 Assembler for R6502 [1.42].                                     Page   76
-------------------------------- bank\bank0.s --------------------------------

c7a2 : 204ec0           [ 6] 	jsr snd_sel_reg
                             
c7a5 : a0b7             [ 2] 	ldy #7+KB_PRB			; Start from row 7
c7a7 :                       kb_any_key_row
c7a7 : 8c0003           [ 4] 	sty IO_0+PRB			; Select row on port B
                             	; Select all columns except 4
c7aa : a910             [ 2] 	lda #0b00010000			; Deselect only col 4
c7ac : 205ec0           [ 6] 	jsr snd_set_reg
                             
c7af : ea               [ 2] 	nop
c7b0 : ea               [ 2] 	nop
c7b1 : ea               [ 2] 	nop						; New NOP
c7b2 : ea               [ 2] 	nop
c7b3 : ea               [ 2] 	nop
                             ;	nop						; New NOP
                             
c7b4 : a908             [ 2] 	lda #KB_SENSE			; Something pressed?
c7b6 : 2d0003           [ 4] 	and IO_0+PRB			; Read Port B
c7b9 : d007             [ 3] 	bne kb_any_key_pressed
c7bb : 88               [ 2] 	dey						; If not then next row
c7bc : c0af             [ 2] 	cpy #KB_PRB-1			; Done rows 0..8?
c7be : d0e7             [ 3] 	bne kb_any_key_row		; Until all rows done
c7c0 :                       kb_any_key_none
c7c0 : 18               [ 2] 	clc						; C=0 means not pressed
c7c1 : 60               [ 6] 	rts
c7c2 :                       kb_any_key_pressed
c7c2 :                       kb_read_got
c7c2 : 38               [ 2] 	sec						; C=1 means pressed
c7c3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_read_raw
                             ;* Read keyboard
                             ;* Y = Keyboard code
                             ;* Carry = 1 means key found, 0 = no keys found
                             ;****************************************
c7c4 :                       kb_read_raw
c7c4 : 20a0c7           [ 6] 	jsr kb_any_key			; Quick check is anything down?
c7c7 : 9046             [ 4] 	bcc kb_read_nothing		; Don't bother if not
c7c9 :                       kb_read_raw_force
c7c9 : a20e             [ 2] 	ldx #SND_REG_IOA		; Select Port A of AY
c7cb : 8e0f03           [ 4] 	stx SND_ADBUS			; Put reg # on Port A (sound bus
c7ce : a2ff             [ 2] 	ldx #SND_SELSETADDR		; Get ready to select the r
c7d0 : 8e0c03           [ 4] 	stx SND_MODE			; Latch the reg # on Port A
c7d3 : a2dd             [ 2] 	ldx #SND_DESELECT		; Deselect AY
c7d5 : 8e0c03           [ 4] 	stx SND_MODE
c7d8 : a200             [ 2] 	ldx #0					; Start at column 0
c7da : 86ab             [ 3] 	stx zp_tmp1
c7dc :                       kb_check_matrix_col
c7dc : a0b0             [ 2] 	ldy #0+KB_PRB			; Start at row 0 (maintain PRB u
c7de :                       kb_check_matrix_row
c7de : 8c0003           [ 4] 	sty IO_0+PRB			; Select row from Y
                             	; Get the col value for AY port A
c7e1 : a6ab             [ 3] 	ldx zp_tmp1
c7e3 : bd56c9           [ 4] 	lda kb_col_mask,x
                             	; Write it to AY port A
c7e6 : 8d0f03           [ 4] 	sta SND_ADBUS			; Put col value on AY bus
c7e9 : a2fd             [ 2] 	ldx #SND_SELWRITE		; Select mode for writing dat
c7eb : 8e0c03           [ 4] 	stx SND_MODE			; Latch reg value on Port A
c7ee : a2dd             [ 2] 	ldx #SND_DESELECT		; Deselect AY
c7f0 : 8e0c03           [ 4] 	stx SND_MODE
                             
AS65 Assembler for R6502 [1.42].                                     Page   77
-------------------------------- bank\bank0.s --------------------------------

c7f3 : ea               [ 2] 	nop						; Wait 10 cycles before reading sense p
c7f4 : ea               [ 2] 	nop
c7f5 : ea               [ 2] 	nop
                             
c7f6 : a908             [ 2] 	lda #KB_SENSE			; Bit 3 is the sense
c7f8 : 2d0003           [ 4] 	and IO_0+PRB			; And with Port B
                             
c7fb : d016             [ 4] 	bne kb_read_raw_got
                             	; No key for this row/col, next
c7fd : c8               [ 2] 	iny
c7fe : c0b8             [ 2] 	cpy #8+KB_PRB			; Done 8 rows?
c800 : d0dc             [ 4] 	bne kb_check_matrix_row
                             	; ok check next row
c802 : a6ab             [ 3] 	ldx zp_tmp1
c804 :                       kb_check_skip4
c804 : e8               [ 2] 	inx
c805 : e004             [ 2] 	cpx #4					; Skip 4?
c807 : f0fb             [ 3] 	beq kb_check_skip4
c809 : 86ab             [ 3] 	stx zp_tmp1
c80b : e008             [ 2] 	cpx #8					; Done 8 cols?
c80d : d0cd             [ 4] 	bne kb_check_matrix_col
                             	; No key was sensed
c80f :                       kb_read_nothing
c80f : a000             [ 2] 	ldy #0					; Raw key codes
c811 : 18               [ 2] 	clc						; No key sensed flag
c812 : 60               [ 6] 	rts
c813 :                       kb_read_raw_got
                             	;Y=row, zp_temp1=col
c813 : a5ab             [ 3] 	lda zp_tmp1				; Get the column num
c815 : 0a               [ 2] 	asl a					; Shift in to bits 5,4,3
c816 : 0a               [ 2] 	asl a
c817 : 0a               [ 2] 	asl a
c818 : 85ab             [ 3] 	sta zp_tmp1
c81a : 98               [ 2] 	tya						; Now or with row number
c81b : 2907             [ 2] 	and #7					; Only bottom 3 bits!
c81d : 05ab             [ 3] 	ora zp_tmp1
c81f : a8               [ 2] 	tay						; Put in to Y
c820 : 38               [ 2] 	sec
c821 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_scan_key
                             ;* Scans for a key, returns zero for no key found
                             ;* Processes caps and shift lock but these don't 
                             ;* A = Key code
                             ;****************************************
c822 :                       kb_scan_key
c822 : a52d             [ 3] 	lda kb_deb				; Do not scan keyboard too often
c824 : d013             [ 3] 	bne kb_no_scan
c826 : a52e             [ 3] 	lda kb_deb_tim			; Else reset debounce timer
c828 : 852d             [ 3] 	sta kb_deb
c82a : 20c4c7           [ 6] 	jsr kb_read_raw			; Check if a key is sensed
c82d : b00e             [ 3] 	bcs kb_scan_decode		; go ahead and decode
                             	; If pressed nothing then reset timers
c82f : a9ff             [ 2] 	lda #255
c831 : 8529             [ 3] 	sta kb_raw				; Reset raw key settings
c833 : 852a             [ 3] 	sta kb_last				; And last key
c835 : a531             [ 3] 	lda kb_rdel_tim			; Reset repeat timer to initia
c837 : 852f             [ 3] 	sta kb_rep
c839 :                       kb_no_scan
c839 : a900             [ 2] 	lda #0
c83b : 38               [ 2] 	sec						; Code not valid
AS65 Assembler for R6502 [1.42].                                     Page   78
-------------------------------- bank\bank0.s --------------------------------

c83c : 60               [ 6] 	rts						; And done (A=0)
c83d :                       kb_scan_decode
                             	; If got here then raw key is good
c83d : a52a             [ 3] 	lda kb_last				; Preload A with last decoded key
c83f : c429             [ 3] 	cpy kb_raw				; Same as last raw key?
c841 : 8429             [ 3] 	sty kb_raw				; Already save new raw key
c843 : d002             [ 3] 	bne kb_process_new		; If is new raw key, look at
c845 : f05f             [ 3] 	beq kb_do_repeat		; Else go handle repeating wit
c847 :                       kb_process_new
c847 : a531             [ 3] 	lda kb_rdel_tim			; Reset repeat timer to initia
c849 : 852f             [ 3] 	sta kb_rep
                             	; Now to get a proper key code translated from r
                             	; Check for shift and ctrl (not debounced!)
c84b : a9ef             [ 2] 	lda #0b11101111			; Select column 4
c84d : a20e             [ 2] 	ldx #SND_REG_IOA		; On AY port A
c84f : 206ec0           [ 6] 	jsr snd_set
                             
                             	; check shifted keys
c852 : a2b4             [ 2] 	ldx #4+KB_PRB			; Row 4 (left shift)
c854 : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c857 : ea               [ 2] 	nop
c858 : ea               [ 2] 	nop
c859 : ea               [ 2] 	nop
c85a : ea               [ 2] 	nop
                             
c85b : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
                             
c85e : a2b7             [ 2] 	ldx #7+KB_PRB			; Row 7 (right shift)
c860 : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c863 : ea               [ 2] 	nop
c864 : ea               [ 2] 	nop
c865 : ea               [ 2] 	nop
c866 : ea               [ 2] 	nop
                             
c867 : 0d0003           [ 4] 	ora IO_0+PRB			; Combine Port B
c86a : bed6c8           [ 4] 	ldx kb_table_std,y		; Pre-load standard key code
c86d : 2908             [ 2] 	and #KB_SENSE			; Bit 3 is the sense
c86f : f003             [ 3] 	beq kb_read_noshift		; Skip over if no shift
c871 : be16c9           [ 4] 	ldx kb_table_shift,y	; Load up standard key code
c874 :                       kb_read_noshift
c874 : 862b             [ 3] 	stx kb_code				; Save the mapped keycode
                             	; check ctrl key
c876 : a2b2             [ 2] 	ldx #2+KB_PRB			; Row 2 (ctrl key)
c878 : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c87b : ea               [ 2] 	nop
c87c : ea               [ 2] 	nop
c87d : ea               [ 2] 	nop
c87e : ea               [ 2] 	nop
                             
c87f : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
c882 : 2908             [ 2] 	and #KB_SENSE
c884 : f00a             [ 3] 	beq kb_skip_ctrl
c886 : a52b             [ 3] 	lda kb_code
c888 : 291f             [ 2] 	and #0x1f				; Ctrl will result in codes 0 to 31
c88a : 852b             [ 3] 	sta kb_code				; Override the keycode
c88c : f028             [ 3] 	beq kb_brk
c88e : 101e             [ 3] 	bpl	kb_store_last		; Check repeat (bpl is always
c890 :                       kb_skip_ctrl
c890 : a52c             [ 3] 	lda kb_stat				; Check caps lock
c892 : 2901             [ 2] 	and #KB_CAPSLK
c894 : f018             [ 3] 	beq kb_store_last
c896 : a52b             [ 3] 	lda kb_code
AS65 Assembler for R6502 [1.42].                                     Page   79
-------------------------------- bank\bank0.s --------------------------------

c898 : c961             [ 2] 	cmp #'a'				; If < 'a' then skip
c89a : 9012             [ 3] 	bcc kb_store_last
c89c : c97b             [ 2] 	cmp #'z'+1				; If > 'z' then skip
c89e : b00e             [ 3] 	bcs kb_store_last
c8a0 : a52b             [ 3] 	lda kb_code				; Get the actual code
c8a2 : 4920             [ 2] 	eor #0x20				; Switch off bit 0x20
c8a4 : d008             [ 3] 	bne kb_store_last
c8a6 :                       kb_do_repeat
c8a6 : a62f             [ 3] 	ldx kb_rep				; Has repeat expired?
c8a8 : d008             [ 3] 	bne	kb_in_repeat		; If not then still in repeat
c8aa : a630             [ 3] 	ldx kb_rep_tim			; Set repeat speed
c8ac : 862f             [ 3] 	stx kb_rep
c8ae :                       kb_store_last
c8ae : 852a             [ 3] 	sta kb_last				; Make last code same as this
c8b0 : 18               [ 2] 	clc						; Code valid
c8b1 : 60               [ 6] 	rts
c8b2 :                       kb_in_repeat
c8b2 : a900             [ 2] 	lda #0					; Don't emit a keycode
c8b4 : 38               [ 2] 	sec
c8b5 : 60               [ 6] 	rts
c8b6 :                       kb_brk
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* kb_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=1 means valid
                             ;****************************************
c8b8 :                       kb_get_key
c8b8 : 8a               [ 2] 	txa
c8b9 : 48               [ 3] 	pha
c8ba : 98               [ 2] 	tya
c8bb : 48               [ 3] 	pha
                             
c8bc :                       kb_get_try
c8bc : 08               [ 3] 	php
c8bd : 2022c8           [ 6] 	jsr kb_scan_key
c8c0 : 900b             [ 3] 	bcc kb_scan_got_key
c8c2 : 28               [ 4] 	plp						; No key, so check C
c8c3 : b0f7             [ 3] 	bcs kb_get_try			; Keep looking if C
c8c5 : 38               [ 2] 	sec						; Indicate key not valid
                             
c8c6 : 68               [ 4] 	pla
c8c7 : a8               [ 2] 	tay
c8c8 : 68               [ 4] 	pla
c8c9 : aa               [ 2] 	tax
c8ca : a900             [ 2] 	lda #0
                             
c8cc : 60               [ 6] 	rts
c8cd :                       kb_scan_got_key
c8cd : 28               [ 4] 	plp						; Pull stack
c8ce : 18               [ 2] 	clc						; Indicate key valid
                             
c8cf : 68               [ 4] 	pla
c8d0 : a8               [ 2] 	tay
c8d1 : 68               [ 4] 	pla
c8d2 : aa               [ 2] 	tax
                             
c8d3 : a52b             [ 3] 	lda kb_code
                             
c8d5 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page   80
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* kb_table_std (no shift)
                             ;* Each line is one column
                             ;****************************************
c8d6 :                       kb_table_std
c8d6 : 376a6d6b20757938      	db '7' ,'j' ,'m' ,'k' ,' ' ,'u' ,'y' ,'8'
c8de : 6e7436392c69686c      	db 'n' ,'t' ,'6' ,'9' ,',' ,'i' ,'h' ,'l'
c8e6 : 3572623b2e6f6730      	db '5' ,'r' ,'b' ,';' ,'.' ,'o' ,'g' ,'0'
c8ee : 7666342d0b70652f      	db 'v' ,'f' ,'4' ,'-' ,0x0b,'p' ,'e' ,'/'
c8f6 : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
c8fe : 311b7a00087f610d      	db '1' ,0x1b,'z' ,0   ,0x08,0x7f,'a' ,0x0d
c906 : 7871325c0a5d7300      	db 'x' ,'q' ,'2' ,0x5c,0x0a,']' ,'s' ,0
c90e : 33646327095b773d      	db '3' ,'d' ,'c' ,0x27,0x09,'[' ,'w' ,'='
                             
                             ;* kb_table_shift (with shift)
c916 :                       kb_table_shift
c916 : 264a4d4b2055592a      	db '&' ,'J' ,'M' ,'K' ,' ' ,'U' ,'Y' ,'*'
c91e : 4e545e283c49484c      	db 'N' ,'T' ,'^' ,'(' ,'<' ,'I' ,'H' ,'L'
c926 : 2552423a3e4f4729      	db '%' ,'R' ,'B' ,':' ,'>' ,'O' ,'G' ,')'
c92e : 5646245f0b50453f      	db 'V' ,'F' ,'$' ,'_' ,0x0b,'P' ,'E' ,'?'
c936 : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
c93e : 211b5a00087f410d      	db '!' ,0x1b,'Z' ,0   ,0x08,0x7f,'A' ,0x0d
c946 : 5851407c0a7d5300      	db 'X' ,'Q' ,'@' ,'|' ,0x0a,'}' ,'S' ,0
c94e : 23444322097b572b      	db '#' ,'D' ,'C' ,0x22,0x09,'{' ,'W' ,'+'
                             
c956 :                       kb_col_mask
c956 : fe                    	db 0b11111110
c957 : fd                    	db 0b11111101
c958 : fb                    	db 0b11111011
c959 : f7                    	db 0b11110111
c95a : ef                    	db 0b11101111
c95b : df                    	db 0b11011111
c95c : bf                    	db 0b10111111
c95d : 7f                    	db 0b01111111
                             
c95e :                       kb_stick_mask
c95e : df                    	db 0b11011111		; Left 	= Bit 0
c95f : 7f                    	db 0b01111111		; Right = Bit 1
c960 : f7                    	db 0b11110111		; Up	= Bit 2
c961 : bf                    	db 0b10111111		; Down	= Bit 3
c962 : fe                    	db 0b11111110		; Space	= Bit 4
                             
                             	include "vdp/graph.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.S
                             ;*  This is the graphics module, to handle text a
                             ;*  graphics.
                             ;*  For text modes, this module keeps track of wh
                             ;*  next put a character, and also takes care of 
                             ;*  to the next line as well as scrolling the con
                             ;*  when the cursor has reached the bottom right.
                             ;*  module also enables text input which is echoe
                             ;*  screen, to allow interactive input and editin
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page   81
-------------------------------- bank\bank0.s --------------------------------

                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c963 :                       mod_sz_graph_s
                             
                             
                             	include "vdp/font.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  FONT.S
                             ;*  This is the font definition, used to initiali
                             ;*  character set.  This is the standard Oric-1 f
                             ;*	Still called vdp as this code was ported from 
                             ;*	machine using the TMS9918a.
                             ;*
                             ;************************************************
                             
c963 :                       vdp_font
                             ; char 32
c963 : 00                    	db %000000
c964 : 00                    	db %000000
c965 : 00                    	db %000000
c966 : 00                    	db %000000
c967 : 00                    	db %000000
c968 : 00                    	db %000000
c969 : 00                    	db %000000
c96a : 00                    	db %000000
                             ; char 33
c96b : 0c                    	db %001100
c96c : 0c                    	db %001100
c96d : 0c                    	db %001100
c96e : 08                    	db %001000
c96f : 08                    	db %001000
c970 : 00                    	db %000000
c971 : 08                    	db %001000
c972 : 00                    	db %000000
                             ; char 34
c973 : 36                    	db %110110
c974 : 36                    	db %110110
c975 : 12                    	db %010010
c976 : 00                    	db %000000
c977 : 00                    	db %000000
c978 : 00                    	db %000000
c979 : 00                    	db %000000
c97a : 00                    	db %000000
                             ; char 35
c97b : 14                    	db %010100
c97c : 14                    	db %010100
c97d : 3e                    	db %111110
c97e : 14                    	db %010100
c97f : 3e                    	db %111110
c980 : 14                    	db %010100
c981 : 14                    	db %010100
c982 : 00                    	db %000000
AS65 Assembler for R6502 [1.42].                                     Page   82
-------------------------------- bank\bank0.s --------------------------------

                             ; char 36
c983 : 08                    	db %001000
c984 : 1e                    	db %011110
c985 : 28                    	db %101000
c986 : 1c                    	db %011100
c987 : 0a                    	db %001010
c988 : 3c                    	db %111100
c989 : 08                    	db %001000
c98a : 00                    	db %000000
                             ; char 37
c98b : 30                    	db %110000
c98c : 32                    	db %110010
c98d : 04                    	db %000100
c98e : 08                    	db %001000
c98f : 10                    	db %010000
c990 : 26                    	db %100110
c991 : 06                    	db %000110
c992 : 00                    	db %000000
                             ; char 38
c993 : 10                    	db %010000
c994 : 28                    	db %101000
c995 : 28                    	db %101000
c996 : 10                    	db %010000
c997 : 2a                    	db %101010
c998 : 24                    	db %100100
c999 : 1a                    	db %011010
c99a : 00                    	db %000000
                             ; char 39
c99b : 0c                    	db %001100
c99c : 0c                    	db %001100
c99d : 04                    	db %000100
c99e : 00                    	db %000000
c99f : 00                    	db %000000
c9a0 : 00                    	db %000000
c9a1 : 00                    	db %000000
c9a2 : 00                    	db %000000
                             ; char 40
c9a3 : 04                    	db %000100
c9a4 : 08                    	db %001000
c9a5 : 10                    	db %010000
c9a6 : 10                    	db %010000
c9a7 : 10                    	db %010000
c9a8 : 08                    	db %001000
c9a9 : 04                    	db %000100
c9aa : 00                    	db %000000
                             ; char 41
c9ab : 10                    	db %010000
c9ac : 08                    	db %001000
c9ad : 04                    	db %000100
c9ae : 04                    	db %000100
c9af : 04                    	db %000100
c9b0 : 08                    	db %001000
c9b1 : 10                    	db %010000
c9b2 : 00                    	db %000000
                             ; char 42
c9b3 : 08                    	db %001000
c9b4 : 2a                    	db %101010
c9b5 : 1c                    	db %011100
c9b6 : 08                    	db %001000
c9b7 : 1c                    	db %011100
c9b8 : 2a                    	db %101010
c9b9 : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page   83
-------------------------------- bank\bank0.s --------------------------------

c9ba : 00                    	db %000000
                             ; char 43
c9bb : 00                    	db %000000
c9bc : 08                    	db %001000
c9bd : 08                    	db %001000
c9be : 3e                    	db %111110
c9bf : 08                    	db %001000
c9c0 : 08                    	db %001000
c9c1 : 00                    	db %000000
c9c2 : 00                    	db %000000
                             ; char 44
c9c3 : 00                    	db %000000
c9c4 : 00                    	db %000000
c9c5 : 00                    	db %000000
c9c6 : 00                    	db %000000
c9c7 : 00                    	db %000000
c9c8 : 08                    	db %001000
c9c9 : 08                    	db %001000
c9ca : 10                    	db %010000
                             ; char 45
c9cb : 00                    	db %000000
c9cc : 00                    	db %000000
c9cd : 00                    	db %000000
c9ce : 3e                    	db %111110
c9cf : 00                    	db %000000
c9d0 : 00                    	db %000000
c9d1 : 00                    	db %000000
c9d2 : 00                    	db %000000
                             ; char 46
c9d3 : 00                    	db %000000
c9d4 : 00                    	db %000000
c9d5 : 00                    	db %000000
c9d6 : 00                    	db %000000
c9d7 : 00                    	db %000000
c9d8 : 04                    	db %000100
c9d9 : 00                    	db %000000
c9da : 00                    	db %000000
                             ; char 47
c9db : 00                    	db %000000
c9dc : 02                    	db %000010
c9dd : 04                    	db %000100
c9de : 08                    	db %001000
c9df : 10                    	db %010000
c9e0 : 20                    	db %100000
c9e1 : 00                    	db %000000
c9e2 : 00                    	db %000000
                             ; char 48
c9e3 : 1c                    	db %011100
c9e4 : 22                    	db %100010
c9e5 : 26                    	db %100110
c9e6 : 2a                    	db %101010
c9e7 : 32                    	db %110010
c9e8 : 22                    	db %100010
c9e9 : 1c                    	db %011100
c9ea : 00                    	db %000000
                             ; char 49
c9eb : 08                    	db %001000
c9ec : 18                    	db %011000
c9ed : 08                    	db %001000
c9ee : 08                    	db %001000
c9ef : 08                    	db %001000
c9f0 : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page   84
-------------------------------- bank\bank0.s --------------------------------

c9f1 : 1c                    	db %011100
c9f2 : 00                    	db %000000
                             ; char 50
c9f3 : 1c                    	db %011100
c9f4 : 22                    	db %100010
c9f5 : 02                    	db %000010
c9f6 : 04                    	db %000100
c9f7 : 08                    	db %001000
c9f8 : 10                    	db %010000
c9f9 : 3e                    	db %111110
c9fa : 00                    	db %000000
                             ; char 51
c9fb : 3e                    	db %111110
c9fc : 02                    	db %000010
c9fd : 04                    	db %000100
c9fe : 0c                    	db %001100
c9ff : 02                    	db %000010
ca00 : 22                    	db %100010
ca01 : 1c                    	db %011100
ca02 : 00                    	db %000000
                             ; char 52
ca03 : 04                    	db %000100
ca04 : 0c                    	db %001100
ca05 : 14                    	db %010100
ca06 : 24                    	db %100100
ca07 : 3e                    	db %111110
ca08 : 04                    	db %000100
ca09 : 04                    	db %000100
ca0a : 00                    	db %000000
                             ; char 53
ca0b : 3e                    	db %111110
ca0c : 20                    	db %100000
ca0d : 3c                    	db %111100
ca0e : 02                    	db %000010
ca0f : 02                    	db %000010
ca10 : 22                    	db %100010
ca11 : 1c                    	db %011100
ca12 : 00                    	db %000000
                             ; char 54
ca13 : 0c                    	db %001100
ca14 : 10                    	db %010000
ca15 : 20                    	db %100000
ca16 : 3c                    	db %111100
ca17 : 22                    	db %100010
ca18 : 22                    	db %100010
ca19 : 1c                    	db %011100
ca1a : 00                    	db %000000
                             ; char 55
ca1b : 3e                    	db %111110
ca1c : 02                    	db %000010
ca1d : 04                    	db %000100
ca1e : 08                    	db %001000
ca1f : 10                    	db %010000
ca20 : 10                    	db %010000
ca21 : 10                    	db %010000
ca22 : 00                    	db %000000
                             ; char 56
ca23 : 1c                    	db %011100
ca24 : 22                    	db %100010
ca25 : 22                    	db %100010
ca26 : 1c                    	db %011100
ca27 : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page   85
-------------------------------- bank\bank0.s --------------------------------

ca28 : 22                    	db %100010
ca29 : 1c                    	db %011100
ca2a : 00                    	db %000000
                             ; char 57
ca2b : 1c                    	db %011100
ca2c : 22                    	db %100010
ca2d : 22                    	db %100010
ca2e : 1e                    	db %011110
ca2f : 02                    	db %000010
ca30 : 04                    	db %000100
ca31 : 18                    	db %011000
ca32 : 00                    	db %000000
                             ; char 58
ca33 : 00                    	db %000000
ca34 : 00                    	db %000000
ca35 : 08                    	db %001000
ca36 : 00                    	db %000000
ca37 : 00                    	db %000000
ca38 : 08                    	db %001000
ca39 : 00                    	db %000000
ca3a : 00                    	db %000000
                             ; char 59
ca3b : 00                    	db %000000
ca3c : 00                    	db %000000
ca3d : 08                    	db %001000
ca3e : 00                    	db %000000
ca3f : 00                    	db %000000
ca40 : 08                    	db %001000
ca41 : 08                    	db %001000
ca42 : 10                    	db %010000
                             ; char 60
ca43 : 04                    	db %000100
ca44 : 08                    	db %001000
ca45 : 10                    	db %010000
ca46 : 20                    	db %100000
ca47 : 10                    	db %010000
ca48 : 08                    	db %001000
ca49 : 04                    	db %000100
ca4a : 00                    	db %000000
                             ; char 61
ca4b : 00                    	db %000000
ca4c : 00                    	db %000000
ca4d : 3e                    	db %111110
ca4e : 00                    	db %000000
ca4f : 3e                    	db %111110
ca50 : 00                    	db %000000
ca51 : 00                    	db %000000
ca52 : 00                    	db %000000
                             ; char 62
ca53 : 10                    	db %010000
ca54 : 08                    	db %001000
ca55 : 04                    	db %000100
ca56 : 02                    	db %000010
ca57 : 04                    	db %000100
ca58 : 08                    	db %001000
ca59 : 10                    	db %010000
ca5a : 00                    	db %000000
                             ; char 63
ca5b : 1c                    	db %011100
ca5c : 22                    	db %100010
ca5d : 04                    	db %000100
ca5e : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page   86
-------------------------------- bank\bank0.s --------------------------------

ca5f : 08                    	db %001000
ca60 : 00                    	db %000000
ca61 : 08                    	db %001000
ca62 : 00                    	db %000000
                             ; char 64
ca63 : 1c                    	db %011100
ca64 : 22                    	db %100010
ca65 : 2a                    	db %101010
ca66 : 2e                    	db %101110
ca67 : 2c                    	db %101100
ca68 : 20                    	db %100000
ca69 : 1e                    	db %011110
ca6a : 00                    	db %000000
ca6b :                       vdp_font_a
                             ; char 65
ca6b : 1c                    	db %011100
ca6c : 22                    	db %100010
ca6d : 22                    	db %100010
ca6e : 3e                    	db %111110
ca6f : 22                    	db %100010
ca70 : 22                    	db %100010
ca71 : 22                    	db %100010
ca72 : 00                    	db %000000
                             ; char 66
ca73 : 3c                    	db %111100
ca74 : 22                    	db %100010
ca75 : 22                    	db %100010
ca76 : 3c                    	db %111100
ca77 : 22                    	db %100010
ca78 : 22                    	db %100010
ca79 : 3c                    	db %111100
ca7a : 00                    	db %000000
                             ; char 67
ca7b : 1c                    	db %011100
ca7c : 22                    	db %100010
ca7d : 20                    	db %100000
ca7e : 20                    	db %100000
ca7f : 20                    	db %100000
ca80 : 22                    	db %100010
ca81 : 1c                    	db %011100
ca82 : 00                    	db %000000
                             ; char 68
ca83 : 3c                    	db %111100
ca84 : 22                    	db %100010
ca85 : 22                    	db %100010
ca86 : 22                    	db %100010
ca87 : 22                    	db %100010
ca88 : 22                    	db %100010
ca89 : 3c                    	db %111100
ca8a : 00                    	db %000000
                             ; char 69
ca8b : 3e                    	db %111110
ca8c : 20                    	db %100000
ca8d : 20                    	db %100000
ca8e : 3c                    	db %111100
ca8f : 20                    	db %100000
ca90 : 20                    	db %100000
ca91 : 3e                    	db %111110
ca92 : 00                    	db %000000
                             ; char 70
ca93 : 3e                    	db %111110
ca94 : 20                    	db %100000
AS65 Assembler for R6502 [1.42].                                     Page   87
-------------------------------- bank\bank0.s --------------------------------

ca95 : 20                    	db %100000
ca96 : 3c                    	db %111100
ca97 : 20                    	db %100000
ca98 : 20                    	db %100000
ca99 : 20                    	db %100000
ca9a : 00                    	db %000000
                             ; char 71
ca9b : 1e                    	db %011110
ca9c : 20                    	db %100000
ca9d : 20                    	db %100000
ca9e : 20                    	db %100000
ca9f : 26                    	db %100110
caa0 : 22                    	db %100010
caa1 : 1e                    	db %011110
caa2 : 00                    	db %000000
                             ; char 72
caa3 : 22                    	db %100010
caa4 : 22                    	db %100010
caa5 : 22                    	db %100010
caa6 : 3e                    	db %111110
caa7 : 22                    	db %100010
caa8 : 22                    	db %100010
caa9 : 22                    	db %100010
caaa : 00                    	db %000000
                             ; char 73
caab : 1c                    	db %011100
caac : 08                    	db %001000
caad : 08                    	db %001000
caae : 08                    	db %001000
caaf : 08                    	db %001000
cab0 : 08                    	db %001000
cab1 : 1c                    	db %011100
cab2 : 00                    	db %000000
                             ; char 74
cab3 : 02                    	db %000010
cab4 : 02                    	db %000010
cab5 : 02                    	db %000010
cab6 : 02                    	db %000010
cab7 : 02                    	db %000010
cab8 : 22                    	db %100010
cab9 : 1c                    	db %011100
caba : 00                    	db %000000
                             ; char 75
cabb : 22                    	db %100010
cabc : 24                    	db %100100
cabd : 28                    	db %101000
cabe : 30                    	db %110000
cabf : 28                    	db %101000
cac0 : 24                    	db %100100
cac1 : 22                    	db %100010
cac2 : 00                    	db %000000
                             ; char 76
cac3 : 20                    	db %100000
cac4 : 20                    	db %100000
cac5 : 20                    	db %100000
cac6 : 20                    	db %100000
cac7 : 20                    	db %100000
cac8 : 20                    	db %100000
cac9 : 3e                    	db %111110
caca : 00                    	db %000000
                             ; char 77
cacb : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page   88
-------------------------------- bank\bank0.s --------------------------------

cacc : 36                    	db %110110
cacd : 2a                    	db %101010
cace : 2a                    	db %101010
cacf : 22                    	db %100010
cad0 : 22                    	db %100010
cad1 : 22                    	db %100010
cad2 : 00                    	db %000000
                             ; char 78
cad3 : 22                    	db %100010
cad4 : 22                    	db %100010
cad5 : 32                    	db %110010
cad6 : 2a                    	db %101010
cad7 : 26                    	db %100110
cad8 : 22                    	db %100010
cad9 : 22                    	db %100010
cada : 00                    	db %000000
                             ; char 79
cadb : 1c                    	db %011100
cadc : 22                    	db %100010
cadd : 22                    	db %100010
cade : 22                    	db %100010
cadf : 22                    	db %100010
cae0 : 22                    	db %100010
cae1 : 1c                    	db %011100
cae2 : 00                    	db %000000
                             ; char 80
cae3 : 3c                    	db %111100
cae4 : 22                    	db %100010
cae5 : 22                    	db %100010
cae6 : 3c                    	db %111100
cae7 : 20                    	db %100000
cae8 : 20                    	db %100000
cae9 : 20                    	db %100000
caea : 00                    	db %000000
                             ; char 81
caeb : 1c                    	db %011100
caec : 22                    	db %100010
caed : 22                    	db %100010
caee : 22                    	db %100010
caef : 2a                    	db %101010
caf0 : 24                    	db %100100
caf1 : 1a                    	db %011010
caf2 : 00                    	db %000000
                             ; char 82
caf3 : 3c                    	db %111100
caf4 : 22                    	db %100010
caf5 : 22                    	db %100010
caf6 : 3c                    	db %111100
caf7 : 28                    	db %101000
caf8 : 24                    	db %100100
caf9 : 22                    	db %100010
cafa : 00                    	db %000000
                             ; char 83
cafb : 1c                    	db %011100
cafc : 22                    	db %100010
cafd : 20                    	db %100000
cafe : 1c                    	db %011100
caff : 02                    	db %000010
cb00 : 22                    	db %100010
cb01 : 1c                    	db %011100
cb02 : 00                    	db %000000
                             ; char 84
AS65 Assembler for R6502 [1.42].                                     Page   89
-------------------------------- bank\bank0.s --------------------------------

cb03 : 3e                    	db %111110
cb04 : 08                    	db %001000
cb05 : 08                    	db %001000
cb06 : 08                    	db %001000
cb07 : 08                    	db %001000
cb08 : 08                    	db %001000
cb09 : 08                    	db %001000
cb0a : 00                    	db %000000
                             ; char 85
cb0b : 22                    	db %100010
cb0c : 22                    	db %100010
cb0d : 22                    	db %100010
cb0e : 22                    	db %100010
cb0f : 22                    	db %100010
cb10 : 22                    	db %100010
cb11 : 1c                    	db %011100
cb12 : 00                    	db %000000
                             ; char 86
cb13 : 22                    	db %100010
cb14 : 22                    	db %100010
cb15 : 22                    	db %100010
cb16 : 22                    	db %100010
cb17 : 22                    	db %100010
cb18 : 14                    	db %010100
cb19 : 08                    	db %001000
cb1a : 00                    	db %000000
                             ; char 87
cb1b : 22                    	db %100010
cb1c : 22                    	db %100010
cb1d : 22                    	db %100010
cb1e : 2a                    	db %101010
cb1f : 2a                    	db %101010
cb20 : 36                    	db %110110
cb21 : 22                    	db %100010
cb22 : 00                    	db %000000
                             ; char 88
cb23 : 22                    	db %100010
cb24 : 22                    	db %100010
cb25 : 14                    	db %010100
cb26 : 08                    	db %001000
cb27 : 14                    	db %010100
cb28 : 22                    	db %100010
cb29 : 22                    	db %100010
cb2a : 00                    	db %000000
                             ; char 89
cb2b : 22                    	db %100010
cb2c : 22                    	db %100010
cb2d : 14                    	db %010100
cb2e : 08                    	db %001000
cb2f : 08                    	db %001000
cb30 : 08                    	db %001000
cb31 : 08                    	db %001000
cb32 : 00                    	db %000000
                             ; char 90
cb33 : 3e                    	db %111110
cb34 : 02                    	db %000010
cb35 : 04                    	db %000100
cb36 : 08                    	db %001000
cb37 : 10                    	db %010000
cb38 : 20                    	db %100000
cb39 : 3e                    	db %111110
cb3a : 00                    	db %000000
AS65 Assembler for R6502 [1.42].                                     Page   90
-------------------------------- bank\bank0.s --------------------------------

                             ; char 91
cb3b : 1c                    	db %011100
cb3c : 10                    	db %010000
cb3d : 10                    	db %010000
cb3e : 10                    	db %010000
cb3f : 10                    	db %010000
cb40 : 10                    	db %010000
cb41 : 1c                    	db %011100
cb42 : 00                    	db %000000
                             ; char 92
cb43 : 00                    	db %000000
cb44 : 20                    	db %100000
cb45 : 10                    	db %010000
cb46 : 08                    	db %001000
cb47 : 04                    	db %000100
cb48 : 02                    	db %000010
cb49 : 00                    	db %000000
cb4a : 00                    	db %000000
                             ; char 93
cb4b : 1c                    	db %011100
cb4c : 04                    	db %000100
cb4d : 04                    	db %000100
cb4e : 04                    	db %000100
cb4f : 04                    	db %000100
cb50 : 04                    	db %000100
cb51 : 1c                    	db %011100
cb52 : 00                    	db %000000
                             ; char 94
cb53 : 08                    	db %001000
cb54 : 1c                    	db %011100
cb55 : 3e                    	db %111110
cb56 : 08                    	db %001000
cb57 : 08                    	db %001000
cb58 : 08                    	db %001000
cb59 : 08                    	db %001000
cb5a : 00                    	db %000000
                             ; char 95
cb5b : 00                    	db %000000
cb5c : 00                    	db %000000
cb5d : 00                    	db %000000
cb5e : 00                    	db %000000
cb5f : 00                    	db %000000
cb60 : 00                    	db %000000
cb61 : 3e                    	db %111110
cb62 : 00                    	db %000000
                             ; char 96
cb63 : 0e                    	db %001110
cb64 : 10                    	db %010000
cb65 : 10                    	db %010000
cb66 : 3c                    	db %111100
cb67 : 10                    	db %010000
cb68 : 10                    	db %010000
cb69 : 3e                    	db %111110
cb6a : 00                    	db %000000
                             ; char 97
cb6b : 00                    	db %000000
cb6c : 00                    	db %000000
cb6d : 1c                    	db %011100
cb6e : 02                    	db %000010
cb6f : 1e                    	db %011110
cb70 : 22                    	db %100010
cb71 : 1e                    	db %011110
AS65 Assembler for R6502 [1.42].                                     Page   91
-------------------------------- bank\bank0.s --------------------------------

cb72 : 00                    	db %000000
                             ; char 98
cb73 : 20                    	db %100000
cb74 : 20                    	db %100000
cb75 : 3c                    	db %111100
cb76 : 22                    	db %100010
cb77 : 22                    	db %100010
cb78 : 22                    	db %100010
cb79 : 3c                    	db %111100
cb7a : 00                    	db %000000
                             ; char 99
cb7b : 00                    	db %000000
cb7c : 00                    	db %000000
cb7d : 1e                    	db %011110
cb7e : 20                    	db %100000
cb7f : 20                    	db %100000
cb80 : 20                    	db %100000
cb81 : 1e                    	db %011110
cb82 : 00                    	db %000000
                             ; char 100
cb83 : 02                    	db %000010
cb84 : 02                    	db %000010
cb85 : 1e                    	db %011110
cb86 : 22                    	db %100010
cb87 : 22                    	db %100010
cb88 : 22                    	db %100010
cb89 : 1e                    	db %011110
cb8a : 00                    	db %000000
                             ; char 101
cb8b : 00                    	db %000000
cb8c : 00                    	db %000000
cb8d : 1c                    	db %011100
cb8e : 22                    	db %100010
cb8f : 3e                    	db %111110
cb90 : 20                    	db %100000
cb91 : 1e                    	db %011110
cb92 : 00                    	db %000000
                             ; char 102
cb93 : 0c                    	db %001100
cb94 : 12                    	db %010010
cb95 : 10                    	db %010000
cb96 : 3c                    	db %111100
cb97 : 10                    	db %010000
cb98 : 10                    	db %010000
cb99 : 10                    	db %010000
cb9a : 00                    	db %000000
                             ; char 103
cb9b : 00                    	db %000000
cb9c : 00                    	db %000000
cb9d : 1c                    	db %011100
cb9e : 22                    	db %100010
cb9f : 22                    	db %100010
cba0 : 1e                    	db %011110
cba1 : 02                    	db %000010
cba2 : 1c                    	db %011100
                             ; char 104
cba3 : 20                    	db %100000
cba4 : 20                    	db %100000
cba5 : 3c                    	db %111100
cba6 : 22                    	db %100010
cba7 : 22                    	db %100010
cba8 : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page   92
-------------------------------- bank\bank0.s --------------------------------

cba9 : 22                    	db %100010
cbaa : 00                    	db %000000
                             ; char 105
cbab : 08                    	db %001000
cbac : 00                    	db %000000
cbad : 18                    	db %011000
cbae : 08                    	db %001000
cbaf : 08                    	db %001000
cbb0 : 08                    	db %001000
cbb1 : 1c                    	db %011100
cbb2 : 00                    	db %000000
                             ; char 106
cbb3 : 04                    	db %000100
cbb4 : 00                    	db %000000
cbb5 : 0c                    	db %001100
cbb6 : 04                    	db %000100
cbb7 : 04                    	db %000100
cbb8 : 04                    	db %000100
cbb9 : 24                    	db %100100
cbba : 18                    	db %011000
                             ; char 107
cbbb : 20                    	db %100000
cbbc : 20                    	db %100000
cbbd : 22                    	db %100010
cbbe : 24                    	db %100100
cbbf : 38                    	db %111000
cbc0 : 24                    	db %100100
cbc1 : 22                    	db %100010
cbc2 : 00                    	db %000000
                             ; char 108
cbc3 : 18                    	db %011000
cbc4 : 08                    	db %001000
cbc5 : 08                    	db %001000
cbc6 : 08                    	db %001000
cbc7 : 08                    	db %001000
cbc8 : 08                    	db %001000
cbc9 : 1c                    	db %011100
cbca : 00                    	db %000000
                             ; char 109
cbcb : 00                    	db %000000
cbcc : 00                    	db %000000
cbcd : 36                    	db %110110
cbce : 2a                    	db %101010
cbcf : 2a                    	db %101010
cbd0 : 2a                    	db %101010
cbd1 : 22                    	db %100010
cbd2 : 00                    	db %000000
                             ; char 110
cbd3 : 00                    	db %000000
cbd4 : 00                    	db %000000
cbd5 : 3c                    	db %111100
cbd6 : 22                    	db %100010
cbd7 : 22                    	db %100010
cbd8 : 22                    	db %100010
cbd9 : 22                    	db %100010
cbda : 00                    	db %000000
                             ; char 111
cbdb : 00                    	db %000000
cbdc : 00                    	db %000000
cbdd : 1c                    	db %011100
cbde : 22                    	db %100010
cbdf : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page   93
-------------------------------- bank\bank0.s --------------------------------

cbe0 : 22                    	db %100010
cbe1 : 1c                    	db %011100
cbe2 : 00                    	db %000000
                             ; char 112
cbe3 : 00                    	db %000000
cbe4 : 00                    	db %000000
cbe5 : 3c                    	db %111100
cbe6 : 22                    	db %100010
cbe7 : 22                    	db %100010
cbe8 : 3c                    	db %111100
cbe9 : 20                    	db %100000
cbea : 20                    	db %100000
                             ; char 113
cbeb : 00                    	db %000000
cbec : 00                    	db %000000
cbed : 1e                    	db %011110
cbee : 22                    	db %100010
cbef : 22                    	db %100010
cbf0 : 1e                    	db %011110
cbf1 : 02                    	db %000010
cbf2 : 02                    	db %000010
                             ; char 114
cbf3 : 00                    	db %000000
cbf4 : 00                    	db %000000
cbf5 : 2e                    	db %101110
cbf6 : 30                    	db %110000
cbf7 : 20                    	db %100000
cbf8 : 20                    	db %100000
cbf9 : 20                    	db %100000
cbfa : 00                    	db %000000
                             ; char 115
cbfb : 00                    	db %000000
cbfc : 00                    	db %000000
cbfd : 1e                    	db %011110
cbfe : 20                    	db %100000
cbff : 1c                    	db %011100
cc00 : 02                    	db %000010
cc01 : 3c                    	db %111100
cc02 : 00                    	db %000000
                             ; char 116
cc03 : 10                    	db %010000
cc04 : 10                    	db %010000
cc05 : 3c                    	db %111100
cc06 : 10                    	db %010000
cc07 : 10                    	db %010000
cc08 : 12                    	db %010010
cc09 : 0c                    	db %001100
cc0a : 00                    	db %000000
                             ; char 117
cc0b : 00                    	db %000000
cc0c : 00                    	db %000000
cc0d : 22                    	db %100010
cc0e : 22                    	db %100010
cc0f : 22                    	db %100010
cc10 : 26                    	db %100110
cc11 : 1a                    	db %011010
cc12 : 00                    	db %000000
                             ; char 118
cc13 : 00                    	db %000000
cc14 : 00                    	db %000000
cc15 : 22                    	db %100010
cc16 : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page   94
-------------------------------- bank\bank0.s --------------------------------

cc17 : 22                    	db %100010
cc18 : 14                    	db %010100
cc19 : 08                    	db %001000
cc1a : 00                    	db %000000
                             ; char 119
cc1b : 00                    	db %000000
cc1c : 00                    	db %000000
cc1d : 22                    	db %100010
cc1e : 22                    	db %100010
cc1f : 2a                    	db %101010
cc20 : 2a                    	db %101010
cc21 : 36                    	db %110110
cc22 : 00                    	db %000000
                             ; char 120
cc23 : 00                    	db %000000
cc24 : 00                    	db %000000
cc25 : 22                    	db %100010
cc26 : 14                    	db %010100
cc27 : 08                    	db %001000
cc28 : 14                    	db %010100
cc29 : 22                    	db %100010
cc2a : 00                    	db %000000
                             ; char 121
cc2b : 00                    	db %000000
cc2c : 00                    	db %000000
cc2d : 22                    	db %100010
cc2e : 22                    	db %100010
cc2f : 22                    	db %100010
cc30 : 1e                    	db %011110
cc31 : 02                    	db %000010
cc32 : 1c                    	db %011100
                             ; char 122
cc33 : 00                    	db %000000
cc34 : 00                    	db %000000
cc35 : 3e                    	db %111110
cc36 : 04                    	db %000100
cc37 : 08                    	db %001000
cc38 : 10                    	db %010000
cc39 : 3e                    	db %111110
cc3a : 00                    	db %000000
                             ; char 123
cc3b : 0e                    	db %001110
cc3c : 18                    	db %011000
cc3d : 18                    	db %011000
cc3e : 30                    	db %110000
cc3f : 18                    	db %011000
cc40 : 18                    	db %011000
cc41 : 0e                    	db %001110
cc42 : 00                    	db %000000
                             ; char 124
cc43 : 08                    	db %001000
cc44 : 08                    	db %001000
cc45 : 08                    	db %001000
cc46 : 08                    	db %001000
cc47 : 08                    	db %001000
cc48 : 08                    	db %001000
cc49 : 08                    	db %001000
cc4a : 00                    	db %000000
                             ; char 125
cc4b : 38                    	db %111000
cc4c : 0c                    	db %001100
cc4d : 0c                    	db %001100
AS65 Assembler for R6502 [1.42].                                     Page   95
-------------------------------- bank\bank0.s --------------------------------

cc4e : 06                    	db %000110
cc4f : 0c                    	db %001100
cc50 : 0c                    	db %001100
cc51 : 38                    	db %111000
cc52 : 00                    	db %000000
                             ; char 126
cc53 : 00                    	db %000000
cc54 : 00                    	db %000000
cc55 : 10                    	db %010000
cc56 : 2a                    	db %101010
cc57 : 04                    	db %000100
cc58 : 00                    	db %000000
cc59 : 00                    	db %000000
cc5a : 00                    	db %000000
                             ; char 127
cc5b : 2a                    	db %101010
cc5c : 15                    	db %010101
cc5d : 2a                    	db %101010
cc5e : 15                    	db %010101
cc5f : 2a                    	db %101010
cc60 : 15                    	db %010101
cc61 : 2a                    	db %101010
cc62 : 15                    	db %010101
                             	
                             	
                             
                             ;****************************************
                             ;* vdp_init_font
                             ;* Initialise fonts from ROM
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cc63 :                       gr_init_font
                             	; Get char base from vdp structure
cc63 : a614             [ 3] 	ldx gr_scrngeom+gr_char
cc65 : 8634             [ 3] 	stx tmp_blo
cc67 : a615             [ 3] 	ldx gr_scrngeom+gr_char+1
cc69 : e8               [ 2] 	inx						; ASCII patterns start 1 page later
cc6a : 8635             [ 3] 	stx tmp_bhi
                             
cc6c : a963             [ 2] 	lda #lo(vdp_font)		; Low byte of fonts source
cc6e : 8536             [ 3] 	sta tmp_clo
cc70 : a9c9             [ 2] 	lda #hi(vdp_font)		; High byte of fonts source
cc72 : 8537             [ 3] 	sta tmp_chi
cc74 : a203             [ 2] 	ldx #3					; Copy 3 pages
cc76 : 4c79cc           [ 3] 	jmp gr_copy_mem
                             
                             
                             ;****************************************
                             ;* vdp_copy_mem
                             ;* Copy memory pages at a time
                             ;* Input :	clo/hi	=	source
                             ;*			blo/hi	=	dest
                             ;*			X		=	pages to copy
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cc79 :                       gr_copy_mem
cc79 : a000             [ 2] 	ldy #0					; byte within page
cc7b : a536             [ 3] 	lda tmp_clo				; Low byte of source
cc7d : 8532             [ 3] 	sta tmp_alo
AS65 Assembler for R6502 [1.42].                                     Page   96
-------------------------------- bank\bank0.s --------------------------------

cc7f : a537             [ 3] 	lda tmp_chi				; High byte of source
cc81 : 8533             [ 3] 	sta tmp_ahi
cc83 :                       gr_copy_byte
cc83 : 98               [ 2] 	tya
cc84 : b132             [ 5] 	lda (tmp_alo),y			; Get byte from font table
cc86 : 9134             [ 5] 	sta (tmp_blo),y			; Put it to the memory
cc88 : c8               [ 2] 	iny
cc89 : d0f8             [ 3] 	bne gr_copy_byte		; keep going for 1 page
cc8b : e633             [ 5] 	inc tmp_ahi				; only need to increment high byt
cc8d : e635             [ 5] 	inc tmp_bhi				; source and destination ptr
cc8f : ca               [ 2] 	dex						; page counter
cc90 : d0f1             [ 3] 	bne gr_copy_byte		; keep going for X pages
cc92 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init
                             ;* First initialisation of screen
                             ;****************************************
cc93 :                       gr_init
cc93 : a210             [ 2] 	ldx #VDP_FLASH			; Default cursor flash rate
cc95 : 860b             [ 3] 	stx vdp_curtim
cc97 : 860c             [ 3] 	stx vdp_curcnt
cc99 : a200             [ 2] 	ldx #0
cc9b : 860e             [ 3] 	stx vdp_curstat
                             
                             	; Hard reset initial geom values (X=0)
cc9d : 20c4cc           [ 6] 	jsr gr_init_geom
                             
                             	; Copy font from ROM to char base
cca0 : 2063cc           [ 6] 	jsr gr_init_font
                             
                             	; Go in to hires mode to generate tables
cca3 : 201acd           [ 6] 	jsr gr_init_hires
cca6 : 2053cd           [ 6] 	jsr gr_init_hires_tables
                             
                             	; But start in text mode
cca9 : 4c01cd           [ 3] 	jmp gr_init_screen_txt
                             
                             
                             ;****************************************
                             ;* gr_check_font_copy
                             ;* check font needs to be copied from
                             ;* current location to another
                             ;* A=high byte of page aligned font addr
                             ;* that the font needs to be at
                             ;****************************************
ccac :                       gr_check_font_copy
                             	; Compare with current high byte
ccac : c515             [ 3] 	cmp gr_scrngeom+gr_char+1
ccae : f013             [ 3] 	beq gr_check_font_copy_done
                             	; save A as high byte of destination
ccb0 : 8535             [ 3] 	sta tmp_blo+1
                             	; destination low is 0
ccb2 : a900             [ 2] 	lda #0
ccb4 : 8534             [ 3] 	sta tmp_blo
                             
                             	; Get source from current vdp structure
ccb6 : a515             [ 3] 	lda gr_scrngeom+gr_char+1
ccb8 : 8537             [ 3] 	sta tmp_clo+1
ccba : a514             [ 3] 	lda gr_scrngeom+gr_char
ccbc : 8536             [ 3] 	sta tmp_clo
AS65 Assembler for R6502 [1.42].                                     Page   97
-------------------------------- bank\bank0.s --------------------------------

                             
                             	; Copy all 8 pages of font (std + alt) data
ccbe : a208             [ 2] 	ldx #8
ccc0 : 2079cc           [ 6] 	jsr gr_copy_mem
ccc3 :                       gr_check_font_copy_done
ccc3 :                       gr_init_geom_done
ccc3 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init_geom
                             ;* initialise geometry entries from X
                             ;* position from base until -1
                             ;****************************************
ccc4 :                       gr_init_geom
                             	; Which geom entry to init = Y
ccc4 : bcd3cc           [ 4] 	ldy gr_scrngeom_base,x
ccc7 : 30fa             [ 3] 	bmi gr_init_geom_done		; Just somewhere with an 
                             	; skip to data and put in A
ccc9 : e8               [ 2] 	inx
ccca : bdd3cc           [ 4] 	lda gr_scrngeom_base,x
                             	; save it in Y
cccd : 991100           [ 5] 	sta gr_scrngeom,y
                             	; next entry
ccd0 : e8               [ 2] 	inx
ccd1 : d0f1             [ 3] 	bne gr_init_geom	; Always
                             	; Hope we don't get here - will crash!
                             
                             ; Geometry initialisation tables
ccd3 :                       gr_scrngeom_base
ccd3 : 1200                  	db gr_ink, 0
ccd5 : 1316                  	db gr_paper, 16+6
ccd7 : 1402                  	db gr_margin, 2
                             	; Not terminated by -1 : continues in to _txt va
                             ;* Geometry for text/lores
ccd9 :                       gr_scrngeom_text
ccd9 : 0000                  	db gr_mode, 0
                             
ccdb : 0300                  	db gr_char,   lo(TEXTCHAR)
ccdd : 04b4                  	db gr_char+1, hi(TEXTCHAR)
                             
ccdf : 0580                  	db gr_text_start,   lo(TEXTSCRN)
cce1 : 06bb                  	db gr_text_start+1, hi(TEXTSCRN)
                             
cce3 : 0828                  	db gr_text_w, 40
cce5 : 091c                  	db gr_text_h, 28
cce7 : ff                    	db -1
                             ;* Geometry for hires
cce8 :                       gr_scrngeom_hires
cce8 : 0001                  	db gr_mode, 1
                             
ccea : 0100                  	db gr_hi_start,   lo(HISCRN)
ccec : 02a0                  	db gr_hi_start+1, hi(HISCRN)
ccee : 0300                  	db gr_char,   lo(HICHAR)
ccf0 : 0498                  	db gr_char+1, hi(HICHAR)
                             
ccf2 : 0568                  	db gr_text_start,   lo(HITEXT)
ccf4 : 06bf                  	db gr_text_start+1, hi(HITEXT)
                             
ccf6 : 1000                  	db gr_hires_x, 0
ccf8 : 1100                  	db gr_hires_y, 0
                             
AS65 Assembler for R6502 [1.42].                                     Page   98
-------------------------------- bank\bank0.s --------------------------------

                             	; Only need to initialise text height, width is 
ccfa : 0903                  	db gr_text_h, 3
                             
ccfc : 0e01                  	db gr_pixmode, 1
ccfe : 0f06                  	db gr_pitch, 6
cd00 : ff                    	db -1
                             
                             
                             
                             ;****************************************
                             ;* gr_init_screen_txt
                             ;* initialise the screen in text mode
                             ;****************************************
cd01 :                       gr_init_screen_txt
cd01 : e60d             [ 5] 	inc vdp_curoff
                             
                             	; Check if font copy needed to 0xb400
cd03 : a9b4             [ 2] 	lda #hi(TEXTCHAR)
cd05 : 20accc           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for text
cd08 : a206             [ 2] 	ldx #gr_scrngeom_text-gr_scrngeom_base
cd0a : 20c4cc           [ 6] 	jsr gr_init_geom
                             
cd0d : 2064d2           [ 6] 	jsr gr_spr_init					; SW Sprites are reset
                             
cd10 : a920             [ 2] 	lda #' '						; Blank is SPACE
cd12 : 8510             [ 3] 	sta vdp_blank
cd14 : 2097cd           [ 6] 	jsr gr_cls
                             
cd17 : c60d             [ 5] 	dec vdp_curoff
                             
cd19 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires
                             ;* Input : X = Colour table fill value
                             ;* initialise the screen in hires mode
                             ;****************************************
cd1a :                       gr_init_hires
cd1a : e60d             [ 5] 	inc vdp_curoff
                             	; Check if font copy needed to 0x9800
cd1c : a998             [ 2] 	lda #hi(HICHAR)
cd1e : 20accc           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for hires
cd21 : a215             [ 2] 	ldx #gr_scrngeom_hires-gr_scrngeom_base
cd23 : 20c4cc           [ 6] 	jsr gr_init_geom
                             
cd26 : a920             [ 2] 	lda #' '						; Blank is SPACE
cd28 : 8510             [ 3] 	sta vdp_blank
cd2a : 2097cd           [ 6] 	jsr gr_cls
                             
                             	; Zero out hires area 0xa000 for 8000 (0x1f40) b
cd2d : a900             [ 2] 	lda #lo(HISCRN)
cd2f : 8532             [ 3] 	sta tmp_alo
cd31 : a9a0             [ 2] 	lda #hi(HISCRN)
cd33 : 8533             [ 3] 	sta tmp_ahi
cd35 : a940             [ 2] 	lda #0x40						; Set bit 6
cd37 : a000             [ 2] 	ldy #0
cd39 : a200             [ 2] 	ldx #0
cd3b :                       vdp_fill_vram_loop
AS65 Assembler for R6502 [1.42].                                     Page   99
-------------------------------- bank\bank0.s --------------------------------

cd3b : 9132             [ 5] 	sta (tmp_alo),y
cd3d : c8               [ 2] 	iny
cd3e : d003             [ 3] 	bne vdp_fill_vram_noinc
cd40 : e633             [ 5] 	inc tmp_ahi
cd42 : e8               [ 2] 	inx
cd43 :                       vdp_fill_vram_noinc
cd43 : e01f             [ 2] 	cpx #hi(0x1f40)			; Reached page count?
cd45 : d0f4             [ 3] 	bne vdp_fill_vram_loop
cd47 : c040             [ 2] 	cpy #lo(0x1f40)			; Reached byte in page?
cd49 : d0f0             [ 3] 	bne vdp_fill_vram_loop
                             
                             	; Set hires attribute in the magic location
cd4b : a91e             [ 2] 	lda #30			; Hires attribute
cd4d : 8ddfbf           [ 4] 	sta 0xbfdf		; Last pos of screen memory
                             
cd50 : c60d             [ 5] 	dec vdp_curoff
cd52 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires_tables
                             ;* Generate the hires tables
                             ;* Do this whilst in hires mode
                             ;****************************************
cd53 :                       gr_init_hires_tables
                             	; Initialise address pointer to start of high re
cd53 : a900             [ 2] 	lda #lo(HISCRN)
cd55 : 8532             [ 3] 	sta tmp_alo
cd57 : a9a0             [ 2] 	lda #hi(HISCRN)
cd59 : 8533             [ 3] 	sta tmp_ahi
                             	; Starting from row zero, do 200 rows
cd5b : a000             [ 2] 	ldy #0
cd5d :                       gr_init_tab_row
                             	; Save low and high bytes of screen address in t
cd5d : a532             [ 3] 	lda tmp_alo
cd5f : 99009c           [ 5] 	sta hires_row_low,y
cd62 : a533             [ 3] 	lda tmp_ahi
cd64 : 99c89c           [ 5] 	sta hires_row_hi,y
                             	; add 40 ready for next row
cd67 : 18               [ 2] 	clc
cd68 : a532             [ 3] 	lda tmp_alo
cd6a : 6928             [ 2] 	adc #40
cd6c : 8532             [ 3] 	sta tmp_alo
                             	_bcc 2
                             
cd70 : e633             [ 5] 	inc tmp_ahi
                             	; Max 200 rows
cd72 : c8               [ 2] 	iny
cd73 : c0c8             [ 2] 	cpy #200
cd75 : d0e6             [ 3] 	bne gr_init_tab_row
                             	; From column 0, do 240 columns
                             	; Mask starts at 0x20, when shifts to 0 then
                             	; the column increments
cd77 : a920             [ 2] 	lda #0x20
cd79 : 8534             [ 3] 	sta tmp_blo			; Pixel mask
cd7b : a200             [ 2] 	ldx #0				; Pixel column
cd7d : a000             [ 2] 	ldy #0				; Byte column
cd7f :                       gr_init_tab_col
                             	; Save current mask and column
cd7f : a534             [ 3] 	lda tmp_blo
cd81 : 9d809e           [ 5] 	sta hires_mask,x
cd84 : 98               [ 2] 	tya
cd85 : 9d909d           [ 5] 	sta hires_col,x
AS65 Assembler for R6502 [1.42].                                     Page  100
-------------------------------- bank\bank0.s --------------------------------

                             	; shift mask, if zero then increment col and res
cd88 : 4634             [ 5] 	lsr tmp_blo
cd8a : d005             [ 3] 	bne gr_init_tab_col_skip
cd8c : a920             [ 2] 	lda #0x20
cd8e : 8534             [ 3] 	sta tmp_blo
cd90 : c8               [ 2] 	iny
cd91 :                       gr_init_tab_col_skip
cd91 : e8               [ 2] 	inx
cd92 : e0f0             [ 2] 	cpx #240
cd94 : d0e9             [ 3] 	bne gr_init_tab_col
cd96 : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
                             ;* gr_cls
                             ;* Clear the text screen
                             ;****************************************
cd97 :                       gr_cls
cd97 : e60d             [ 5] 	inc vdp_curoff
                             	; Set screen address for text mode
cd99 : a516             [ 3] 	lda gr_scrngeom+gr_text_start
cd9b : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cd9d : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
cd9f : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
cda1 : a61a             [ 3] 	ldx gr_scrngeom+gr_text_h		; Count of rows to cl
                             
                             	; X and Y count bytes to fill
cda3 :                       gr_cls_row
cda3 : a000             [ 2] 	ldy #0							; Count of columns
cda5 : a525             [ 3] 	lda gr_scrngeom+gr_margin		; Is there a margin?
cda7 : f00a             [ 3] 	beq gr_cls_skip_marg
cda9 : a524             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
cdab : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cdad : c8               [ 2] 	iny
cdae : a523             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
cdb0 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cdb2 : c8               [ 2] 	iny
cdb3 :                       gr_cls_skip_marg
cdb3 : a510             [ 3] 	lda vdp_blank
cdb5 : 850f             [ 3] 	sta vdp_curval					; Under cursor is also blank
cdb7 :                       gr_cls_col
cdb7 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cdb9 : c8               [ 2] 	iny
cdba : c419             [ 3] 	cpy gr_scrngeom+gr_text_w		; Done all columns?
cdbc : d0f9             [ 3] 	bne gr_cls_col
                             	; Update pointer
cdbe : 18               [ 2] 	clc
cdbf : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
cdc1 : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
cdc3 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
cdc7 : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
cdc9 : ca               [ 2] 	dex								; 1 row done
cdca : d0d7             [ 3] 	bne gr_cls_row					; Done all rows?
                             
                             	; set cursror position to top left
cdcc : a510             [ 3] 	lda vdp_blank
cdce : 850f             [ 3] 	sta vdp_curval
cdd0 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
AS65 Assembler for R6502 [1.42].                                     Page  101
-------------------------------- bank\bank0.s --------------------------------

cdd2 : a000             [ 2] 	ldy #0
cdd4 : 38               [ 2] 	sec								; Init mode
cdd5 : 2005ce           [ 6] 	jsr gr_set_cur_init
                             
cdd8 : c60d             [ 5] 	dec vdp_curoff
                             
cdda : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_getXY_base
                             ;* Get base screen address using Y coord only
                             ;* Input : X = y coord
                             ;* Output :	gr_geom_tmp updated with base
                             ;* Regs affected : A
                             ;****************************************
cddb :                       gr_getXY_base
                             	; Find y offset using **X register**
cddb : 18               [ 2] 	clc
cddc : bd2cd2           [ 4] 	lda gr_offset_40lo,x
cddf : 6516             [ 3] 	adc gr_scrngeom+gr_text_start
cde1 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cde3 : bd48d2           [ 4] 	lda gr_offset_40hi,x
cde6 : 6517             [ 3] 	adc gr_scrngeom+gr_text_start+1
cde8 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
                             	; A = high byte of base address
cdea : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_plot
                             ;* Write a byte in the screen pos
                             ;* Input :	Y,X = coord, A = Byte to put
                             ;*			X = Y COORDINATE
                             ;*			Y = X COORDINATE!!
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cdeb :                       gr_plot
cdeb : 48               [ 3] 	pha					; Save byte to put
cdec : 20dbcd           [ 6] 	jsr gr_getXY_base	; base addre
cdef : 68               [ 4] 	pla					; Get byte to put
cdf0 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cdf2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_put
                             ;* Write a byte in the current cursor position
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cdf3 :                       gr_put
cdf3 : e60d             [ 5] 	inc vdp_curoff		; Disable cusror
cdf5 : 850f             [ 3] 	sta vdp_curval		; Update cursor value
                             	; Base address plus X offset
cdf7 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
cdf9 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
cdfb : c60d             [ 5] 	dec vdp_curoff		; Allow cursor flashing
cdfd : 60               [ 6] 	rts
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  102
-------------------------------- bank\bank0.s --------------------------------

                             ;* gr_get
                             ;* Get the byte in the screen pos
                             ;* Input : Y,X = coord (**Y = X coordinate!!)
                             ;* Output : X,Y = address, A = peeked byte
                             ;* Regs affected : All
                             ;****************************************
cdfe :                       gr_get
cdfe : 20dbcd           [ 6] 	jsr gr_getXY_base	; Base address
ce01 : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y
ce03 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_set_cur
                             ;* Set the cursor position
                             ;* Input : X, Y = position
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce04 :                       gr_set_cur
ce04 : 18               [ 2] 	clc
ce05 :                       gr_set_cur_init
ce05 : e60d             [ 5] 	inc vdp_curoff				; Disable cursor
                             
ce07 : b00e             [ 3] 	bcs gr_set_cur_skip			; Skip restore if C=1
ce09 : 8632             [ 3] 	stx tmp_alo
ce0b : 8433             [ 3] 	sty tmp_ahi
                             	; First restore what is under the cursor
                             	; in case cursor is ON
ce0d : 8426             [ 3] 	sty gr_scrngeom+gr_geom_tmp
ce0f : a50f             [ 3] 	lda vdp_curval
ce11 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
ce13 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
ce15 : a426             [ 3] 	ldy gr_scrngeom+gr_geom_tmp
ce17 :                       gr_set_cur_skip
                             	; Save new cursor position
ce17 : 861b             [ 3] 	stx gr_scrngeom+gr_cur_x
ce19 : 841c             [ 3] 	sty gr_scrngeom+gr_cur_y
                             
                             	; Now calculate the new cursor vram address
ce1b : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_y
ce1d : 20dbcd           [ 6] 	jsr gr_getXY_base
                             	; Update pointer in tmp, A already has high byte
ce20 : 851e             [ 3] 	sta gr_scrngeom+gr_cur_ptr+1
ce22 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
ce24 : 851d             [ 3] 	sta gr_scrngeom+gr_cur_ptr
                             	; Read screen at this position, offset with X co
ce26 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
ce28 : b11d             [ 5] 	lda (gr_scrngeom+gr_cur_ptr),y
ce2a : 850f             [ 3] 	sta vdp_curval
                             	; Reset cursor so it's visible
ce2c : a900             [ 2] 	lda #0
ce2e : 850e             [ 3] 	sta vdp_curstat
ce30 : a901             [ 2] 	lda #1
ce32 : 850c             [ 3] 	sta vdp_curcnt
                             
ce34 : c60d             [ 5] 	dec vdp_curoff
                             
ce36 : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  103
-------------------------------- bank\bank0.s --------------------------------

                             ;* gr_scroll_up
                             ;* Scroll screen one line up
                             ;****************************************
ce37 :                       gr_scroll_up
ce37 : e60d             [ 5] 	inc vdp_curoff
                             
                             	; Set source in a and dest in b
                             	; b is first line, source is second
ce39 : 18               [ 2] 	clc
ce3a : a516             [ 3] 	lda gr_scrngeom+gr_text_start
ce3c : 8534             [ 3] 	sta tmp_blo
ce3e : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
ce40 : 8532             [ 3] 	sta tmp_alo
ce42 : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
ce44 : 8535             [ 3] 	sta tmp_bhi
ce46 : 6900             [ 2] 	adc #0
ce48 : 8533             [ 3] 	sta tmp_ahi
                             
                             	; Restore what was underneath cursor
ce4a : a50f             [ 3] 	lda vdp_curval
ce4c : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
ce4e : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
                             	; x = lines to scroll (1 less than screen height
ce50 : a61a             [ 3] 	ldx gr_scrngeom+gr_text_h
ce52 : ca               [ 2] 	dex
                             
ce53 :                       gr_scroll_cpy_ln
                             	; Start from right hand edge (easier)
ce53 : a419             [ 3] 	ldy gr_scrngeom+gr_text_w
ce55 : 88               [ 2] 	dey
ce56 :                       gr_scroll_char
                             	; get char from source and copy to dest
ce56 : b132             [ 5] 	lda (tmp_alo),y
ce58 : 9134             [ 5] 	sta (tmp_blo),y
ce5a : 88               [ 2] 	dey
ce5b : 10f9             [ 3] 	bpl gr_scroll_char
                             
                             	; Update source address
ce5d : 18               [ 2] 	clc
ce5e : a532             [ 3] 	lda tmp_alo
ce60 : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
ce62 : 8532             [ 3] 	sta tmp_alo
                             	_bcc 2
                             
ce66 : e633             [ 5] 	inc tmp_ahi
                             	; Update destination address
ce68 : 18               [ 2] 	clc
ce69 : a534             [ 3] 	lda tmp_blo
ce6b : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
ce6d : 8534             [ 3] 	sta tmp_blo
                             	_bcc 2
                             
ce71 : e635             [ 5] 	inc tmp_bhi
                             
                             	; One line complete
ce73 : ca               [ 2] 	dex
ce74 : d0dd             [ 3] 	bne gr_scroll_cpy_ln
                             
                             	; Source is pointing at last line
                             	; Last line needs filling
ce76 : a000             [ 2] 	ldy #0							; Start from left
AS65 Assembler for R6502 [1.42].                                     Page  104
-------------------------------- bank\bank0.s --------------------------------

ce78 : a525             [ 3] 	lda gr_scrngeom+gr_margin		; Margin?
ce7a : f00a             [ 3] 	beq gr_scroll_marg				; Skip if not
ce7c : a524             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
ce7e : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
ce80 : c8               [ 2] 	iny
ce81 : a523             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
ce83 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
ce85 : c8               [ 2] 	iny
ce86 :                       gr_scroll_marg
                             	; Needs to be filled with blank
ce86 : a510             [ 3] 	lda vdp_blank
ce88 : 850f             [ 3] 	sta vdp_curval			; Also this is the cursor value
ce8a :                       gr_scroll_erase_ln
ce8a : 9134             [ 5] 	sta (tmp_blo),y
ce8c : c8               [ 2] 	iny
ce8d : c419             [ 3] 	cpy gr_scrngeom+gr_text_w
ce8f : d0f9             [ 3] 	bne gr_scroll_erase_ln
                             
ce91 : c60d             [ 5] 	dec vdp_curoff
                             
ce93 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_new_ln
                             ;* Carry out a new line
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ce94 :                       gr_new_ln
                             	; X pos is zero, Y needs to increment
ce94 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
ce96 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
ce98 : c8               [ 2] 	iny
ce99 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h
ce9b : d00c             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
                             	; Common routine also used by cursor right
ce9d :                       gr_scroll_routine
ce9d : 88               [ 2] 	dey
ce9e : 8a               [ 2] 	txa
ce9f : 48               [ 3] 	pha
cea0 : 98               [ 2] 	tya
cea1 : 48               [ 3] 	pha
cea2 : 2037ce           [ 6] 	jsr gr_scroll_up
cea5 : 68               [ 4] 	pla
cea6 : a8               [ 2] 	tay
cea7 : 68               [ 4] 	pla
cea8 : aa               [ 2] 	tax
cea9 :                       gr_nl_skip_nl
cea9 : 4c04ce           [ 3] 	jmp gr_set_cur
                             
                             
                             ;****************************************
                             ;* gr_cur_right
                             ;* Advance cursor position
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ceac :                       gr_cur_right
                             	; Load cursor x,y position
AS65 Assembler for R6502 [1.42].                                     Page  105
-------------------------------- bank\bank0.s --------------------------------

ceac : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
ceae : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
ceb0 : e8               [ 2] 	inx
                             	; Check if reached past edge of line
ceb1 : e419             [ 3] 	cpx gr_scrngeom+gr_text_w
ceb3 : d0f4             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then wrap to next line
ceb5 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
ceb7 : c8               [ 2] 	iny
ceb8 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h
ceba : f0e1             [ 3] 	beq gr_scroll_routine		; Common scroll routine
cebc : d0eb             [ 3] 	bne gr_nl_skip_nl			; Common set cursor
                             
                             ;****************************************
                             ;* gr_cur_left
                             ;* Advance cursor left
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cebe :                       gr_cur_left
                             	; Load cursor x,y position, load X last to check
cebe : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
cec0 : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
                             
                             	; Decrement screen pointer
                             	; Move cursor left
cec2 : e425             [ 3] 	cpx gr_scrngeom+gr_margin	; Already at left marg
cec4 : d007             [ 3] 	bne gr_cur_skip_at_left		; No, then just go left
cec6 : c000             [ 2] 	cpy #0						; Else check if can wrap up
cec8 : f007             [ 3] 	beq gr_cur_skip_at_tl
ceca : 88               [ 2] 	dey
cecb : a619             [ 3] 	ldx gr_scrngeom+gr_text_w
cecd :                       gr_cur_skip_at_left
cecd : ca               [ 2] 	dex
cece : 4c04ce           [ 3] 	jmp gr_set_cur
                             
ced1 :                       gr_cur_skip_at_tl
ced1 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_up
                             ;* Advance cursor up
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
ced2 :                       gr_cur_up
                             	; Load cursor x,y position, load Y last to check
ced2 : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
ced4 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	; if y==0 then don't do anything
ced6 : f0f9             [ 3] 	beq gr_cur_skip_at_tl	; Just somewhere with an r
ced8 : 88               [ 2] 	dey
ced9 : 4c04ce           [ 3] 	jmp gr_set_cur
                             
                             ;****************************************
                             ;* gr_cur_down
                             ;* Advance cursor down
                             ;* Input : None
AS65 Assembler for R6502 [1.42].                                     Page  106
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cedc :                       gr_cur_down
                             	; Load cursor x,y position
cedc : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
cede : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
cee0 : c8               [ 2] 	iny
                             	; If already at  bottom then don't do anything
cee1 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h			
cee3 : f0ec             [ 3] 	beq gr_cur_skip_at_tl				; Just somewhere with a
cee5 : 2004ce           [ 6] 	jsr gr_set_cur
                             
cee8 :                       gr_cur_skip_at_bot
cee8 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_del
                             ;* Action del
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cee9 :                       gr_del
cee9 : 20bece           [ 6] 	jsr gr_cur_left
ceec : a920             [ 2] 	lda #' '							; Put a space
ceee : 4cf3cd           [ 3] 	jmp gr_put
                             
                             ;****************************************
                             ;* gr_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=0 means valid code
                             ;****************************************
cef1 :                       gr_get_key
                             	; save X,Y but A is ok to trample
cef1 : 8a               [ 2] 	txa
cef2 : 48               [ 3] 	pha
cef3 : 98               [ 2] 	tya
cef4 : 48               [ 3] 	pha
cef5 :                       gr_get_key_2
cef5 : 08               [ 3] 	php
cef6 : 20b8c8           [ 6] 	jsr kb_get_key
cef9 : 9006             [ 4] 	bcc gr_key_check_key
cefb : 28               [ 4] 	plp									; Get async pref
cefc : b0f7             [ 3] 	bcs	gr_get_key_2					; Keep checking if sync
cefe : 38               [ 2] 	sec
ceff : b019             [ 4] 	bcs gr_key_tidy_up					; Finish if not
cf01 :                       gr_key_check_key						; Check the key pressed
cf01 : c901             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
cf03 : d004             [ 3] 	bne gr_key_skip_copy
cf05 : a50f             [ 3] 	lda vdp_curval						; If yes the get char under 
cf07 : b00f             [ 3] 	bcs gr_key_got_key					; Always branches (n=1, c
cf09 :                       gr_key_skip_copy
cf09 : c914             [ 2] 	cmp #CTRL_CAPS
cf0b : d00b             [ 3] 	bne gr_key_got_key
cf0d : a52c             [ 3] 	lda kb_stat							; Toggle caps bit
cf0f : 4901             [ 2] 	eor #KB_CAPSLK
cf11 : 852c             [ 3] 	sta kb_stat
cf13 : 28               [ 4] 	plp									; Get back synchronous pref
cf14 : b0df             [ 4] 	bcs gr_get_key_2					; And check again for sync
cf16 : 900b             [ 3] 	bcc gr_key_no_key					; Else no key
AS65 Assembler for R6502 [1.42].                                     Page  107
-------------------------------- bank\bank0.s --------------------------------

cf18 :                       gr_key_got_key
cf18 : 28               [ 4] 	plp
cf19 : 18               [ 2] 	clc									; Ensure C=0 for valid key
cf1a :                       gr_key_tidy_up
                             	; restore X,Y but don't lose A
cf1a : 8538             [ 3] 	sta tmp_d
cf1c : 68               [ 4] 	pla
cf1d : a8               [ 2] 	tay
cf1e : 68               [ 4] 	pla
cf1f : aa               [ 2] 	tax
cf20 : a538             [ 3] 	lda tmp_d
cf22 : 60               [ 6] 	rts
cf23 :                       gr_key_no_key
cf23 : 28               [ 4] 	plp
cf24 : 38               [ 2] 	sec									; Ensure C=1 for invalid key
cf25 : b0f3             [ 3] 	bcs gr_key_tidy_up					; Always branches
                             
                             ;****************************************
                             ;* gr_put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cf27 :                       gr_put_byte
                             	_pushAXY
                             
cf30 : 2039cf           [ 6] 	jsr gr_put_byte_low
                             	_pullAXY
                             
cf38 :                       gr_no_special
cf38 : 60               [ 6] 	rts
                             
cf39 :                       gr_put_byte_low
cf39 : c97f             [ 2] 	cmp #UTF_DEL			; Del key
cf3b : f004             [ 3] 	beq gr_process_special
cf3d : c920             [ 2] 	cmp #32					; Special char?
cf3f : b01b             [ 3] 	bcs gr_printable		; >=32 == carry clear
cf41 :                       gr_process_special
                             	; Else find special behaviour to do
cf41 : a2ff             [ 2] 	ldx #-1
cf43 : 8532             [ 3] 	sta tmp_alo
cf45 :                       gr_special_loop
cf45 : e8               [ 2] 	inx
cf46 : bd62cf           [ 4] 	lda gr_special_ch,x
cf49 : f0ed             [ 3] 	beq gr_no_special		; Somewhere with an rts!
cf4b : c532             [ 3] 	cmp tmp_alo
cf4d : d0f6             [ 3] 	bne gr_special_loop
cf4f : bd6bcf           [ 4] 	lda gr_special_fn_lo,x
cf52 : 8532             [ 3] 	sta tmp_alo
cf54 : bd73cf           [ 4] 	lda gr_special_fn_hi,x
cf57 : 8533             [ 3] 	sta tmp_ahi
cf59 : 6c3200           [ 6] 	jmp (tmp_alo)
                             
                             	;	Normal caracter processing here.
cf5c :                       gr_printable
                             	; Place in current position and move right
cf5c : 20f3cd           [ 6] 	jsr gr_put
cf5f : 4cacce           [ 3] 	jmp gr_cur_right
                             
cf62 :                       gr_special_ch
cf62 : 0d                    	db UTF_CR
AS65 Assembler for R6502 [1.42].                                     Page  108
-------------------------------- bank\bank0.s --------------------------------

cf63 : 7f                    	db UTF_DEL
cf64 : 08                    	db CRSR_LEFT
cf65 : 09                    	db CRSR_RIGHT
cf66 : 0b                    	db CRSR_UP
cf67 : 0a                    	db CRSR_DOWN
cf68 : 0c                    	db UTF_FF
cf69 : 07                    	db UTF_BEL
cf6a : 00                    	db 0
                             
cf6b :                       gr_special_fn_lo
cf6b : 94                    	db lo(gr_new_ln)
cf6c : e9                    	db lo(gr_del)
cf6d : be                    	db lo(gr_cur_left)
cf6e : ac                    	db lo(gr_cur_right)
cf6f : d2                    	db lo(gr_cur_up)
cf70 : dc                    	db lo(gr_cur_down)
cf71 : 97                    	db lo(gr_cls)
cf72 : 2e                    	db lo(init_snd)
                             
cf73 :                       gr_special_fn_hi
cf73 : ce                    	db hi(gr_new_ln)
cf74 : ce                    	db hi(gr_del)
cf75 : ce                    	db hi(gr_cur_left)
cf76 : ce                    	db hi(gr_cur_right)
cf77 : ce                    	db hi(gr_cur_up)
cf78 : ce                    	db hi(gr_cur_down)
cf79 : cd                    	db hi(gr_cls)
cf7a : d4                    	db hi(init_snd)
                             
                             ; Special command to print to the screen
                             ; Y,A=Message, zero terminated
cf7b :                       gr_print_msg
cf7b : 8449             [ 3] 	sty num_tmp
cf7d : 854a             [ 3] 	sta num_tmp+1
cf7f : a000             [ 2] 	ldy #0
cf81 :                       gr_print_msg_loop
cf81 : b149             [ 5] 	lda (num_tmp),y
cf83 : f006             [ 3] 	beq gr_print_msg_done
cf85 : 2027cf           [ 6] 	jsr gr_put_byte
cf88 : c8               [ 2] 	iny
cf89 : d0f6             [ 3] 	bne gr_print_msg_loop
cf8b :                       gr_print_msg_done
cf8b : a54a             [ 3] 	lda num_tmp+1
cf8d : a449             [ 3] 	ldy num_tmp
cf8f : 60               [ 6] 	rts
                             
                             ;******* HIRES STUFF *****
                             
                             
                             ;****************************************
                             ;* gr_hcode
                             ;* Plot bytecode at hires X,Y coordinates with co
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cf90 :                       gr_hcode
cf90 : 48               [ 3] 	pha
                             	; Set up destination position tmpalo,hi and Y
cf91 : 204cd0           [ 6] 	jsr gr_point_setup
cf94 : a208             [ 2] 	ldx #8				; Always do 8 rows like a character
cf96 :                       gr_hcode_loop
AS65 Assembler for R6502 [1.42].                                     Page  109
-------------------------------- bank\bank0.s --------------------------------

cf96 : 68               [ 4] 	pla 				; Get the code to place
cf97 : 48               [ 3] 	pha					; Need to save it back
cf98 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y		; Store it in d
cf9a : 18               [ 2] 	clc
cf9b : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp			; Update base poin
cf9d : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
cf9f : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
cfa3 : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
cfa5 : ca               [ 2] 	dex
cfa6 : d0ee             [ 3] 	bne gr_hcode_loop
cfa8 : 68               [ 4] 	pla
cfa9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_hchar
                             ;* Plot character to hires X,Y coordinates with c
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cfaa :                       gr_hchar
                             	; If char code < 32 then plot attribute
cfaa : c91f             [ 2] 	cmp #31
cfac : 90e2             [ 3] 	bcc gr_hcode
                             	; Multiply char code by 8
                             	; and add to char font base
                             	; tmp_clo contains base address
cfae : 0a               [ 2] 	asl a
cfaf : 2637             [ 5] 	rol tmp_chi
cfb1 : 0a               [ 2] 	asl a
cfb2 : 2637             [ 5] 	rol tmp_chi
cfb4 : 0a               [ 2] 	asl a
cfb5 : 2637             [ 5] 	rol tmp_chi
cfb7 : 18               [ 2] 	clc
cfb8 : 6514             [ 3] 	adc gr_scrngeom+gr_char
cfba : 8536             [ 3] 	sta tmp_clo
cfbc : a537             [ 3] 	lda tmp_chi
cfbe : 2907             [ 2] 	and #7
cfc0 : 6515             [ 3] 	adc gr_scrngeom+gr_char+1
cfc2 : 8537             [ 3] 	sta tmp_chi
                             
                             	; Set up destination position
cfc4 : 204cd0           [ 6] 	jsr gr_point_setup
                             	; tmp needs to contains address including column
cfc7 : 18               [ 2] 	clc
cfc8 : 98               [ 2] 	tya
cfc9 : 6526             [ 3] 	adc gr_scrngeom+gr_geom_tmp
cfcb : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
cfcf : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
                             
cfd1 : a528             [ 3] 	lda gr_scrngeom+gr_geom_tmp2		; Get the mask
cfd3 : a207             [ 2] 	ldx #7
cfd5 :                       gr_hchar_mask							; Calculate how many shifts t
cfd5 : ca               [ 2] 	dex
cfd6 : 4a               [ 2] 	lsr a
cfd7 : d0fc             [ 3] 	bne gr_hchar_mask
cfd9 : 8628             [ 3] 	stx gr_scrngeom+gr_geom_tmp2		; number between 1
                             
AS65 Assembler for R6502 [1.42].                                     Page  110
-------------------------------- bank\bank0.s --------------------------------

                             	; copy font bytes and shift the required number 
                             	; go from bottom to top as data gets stored on t
cfdb : a007             [ 2] 	ldy #7
cfdd :                       gr_hchar_getfont
cfdd : b136             [ 5] 	lda (tmp_clo),y
cfdf : 853d             [ 3] 	sta ztmp_24
cfe1 : a900             [ 2] 	lda #0
cfe3 : 853e             [ 3] 	sta ztmp_24+1
                             
                             	; shift the right number of times
cfe5 : a628             [ 3] 	ldx gr_scrngeom+gr_geom_tmp2
cfe7 :                       gr_hchar_rot1bit
cfe7 : ca               [ 2] 	dex
cfe8 : f00d             [ 3] 	beq gr_hchar_rot1bit_nx
cfea : 463d             [ 5] 	lsr ztmp_24					; Rotate left hand side
cfec : a53e             [ 3] 	lda ztmp_24+1				; Rotate right hand side
cfee : 9002             [ 3] 	bcc gr_hchar_rot1bit_bcc
cff0 : 0940             [ 2] 	ora #0x40					; account for 6 bits per byte
cff2 :                       gr_hchar_rot1bit_bcc
cff2 : 4a               [ 2] 	lsr a
cff3 : 853e             [ 3] 	sta ztmp_24+1
cff5 : 10f0             [ 3] 	bpl gr_hchar_rot1bit		; Always as lsr sets N=0
cff7 :                       gr_hchar_rot1bit_nx
cff7 : a53e             [ 3] 	lda ztmp_24+1				; Get RHS
cff9 : 48               [ 3] 	pha							; Push RHS on to stack
cffa : a53d             [ 3] 	lda ztmp_24					; Get LHS
cffc : 48               [ 3] 	pha							; Push that too - LH gets pulled first
cffd : 88               [ 2] 	dey							; Bottom to to lines
cffe : 10dd             [ 3] 	bpl gr_hchar_getfont
                             
                             	; Now copy shift source to destination, accounti
d000 : a208             [ 2] 	ldx #8
d002 :                       gr_hchar_copyline
d002 : a41f             [ 3] 	ldy gr_scrngeom+gr_pixmode	; Mode determines how
d004 : f022             [ 3] 	beq gr_hchar_copyline_erase
d006 : 3010             [ 3] 	bmi gr_hchar_copyline_eor
                             
                             	; Mode = ~Z : OR
d008 : a000             [ 2] 	ldy #0						; Get lh side source
d00a : 68               [ 4] 	pla
d00b : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d00d : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d00f : c8               [ 2] 	iny							; Get rh side source
d010 : 68               [ 4] 	pla
d011 : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d013 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d015 : 4c3dd0           [ 3] 	jmp gr_hchar_copyline_nx
d018 :                       gr_hchar_copyline_eor
                             	; Mode = N : EOR
d018 : a000             [ 2] 	ldy #0						; Get lh side source
d01a : 68               [ 4] 	pla
d01b : 5126             [ 5] 	eor (gr_scrngeom+gr_geom_tmp),y
d01d : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d01f : c8               [ 2] 	iny							; Get rh side source
d020 : 68               [ 4] 	pla
d021 : 5126             [ 5] 	eor (gr_scrngeom+gr_geom_tmp),y
d023 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d025 : 4c3dd0           [ 3] 	jmp gr_hchar_copyline_nx
d028 :                       gr_hchar_copyline_erase
                             	; Mode = Z : erase
d028 : a000             [ 2] 	ldy #0						; Get lh side source
d02a : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  111
-------------------------------- bank\bank0.s --------------------------------

d02b : 853d             [ 3] 	sta ztmp_24
d02d : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d02f : 453d             [ 3] 	eor ztmp_24
d031 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d033 : c8               [ 2] 	iny							; Get rh side source
d034 : 68               [ 4] 	pla
d035 : 853d             [ 3] 	sta ztmp_24
d037 : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d039 : 453d             [ 3] 	eor ztmp_24
d03b : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d03d :                       gr_hchar_copyline_nx
d03d : 18               [ 2] 	clc							; Next address
d03e : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
d040 : 6928             [ 2] 	adc #40
d042 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
d046 : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
d048 : ca               [ 2] 	dex
d049 : d0b7             [ 3] 	bne gr_hchar_copyline
d04b : 60               [ 6] 	rts							; Done after 8 lines
                             
                             ;****************************************
                             ;* gr_point_setup
                             ;* Calculate information about a pixel location
                             ;* Input : X,Y = coord
                             ;* Output : None
                             ;* Regs affected :
                             ;* gr_geom_tmp contains the row base address
                             ;* gr_geom_tmp2 contains the mask
                             ;* A contains the mask
                             ;* X untouched
                             ;* Y contains column offet from base address
                             ;****************************************
d04c :                       gr_point_setup
                             	; Get row address
d04c : b9009c           [ 4] 	lda hires_row_low,y
d04f : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d051 : b9c89c           [ 4] 	lda hires_row_hi,y
d054 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             	; Get the pixel mask
d056 : bd809e           [ 4] 	lda hires_mask,x
d059 : 8528             [ 3] 	sta gr_scrngeom+gr_geom_tmp2
                             	; Get the column offset to Y
d05b : bc909d           [ 4] 	ldy hires_col,x
d05e : 60               [ 6] 	rts
                             
d05f :                       gr_set_hires_cur
d05f : 8621             [ 3] 	stx gr_scrngeom+gr_hires_x
d061 : 8422             [ 3] 	sty gr_scrngeom+gr_hires_y
d063 : 60               [ 6] 	rts
                             
                             ;* Get pixel value at X,Y in to A
d064 :                       gr_pixel
d064 : 204cd0           [ 6] 	jsr gr_point_setup				; Set up mask and addresse
d067 : 3126             [ 5] 	and (gr_scrngeom+gr_geom_tmp),y	; And with scree
d069 : 60               [ 6] 	rts
                             
                             ;* Plot a point based on X,Y coordinates
d06a :                       gr_point
d06a : e0f0             [ 2] 	cpx #240						; Check bounds
d06c : b02c             [ 3] 	bcs gr_point_done
AS65 Assembler for R6502 [1.42].                                     Page  112
-------------------------------- bank\bank0.s --------------------------------

d06e : c0c8             [ 2] 	cpy #200
d070 : b028             [ 3] 	bcs gr_point_done
                             
                             	;** FOR SPEED COPYING THE POINT SETUP ROUTINE **
                             	;** OBVS MAKE SURE THIS REFLECTS ANY POINT SETUP
                             	; Get row address
d072 : b9009c           [ 4] 	lda hires_row_low,y
d075 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d077 : b9c89c           [ 4] 	lda hires_row_hi,y
d07a : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             	; Get the pixel mask
d07c : bd809e           [ 4] 	lda hires_mask,x
d07f : 8528             [ 3] 	sta gr_scrngeom+gr_geom_tmp2
                             	; Get the column offset to Y
d081 : bc909d           [ 4] 	ldy hires_col,x
                             
                             ;* Plot a point based on gr_geom_tmp base, Y offs
d084 : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y	; Get screen byt
d086 : c920             [ 2] 	cmp #32							; If less than 32 (i.e. an attribu
d088 : b002             [ 3] 	bcs gr_point_skip_attr
d08a : a940             [ 2] 	lda #64							; then make it a normal cell (else
d08c :                       gr_point_skip_attr
d08c : a61f             [ 3] 	ldx gr_scrngeom+gr_pixmode		; Look at the mode
d08e : 3006             [ 3] 	bmi gr_point_eor				; If eor mode then go and wr
d090 : 0528             [ 3] 	ora gr_scrngeom+gr_geom_tmp2	; Or with MASK
d092 : e000             [ 2] 	cpx #0							; But if zero mode then eor
d094 : d002             [ 3] 	bne gr_point_write
d096 :                       gr_point_eor
d096 : 4528             [ 3] 	eor gr_scrngeom+gr_geom_tmp2	; EOR with MASK
d098 :                       gr_point_write
d098 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d09a :                       gr_point_done
d09a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_circle
                             ;* Draw a circle centre x0,y0, radius r
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = r
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d09b :                       gr_circle
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003d =                       grc_x0 	= (num_a)
003e =                       grc_y0 	= (num_a+1)
003f =                       grc_r 	= (num_a+2)
0040 =                       grc_x 	= (num_a+3)
0042 =                       grc_y	= (num_b+1)
0043 =                       grc_d	= (num_b+2)
                             
                             	;x = radius
d09b : a53f             [ 3] 	lda grc_r
d09d : 8540             [ 3] 	sta grc_x
                             	;decision = 1 - x
d09f : a900             [ 2] 	lda #0
                             	;y = 0
d0a1 : 8542             [ 3] 	sta grc_y
d0a3 : 18               [ 2] 	clc			; A=0 so CLC subtracts 1 :-)
d0a4 : e540             [ 3] 	sbc grc_x
AS65 Assembler for R6502 [1.42].                                     Page  113
-------------------------------- bank\bank0.s --------------------------------

d0a6 : 8543             [ 3] 	sta grc_d
d0a8 :                       gr_circle_plot
                             	;while(x >= y)
d0a8 : a540             [ 3] 	lda grc_x
d0aa : c542             [ 3] 	cmp grc_y
d0ac : 902a             [ 3] 	bcc gr_circle_done
                             	;plot 8 points on current x,y
d0ae : 20d9d0           [ 6] 	jsr gr_circle_points
                             	;y++
d0b1 : e642             [ 5] 	inc grc_y
                             	;if d<=0
d0b3 : a543             [ 3] 	lda grc_d
d0b5 : f014             [ 3] 	beq gr_circle_d_lte0
d0b7 : 3012             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
d0b9 : c640             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
d0bb : a542             [ 3] 	lda grc_y
d0bd : 38               [ 2] 	sec
d0be : e540             [ 3] 	sbc grc_x
d0c0 : 0a               [ 2] 	asl a
d0c1 : 18               [ 2] 	clc
d0c2 : 6901             [ 2] 	adc #1
d0c4 : 6543             [ 3] 	adc grc_d
d0c6 : 8543             [ 3] 	sta grc_d
d0c8 : 4ca8d0           [ 3] 	jmp gr_circle_plot
d0cb :                       gr_circle_d_lte0
                             	;decision += 2 * y + 1
d0cb : a542             [ 3] 	lda grc_y
d0cd : 0a               [ 2] 	asl a
d0ce : 18               [ 2] 	clc
d0cf : 6901             [ 2] 	adc #1
d0d1 : 6543             [ 3] 	adc grc_d
d0d3 : 8543             [ 3] 	sta grc_d
d0d5 : 4ca8d0           [ 3] 	jmp gr_circle_plot
d0d8 :                       gr_circle_done
d0d8 : 60               [ 6] 	rts
d0d9 :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
d0d9 : a540             [ 3] 	lda grc_x
d0db : 18               [ 2] 	clc
d0dc : 653d             [ 3] 	adc grc_x0
d0de : aa               [ 2] 	tax
d0df : a542             [ 3] 	lda grc_y
d0e1 : 18               [ 2] 	clc
d0e2 : 653e             [ 3] 	adc grc_y0
d0e4 : a8               [ 2] 	tay
d0e5 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
d0e8 : a542             [ 3] 	lda grc_y
d0ea : 18               [ 2] 	clc
d0eb : 653d             [ 3] 	adc grc_x0
d0ed : aa               [ 2] 	tax
d0ee : a540             [ 3] 	lda grc_x
d0f0 : 18               [ 2] 	clc
d0f1 : 653e             [ 3] 	adc grc_y0
d0f3 : a8               [ 2] 	tay
d0f4 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
AS65 Assembler for R6502 [1.42].                                     Page  114
-------------------------------- bank\bank0.s --------------------------------

d0f7 : a53d             [ 3] 	lda grc_x0
d0f9 : 38               [ 2] 	sec
d0fa : e540             [ 3] 	sbc grc_x
d0fc : aa               [ 2] 	tax
d0fd : a542             [ 3] 	lda grc_y
d0ff : 18               [ 2] 	clc
d100 : 653e             [ 3] 	adc grc_y0
d102 : a8               [ 2] 	tay
d103 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
d106 : a53d             [ 3] 	lda grc_x0
d108 : 38               [ 2] 	sec
d109 : e542             [ 3] 	sbc grc_y
d10b : aa               [ 2] 	tax
d10c : a540             [ 3] 	lda grc_x
d10e : 18               [ 2] 	clc
d10f : 653e             [ 3] 	adc grc_y0
d111 : a8               [ 2] 	tay
d112 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
d115 : a53d             [ 3] 	lda grc_x0
d117 : 38               [ 2] 	sec
d118 : e540             [ 3] 	sbc grc_x
d11a : aa               [ 2] 	tax
d11b : a53e             [ 3] 	lda grc_y0
d11d : 38               [ 2] 	sec
d11e : e542             [ 3] 	sbc grc_y
d120 : a8               [ 2] 	tay
d121 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
d124 : a53d             [ 3] 	lda grc_x0
d126 : 38               [ 2] 	sec
d127 : e542             [ 3] 	sbc grc_y
d129 : aa               [ 2] 	tax
d12a : a53e             [ 3] 	lda grc_y0
d12c : 38               [ 2] 	sec
d12d : e540             [ 3] 	sbc grc_x
d12f : a8               [ 2] 	tay
d130 : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
d133 : a540             [ 3] 	lda grc_x
d135 : 18               [ 2] 	clc
d136 : 653d             [ 3] 	adc grc_x0
d138 : aa               [ 2] 	tax
d139 : a53e             [ 3] 	lda grc_y0
d13b : 38               [ 2] 	sec
d13c : e542             [ 3] 	sbc grc_y
d13e : a8               [ 2] 	tay
d13f : 206ad0           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
d142 : a542             [ 3] 	lda grc_y
d144 : 18               [ 2] 	clc
d145 : 653d             [ 3] 	adc grc_x0
d147 : aa               [ 2] 	tax
d148 : a53e             [ 3] 	lda grc_y0
d14a : 38               [ 2] 	sec
d14b : e540             [ 3] 	sbc grc_x
d14d : a8               [ 2] 	tay
d14e : 4c6ad0           [ 3] 	jmp gr_point
                             
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  115
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* gr_line
                             ;* Draw a line from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d151 :                       gr_line
                             
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003d =                       grl_x0 	= (num_a)
003e =                       grl_y0 	= (num_a+1)
003f =                       grl_x1 	= (num_a+2)
0040 =                       grl_y1 	= (num_a+3)
0041 =                       grl_dx	= (ztmp_24+4)
0042 =                       grl_dy	= (ztmp_24+5)
0043 =                       grl_xyyx= (ztmp_24+6)
0044 =                       grl_2dx	= (ztmp_24+7)			; Word
0046 =                       grl_2dy	= (ztmp_24+9)			; Word
0048 =                       grl_2dxy= (ztmp_24+11)			; Word
004a =                       grl_sinx= (ztmp_24+13)
004b =                       grl_p	= (ztmp_24+14)			; Word
004d =                       grl_siny= (ztmp_24+16)
                             
                             	; Start from hires cursor position
                             	; New cursor pos = end of line pos
d151 : a521             [ 3] 	lda gr_scrngeom+gr_hires_x
d153 : 853d             [ 3] 	sta grl_x0
d155 : a522             [ 3] 	lda gr_scrngeom+gr_hires_y
d157 : 853e             [ 3] 	sta grl_y0
d159 : a63f             [ 3] 	ldx grl_x1
d15b : a440             [ 3] 	ldy grl_y1
d15d : 205fd0           [ 6] 	jsr gr_set_hires_cur
                             	
d160 : a900             [ 2] 	lda #0
d162 : 8543             [ 3] 	sta grl_xyyx				; Assume normal xy axis
                             
                             	; check if abs(dy)>abs(dx) if so need to swap xy
                             	; num_b = abs(x), num_b+1 = abs(dy)
d164 : 38               [ 2] 	sec
d165 : a53f             [ 3] 	lda grl_x1
d167 : e53d             [ 3] 	sbc grl_x0
d169 : b004             [ 3] 	bcs gr_line_skip_dx_neg
d16b : 49ff             [ 2] 	eor #0xff
d16d : 6901             [ 2] 	adc #1
d16f :                       gr_line_skip_dx_neg
d16f : 8541             [ 3] 	sta grl_dx
d171 : 38               [ 2] 	sec
d172 : a540             [ 3] 	lda grl_y1
d174 : e53e             [ 3] 	sbc grl_y0
d176 : b004             [ 3] 	bcs gr_line_skip_dy_neg
d178 : 49ff             [ 2] 	eor #0xff
d17a : 6901             [ 2] 	adc #1
d17c :                       gr_line_skip_dy_neg
d17c : 8542             [ 3] 	sta grl_dy
d17e : c541             [ 3] 	cmp grl_dx
d180 : 901a             [ 3] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
AS65 Assembler for R6502 [1.42].                                     Page  116
-------------------------------- bank\bank0.s --------------------------------

d182 : a53d             [ 3] 	lda grl_x0					; swap x0 and y0
d184 : a63e             [ 3] 	ldx grl_y0
d186 : 853e             [ 3] 	sta grl_y0
d188 : 863d             [ 3] 	stx grl_x0
d18a : a53f             [ 3] 	lda grl_x1					; swap x1 and y1
d18c : a640             [ 3] 	ldx grl_y1
d18e : 8540             [ 3] 	sta grl_y1
d190 : 863f             [ 3] 	stx grl_x1
d192 : a541             [ 3] 	lda grl_dx					; swap dy and dx
d194 : a642             [ 3] 	ldx grl_dy
d196 : 8542             [ 3] 	sta grl_dy
d198 : 8641             [ 3] 	stx grl_dx
d19a : e643             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             
d19c :                       gr_line_skip_xy_swap
                             	; assume going from left to right and top to bot
d19c : a901             [ 2] 	lda #1
d19e : a0ff             [ 2] 	ldy #255					; -1
d1a0 : 854a             [ 3] 	sta grl_sinx
d1a2 : 854d             [ 3] 	sta grl_siny
                             
                             	; check going right to left
d1a4 : a53d             [ 3] 	lda grl_x0
d1a6 : c53f             [ 3] 	cmp grl_x1
d1a8 : 9002             [ 3] 	bcc gr_line_skip_left
d1aa : 844a             [ 3] 	sty grl_sinx				; make -1
d1ac :                       gr_line_skip_left
                             	; check going bottom to top
d1ac : a53e             [ 3] 	lda grl_y0
d1ae : c540             [ 3] 	cmp grl_y1
d1b0 : 9002             [ 3] 	bcc gr_line_skip_y_up
d1b2 : 844d             [ 3] 	sty grl_siny				; make -1
                             
d1b4 :                       gr_line_skip_y_up
d1b4 : a541             [ 3] 	lda grl_dx
d1b6 : 0a               [ 2] 	asl a
d1b7 : 8544             [ 3] 	sta grl_2dx					; 2*dx (word)
d1b9 : a900             [ 2] 	lda #0
d1bb : 8545             [ 3] 	sta grl_2dx+1
d1bd : 2645             [ 5] 	rol grl_2dx+1
                             
d1bf : a542             [ 3] 	lda grl_dy
d1c1 : 0a               [ 2] 	asl a
d1c2 : 8546             [ 3] 	sta grl_2dy					; 2*dy (word)
d1c4 : a900             [ 2] 	lda #0
d1c6 : 8547             [ 3] 	sta grl_2dy+1
d1c8 : 2647             [ 5] 	rol grl_2dy+1
                             
                             ;    p=2*dy-dx;					; p (word)
d1ca : 38               [ 2] 	sec
d1cb : a546             [ 3] 	lda grl_2dy
d1cd : e541             [ 3] 	sbc grl_dx
d1cf : 854b             [ 3] 	sta grl_p
d1d1 : a547             [ 3] 	lda grl_2dy+1
d1d3 : e900             [ 2] 	sbc #0
d1d5 : 854c             [ 3] 	sta grl_p+1
                             
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
d1d7 : 38               [ 2] 	sec
d1d8 : a546             [ 3] 	lda grl_2dy
d1da : e544             [ 3] 	sbc grl_2dx
d1dc : 8548             [ 3] 	sta grl_2dxy
AS65 Assembler for R6502 [1.42].                                     Page  117
-------------------------------- bank\bank0.s --------------------------------

d1de : a547             [ 3] 	lda grl_2dy+1
d1e0 : e545             [ 3] 	sbc grl_2dx+1
d1e2 : 8549             [ 3] 	sta grl_2dxy+1
                             
d1e4 :                       gr_line_pixel
d1e4 : a63d             [ 3] 	ldx grl_x0
d1e6 : a43e             [ 3] 	ldy grl_y0
d1e8 : a543             [ 3] 	lda grl_xyyx				; Swapped?
d1ea : f004             [ 3] 	beq gr_line_yx_skip
d1ec : a63e             [ 3] 	ldx grl_y0
d1ee : a43d             [ 3] 	ldy grl_x0
d1f0 :                       gr_line_yx_skip
d1f0 : 206ad0           [ 6] 	jsr gr_point				; Plot point x,y
                             
d1f3 : a53d             [ 3] 	lda grl_x0					; Check if done
d1f5 : c53f             [ 3] 	cmp grl_x1
d1f7 : f032             [ 4] 	beq gr_line_done
                             
                             	; Increment x always
d1f9 : 18               [ 2] 	clc
d1fa : a53d             [ 3] 	lda grl_x0
d1fc : 654a             [ 3] 	adc grl_sinx
d1fe : 853d             [ 3] 	sta grl_x0
                             
                             	; check sign of p
d200 : a54c             [ 3] 	lda grl_p+1
d202 : 3017             [ 3] 	bmi gr_line_neg_p
                             
                             	; if p >=0
                             
                             	; y=y+increment
d204 : 18               [ 2] 	clc
d205 : a53e             [ 3] 	lda grl_y0
d207 : 654d             [ 3] 	adc grl_siny
d209 : 853e             [ 3] 	sta grl_y0
                             
                             	; p=p+2*dy-2*dx
                             	_addZPWord grl_p,grl_2dxy
                             
d218 : 4ce4d1           [ 3] 	jmp gr_line_pixel
                             
d21b :                       gr_line_neg_p
                             	; if p < 0
                             	; p=p+2*dy
                             	_addZPWord grl_p,grl_2dy
                             
                             
d228 : 4ce4d1           [ 3] 	jmp gr_line_pixel
d22b :                       gr_line_done
d22b : 60               [ 6] 	rts
                             
                             
                             ; Line drawing pseudo code
                             ;    while(x<x1)
                             ;    {
                             ;        putpixel(x,y);
                             ;        if(p>=0)
                             ;        {
                             ;            y=y+1;
                             ;            p=p+2*dy-2*dx;
                             ;        }
                             ;        else
AS65 Assembler for R6502 [1.42].                                     Page  118
-------------------------------- bank\bank0.s --------------------------------

                             ;        {
                             ;            p=p+2*dy;
                             ;        }
                             ;        x=x+1;
                             ;    }
                             
                             
                             ;* These tables are to speed up calculating the
                             ;* offset for plot commands
d22c :                       gr_offset_40lo
d22c : 00285078a0            	db lo(000*40), lo(001*40), lo(002*40), lo(003*40
d231 : c8f0184068            	db lo(005*40), lo(006*40), lo(007*40), lo(008*40
d236 : 90b8e00830            	db lo(010*40), lo(011*40), lo(012*40), lo(013*40
d23b : 5880a8d0f8            	db lo(015*40), lo(016*40), lo(017*40), lo(018*40
d240 : 20487098c0            	db lo(020*40), lo(021*40), lo(022*40), lo(023*40
d245 : e81038                	db lo(025*40), lo(026*40), lo(027*40)
d248 :                       gr_offset_40hi
d248 : 0000000000            	db hi(000*40), hi(001*40), hi(002*40), hi(003*40
d24d : 0000010101            	db hi(005*40), hi(006*40), hi(007*40), hi(008*40
d252 : 0101010202            	db hi(010*40), hi(011*40), hi(012*40), hi(013*40
d257 : 0202020202            	db hi(015*40), hi(016*40), hi(017*40), hi(018*40
d25c : 0303030303            	db hi(020*40), hi(021*40), hi(022*40), hi(023*40
d261 : 030404                	db hi(025*40), hi(026*40), hi(027*40)
                             
                             
                             ;* Character based sprites for text mode only
d264 :                       mod_sz_sprite_s
                             ;* Initialisation
d264 :                       gr_spr_init
d264 : a21f             [ 2] 	ldx #31							; Start at last sprite
d266 :                       gr_spr_init_loop
d266 : a9ff             [ 2] 	lda #-1							; Put -1 in the x coords
d268 : 9d00b4           [ 5] 	sta spr_curX,x
d26b : 9d20b4           [ 5] 	sta spr_newX,x
d26e : ca               [ 2] 	dex								; Next sprite
d26f : 10f5             [ 3] 	bpl gr_spr_init_loop			; Until all 32 sprites in
d271 : 60               [ 6] 	rts
                             
                             
                             ;* Erase all active sprites
d272 :                       gr_spr_erase
                             	; First restore background from sprites
                             	; that are active and new pos is different from 
d272 : a21f             [ 2] 	ldx #31							; Start at last sprite
d274 :                       gr_spr_erase_loop
d274 : bd00b4           [ 4] 	lda spr_curX,x					; Is sprite active?
d277 : 3007             [ 3] 	bmi gr_spr_erase_next
d279 : a8               [ 2] 	tay								; x pos in to Y
d27a :                       gr_spr_erase_do
d27a : bda0b4           [ 4] 	lda spr_bgnd,x					; Get the background
d27d : 20c8d2           [ 6] 	jsr gr_spr_put					; And restore it
d280 :                       gr_spr_erase_next
d280 : ca               [ 2] 	dex
d281 : 10f1             [ 3] 	bpl gr_spr_erase_loop
d283 : 60               [ 6] 	rts
                             
                             ;* Get ready for new position
d284 :                       gr_spr_new
d284 : a21f             [ 2] 	ldx #31							; Start at last sprite
d286 :                       gr_spr_new_loop
d286 : bd60b4           [ 4] 	lda spr_newY,x					; Get new Y
d289 : 9d40b4           [ 5] 	sta spr_curY,x					; Update new->cur Y
AS65 Assembler for R6502 [1.42].                                     Page  119
-------------------------------- bank\bank0.s --------------------------------

d28c : a8               [ 2] 	tay								; Used for address calc.
d28d : bd20b4           [ 4] 	lda spr_newX,x					; Get new X
d290 : 9d00b4           [ 5] 	sta spr_curX,x					; Update new->cur X
d293 : 301d             [ 3] 	bmi gr_spr_new_next				; Is the new position act
d295 : 48               [ 3] 	pha 							; x pos saved for later
                             	; Calculate screen address
                             	; save as part of sprite data and in zp area
d296 : 18               [ 2] 	clc
d297 : b92cd2           [ 4] 	lda gr_offset_40lo,y
d29a : 6980             [ 2] 	adc #lo(TEXTSCRN)
d29c : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d29e : 9dc0b4           [ 5] 	sta spr_baseadrl,x
d2a1 : b948d2           [ 4] 	lda gr_offset_40hi,y
d2a4 : 69bb             [ 2] 	adc #hi(TEXTSCRN)
d2a6 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d2a8 : 9de0b4           [ 5] 	sta spr_baseadrh,x
d2ab : 68               [ 4] 	pla								; Get x pos back in to Y reg
d2ac : a8               [ 2] 	tay
d2ad : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y	; Get background
d2af : 9da0b4           [ 5] 	sta spr_bgnd,x					; And save this
d2b2 :                       gr_spr_new_next
d2b2 : ca               [ 2] 	dex
d2b3 : 10d1             [ 3] 	bpl gr_spr_new_loop
d2b5 : 60               [ 6] 	rts
                             
                             
                             ; Draw all active sprites
                             ; Active sprites are always drawn - 0 = highest p
d2b6 :                       gr_spr_draw
d2b6 : a21f             [ 2] 	ldx #31							; Start at last sprite
d2b8 :                       gr_spr_draw_loop
d2b8 : bd20b4           [ 4] 	lda spr_newX,x					; Is sprite active?
d2bb : 3007             [ 3] 	bmi gr_spr_draw_next
d2bd : a8               [ 2] 	tay								; X pos in to Y
d2be : bd80b4           [ 4] 	lda spr_chr,x					; Get the sprite char
d2c1 : 20c8d2           [ 6] 	jsr gr_spr_put
d2c4 :                       gr_spr_draw_next
d2c4 : ca               [ 2] 	dex
d2c5 : 10f1             [ 3] 	bpl gr_spr_draw_loop
d2c7 : 60               [ 6] 	rts
                             
                             
                             ;* Common routine to put A to screen address
                             ;* Used for erase and draw of sprites
                             ;* X=index in to sprite table
                             ;* Y=X offset from screen pointer
d2c8 :                       gr_spr_put
d2c8 : 48               [ 3] 	pha
d2c9 : bdc0b4           [ 4] 	lda spr_baseadrl,x		; Get the screen pointer
d2cc : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d2ce : bde0b4           [ 4] 	lda spr_baseadrh,x
d2d1 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d2d3 : 68               [ 4] 	pla								; Get back the char to
d2d4 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y	; put on to scre
d2d6 : 60               [ 6] 	rts
                             
                             
                             ;* Update spr A with char X
d2d7 :                       gr_spr_char
d2d7 : a8               [ 2] 	tay
d2d8 : 8a               [ 2] 	txa
d2d9 : 9980b4           [ 5] 	sta spr_chr,y
AS65 Assembler for R6502 [1.42].                                     Page  120
-------------------------------- bank\bank0.s --------------------------------

d2dc : 60               [ 6] 	rts
                             
                             ;* Locate what is at the location of sprite A, re
                             ;* C=1 if sprite it not active
d2dd :                       gr_spr_hit
d2dd : aa               [ 2] 	tax
d2de : bd00b4           [ 4] 	lda spr_curX,x
d2e1 : c980             [ 2] 	cmp #0x80						; If A>=0x80 then C=1
d2e3 : bda0b4           [ 4] 	lda spr_bgnd,x
d2e6 : 60               [ 6] 	rts
                             
                             ;* Update spr A with coords X,Y
d2e7 :                       gr_spr_pos
d2e7 : 8432             [ 3] 	sty tmp_alo
d2e9 : a8               [ 2] 	tay
d2ea : 8a               [ 2] 	txa								; X coord still in X reg
d2eb : 9920b4           [ 5] 	sta spr_newX,y
d2ee : a532             [ 3] 	lda tmp_alo						; Y coord from temp
d2f0 : 9960b4           [ 5] 	sta spr_newY,y
d2f3 : 60               [ 6] 	rts
                             
                             ;* Update all sprite positions from df_tmpptra, d
d2f4 :                       gr_spr_multi_pos
d2f4 : a03e             [ 2] 	ldy #62
d2f6 : a21f             [ 2] 	ldx #31
d2f8 :                       gr_spr_multi_loop
d2f8 : b1a1             [ 5] 	lda (df_tmpptra),y
d2fa : 9d20b4           [ 5] 	sta spr_newX,x
d2fd : b1a3             [ 5] 	lda (df_tmpptrb),y
d2ff : 9d60b4           [ 5] 	sta spr_newY,x
d302 : 88               [ 2] 	dey
d303 : 88               [ 2] 	dey
d304 : ca               [ 2] 	dex
d305 : 10f1             [ 4] 	bpl gr_spr_multi_loop
d307 : 60               [ 6] 	rts
                             
d308 :                       mod_sz_sprite_e
d308 :                       mod_sz_graph_e
                             
                             ; Old version of point calculator - in case I nee
                             ;	; Calculate destination address
                             ;	lda #0
                             ;	sta tmp_ahi
                             ;
                             ;	tya				; Row number in A
                             ;	; Multiply 8
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	sta tmp_alo
                             ;
                             ;	; Multiply 32
                             ;	; Use partial result from m8
                             ;	lda tmp_ahi
                             ;	sta tmp_bhi
                             ;	lda tmp_alo
                             ;	; Just two more rotates to get m32
                             ;	asl a
                             ;	rol tmp_bhi
AS65 Assembler for R6502 [1.42].                                     Page  121
-------------------------------- bank\bank0.s --------------------------------

                             ;	asl a
                             ;	rol tmp_bhi
                             ;	sta tmp_blo
                             ;	; Add m8 and m32 for m40
                             ;	clc
                             ;	lda tmp_alo
                             ;	adc tmp_blo
                             ;	sta tmp_alo
                             ;	lda tmp_ahi
                             ;	adc tmp_bhi
                             ;	; Add high byte of screen address
                             ;	adc gr_scrngeom+vdp_scrn+1
                             ;	sta tmp_ahi
                             ;	; Dest offset in tmp_alo
                             ;
                             ;	; pixel x coord in to A
                             ;	; We dvide by 48 doing trial subtracts
                             ;	; This leaves Y with a number 0..5
                             ;	; And A has the remainder 0..47
                             ;	; Use these to look up byte column and mask
                             ;	; We don't do more than 5 trial subtracts
                             ;	; plus the table size is much smaller
                             ;	; Comprimise of space vs speed
                             ;	txa
                             ;	ldy #0				; Start at segment 0
                             ;	sec
                             ;gr_point_d48
                             ;	sbc #48
                             ;	iny
                             ;	bcs gr_point_d48				; Keep going until underflo
                             ;
                             ;	dey								; Adjust segment count
                             ;	adc #48							; Get remainder in A
                             ;	tax								; Put remainder in to X (0..47)
                             ;	lda gr_col_seg,y				; Get the start column of s
                             ;	clc
                             ;	adc gr_col_offset,x				; Add segment offset usi
                             ;	tay								; We have the byte column in Y
                             ;	sty tmp_bhi						; Save in tmp, also still in Y
                             ;	stx tmp_blo						; Save remainder 0..47
                             ;	rts
                             
                             ;gr_point_mask
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;gr_col_offset
                             ;	db 0,0,0,0,0,0
                             ;	db 1,1,1,1,1,1
                             ;	db 2,2,2,2,2,2
                             ;	db 3,3,3,3,3,3
                             ;	db 4,4,4,4,4,4
                             ;	db 5,5,5,5,5,5
                             ;	db 6,6,6,6,6,6
                             ;	db 7,7,7,7,7,7
                             ;gr_col_seg
                             ;	db 0,8,16,24,32
AS65 Assembler for R6502 [1.42].                                     Page  122
-------------------------------- bank\bank0.s --------------------------------

                             
                             	include "monitor/cmd.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  CMD.S
                             ;*	A really simple monitor that needs to be impro
                             ;*	optimised.  Only has these commands;
                             ;*		dxxxx			Dump memory location xxxx
                             ;*						Press enter for more else stop
                             ;*		sxxxx [yy]		Set memory location xxxx with hex
                             ;*						bytes, respond with next location
                             ;*		q				Quit
                             ;*	Now you see why this needs optimising!
                             ;*
                             ;************************************************
                             
0094 =                       cmd_lo					= df_currdat
0095 =                       cmd_hi					= (df_currdat+1)
                             
                             	; ROM code
                             	code  
                             
d308 :                       _mod_sz_cmd_s
                             
d308 :                       command_line
                             
d308 :                       cmd_ready
                             	_println_low msg_ready
                             
                             
d30f : 38               [ 2] 	sec							; Set carry flag = echo characters
d310 : 2069c4           [ 6] 	jsr io_read_line			; Get a command line
d313 : a000             [ 2] 	ldy #0
d315 : b139             [ 5] 	lda (buf_lo),y
d317 : c971             [ 2] 	cmp #'q'
d319 : d001             [ 3] 	bne cmd_check_cmd
d31b : 60               [ 6] 	rts
d31c :                       cmd_check_cmd
d31c : 202ed3           [ 6] 	jsr cmd_parse				; Find command and execute
d31f : b003             [ 3] 	bcs cmd_error				; Carry set = error condition
d321 : 4c08d3           [ 3] 	jmp cmd_ready
                             
d324 :                       cmd_error
                             	_println_low msg_errmsg
                             
d32b : 4c08d3           [ 3] 	jmp cmd_ready
                             
                             
                             ;****************************************
                             ;* cmd_parse
                             ;* Parse the command line in the io buffer
                             ;* Regs affected : 
                             ;****************************************
d32e :                       cmd_parse
d32e : c8               [ 2] 	iny						; Ready for next char
                             	
AS65 Assembler for R6502 [1.42].                                     Page  123
-------------------------------- bank\bank0.s --------------------------------

d32f :                       cmd_check_d
d32f : c964             [ 2] 	cmp #'d'				; Check for d
d331 : f030             [ 3] 	beq cmd_dumpmem
d333 :                       cmd_check_s
d333 : c973             [ 2] 	cmp #'s'				; Check for s
d335 : f006             [ 3] 	beq cmd_setmem
                             
d337 :                       cmd_not_found
d337 : a901             [ 2] 	lda #CMD_ERR_NOTFOUND
d339 : 855d             [ 3] 	sta errno
d33b : 38               [ 2] 	sec
d33c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_setmem
                             ;* Set the memory at address AAAA to byte string
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d33d :                       cmd_setmem
d33d : 20f4d3           [ 6] 	jsr cmd_parse_word
d340 : b01f             [ 3] 	bcs cmd_setmem_err
d342 :                       cmd_setmem_byte
d342 : 20d8d3           [ 6] 	jsr cmd_parse_byte
d345 : b01a             [ 3] 	bcs cmd_setmem_err
d347 : 20cfd3           [ 6] 	jsr cmd_poke				; Poke A in to cmd_lo, hi
d34a : 20c3d3           [ 6] 	jsr cmd_incmem
d34d : 2006d4           [ 6] 	jsr cmd_parse_next_parm		; Try and find another 
d350 : 90f0             [ 3] 	bcc cmd_setmem_byte			; Process if found, else f
d352 : a595             [ 3] 	lda cmd_hi
d354 : 2083c1           [ 6] 	jsr utilPrintA
d357 : a594             [ 3] 	lda cmd_lo
d359 : 2083c1           [ 6] 	jsr utilPrintA
d35c : 207bc1           [ 6] 	jsr utilPrintCRLF
d35f : 18               [ 2] 	clc
d360 : 60               [ 6] 	rts
d361 :                       cmd_setmem_err
d361 : 38               [ 2] 	sec
d362 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_dumpmem
                             ;* Dump memory at address AAAA
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d363 :                       cmd_dumpmem
d363 : 20f4d3           [ 6] 	jsr cmd_parse_word			; Get address to dump
d366 : 9001             [ 3] 	bcc cmd_dumpmem_block
d368 : 60               [ 6] 	rts							; C is set
d369 :                       cmd_dumpmem_block
d369 : a595             [ 3] 	lda cmd_hi					; Show the address
d36b : 2083c1           [ 6] 	jsr utilPrintA
d36e : a594             [ 3] 	lda cmd_lo
d370 : 2083c1           [ 6] 	jsr utilPrintA
d373 : 2073c1           [ 6] 	jsr utilPrintSPC
                             	
d376 : a008             [ 2] 	ldy #8						; 8 Bytes per line
AS65 Assembler for R6502 [1.42].                                     Page  124
-------------------------------- bank\bank0.s --------------------------------

d378 :                       cmd_dumpmem_byte
d378 : 20cad3           [ 6] 	jsr cmd_peek
d37b : 2083c1           [ 6] 	jsr utilPrintA
d37e : 2073c1           [ 6] 	jsr utilPrintSPC
d381 : 20c3d3           [ 6] 	jsr cmd_incmem
d384 : 88               [ 2] 	dey
d385 : d0f1             [ 3] 	bne cmd_dumpmem_byte
d387 :                       cmd_dumpmemASCII
d387 : 38               [ 2] 	sec							; Move pointer back to start
d388 : a594             [ 3] 	lda cmd_lo
d38a : e908             [ 2] 	sbc #8
d38c : 8594             [ 3] 	sta cmd_lo
d38e : a595             [ 3] 	lda cmd_hi
d390 : e900             [ 2] 	sbc #0
d392 : 8595             [ 3] 	sta cmd_hi
                             	
d394 : 2073c1           [ 6] 	jsr utilPrintSPC
d397 : a008             [ 2] 	ldy #8						; 8 Bytes per line
d399 :                       cmd_dumpmem_ascii
d399 : 20cad3           [ 6] 	jsr cmd_peek
d39c : a22e             [ 2] 	ldx #'.'					; Non-printable char
d39e : c920             [ 2] 	cmp #' '					; A<32 is unprintable
d3a0 : b001             [ 3] 	bcs cmd_dump_skip_ctrl
d3a2 : 8a               [ 2] 	txa							; Replace with dot
d3a3 :                       cmd_dump_skip_ctrl
d3a3 : c97f             [ 2] 	cmp #UTF_DEL				; >= DEL is unprintable
d3a5 : 9001             [ 3] 	bcc cmd_dump_skip_del
d3a7 : 8a               [ 2] 	txa							; Replace with dot
d3a8 :                       cmd_dump_skip_del	
d3a8 : 2054c4           [ 6] 	jsr io_put_ch
d3ab : 20c3d3           [ 6] 	jsr cmd_incmem
d3ae : 88               [ 2] 	dey		
d3af : d0e8             [ 3] 	bne cmd_dumpmem_ascii		; Show 8 bytes
d3b1 : 38               [ 2] 	sec
d3b2 : 2051c4           [ 6] 	jsr io_get_ch				; Wait for key press
d3b5 : c90d             [ 2] 	cmp #UTF_CR		
d3b7 : d003             [ 3] 	bne cmd_dumpmemFin			; Any key but enter finishe
                             ;	jsr io_put_ch				; Do new line
d3b9 : 4c69d3           [ 3] 	jmp cmd_dumpmem_block
d3bc :                       cmd_dumpmemFin
d3bc : a90d             [ 2] 	lda #UTF_CR
d3be : 2054c4           [ 6] 	jsr io_put_ch
d3c1 : 18               [ 2] 	clc
d3c2 : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* cmd_incmem
                             ;* Increment pointer
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : cmd_lo, cmd_hi
                             ;* Regs affected : 
                             ;****************************************
d3c3 :                       cmd_incmem
                             	_incZPWord cmd_lo
                             
d3c9 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_peek
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi
AS65 Assembler for R6502 [1.42].                                     Page  125
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d3ca :                       cmd_peek
d3ca : a200             [ 2] 	ldx #0
d3cc : a194             [ 6] 	lda (cmd_lo,x)
d3ce : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_poke
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d3cf :                       cmd_poke
d3cf : 8638             [ 3] 	stx tmp_d
d3d1 : a200             [ 2] 	ldx #0
d3d3 : 8194             [ 6] 	sta (cmd_lo,x)
d3d5 : a638             [ 3] 	ldx tmp_d
d3d7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_byte
                             ;* Find 2 char hex byte
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = value
                             ;* Regs affected : A,Y
                             ;****************************************
d3d8 :                       cmd_parse_byte
d3d8 : 2006d4           [ 6] 	jsr cmd_parse_next_parm	; Find the next paramete
d3db : b015             [ 3] 	bcs cmd_parse_byte_err
d3dd : b139             [ 5] 	lda (buf_lo),y			; Get hi nibble of high byte
d3df : f011             [ 3] 	beq cmd_parse_byte_err	; If no char then error w
d3e1 : 48               [ 3] 	pha						; Save on stack
d3e2 : c8               [ 2] 	iny
d3e3 : b139             [ 5] 	lda (buf_lo),y			; Get lo nibble of high byte
d3e5 : f00a             [ 3] 	beq cmd_parse_byte_errp	; If no char then error 
d3e7 : aa               [ 2] 	tax						; Lo nibble goes to X
d3e8 : 68               [ 4] 	pla						; Restore hi nibble
d3e9 : 20b4c1           [ 6] 	jsr str_x_to_a			; Convert from hex to A
d3ec : b004             [ 3] 	bcs cmd_parse_byte_err	; If error then stop
d3ee : c8               [ 2] 	iny						; Point to next char
d3ef : 18               [ 2] 	clc
d3f0 : 60               [ 6] 	rts						; A contains the byte
d3f1 :                       cmd_parse_byte_errp
d3f1 : 68               [ 4] 	pla
d3f2 :                       cmd_parse_byte_err
d3f2 : aa               [ 2] 	tax
d3f3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_word
                             ;* Find 4 char hex word
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = hi, X = 
                             ;* Regs affected : A,X,Y
                             ;****************************************
d3f4 :                       cmd_parse_word
d3f4 : 20d8d3           [ 6] 	jsr cmd_parse_byte			; Get hi byte of word
d3f7 : b00b             [ 4] 	bcs cmd_word_err
d3f9 : 8595             [ 3] 	sta cmd_hi					; Save hi byte of word
AS65 Assembler for R6502 [1.42].                                     Page  126
-------------------------------- bank\bank0.s --------------------------------

d3fb : 20d8d3           [ 6] 	jsr cmd_parse_byte			; Get lo byte of word
d3fe : b004             [ 4] 	bcs cmd_word_err
d400 : 8594             [ 3] 	sta cmd_lo
d402 : 18               [ 2] 	clc
d403 : 60               [ 6] 	rts
d404 :                       cmd_word_err
d404 : 38               [ 2] 	sec
d405 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_next_parm
                             ;* Find next non-white space
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d406 :                       cmd_parse_next_parm
d406 : 88               [ 2] 	dey
d407 :                       cmd_find_parm
d407 : c8               [ 2] 	iny
d408 : b139             [ 5] 	lda (buf_lo),y
d40a : f005             [ 3] 	beq cmd_next_parm_err	; If z then no parms, fin 
d40c : c921             [ 2] 	cmp #' '+1				; Ignore space or less
d40e : f0f7             [ 3] 	beq cmd_find_parm
d410 : 18               [ 2] 	clc						; else ok, C is cleared
d411 :                       cmd_next_parm_err
d411 : 60               [ 6] 	rts
                             
                             	
d412 : 3e00                  msg_ready				db ">\x0"
d414 : 3f0d00                msg_errmsg				db "?\xd\x0"
d417 :                       _mod_sz_cmd_e
                             
                             	include "sound/sound.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SOUND.S
                             ;*  Sound driver module - routines to access the 
                             ;*  This sound chip was found in a number of popu
                             ;*  in the early to mid 80s, including my first c
                             ;*  the Oric-1, as well as the MSX range.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
d417 :                       mod_sz_sound_s
                             
                             
                             ;****************************************
                             ;* snd_get_note
                             ;* Get a note from the music scale table
                             ;* Input : Octave in X, note in Y
                             ;*         Octave between 1 and 6
AS65 Assembler for R6502 [1.42].                                     Page  127
-------------------------------- bank\bank0.s --------------------------------

                             ;* Output : A,X = Value hi,lo
                             ;* Regs affected : X
                             ;****************************************
d417 :                       snd_get_note
d417 : 98               [ 2] 	tya
d418 : 0a               [ 2] 	asl a
d419 : a8               [ 2] 	tay
                             	; Get note for octave 1
d41a : b94ad4           [ 4] 	lda snd_music_tab,y
d41d : 8532             [ 3] 	sta tmp_alo
d41f : b94bd4           [ 4] 	lda snd_music_tab+1,y
                             	
d422 :                       snd_get_note_oct
d422 : ca               [ 2] 	dex
d423 : f006             [ 3] 	beq snd_note_done
                             	; Divide freq by 2 each octave
d425 : 4a               [ 2] 	lsr a
d426 : 6632             [ 5] 	ror tmp_alo
d428 : 4c22d4           [ 3] 	jmp snd_get_note_oct
d42b :                       snd_note_done
d42b : a632             [ 3] 	ldx tmp_alo
d42d : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_snd
                             ;* Initialise sound - after cia 1 has been initia
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d42e :                       init_snd
d42e : a20f             [ 2] 	ldx #15
d430 :                       init_snd_regs
d430 : bd3ad4           [ 4] 	lda snd_init_tab,x
d433 : 206ec0           [ 6] 	jsr snd_set				; Set X to A
d436 : ca               [ 2] 	dex
d437 : 10f7             [ 3] 	bpl init_snd_regs		; 16 regs
                             	
d439 : 60               [ 6] 	rts						; return from sub
                             
                             	; Register array initialisation values
                             	; Assuming 1.34Mhz input clock
d43a :                       snd_init_tab
d43a : 40                    	db 0x40				; R0 = Channel A Tone Low
d43b : 00                    	db 0x00				; R1 = Channel A Tone High
d43c : 00                    	db 0x00				; R2 = Channel B Tone Low
d43d : 01                    	db 0x01				; R3 = Channel B Tone High
d43e : 00                    	db 0x00				; R4 = Channel C Tone Low
d43f : 02                    	db 0x02				; R5 = Channel C Tone High
d440 : 00                    	db 0x00				; R6 = Noise period
d441 : 7e                    	db 0b01111110		; R7 = Control : IOB input, IOA o
d442 : 1f                    	db 0x1f				; R8 = Channel A Vol
d443 : 1f                    	db 0x1f				; R9 = Channel B Vol
d444 : 1f                    	db 0x1f				; R10 = Channel C Vol
d445 : 00                    	db 0x00				; R11 = Envelope Period Low
d446 : 03                    	db 0x03				; R12 = Envelope Period High
d447 : 00                    	db 0b00000000		; R13 = Envelope Shape : 0000
d448 : ff                    	db 0xff				; R14 = IO Port A - KB lines disabled
d449 : 00                    	db 0x00				; R15 = IO Port B ; Initialise to 0 (
                             
d44a :                       snd_music_tab
AS65 Assembler for R6502 [1.42].                                     Page  128
-------------------------------- bank\bank0.s --------------------------------

d44a : f20b                  	dw 3058				; C		0 (Octave 1 3058Hz)
d44c : 460b                  	dw 2886				; C#	1
d44e : a40a                  	dw 2724				; D		2
d450 : 0b0a                  	dw 2571				; D#	3
d452 : 7b09                  	dw 2427				; E		4
d454 : f308                  	dw 2291				; F		5
d456 : 7208                  	dw 2162				; F#	6
d458 : f907                  	dw 2041				; G		7
d45a : 8607                  	dw 1926				; G#	8
d45c : 1a07                  	dw 1818				; A		9
d45e : b406                  	dw 1716				; A#	10
d460 : 5406                  	dw 1620				; B		11
d462 : 0000                  	dw 0				; Null  12
                             
d464 :                       mod_sz_sound_e
                             
d464 :                       mod_sz_bios_e
d464 :                       mod_sz_language_s
                             	include "utils/intmath.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INTMATH.S
                             ;*  Core module for integer maths supported by df
                             ;*  Now supports signed integers in 2s complement
                             ;*  Uses the intmath registers: num_a, num_b, num
                             ;*  Most inputs are through num_a and num_b, with
                             ;*  num_a
                             ;*  Operations: add, sub, swap, 8 bit mult, mult,
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* Add : A + B result in A
                             ;****************************************
                             ;int_add
                             ;	clc
                             ;	lda num_a
                             ;	adc num_b
                             ;	sta num_a
                             ;	lda num_a+1
                             ;	adc num_b+1
                             ;	sta num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Sub : A - B result in A
                             ;****************************************
                             ;int_sub
                             ;	sec
                             ;	lda num_a
                             ;	sbc num_b
                             ;	sta num_a
                             ;	lda num_a+1
AS65 Assembler for R6502 [1.42].                                     Page  129
-------------------------------- bank\bank0.s --------------------------------

                             ;	sbc num_b+1
                             ;	sta num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Swp : A <-> B 
                             ;****************************************
                             ;int_swp
                             ;	lda num_a
                             ;	ldx num_b
                             ;	sta num_b
                             ;	stx num_a
                             ;	lda num_a+1
                             ;	ldx num_b+1
                             ;	sta num_b+1
                             ;	stx num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;* B assumed to be an 8 bit quantity 
                             ;****************************************
d464 :                       int_fast_mult
                             	_cpyZPWord num_a,num_tmp
                             
d46c : a900             [ 2] 	lda #0
d46e : 853d             [ 3] 	sta num_a
d470 : 853e             [ 3] 	sta num_a+1
d472 : a008             [ 2] 	ldy #8
d474 :                       int_fast_mult_cycle
d474 : 4641             [ 5] 	lsr num_b
d476 : 900d             [ 3] 	bcc int_fast_mult_next
d478 : 18               [ 2] 	clc
d479 : a53d             [ 3] 	lda num_a
d47b : 6549             [ 3] 	adc num_tmp
d47d : 853d             [ 3] 	sta num_a
d47f : a53e             [ 3] 	lda num_a+1
d481 : 654a             [ 3] 	adc num_tmp+1
d483 : 853e             [ 3] 	sta num_a+1
d485 :                       int_fast_mult_next
d485 : 0649             [ 5] 	asl num_tmp
d487 : 264a             [ 5] 	rol num_tmp+1
d489 : 88               [ 2] 	dey
d48a : d0e8             [ 3] 	bne int_fast_mult_cycle
d48c : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;****************************************
d48d :                       int_mult
                             	_cpyZPWord num_a,num_tmp
                             
d495 : a900             [ 2] 	lda #0
d497 : 853d             [ 3] 	sta num_a
d499 : 853e             [ 3] 	sta num_a+1
d49b : a010             [ 2] 	ldy #16
d49d :                       int_mult_cycle
d49d : 4642             [ 5] 	lsr num_b+1
d49f : 6641             [ 5] 	ror num_b
d4a1 : 900d             [ 3] 	bcc int_mult_next
d4a3 : 18               [ 2] 	clc
d4a4 : a53d             [ 3] 	lda num_a
AS65 Assembler for R6502 [1.42].                                     Page  130
-------------------------------- bank\bank0.s --------------------------------

d4a6 : 6549             [ 3] 	adc num_tmp
d4a8 : 853d             [ 3] 	sta num_a
d4aa : a53e             [ 3] 	lda num_a+1
d4ac : 654a             [ 3] 	adc num_tmp+1
d4ae : 853e             [ 3] 	sta num_a+1
d4b0 :                       int_mult_next
d4b0 : 0649             [ 5] 	asl num_tmp
d4b2 : 264a             [ 5] 	rol num_tmp+1
d4b4 : 88               [ 2] 	dey
d4b5 : d0e6             [ 3] 	bne int_mult_cycle
d4b7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Div : A / B result in A, remainder X
                             ;****************************************
d4b8 :                       int_div
                             	; adjust signs
d4b8 : a900             [ 2] 	lda #0
d4ba : 8549             [ 3] 	sta num_tmp				; Assume all +ve
d4bc : a53e             [ 3] 	lda num_a+1				; Check A hi
d4be : 100f             [ 3] 	bpl int_div_skip_negA
d4c0 : e649             [ 5] 	inc num_tmp				; Record sign flip
d4c2 : 38               [ 2] 	sec						; 2's complement A
d4c3 : a900             [ 2] 	lda #0					; by 0-A
d4c5 : e53d             [ 3] 	sbc num_a				; A is now +ve
d4c7 : 853d             [ 3] 	sta num_a
d4c9 : a900             [ 2] 	lda #0
d4cb : e53e             [ 3] 	sbc num_a+1
d4cd : 853e             [ 3] 	sta num_a+1	
d4cf :                       int_div_skip_negA
d4cf : a542             [ 3] 	lda num_b+1				; Check B hi
d4d1 : 100f             [ 3] 	bpl int_div_skip_negB
d4d3 : e649             [ 5] 	inc num_tmp				; Record sign flip
d4d5 : 38               [ 2] 	sec						; 2's complement B
d4d6 : a900             [ 2] 	lda #0					; by 0-B
d4d8 : e541             [ 3] 	sbc num_b				; B is now +ve
d4da : 8541             [ 3] 	sta num_b
d4dc : a900             [ 2] 	lda #0
d4de : e542             [ 3] 	sbc num_b+1
d4e0 : 8542             [ 3] 	sta num_b+1
d4e2 :                       int_div_skip_negB			; num_tmp bit 0=1 for result 
                             	; x is the remainder
d4e2 : a900             [ 2] 	lda #0
d4e4 : 8545             [ 3] 	sta num_x
d4e6 : 8546             [ 3] 	sta num_x+1
                             	; 16 bit division
d4e8 : a010             [ 2] 	ldy #16
d4ea :                       int_div_cycle
                             	; shift a left 1 bit
d4ea : 063d             [ 5] 	asl num_a
d4ec : 263e             [ 5] 	rol num_a+1
                             	; shift in to remainder
d4ee : 2645             [ 5] 	rol num_x
d4f0 : 2646             [ 5] 	rol num_x+1
                             	; try and subtract b from remainder
d4f2 : 38               [ 2] 	sec
d4f3 : a545             [ 3] 	lda num_x
d4f5 : e541             [ 3] 	sbc num_b
d4f7 : aa               [ 2] 	tax
d4f8 : a546             [ 3] 	lda num_x+1
d4fa : e542             [ 3] 	sbc num_b+1
d4fc : 9006             [ 4] 	bcc int_div_skip
AS65 Assembler for R6502 [1.42].                                     Page  131
-------------------------------- bank\bank0.s --------------------------------

                             	; so b did fit in to remainder, save it
d4fe : 8645             [ 3] 	stx num_x
d500 : 8546             [ 3] 	sta num_x+1
d502 : e63d             [ 5] 	inc num_a
d504 :                       int_div_skip
                             	; carry on for 16 bits
d504 : 88               [ 2] 	dey
d505 : d0e3             [ 4] 	bne int_div_cycle
                             	; result in a, remainder in x
                             	; check num_tmp bit 0
d507 : a549             [ 3] 	lda num_tmp
d509 : 2901             [ 2] 	and #1
d50b : f00d             [ 3] 	beq int_div_noflip
d50d : 38               [ 2] 	sec						; 2's complement A
d50e : a900             [ 2] 	lda #0					; by 0-A
d510 : e53d             [ 3] 	sbc num_a				; A is now +ve
d512 : 853d             [ 3] 	sta num_a
d514 : a900             [ 2] 	lda #0
d516 : e53e             [ 3] 	sbc num_a+1
d518 : 853e             [ 3] 	sta num_a+1	
d51a :                       int_div_noflip
d51a : 60               [ 6] 	rts
                             	
                             
                             	include "dflat/dflat.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.S
                             ;*  This is the main controller code file for dfl
                             ;*  This file includes all the required dflat sou
                             ;*  needed:
                             ;*  - error.s is the error handling module
                             ;*  - var.s is the variable handling module
                             ;*  - tokenise.s is the tokenisation module
                             ;*  - progedit.s is the program editing module
                             ;*  - runtime.s is the runtime module
                             ;*  - stack.s is the stack handling module
                             ;*  The above modules include further source file
                             ;*  needed.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d51b :                       mod_sz_dflat_s
                             
                             ;	include "dflat/error.s"  ** included in the mai
                             	include "dflat/var.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
AS65 Assembler for R6502 [1.42].                                     Page  132
-------------------------------- bank\bank0.s --------------------------------

                             ;*
                             ;*  VAR.S
                             ;*  This module handles all the variable manageme
                             ;*  When a new variable is detected during tokeni
                             ;*  is added to the variable tables.  Any subsequ
                             ;*  that variable is tokenised as an index in to 
                             ;*  table.  There are two variable tables:
                             ;*  Variable name table (VNT) keeps track of vari
                             ;*  Variable value table (VVT) maintains variable
                             ;*  including type, dimension (if array) and of c
                             ;*  actual values.  For an array, the value is a 
                             ;*  memory grabbed using the 'malloc' function (s
                             ;*  This approach to variable managemet is direct
                             ;*  Atari 8 bit.  The disadvantage is that during
                             ;*  session you may end up having a much larger v
                             ;*  table than you need.  Why?  Well because say 
                             ;*  a as a new variable, but then later change it
                             ;*  In this case a remains in the variable tables
                             ;*  only ever adds to the table!  However it is e
                             ;*  solved - when you save and then reload from n
                             ;*  program, the variable table is built up as th
                             ;*  is loaded.
                             ;*  The VNT grows DOWN from the top of free memor
                             ;*  the VVT growing UP from just below the VNT.
                             ;*	This means that the VVT for a variable will al
                             ;*	found in a fixed place in the VVT table and me
                             ;*	For the VNT (names) it grows from vvstart at l
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code  
                             
d51b :                       mod_sz_var_s
                             
                             
                             ;****************************************
                             ;* Find a variable
                             ;* CC if found, A has index
                             ;****************************************
d51b :                       df_var_find
                             	; start at the beginning of the vnt table
                             	; vars are stored in reverse order
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
                             	; start at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
d52b :                       df_var_match_vnt
                             	; If reached top of VVT then not found
d52b : a5a1             [ 3] 	lda df_tmpptra
d52d : c56d             [ 3] 	cmp df_vvtstrt
d52f : d006             [ 3] 	bne df_var_match_vnt_do
d531 : a5a2             [ 3] 	lda df_tmpptra+1
d533 : c56e             [ 3] 	cmp df_vvtstrt+1
d535 : f042             [ 3] 	beq df_var_find_no_vnt
d537 :                       df_var_match_vnt_do
                             	; match each char in buffer with vnt
d537 : a47c             [ 3] 	ldy df_linoff
d539 : a200             [ 2] 	ldx #0
d53b :                       df_var_match_vnt_sym
AS65 Assembler for R6502 [1.42].                                     Page  133
-------------------------------- bank\bank0.s --------------------------------

d53b : b90004           [ 4] 	lda df_linbuff,y
d53e : c1a3             [ 6] 	cmp (df_tmpptrb,x)
d540 : d017             [ 3] 	bne df_var_vnt_sym_nomatch
                             	; if single char match then increment
                             	; source and search
d542 : c8               [ 2] 	iny
                             	_incZPWord df_tmpptrb
                             
                             	; if more chars in vnt entry then continue
d549 : a1a3             [ 6] 	lda (df_tmpptrb,x)
d54b : d0ee             [ 3] 	bne df_var_match_vnt_sym
                             	; if no more chars in vnt entry but
                             	; but chars in buffer then try next vnt
d54d : b90004           [ 4] 	lda df_linbuff,y
                             	; check for valid alpha-numeric
d550 : 20fcd6           [ 6] 	jsr df_tk_isalphanum
                             	; if there is a valid alpha-num then no match
d553 : b004             [ 3] 	bcs df_var_vnt_sym_nomatch
                             	; else check type
d555 :                       df_var_check_type
                             	; if not alpha-num then check for type
                             	; string or int postfix didn't match with VNT
                             ;	cmp #'%'
                             ;	beq df_var_vnt_sym_nomatch
d555 : c924             [ 2] 	cmp #'$'
                             	; ok, all good got a match
d557 : d025             [ 3] 	bne df_var_find_true
d559 :                       df_var_vnt_sym_nomatch
                             	; find the zero terminator
d559 : a1a3             [ 6] 	lda (df_tmpptrb,x)
d55b : f009             [ 3] 	beq	df_var_vnt_entry_end
                             	_incZPWord df_tmpptrb
                             
d563 : 4c59d5           [ 3] 	jmp df_var_vnt_sym_nomatch
d566 :                       df_var_vnt_entry_end
                             	; skip over zero terminator
                             	_incZPWord df_tmpptrb
                             
                             	; update vvt address pointer
d56c : 18               [ 2] 	clc
d56d : a5a1             [ 3] 	lda df_tmpptra
d56f : 6908             [ 2] 	adc #8
d571 : 85a1             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
d575 : e6a2             [ 5] 	inc df_tmpptra+1
d577 : d0b2             [ 3] 	bne df_var_match_vnt		; Always - high byte is no
                             
                             	; if at end of vnt then no matches found
d579 :                       df_var_find_no_vnt
d579 : a900             [ 2] 	lda #0
d57b : aa               [ 2] 	tax
d57c : 38               [ 2] 	sec
d57d : 60               [ 6] 	rts
                             
d57e :                       df_var_find_true
                             	; Get slot address into x,a
d57e : a6a1             [ 3] 	ldx df_tmpptra
d580 : a5a2             [ 3] 	lda df_tmpptra+1
                             	
                             	; Consume characters found in source
d582 : 847c             [ 3] 	sty df_linoff
AS65 Assembler for R6502 [1.42].                                     Page  134
-------------------------------- bank\bank0.s --------------------------------

d584 : 18               [ 2] 	clc
d585 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Insert a variable name in to vnt
                             ;* X = number of bytes to make room
                             ;* Space allocated is;
                             ;*	8 bytes for the new VVT entry
                             ;*  X bytes for the new VNT entry
                             ;* df_vntstrt is new var name entry
                             ;* df_vvtend is new vvt entry
                             ;****************************************
d586 :                       df_var_insert_space
                             	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! *
                             
                             	; adjust down the VNT start by VVT size (for ext
                             	; put it in tmpptrb
d586 : 38               [ 2] 	sec
d587 : a569             [ 3] 	lda df_vntstrt
d589 : e908             [ 2] 	sbc #DFVVT_SZ
d58b : 8569             [ 3] 	sta df_vntstrt
d58d : a56a             [ 3] 	lda df_vntstrt+1
d58f : e900             [ 2] 	sbc #0
d591 : 856a             [ 3] 	sta df_vntstrt+1
                             	
                             	; adjust VNT end by VVT size (for extra VVT entr
                             	; and put it in tmpptrc
d593 : 38               [ 2] 	sec
d594 : a56b             [ 3] 	lda df_vntend
d596 : e908             [ 2] 	sbc #DFVVT_SZ
d598 : 856b             [ 3] 	sta df_vntend
d59a : a56c             [ 3] 	lda df_vntend+1
d59c : e900             [ 2] 	sbc #0
d59e : 856c             [ 3] 	sta df_vntend+1
                             
                             	; Set copy point to new start of VNT
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             
                             	; Now move all bytes from old VNT (higher up) to
d5a8 :                       df_var_move_byte
                             	; When pointer = vntend then done
d5a8 : a5a1             [ 3] 	lda df_tmpptra
d5aa : c56b             [ 3] 	cmp df_vntend
d5ac : d006             [ 3] 	bne df_var_move_byte_do
d5ae : a5a2             [ 3] 	lda df_tmpptra+1
d5b0 : c56c             [ 3] 	cmp df_vntend+1
d5b2 : f011             [ 3] 	beq df_var_move_byte_fin
d5b4 :                       df_var_move_byte_do
                             	; First the source byte VVT size higher in memor
d5b4 : a008             [ 2] 	ldy #DFVVT_SZ
d5b6 : b1a1             [ 5] 	lda (df_tmpptra),y
                             	; And copy to new position lower in memory
d5b8 : a000             [ 2] 	ldy #0
d5ba : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; Increment memory pointer
                             	_incZPWord df_tmpptra
                             
d5c2 : 4ca8d5           [ 3] 	jmp df_var_move_byte		; Always as C is not touch
d5c5 :                       df_var_move_byte_fin
                             	
AS65 Assembler for R6502 [1.42].                                     Page  135
-------------------------------- bank\bank0.s --------------------------------

                             	; Now subtract X bytes from VNT start to accommo
d5c5 : 8638             [ 3] 	stx tmp_d
d5c7 : 38               [ 2] 	sec
d5c8 : a569             [ 3] 	lda df_vntstrt
d5ca : e538             [ 3] 	sbc tmp_d
d5cc : 8569             [ 3] 	sta df_vntstrt
d5ce : a56a             [ 3] 	lda df_vntstrt+1
d5d0 : e900             [ 2] 	sbc #0
d5d2 : 856a             [ 3] 	sta df_vntstrt+1
                             
                             	; VVT end is the same as VNT end
                             	_cpyZPWord df_vntend,df_vvtend
                             
                             
                             	; Copy done increment variable count
d5dc : e671             [ 5] 	inc df_varcnt
d5de : 18               [ 2] 	clc
d5df : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* Analyse variable name
                             ;* Return type in A
                             ;* NOT C = It is a variable
                             ;* C = It is not a variable
                             ;* X = Length including pre-fixes
                             ;* Y = Offset to next char after var name
                             ;****************************************
d5e0 :                       df_var_analyse
                             	; Default type is INT
d5e0 : a901             [ 2] 	lda #DFVVT_INT
d5e2 : 85a1             [ 3] 	sta df_tmpptra
                             	
                             	; start at the current buffer position
d5e4 : a47c             [ 3] 	ldy df_linoff
                             	
                             	; check for PROC prefix
d5e6 : b90004           [ 4] 	lda df_linbuff,y
d5e9 : c95f             [ 2] 	cmp #'_'
                             	; if it is not proc then get the name
d5eb : d005             [ 3] 	bne df_var_not_proc
                             	; else set type to PROC
d5ed : a940             [ 2] 	lda #DFVVT_PROC
d5ef : 85a1             [ 3] 	sta df_tmpptra
                             	; skip over prefix
d5f1 : c8               [ 2] 	iny
d5f2 :                       df_var_not_proc
                             	; found the actual number of alpha nums
d5f2 : a2ff             [ 2] 	ldx #0xff
                             	; go back on pos on index as loop always does in
d5f4 : 88               [ 2] 	dey
d5f5 :                       df_var_type_countlen
                             	; count alpha nums
d5f5 : c8               [ 2] 	iny
d5f6 : e8               [ 2] 	inx
d5f7 : b90004           [ 4] 	lda df_linbuff,y
                             	; first char has to be alpha, rest can be alpha-
d5fa : e000             [ 2] 	cpx #0
d5fc : d007             [ 4] 	bne df_var_type_countlen_alphanum
d5fe : 20efd6           [ 6] 	jsr df_tk_isalpha
d601 : b0f2             [ 4] 	bcs df_var_type_countlen
d603 : 9005             [ 3] 	bcc df_var_type_countlen_done
AS65 Assembler for R6502 [1.42].                                     Page  136
-------------------------------- bank\bank0.s --------------------------------

d605 :                       df_var_type_countlen_alphanum
d605 : 20fcd6           [ 6] 	jsr df_tk_isalphanum
d608 : b0eb             [ 4] 	bcs df_var_type_countlen
d60a :                       df_var_type_countlen_done
d60a : e000             [ 2] 	cpx #0
d60c : d00a             [ 3] 	bne df_var_analyse_chk_post
                             	; if zero alphanums error but not fatal
d60e :                       df_var_analyse_err
                             	; If already prefix of PROC then fatal error
d60e : a5a1             [ 3] 	lda df_tmpptra
d610 : c940             [ 2] 	cmp #DFVVT_PROC
d612 : f002             [ 3] 	beq df_var_analyse_fatal_err
d614 : 38               [ 2] 	sec
d615 : 60               [ 6] 	rts
d616 :                       df_var_analyse_fatal_err
                             	SWBRK DFERR_SYNTAX
                             
d618 :                       df_var_analyse_chk_post
                             	; first see if the char is $
                             	; but cannot already have PROC prefix
                             ;	cmp #'%'
                             ;	bne df_var_analyse_chk_dollar
                             ;	ldx df_tmpptra
                             ;	cpx #DFVVT_PROC
                             ;	beq df_var_analyse_fatal_err
                             	; Set to INT type although it is the default alr
                             ;	lda #DFVVT_INT
                             ;	sta df_tmpptra
                             	; advance the buffer index
                             ;	iny
                             ;	bne df_var_analyse_chk_arry
d618 :                       df_var_analyse_chk_dollar
                             	; now see if the char is $
                             	; but cannot already have PROC prefix
d618 : c924             [ 2] 	cmp #'$'
d61a : d00b             [ 3] 	bne df_var_analyse_chk_arry
d61c : a6a1             [ 3] 	ldx df_tmpptra
d61e : e040             [ 2] 	cpx #DFVVT_PROC
d620 : f0f4             [ 3] 	beq df_var_analyse_fatal_err
                             	; Set to STRING type
d622 : a904             [ 2] 	lda #DFVVT_STR
d624 : 85a1             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
d626 : c8               [ 2] 	iny
d627 :                       df_var_analyse_chk_arry
                             	; Check for array type vs PROC
d627 : b90004           [ 4] 	lda df_linbuff,y
d62a : c95b             [ 2] 	cmp #'['
d62c : d00a             [ 3] 	bne df_var_not_arry
                             	; array and proc type not compatible
d62e : a5a1             [ 3] 	lda df_tmpptra
d630 : c940             [ 2] 	cmp #DFVVT_PROC
d632 : f0e2             [ 3] 	beq df_var_analyse_fatal_err
d634 : 0980             [ 2] 	ora #DFVVT_ARRY
d636 : 85a1             [ 3] 	sta df_tmpptra
d638 :                       df_var_not_arry
                             	; Ok got everything
                             	; calculate length from y
                             	; y is next char after var name
d638 : 98               [ 2] 	tya
d639 : 38               [ 2] 	sec
d63a : e57c             [ 3] 	sbc df_linoff			; where we started
AS65 Assembler for R6502 [1.42].                                     Page  137
-------------------------------- bank\bank0.s --------------------------------

                             	; put len in X
d63c : aa               [ 2] 	tax
                             	; put type in A
d63d : a5a1             [ 3] 	lda df_tmpptra
d63f : 18               [ 2] 	clc
d640 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find or create a variable
                             ;* If found then type needs to match mask
                             ;* Not a fatal error because could be part
                             ;* of a trial of different parsing options
                             ;****************************************
d641 :                       df_var_findcreate
                             	; save mask
d641 : 48               [ 3] 	pha
d642 : 201bd5           [ 6] 	jsr df_var_find
d645 : b013             [ 3] 	bcs df_var_findcreate_create
                             	; restore mask to check for 0 then push
d647 : 68               [ 4] 	pla
d648 : 48               [ 3] 	pha
                             	; don't check mask if zero
d649 : f008             [ 3] 	beq df_var_findcreate_found
                             	; restore mask
d64b : 68               [ 4] 	pla
d64c : a000             [ 2] 	ldy #DFVVT_TYPE
d64e : 31a1             [ 5] 	and (df_tmpptra),y
                             	; but if mask is non zero then this must be non 
d650 : f019             [ 3] 	beq df_var_findcreate_err
d652 : 48               [ 3] 	pha		; Dummy push to match the pla
d653 :                       df_var_findcreate_found
                             	; discard mask
d653 : 68               [ 4] 	pla	
                             	; put slot address in x,a
d654 : a6a1             [ 3] 	ldx df_tmpptra
d656 : a5a2             [ 3] 	lda df_tmpptra+1
d658 : 18               [ 2] 	clc
d659 : 60               [ 6] 	rts
                             	
                             	;* If no existing variable found, add one to VNT
d65a :                       df_var_findcreate_create
                             	; find type (A) and length (X)
d65a : 20e0d5           [ 6] 	jsr df_var_analyse
                             	; keep A temporarily
d65d : 85a1             [ 3] 	sta df_tmpptra
                             	; if not a variable then return with C=1
d65f : b009             [ 3] 	bcs df_var_findcreate_errp
                             	; check if mask needs to be applied
d661 : 68               [ 4] 	pla
d662 : f009             [ 3] 	beq df_var_analyse_ok
                             	; else mask and check
d664 : 25a1             [ 3] 	and df_tmpptra
                             	; mask match is ok
d666 : d005             [ 3] 	bne df_var_analyse_ok
                             	; else return not found
d668 : f001             [ 3] 	beq df_var_findcreate_err
d66a :                       df_var_findcreate_errp
d66a : 68               [ 4] 	pla
d66b :                       df_var_findcreate_err
d66b : 38               [ 2] 	sec
d66c : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  138
-------------------------------- bank\bank0.s --------------------------------

d66d :                       df_var_analyse_ok
                             	; extra space for zero terminator
d66d : e8               [ 2] 	inx
                             	; save data in reverse order to when needed
                             	; by the initialise section x,a (var name sz, ty
                             	; insert space of X bytes
d66e : a5a1             [ 3] 	lda df_tmpptra
d670 : 48               [ 3] 	pha
d671 : 8a               [ 2] 	txa
d672 : 48               [ 3] 	pha
                             	
d673 : 2086d5           [ 6] 	jsr df_var_insert_space
d676 : 9002             [ 3] 	bcc df_var_initialise_var
                             	; error inserting space
                             	SWBRK DFERR_OK
                             
                             	
d67a :                       df_var_initialise_var
d67a : 68               [ 4] 	pla
d67b : 85a5             [ 3] 	sta df_tmpptrc				; var name size + 1
                             
d67d : 68               [ 4] 	pla							; type
d67e : a000             [ 2] 	ldy #DFVVT_TYPE
d680 : 916f             [ 5] 	sta (df_vvtend),y			; put type in vvt slot
d682 : a900             [ 2] 	lda #0						; zero the rest
d684 : a007             [ 2] 	ldy #7
d686 :                       df_var_zero_vnt
d686 : 916f             [ 5] 	sta (df_vvtend),y
d688 : 88               [ 2] 	dey
d689 : d0fb             [ 3] 	bne df_var_zero_vnt			; Don't zero out the type
                             
d68b : c6a5             [ 5] 	dec df_tmpptrc				; 1 less to copy variable name
                             
d68d : a67c             [ 3] 	ldx df_linoff				; Start at var name beginning, 
                             	; copy variable name to vnt slot
d68f :                       df_var_findcreate_copy
d68f : bd0004           [ 4] 	lda df_linbuff,x
d692 : 9169             [ 5] 	sta (df_vntstrt),y
d694 : e8               [ 2] 	inx
d695 : c8               [ 2] 	iny
d696 : c6a5             [ 5] 	dec df_tmpptrc
d698 : d0f5             [ 3] 	bne df_var_findcreate_copy
                             	; put in zero terminator
d69a : a900             [ 2] 	lda #0
d69c : 9169             [ 5] 	sta (df_vntstrt),y
                             
d69e : 867c             [ 3] 	stx df_linoff				; Update line pointer
                             
                             	; Return address of slot in X,A
d6a0 : a66f             [ 3] 	ldx df_vvtend
d6a2 : a570             [ 3] 	lda df_vvtend+1
                             	
d6a4 : 18               [ 2] 	clc
d6a5 : 60               [ 6] 	rts
                             	
d6a6 :                       mod_sz_var_e
                             
                             	include "dflat/tokenise.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
AS65 Assembler for R6502 [1.42].                                     Page  139
-------------------------------- bank\bank0.s --------------------------------

                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKENISE.S
                             ;*  Controlling module for tokenisation.  Basical
                             ;*  module is given a raw input buffer, which it 
                             ;*  attempt to tokenise fully.  Any syntax errors
                             ;*  thrown at the first point of detection.  If a
                             ;*  well, the parsed input will be in a tokenised
                             ;*  which can be executed in immediate mode or sa
                             ;*  line number order to memory.
                             ;*  dflat syntax is very simple - every statement
                             ;*  with a keyword.  The only exception is assign
                             ;*  procedure invocation - but even these scenari
                             ;*  tokenised so during runtime we just execute t
                             ;*  The raw buffer is consumed one byte at a time
                             ;*  tokenised buffer is written one byte at a tim
                             ;*  syntax means there is no need to undo reads o
                             ;*  or tokenised buffer.  The only refinement is 
                             ;*  allowed to peek a character in the raw buffer
                             ;*  consuming it.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d6a6 :                       mod_sz_tokenise_s
                             
                             
                             ;****************************************
                             ;* df_tk_peek_buf
                             ;* Return next char in A but no change to pointer
                             ;****************************************
d6a6 :                       df_tk_peek_buf
d6a6 : a47c             [ 3] 	ldy df_linoff
d6a8 : b90004           [ 4] 	lda df_linbuff,y
d6ab : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_get_buf
                             ;* Return next char in A and inc pointer
                             ;* Don't advance if null char found and Z=1
                             ;****************************************
d6ac :                       df_tk_get_buf
d6ac : a47c             [ 3] 	ldy df_linoff
d6ae : b90004           [ 4] 	lda df_linbuff,y
d6b1 : f003             [ 3] 	beq df_tk_get_buf_null
d6b3 : c8               [ 2] 	iny
d6b4 : 847c             [ 3] 	sty df_linoff
d6b6 :                       df_tk_get_buf_null
d6b6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_put_tok
                             ;* Put A in token buffer and inc pointer
                             ;* C=Clear on exit
                             ;****************************************
d6b7 :                       df_tk_put_tok
d6b7 : a47d             [ 3] 	ldy df_tokoff
d6b9 : 998004           [ 5] 	sta df_tokbuff,y
AS65 Assembler for R6502 [1.42].                                     Page  140
-------------------------------- bank\bank0.s --------------------------------

d6bc : c8               [ 2] 	iny
d6bd : 3004             [ 3] 	bmi df_tk_put_overflow
d6bf : 847d             [ 3] 	sty df_tokoff
d6c1 : 18               [ 2] 	clc
d6c2 : 60               [ 6] 	rts
d6c3 :                       df_tk_put_overflow
                             	SWBRK DFERR_STRLONG
                             
                             
                             ;****************************************
                             ;* df_tk_isdigit
                             ;* Check char in A for number 0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6c5 :                       df_tk_isdigit
d6c5 : c93a             [ 2] 	cmp #'9'+1
d6c7 : b005             [ 3] 	bcs df_tk_isdigit_false
d6c9 : c930             [ 2] 	cmp #'0'
d6cb : 9001             [ 3] 	bcc df_tk_isdigit_false
d6cd : 60               [ 6] 	rts						; C must be 1
d6ce :                       df_tk_isdigit_false
d6ce : 18               [ 2] 	clc
d6cf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isbin
                             ;* Check char in A for binary digit
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6d0 :                       df_tk_isbin
d6d0 : c930             [ 2] 	cmp #'0'
d6d2 : f005             [ 3] 	beq df_tk_isbin_true	; C=1
d6d4 : c931             [ 2] 	cmp #'1'
d6d6 : f001             [ 3] 	beq df_tk_isbin_true	; C=1
d6d8 : 18               [ 2] 	clc
d6d9 :                       df_tk_isbin_true
d6d9 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_ishex
                             ;* Check char in A for number 0-9, A-F, a-f
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6da :                       df_tk_ishex
d6da : 48               [ 3] 	pha
d6db : 20c5d6           [ 6] 	jsr df_tk_isdigit
d6de : b00a             [ 3] 	bcs df_tk_ishex_truep
d6e0 : 0920             [ 2] 	ora #0x20
d6e2 : c967             [ 2] 	cmp #'f'+1
d6e4 : b006             [ 3] 	bcs df_tk_ishex_false
d6e6 : c961             [ 2] 	cmp #'a'
d6e8 : 9002             [ 3] 	bcc df_tk_ishex_false
                             	; C must be 1 here
d6ea :                       df_tk_ishex_truep
d6ea : 68               [ 4] 	pla
d6eb : 60               [ 6] 	rts
d6ec :                       df_tk_ishex_false
d6ec :                       df_tk_isalpha_false
d6ec : 18               [ 2] 	clc
d6ed : 68               [ 4] 	pla
d6ee : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  141
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* df_tk_isalpha
                             ;* Check next char in A alpha a-z, A-Z
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6ef :                       df_tk_isalpha
d6ef : 48               [ 3] 	pha
d6f0 : 0920             [ 2] 	ora #0x20					; Convert to lower case for checki
d6f2 : c97b             [ 2] 	cmp #'z'+1
d6f4 : b0f6             [ 3] 	bcs df_tk_isalpha_false
d6f6 : c961             [ 2] 	cmp #'a'
d6f8 : 90f2             [ 3] 	bcc df_tk_isalpha_false
                             	; C must be 1 here
d6fa : 68               [ 4] 	pla
d6fb : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalphanum
                             ;* Check next char A for a-z,A-Z,0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d6fc :                       df_tk_isalphanum
d6fc : 20efd6           [ 6] 	jsr df_tk_isalpha
d6ff : 90c4             [ 3] 	bcc df_tk_isdigit
d701 :                       df_tk_rts1				; branch to this RTS where possible
d701 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isproc
                             ;* Check next char A for _
                             ;* Return: CC = False, CS = True
                             ;****************************************
d702 :                       df_tk_isproc
d702 : c95f             [ 2] 	cmp #'_'
d704 : f001             [ 3] 	beq df_tk_isproc_true	; C=1
d706 : 18               [ 2] 	clc
d707 :                       df_tk_isproc_true
d707 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
d708 :                       df_tk_skip_ws
d708 :                       df_tk_ws_loop1
d708 : 20a6d6           [ 6] 	jsr df_tk_peek_buf
d70b : 2017d7           [ 6] 	jsr df_tk_isws
d70e : 90f1             [ 3] 	bcc df_tk_rts1
d710 : e67c             [ 5] 	inc df_linoff
d712 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d715 : 90f1             [ 3] 	bcc df_tk_ws_loop1		; Always as put_tok clears C
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
                             ;df_tk_strip_ws
                             ;df_tk_sws_loop1
                             ;	jsr df_tk_peek_buf
                             ;	jsr df_tk_isws
AS65 Assembler for R6502 [1.42].                                     Page  142
-------------------------------- bank\bank0.s --------------------------------

                             ;	bcc df_tk_rts1
                             ;	inc df_linoff
                             ;	bcs df_tk_sws_loop1		; Always as C is not touch
                             
                             ;****************************************
                             ;* df_tk_isws
                             ;* Check char is ws (only space is counted)
                             ;* Return: CC = False, CS = True
                             ;****************************************
d717 :                       df_tk_isws
d717 : c920             [ 2] 	cmp #' '
d719 : d001             [ 3] 	bne df_tk_isws_false
                             	; C must be 1 here
d71b : 60               [ 6] 	rts
d71c :                       df_tk_isws_false
d71c :                       df_tk_expectok
d71c : 18               [ 2] 	clc
d71d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* CC = found, CS = Error
                             ;****************************************
d71e :                       df_tk_expect
d71e : 48               [ 3] 	pha
                             	; skip ws
d71f : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; peek the buffer
d722 : 68               [ 4] 	pla
d723 : a47c             [ 3] 	ldy df_linoff
d725 : d90004           [ 4] 	cmp df_linbuff,y
                             	; if expected char then ok
d728 : f0f2             [ 3] 	beq df_tk_expectok
                             	; else error
d72a :                       df_tk_num_err
d72a :                       df_tk_char_err
d72a : 38               [ 2] 	sec
d72b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* CC = found, CS = Error
                             ;****************************************
d72c :                       df_tk_expect_tok
d72c : 201ed7           [ 6] 	jsr df_tk_expect
d72f : b0d0             [ 3] 	bcs df_tk_rts1
d731 : 20acd6           [ 6] 	jsr df_tk_get_buf
d734 : 4cb7d6           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* FATAL IF NOT FOUND
                             ;****************************************
d737 :                       df_tk_expect_tok_err
d737 : 202cd7           [ 6] 	jsr df_tk_expect_tok
d73a : 90c5             [ 3] 	bcc df_tk_rts1
d73c :                       df_tk_expect_tok_fatal
AS65 Assembler for R6502 [1.42].                                     Page  143
-------------------------------- bank\bank0.s --------------------------------

                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant number
                             ;****************************************
d73e :                       df_tk_num
                             	; X,A = address, linbuff must be on page boundar
d73e : 18               [ 2] 	clc
d73f : a900             [ 2] 	lda #lo(df_linbuff)
d741 : 657c             [ 3] 	adc df_linoff
d743 : aa               [ 2] 	tax
d744 : a904             [ 2] 	lda #hi(df_linbuff)
d746 : 6900             [ 2] 	adc #0
d748 : a000             [ 2] 	ldy #0				; any numeric format
d74a : 20e1c1           [ 6] 	jsr con_n_to_a
d74d : b0db             [ 3] 	bcs df_tk_num_err
                             	; A = format
                             	; X = how many digits processed
                             	; Jump over that many chars
d74f : a8               [ 2] 	tay
d750 : 18               [ 2] 	clc
d751 : 8a               [ 2] 	txa
d752 : 657c             [ 3] 	adc df_linoff
d754 : 857c             [ 3] 	sta df_linoff
                             	; Now tokenise an integer (always 2 bytes, but t
d756 : 98               [ 2] 	tya
d757 : c901             [ 2] 	cmp #NUM_DEC
d759 : d004             [ 3] 	bne df_tk_num_hexbin
d75b : a909             [ 2] 	lda #DFTK_INTDEC	; decimal always an int
d75d : d016             [ 3] 	bne df_tk_num_put
d75f :                       df_tk_num_hexbin
d75f : c902             [ 2] 	cmp #NUM_HEX
d761 : d00a             [ 3] 	bne df_tk_num_bin
d763 : a906             [ 2] 	lda #DFTK_BYTHEX	; Assume BYT
d765 : e005             [ 2] 	cpx #5				; If >4 chars then INT
d767 : 900c             [ 3] 	bcc df_tk_num_put
d769 : a90a             [ 2] 	lda #DFTK_INTHEX
d76b : d008             [ 3] 	bne df_tk_num_put
d76d :                       df_tk_num_bin
d76d : a907             [ 2] 	lda #DFTK_BYTBIN	; Assume BYT
d76f : e00b             [ 2] 	cpx #11				; If >10 chars then INT
d771 : 9002             [ 3] 	bcc df_tk_num_put
d773 : a90b             [ 2] 	lda #DFTK_INTBIN
d775 :                       df_tk_num_put
d775 : 20b7d6           [ 6] 	jsr df_tk_put_tok	; Save number type (DEC,HEX,BI
d778 : a53d             [ 3] 	lda num_a
d77a : 20b7d6           [ 6] 	jsr df_tk_put_tok
d77d : a53e             [ 3] 	lda num_a+1
d77f : 4cb7d6           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Tokenise a constant char
                             ;****************************************
d782 :                       df_tk_char
                             	; skip the first quote
d782 : 20acd6           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d785 : a900             [ 2] 	lda #DFTK_CHR
d787 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; get the char value and save
d78a : 20acd6           [ 6] 	jsr df_tk_get_buf
AS65 Assembler for R6502 [1.42].                                     Page  144
-------------------------------- bank\bank0.s --------------------------------

d78d : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; always put two bytes in, even for a BYTE type
d790 : a900             [ 2] 	lda #0
d792 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; next byte must be single quote
d795 : 20acd6           [ 6] 	jsr df_tk_get_buf
d798 : c927             [ 2] 	cmp #0x27
d79a : d08e             [ 3] 	bne df_tk_char_err
d79c : 18               [ 2] 	clc
d79d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant string
                             ;****************************************
d79e :                       df_tk_str
                             	; skip the first quote
d79e : 20acd6           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d7a1 : a910             [ 2] 	lda #DFTK_STRLIT
d7a3 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d7a6 :                       df_tk_str_ch
                             	; copy string chars in to token buffer
                             	; until another quote or end of line
d7a6 : 20acd6           [ 6] 	jsr df_tk_get_buf
d7a9 : c900             [ 2] 	cmp #0
d7ab : f011             [ 3] 	beq df_tk_str_err
d7ad : c922             [ 2] 	cmp #0x22
d7af : f006             [ 3] 	beq df_tk_str_don
d7b1 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d7b4 : 4ca6d7           [ 3] 	jmp df_tk_str_ch
d7b7 :                       df_tk_str_don
                             	; zero terminated strings
d7b7 : a900             [ 2] 	lda #0
d7b9 : 4cb7d6           [ 3] 	jmp df_tk_put_tok
d7bc :                       df_tk_var_noarry
d7bc : 18               [ 2] 	clc
d7bd : 60               [ 6] 	rts
d7be :                       df_tk_str_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant (num, string, char)
                             ;****************************************
d7c0 :                       df_tk_const
d7c0 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; Check what constant it is
d7c3 : 20a6d6           [ 6] 	jsr df_tk_peek_buf
                             	; Minus symbol could be start of a number
d7c6 : c92d             [ 2] 	cmp #'-'
d7c8 : f005             [ 3] 	beq df_tk_const_try_num
d7ca : 20c5d6           [ 6] 	jsr df_tk_isdigit
d7cd : 9003             [ 3] 	bcc df_tk_const_try_str
d7cf :                       df_tk_const_try_num
d7cf : 4c3ed7           [ 3] 	jmp df_tk_num
d7d2 :                       df_tk_const_try_str
                             	; check for double quote
d7d2 : c922             [ 2] 	cmp #0x22
d7d4 : d003             [ 3] 	bne df_tk_const_try_char
d7d6 : 4c9ed7           [ 3] 	jmp df_tk_str
d7d9 :                       df_tk_const_try_char
                             	; check for single apostrophe
AS65 Assembler for R6502 [1.42].                                     Page  145
-------------------------------- bank\bank0.s --------------------------------

d7d9 : c927             [ 2] 	cmp #0x27
d7db : d003             [ 3] 	bne df_tk_const_err
d7dd : 4c82d7           [ 3] 	jmp df_tk_char
d7e0 :                       df_tk_const_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a variable - A = mask
                             ;* Return : A = variable index
                             ;****************************************
d7e2 :                       df_tk_var
                             	; Find or create variable, address in X,A
d7e2 : 2041d6           [ 6] 	jsr df_var_findcreate
d7e5 : 9001             [ 3] 	bcc df_tk_var_cont
d7e7 : 60               [ 6] 	rts
d7e8 :                       df_tk_var_cont
                             	; Save X,A for later
d7e8 : 48               [ 3] 	pha
d7e9 : 8a               [ 2] 	txa
d7ea : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d7eb : a911             [ 2] 	lda #DFTK_VAR
d7ed : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
d7f0 : 68               [ 4] 	pla
d7f1 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d7f4 : 68               [ 4] 	pla
d7f5 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; count of any array indices
d7f8 :                       df_tk_var_ck
                             	; check if array procesing needed
d7f8 : a95b             [ 2] 	lda #'['
d7fa : 202cd7           [ 6] 	jsr df_tk_expect_tok
d7fd : b0bd             [ 3] 	bcs df_tk_var_noarry
                             	; process numeric expression in bracket
d7ff : 4ca9d8           [ 3] 	jmp df_tk_narry
                             
                             
                             ;****************************************
                             ;* Tokenise a parameter in proc definition
                             ;* Return : A = variable index
                             ;****************************************
d802 :                       df_tk_parm
                             	; if preceeding with non-local qualifier DFTK_VA
d802 : 20a6d6           [ 6] 	jsr df_tk_peek_buf
d805 : c926             [ 2] 	cmp #DFTK_VARPARM
d807 : d006             [ 3] 	bne df_tk_parm_skip_var
                             	; get the qualifier and put in token buffer
d809 : 20acd6           [ 6] 	jsr df_tk_get_buf
d80c : 20b7d6           [ 6] 	jsr df_tk_put_tok
d80f :                       df_tk_parm_skip_var
                             	; don't have a certain type of var
d80f : a900             [ 2] 	lda #0
d811 : 4ce2d7           [ 3] 	jmp df_tk_var
                             
                             
                             ;****************************************
                             ;* Tokenise a variable to localise
                             ;* Return : A,X = variable index
                             ;****************************************
d814 :                       df_tk_localvar
AS65 Assembler for R6502 [1.42].                                     Page  146
-------------------------------- bank\bank0.s --------------------------------

                             	; Find or create variable, index in A
d814 : 2041d6           [ 6] 	jsr df_var_findcreate
d817 : 9001             [ 3] 	bcc df_tk_localvar_cont
d819 : 60               [ 6] 	rts
d81a :                       df_tk_localvar_cont
                             	; Save variable address for later
d81a : 48               [ 3] 	pha
d81b : 8a               [ 2] 	txa
d81c : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d81d : a911             [ 2] 	lda #DFTK_VAR
d81f : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
d822 : 68               [ 4] 	pla
d823 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d826 : 68               [ 4] 	pla
d827 : 4cb7d6           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Tokenise array variable
                             ;* Return : A = variable index
                             ;****************************************
d82a :                       df_tk_arrvar
                             	; Like a local var at first
d82a : 2014d8           [ 6] 	jsr df_tk_localvar
                             	; but must be array
d82d : a95b             [ 2] 	lda #'['
d82f : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; process numeric expression in bracket
d832 : 4ca9d8           [ 3] 	jmp df_tk_narry
                             
                             ;****************************************
                             ;* Tokenise call or def of proc
                             ;* Mode : A = 0 means def, else call
                             ;****************************************
d835 :                       df_tk_proc
d835 : 858b             [ 3] 	sta df_procmode
d837 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; Find or create proc, index in A
d83a : a940             [ 2] 	lda #DFVVT_PROC
d83c : 2041d6           [ 6] 	jsr df_var_findcreate
d83f : b066             [ 3] 	bcs df_tk_proc_err
                             
                             	; Save variable address for later
d841 : 868e             [ 3] 	stx df_procptr
d843 : 858f             [ 3] 	sta df_procptr+1
                             
                             	; Put PROC escape in token buffer
d845 : a912             [ 2] 	lda #DFTK_PROC
d847 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
d84a : a58e             [ 3] 	lda df_procptr
d84c : 20b7d6           [ 6] 	jsr df_tk_put_tok
d84f : a58f             [ 3] 	lda df_procptr+1
d851 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             
                             	; initially assume no args
d854 : a900             [ 2] 	lda #0
d856 : 858c             [ 3] 	sta df_procargs
                             
                             	; Must have an open bracket
d858 : a928             [ 2] 	lda #'('
AS65 Assembler for R6502 [1.42].                                     Page  147
-------------------------------- bank\bank0.s --------------------------------

d85a : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; if immediately followed by close bracket then 
d85d : 20a6d6           [ 6] 	jsr df_tk_peek_buf
d860 : c929             [ 2] 	cmp #')'
d862 : f030             [ 3] 	beq df_tk_proc_noparm
                             	; else tokenise parm variables
d864 :                       df_tk_proc_parms
d864 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; call appropriate routine for mode
d867 : a58b             [ 3] 	lda df_procmode
d869 : d006             [ 3] 	bne df_tk_proc_call
                             	; tokenise parameter variable in def mode
d86b : 2002d8           [ 6] 	jsr df_tk_parm
d86e : 4c7ad8           [ 3] 	jmp df_tk_proc_skip_call
d871 :                       df_tk_proc_call
                             	; tokenise expression in call mode
                             	;**CHECK**
d871 : a58c             [ 3] 	lda df_procargs	; procargs could be impacted ins
d873 : 48               [ 3] 	pha
d874 : 2029d9           [ 6] 	jsr df_tk_expression
d877 : 68               [ 4] 	pla
d878 : 858c             [ 3] 	sta df_procargs
d87a :                       df_tk_proc_skip_call
d87a : b02a             [ 3] 	bcs df_tk_proc_errp
                             	; increment number of args
d87c : e68c             [ 5] 	inc df_procargs
                             	; what is next non ws char
d87e : 2008d7           [ 6] 	jsr df_tk_skip_ws
d881 : c92c             [ 2] 	cmp #','
d883 : f006             [ 3] 	beq df_tk_proc_comma
d885 : c929             [ 2] 	cmp #')'
d887 : d01d             [ 3] 	bne df_tk_proc_errp
d889 : f009             [ 3] 	beq df_tk_proc_noparm
                             	; comma found, more parms to process
d88b :                       df_tk_proc_comma
d88b : 20acd6           [ 6] 	jsr df_tk_get_buf
d88e : 20b7d6           [ 6] 	jsr df_tk_put_tok
d891 : 4c64d8           [ 3] 	jmp df_tk_proc_parms
d894 :                       df_tk_proc_noparm
                             	; consume the close bracket
d894 : 20acd6           [ 6] 	jsr df_tk_get_buf
d897 : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             
                             	; update arg count if def mode
d89a : a68b             [ 3] 	ldx df_procmode
d89c : d006             [ 3] 	bne df_tk_proc_skip_args
                             	; use address of proc
                             	; put arg count in dim2
d89e : a004             [ 2] 	ldy #DFVVT_DIM2
d8a0 : a58c             [ 3] 	lda df_procargs
d8a2 : 918e             [ 5] 	sta (df_procptr),y
d8a4 :                       df_tk_proc_skip_args
d8a4 : 18               [ 2] 	clc
d8a5 : 60               [ 6] 	rts
d8a6 :                       df_tk_proc_errp
d8a6 : 68               [ 4] 	pla
d8a7 :                       df_tk_proc_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse array index
AS65 Assembler for R6502 [1.42].                                     Page  148
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
d8a9 :                       df_tk_narry
                             	; if array open bracket encountered
                             	; then tokenise a numeric expression
d8a9 : 2029d9           [ 6] 	jsr df_tk_expression
                             	; If a comma is next, then another expression
d8ac : a92c             [ 2] 	lda #','
d8ae : 202cd7           [ 6] 	jsr df_tk_expect_tok
d8b1 : b003             [ 3] 	bcs df_tk_narry_end
d8b3 : 2029d9           [ 6] 	jsr df_tk_expression
d8b6 :                       df_tk_narry_end
                             	; after the second dimension, must be close sq b
d8b6 : a95d             [ 2] 	lda #']'
d8b8 : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
                             ;* Parse bracket
                             ;****************************************
d8bb :                       df_tk_nbrkt
                             	; if  open bracket encountered
                             	; then tokenise a numeric expression
d8bb : 2029d9           [ 6] 	jsr df_tk_expression
d8be : a929             [ 2] 	lda #')'
d8c0 : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
                             ;* Parse call to numeric proc
                             ;****************************************
d8c3 :                       df_tk_nterm_proc
                             	; call mode
d8c3 : a901             [ 2] 	lda #1
d8c5 : 4c35d8           [ 3] 	jmp df_tk_proc
                             
                             ;****************************************
                             ;* Parse numeric term
                             ;****************************************
d8c8 :                       df_tk_nterm
                             	; skip any ws first, copying in to tokbuff
                             	; A containts the non-ws char
d8c8 : 2008d7           [ 6] 	jsr df_tk_skip_ws
d8cb : c900             [ 2] 	cmp #0
d8cd : f004             [ 3] 	beq df_tk_nterm_done
d8cf : c93a             [ 2] 	cmp #':'
d8d1 : d002             [ 3] 	bne df_tk_nterm_cont
d8d3 :                       df_tk_nterm_done
d8d3 :                       df_tk_nop_false
d8d3 : 38               [ 2] 	sec
d8d4 : 60               [ 6] 	rts
d8d5 :                       df_tk_nterm_cont
                             	; if open bracket then process it
d8d5 : c928             [ 2] 	cmp #'('
d8d7 : d009             [ 3] 	bne df_tk_nterm_tryfn
                             	; get the bracket and put in token buffer
d8d9 : 20acd6           [ 6] 	jsr df_tk_get_buf
d8dc : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; go process the open bracket
d8df : 4cbbd8           [ 3] 	jmp df_tk_nbrkt
d8e2 :                       df_tk_nterm_tryfn
d8e2 : 48               [ 3] 	pha
                             	; try decoding a built-in function
d8e3 : a902             [ 2] 	lda #DFTK_FN
d8e5 : 2015da           [ 6] 	jsr df_tk_matchtok
AS65 Assembler for R6502 [1.42].                                     Page  149
-------------------------------- bank\bank0.s --------------------------------

d8e8 : b00e             [ 3] 	bcs df_tk_nterm_try_proc
                             	; pull old A in to Y but don't use
d8ea : 68               [ 4] 	pla
d8eb : a8               [ 2] 	tay
                             	; restore A and put the token with MSB set
d8ec : 8a               [ 2] 	txa
d8ed : 0980             [ 2] 	ora #0x80
d8ef : 20b7d6           [ 6] 	jsr df_tk_put_tok
d8f2 : 20e7d9           [ 6] 	jsr df_tk_exec_parser
d8f5 : b01b             [ 4] 	bcs df_tk_nterm_err
d8f7 : 60               [ 6] 	rts
d8f8 :                       df_tk_nterm_try_proc
d8f8 : 68               [ 4] 	pla
                             	; if it's not a func then try proc
d8f9 : 2002d7           [ 6] 	jsr df_tk_isproc
d8fc : 9006             [ 4] 	bcc df_tk_nterm_try_var
d8fe : 20c3d8           [ 6] 	jsr df_tk_nterm_proc
d901 : b00f             [ 3] 	bcs df_tk_nterm_err
d903 : 60               [ 6] 	rts
d904 :                       df_tk_nterm_try_var
                             	; Non-zero mask means var must be this type
d904 : a900             [ 2] 	lda #0
d906 : 20e2d7           [ 6] 	jsr df_tk_var
d909 : b001             [ 3] 	bcs df_tk_nterm_try_const
d90b : 60               [ 6] 	rts
d90c :                       df_tk_nterm_try_const
                             	; Try decoding a constant
d90c : 20c0d7           [ 6] 	jsr df_tk_const
d90f : b001             [ 3] 	bcs df_tk_nterm_err
d911 : 60               [ 6] 	rts
d912 :                       df_tk_nterm_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric operator
                             ;****************************************
d914 :                       df_tk_nop
d914 : 2008d7           [ 6] 	jsr df_tk_skip_ws
d917 : c900             [ 2] 	cmp #0
d919 : f0b8             [ 4] 	beq df_tk_nop_false
                             	; must be an operator token for numeric
d91b : a90c             [ 2] 	lda #DFTK_OP | DFTK_STROP
d91d : 2015da           [ 6] 	jsr df_tk_matchtok
d920 : b0b1             [ 4] 	bcs df_tk_nop_false
                             	; got a token
d922 : 0980             [ 2] 	ora #DFTK_TOKEN
d924 : 20b7d6           [ 6] 	jsr df_tk_put_tok
d927 : 18               [ 2] 	clc
d928 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Parse numeric expression
                             ;****************************************
d929 :                       df_tk_expression
                             	; Tokenise a numeric term
d929 : 20c8d8           [ 6] 	jsr df_tk_nterm
d92c : b006             [ 3] 	bcs df_tk_expre_err
                             	; Try and tokenise a numeric operator
d92e : 2014d9           [ 6] 	jsr df_tk_nop
                             	; If an operator was tokenised
AS65 Assembler for R6502 [1.42].                                     Page  150
-------------------------------- bank\bank0.s --------------------------------

                             	; then loop back for another term
d931 : 90f6             [ 3] 	bcc df_tk_expression
                             	; If no operator was found then
                             	; expression is done
d933 :                       df_tk_not_eos
d933 : 18               [ 2] 	clc
d934 :                       df_tk_expre_err
d934 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find expected token and parse expression
                             ;****************************************
d935 :                       df_tk_tok_expression
d935 : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
d938 : 4c29d9           [ 3] 	jmp df_tk_expression
                             
                             
                             ;****************************************
                             ;* Check end of statement
                             ;****************************************
d93b :                       df_tk_isEOS
d93b : a93a             [ 2] 	lda #':'
d93d : 202cd7           [ 6] 	jsr df_tk_expect_tok
d940 : b0f1             [ 3] 	bcs df_tk_not_eos
                             	; this is the position of the next statement
d942 : a57d             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
d944 : a47f             [ 3] 	ldy df_nxtstidx
d946 : 998004           [ 5] 	sta df_tokbuff,y
d949 : 38               [ 2] 	sec
d94a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Parse user defined proc
                             ;****************************************
d94b :                       df_tk_parse_user_proc
                             	; put proc token in as a call
d94b : a981             [ 2] 	lda #0x81
d94d : 20b7d6           [ 6] 	jsr df_tk_put_tok
d950 : a901             [ 2] 	lda #1
d952 : 4c35d8           [ 3] 	jmp df_tk_proc
                             
                             
                             ;****************************************
                             ;* Parse a command
                             ;* Do not fatal error if this fails
                             ;****************************************
d955 :                       df_tk_parse_command
                             	; only looking for keywords
d955 : a901             [ 2] 	lda #DFTK_KW
d957 : 2015da           [ 6] 	jsr df_tk_matchtok
                             	; if didn't find regular keywords then try non f
d95a : b010             [ 3] 	bcs df_tk_parse_command_err
                             	; if match then store token in the line buffer
                             	; Set MSB
d95c : 0980             [ 2] 	ora #0x80
d95e : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; call the parser to do tokenise based on the st
d961 : a583             [ 3] 	lda df_symoff
d963 : 20e7d9           [ 6] 	jsr df_tk_exec_parser
d966 : b004             [ 3] 	bcs df_tk_parse_command_err
AS65 Assembler for R6502 [1.42].                                     Page  151
-------------------------------- bank\bank0.s --------------------------------

                             	; [1] ignore white space but keep it
d968 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
d96b :                       df_tk_parse_command_done
d96b : 18               [ 2] 	clc
d96c :                       df_tk_parse_command_err
d96c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* lexer
                             ;****************************************
d96d :                       df_lexer_line
d96d : a900             [ 2] 	lda #0
                             	; start at the beginning of the line buffer
d96f : 857c             [ 3] 	sta df_linoff
                             	; start at the beginning of the tokenised buffer
d971 : 857d             [ 3] 	sta df_tokoff
                             	; set current line to the token buffer
d973 : a980             [ 2] 	lda #lo(df_tokbuff)
d975 : 8586             [ 3] 	sta df_currlin
d977 : a904             [ 2] 	lda #hi(df_tokbuff)
d979 : 8587             [ 3] 	sta df_currlin+1
                             	; Set the line length to 0
d97b : a900             [ 2] 	lda #0
d97d : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             
                             	; any leading white space, ignore and discard
                             ;	jsr df_tk_strip_ws
                             
                             	; if peek next character is a number then assume
                             	; else assume a statement
d980 : 20a6d6           [ 6] 	jsr df_tk_peek_buf
d983 : 20c5d6           [ 6] 	jsr df_tk_isdigit
d986 : 9006             [ 3] 	bcc df_lexer_skip_lnum
                             	; if line number then capture the line number an
d988 : 20f6d9           [ 6] 	jsr df_tk_linenum
d98b : 4c96d9           [ 3] 	jmp df_tk_body
d98e :                       df_lexer_skip_lnum
                             	; if no line number then zero out the line numbe
                             	; line zero will indicate an immediate mode comm
d98e : a900             [ 2] 	lda #0
d990 : 20b7d6           [ 6] 	jsr df_tk_put_tok				; Line num low byte
d993 : 20b7d6           [ 6] 	jsr df_tk_put_tok				; Line num high byte
d996 :                       df_tk_body
                             	; Offset for next statement
d996 : a57d             [ 3] 	lda df_tokoff
d998 : 857f             [ 3] 	sta df_nxtstidx
d99a : a900             [ 2] 	lda #0
d99c : 20b7d6           [ 6] 	jsr df_tk_put_tok				; Offset to next statement
d99f : 20a6d6           [ 6] 	jsr df_tk_peek_buf				; Check for a single space
d9a2 : 2017d7           [ 6] 	jsr df_tk_isws					; and first character
d9a5 : 9002             [ 3] 	bcc df_tk_skip_1_spc
d9a7 : e67c             [ 5] 	inc df_linoff					; Don't tokenise this single s
d9a9 :                       df_tk_skip_1_spc
                             	; [1] capture white space from line buffer in to
d9a9 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; If next non ws is zero then this is an empty l
                             	; so return with length zero but line number fil
                             	; token buffer
d9ac : c900             [ 2] 	cmp #0
d9ae : f033             [ 3] 	beq df_tk_line_empty
AS65 Assembler for R6502 [1.42].                                     Page  152
-------------------------------- bank\bank0.s --------------------------------

                             	; if next char is _ then parse a user defined pr
d9b0 : 2002d7           [ 6] 	jsr df_tk_isproc
d9b3 : 9006             [ 3] 	bcc df_tk_try_command
d9b5 : 204bd9           [ 6] 	jsr df_tk_parse_user_proc
d9b8 : 4cc5d9           [ 3] 	jmp df_tk_done
d9bb :                       df_tk_try_command
                             	; try  a keyword
d9bb : 2055d9           [ 6] 	jsr df_tk_parse_command
                             ;	bcs	df_tk_try_assign
d9be : 9005             [ 3] 	bcc df_tk_done
d9c0 :                       df_tk_try_assign
                             	; nothing but to try an assignment operation
d9c0 : 207add           [ 6] 	jsr df_tk_assign
d9c3 : b020             [ 3] 	bcs	df_tk_parseerror
d9c5 :                       df_tk_done
                             	; put statement index stuff here in case of mult
                             	; check for : and if present tokenise plus updat
                             	; then go back to try and process another statem
d9c5 : 203bd9           [ 6] 	jsr df_tk_isEOS
d9c8 : b0cc             [ 3] 	bcs df_tk_body
                             	; if not at end of line, then must be error
d9ca : 20a6d6           [ 6] 	jsr df_tk_peek_buf
d9cd : c900             [ 2] 	cmp #0
d9cf : d014             [ 3] 	bne df_tk_parseerror
                             	; this is the position of the next line
d9d1 : a57d             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
d9d3 : a47f             [ 3] 	ldy df_nxtstidx
d9d5 : 998004           [ 5] 	sta df_tokbuff,y
                             	; Get line length
d9d8 : a47d             [ 3] 	ldy df_tokoff
                             	; ensure there is always a zero after the last t
                             	; A is already zero
d9da : a900             [ 2] 	lda #0
d9dc : 998004           [ 5] 	sta df_tokbuff,y
                             	; save the line length
d9df : 98               [ 2] 	tya
d9e0 : 8d8004           [ 4] 	sta df_tokbuff
d9e3 :                       df_tk_line_empty
d9e3 : 18               [ 2] 	clc
d9e4 : 60               [ 6] 	rts
d9e5 :                       df_tk_parseerror
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* df_tk_parsestatement
                             ;* Execute parse routine for this statement
                             ;* Input: df_tokoff is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
d9e7 :                       df_tk_exec_parser
d9e7 : 0a               [ 2] 	asl a
d9e8 : aa               [ 2] 	tax
d9e9 : bd31dc           [ 4] 	lda df_tk_tokenjmp,x
d9ec : 85a1             [ 3] 	sta df_tmpptra
d9ee : bd32dc           [ 4] 	lda df_tk_tokenjmp+1,x
d9f1 : 85a2             [ 3] 	sta df_tmpptra+1
d9f3 : 6ca100           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  153
-------------------------------- bank\bank0.s --------------------------------

                             ;* df_tk_linenum
                             ;* Tokenise line number
                             ;****************************************
d9f6 :                       df_tk_linenum
                             	; Convert line number to 16 bit number
                             	; Save the line number
                             	; Increment the buffer pointer
d9f6 : 18               [ 2] 	clc
d9f7 : a900             [ 2] 	lda #lo(df_linbuff)
d9f9 : 657c             [ 3] 	adc df_linoff
d9fb : aa               [ 2] 	tax
d9fc : a904             [ 2] 	lda #hi(df_linbuff)
d9fe : 6900             [ 2] 	adc #0
da00 : a001             [ 2] 	ldy #1			; Decimal format only
da02 : 20e1c1           [ 6] 	jsr con_n_to_a
da05 : 18               [ 2] 	clc
da06 : 8a               [ 2] 	txa
da07 : 657c             [ 3] 	adc df_linoff
da09 : 857c             [ 3] 	sta df_linoff
                             	; Now save line number
da0b : a53d             [ 3] 	lda num_a
da0d : 20b7d6           [ 6] 	jsr df_tk_put_tok
da10 : a53e             [ 3] 	lda num_a+1
da12 : 4cb7d6           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* df_tk_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;*			df_symoff is the symbol table index
                             ;****************************************
da15 :                       df_tk_matchtok
                             	; save the mask to check types against
da15 : 48               [ 3] 	pha
                             	; Start at token symbols beginning
da16 : a997             [ 2] 	lda #lo(df_tokensyms)
da18 : 8581             [ 3] 	sta df_symtab
da1a : a9da             [ 2] 	lda #hi(df_tokensyms)
da1c : 8582             [ 3] 	sta df_symtab+1
da1e : a900             [ 2] 	lda #0
da20 : 8583             [ 3] 	sta df_symoff
da22 :                       df_tk_checknexttok
                             	; check this token type first
da22 : 68               [ 4] 	pla
da23 : 48               [ 3] 	pha
da24 : a683             [ 3] 	ldx df_symoff
da26 : 3df7dc           [ 4] 	and df_tk_tokentype,x
da29 : f032             [ 3] 	beq df_tk_symnomatch
                             	; Special check for operator token
                             	; because of order of precedence fudge
                             	; ******FIX THIS ONE DAY!!!!!!******
                             	; if parm and token type = DFTK_OP then ok
                             	; if parm and token type <> DFTK_OP then not ok
da2b : bdf7dc           [ 4] 	lda df_tk_tokentype,x
da2e : 2908             [ 2] 	and #DFTK_OP
da30 : f009             [ 3] 	beq df_tk_matchtok_skip_op
da32 : 68               [ 4] 	pla
da33 : 48               [ 3] 	pha
da34 : 2908             [ 2] 	and #DFTK_OP
AS65 Assembler for R6502 [1.42].                                     Page  154
-------------------------------- bank\bank0.s --------------------------------

da36 : 3df7dc           [ 4] 	and df_tk_tokentype,x
da39 : f022             [ 3] 	beq df_tk_symnomatch
da3b :                       df_tk_matchtok_skip_op
                             	; From the line buffer current pointer
                             	; Check for a token match
da3b : a47c             [ 3] 	ldy df_linoff
da3d : a200             [ 2] 	ldx #0
da3f :                       df_tk_checktokch
                             	; Get symtable char
                             	; and mask off MSB
da3f : a181             [ 6] 	lda (df_symtab,x)
                             	; Save the value and mask off MSB
da41 : 48               [ 3] 	pha
da42 : 297f             [ 2] 	and #0x7f
                             	; Compare with current line buffer char
da44 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
da47 : d013             [ 3] 	bne df_tk_symnomatchp
                             	; If match and symbol has MSB then
                             	; all of the symbol matched
da49 : 68               [ 4] 	pla
da4a : 3033             [ 3] 	bmi df_tk_symfound
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
da52 : c8               [ 2] 	iny
                             	; If buffer is '.' then let this be a match
da53 : b90004           [ 4] 	lda df_linbuff,y
da56 : c92e             [ 2] 	cmp #'.'
da58 : f025             [ 3] 	beq df_tk_symfound
da5a : d0e3             [ 3] 	bne df_tk_checktokch	; branch always
da5c :                       df_tk_symnomatchp
da5c : 68               [ 4] 	pla
da5d :                       df_tk_symnomatch
                             	; Increment symbol counter to next symbol
da5d : e683             [ 5] 	inc df_symoff
da5f :                       df_tk_symnextentry
da5f : a200             [ 2] 	ldx #0
da61 : a181             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is MSB
da63 : 3009             [ 3] 	bmi  df_tk_foundsymend
                             	_incZPWord df_symtab
                             
da6b : 4c5fda           [ 3] 	jmp df_tk_symnextentry
da6e :                       df_tk_foundsymend
                             	; Increment char to point to new symbol
                             	; for matching with line buffer
                             	_incZPWord df_symtab
                             
                             	; If next char is not zero then
                             	; try and match with line buffer
da74 : a181             [ 6] 	lda (df_symtab,x)
da76 : d0aa             [ 3] 	bne df_tk_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; pop mask off stack
da78 : 68               [ 4] 	pla
                             	; Zero symbol counter
da79 : a900             [ 2] 	lda #0
da7b : 8583             [ 3] 	sta df_symoff
                             	; Set C to indicate error (no match)
AS65 Assembler for R6502 [1.42].                                     Page  155
-------------------------------- bank\bank0.s --------------------------------

da7d : 38               [ 2] 	sec
da7e : 60               [ 6] 	rts
da7f :                       df_tk_symfound
                             	; Full match with keyword in symtable but
                             	; if matching with something that ended in alpha
                             	; then check the next buffer char is not alphanu
                             	; as this could be part of a variable name
                             	; Point to next buffer char in any case
da7f : c8               [ 2] 	iny
                             	; First mask off MSB
da80 : 297f             [ 2] 	and #0x7f
                             	; Then check if alpha
da82 : 20efd6           [ 6] 	jsr df_tk_isalpha
                             	; if not alpha then we're definitely done
da85 : 9008             [ 3] 	bcc df_tk_symfound_final
                             	; else check buffer
da87 : b90004           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
da8a : 20fcd6           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
da8d : b0ce             [ 3] 	bcs df_tk_symnomatch
da8f :                       df_tk_symfound_final
                             	; pop mask off stack
da8f : 68               [ 4] 	pla
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
da90 : 847c             [ 3] 	sty df_linoff
da92 : a583             [ 3] 	lda df_symoff
da94 : aa               [ 2] 	tax
da95 : 18               [ 2] 	clc
da96 : 60               [ 6] 	rts
                             
                             	include "dflat/tksymtab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKSYMTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Statement Token table
                             ; keywords
da97 :                       df_tokensyms
AS65 Assembler for R6502 [1.42].                                     Page  156
-------------------------------- bank\bank0.s --------------------------------

da97 : 80                    	db	0x80						; Implicit numeric assign
da98 : 80                    	db	0x80						; Implicit call procedure
da99 : bb                    	db	";"+0x80					; Comment
da9a : 7072696e746cee        	db	"printl",'n'+0x80			; println exprlist
daa1 : 7072696e7461f4        	db	"printa",'t'+0x80			; printat x,y,exprlist
daa8 : 7072696ef4            	db	"prin",'t'+0x80				; print exprlist
daad : 6465e6                	db	"de",'f'+0x80				; def_subname
dab0 : 656e646465e6          	db	"endde",'f'+0x80			; enddef
dab6 : 7265747572ee          	db	"retur",'n'+0x80			; return
dabc : 61626f72f4            	db	"abor",'t'+0x80				; abort
dac1 : 6c6f6361ec            	db	"loca",'l'+0x80				; local varlist
dac6 : 6469ed                	db	"di",'m'+0x80				; dim varlist
dac9 : 7265706561f4          	db	"repea",'t'+0x80			; repeat
dacf : 756e7469ec            	db	"unti", 'l'+0x80			; until condition
dad4 : 666ff2                	db	"fo",'r'+0x80				; for var=start,end,incremen
dad7 : 6e6578f4              	db	"nex",'t'+0x80				; next
dadb : 7768696ce5            	db	"whil",'e'+0x80				; while condition
dae0 : 77656ee4              	db	"wen",'d'+0x80				; wend
dae4 : 69e6                  	db	"i",'f'+0x80				; if condition
dae6 : 656c73e5              	db	"els",'e'+0x80				; else
daea : 656e6469e6            	db	"endi",'f'+0x80				; endif
daef : 656c69e6              	db	"eli",'f'+0x80				; elif condition
daf3 : 646174e1              	db	"dat",'a'+0x80				; data
daf7 : ae                    	db	'.'+0x80					; assembler command
daf8 : 7275ee                	db	"ru",'n'+0x80				; run
dafb : 6c6973f4              	db	"lis",'t'+0x80				; list _proc-|*|line,line
daff : 696e7075f4            	db	"inpu",'t'+0x80				; input var
db04 : 746578f4              	db	"tex",'t'+0x80				; text
db08 : 706c6ff4              	db	"plo",'t'+0x80				; plot x,y,char|string
db0c : 637572736ff2          	db	"curso",'r'+0x80			; cursor n
db12 : 636cf3                	db	"cl",'s'+0x80				; cls
db15 : 706f6be5              	db	"pok",'e'+0x80				; poke a,v
db19 : 646f6be5              	db	"dok",'e'+0x80				; doke a,v
db1d : 736f756ee4            	db	"soun",'d'+0x80				; sound
db22 : 6d757369e3            	db	"musi",'c'+0x80				; music
db27 : 706c61f9              	db	"pla",'y'+0x80				; play
db2b : 736176e5              	db	"sav",'e'+0x80				; save "fname"
db2f : 6c6f61e4              	db	"loa",'d'+0x80				; load "fname"
db33 : 726561e4              	db	"rea",'d'+0x80				; read
db37 : 6e65f7                	db	"ne",'w'+0x80				; new
db3a : 72656e75ed            	db	"renu",'m'+0x80				; renum start,offset,incre
db3f : 776169f4              	db	"wai",'t'+0x80				; wait delay
db43 : 72657365f4            	db	"rese",'t'+0x80				; reset var
db48 : 68697265f3            	db	"hire",'s'+0x80				; hires col
db4d : 706f696ef4            	db	"poin",'t'+0x80				; point x,y
db52 : 6c696ee5              	db	"lin",'e'+0x80				; line x0,y0,x1,y1
db56 : 6c696e6574ef          	db	"linet",'o'+0x80			; lineto x1,y1
db5c : 7069786d6f64e5        	db	"pixmod",'e'+0x80			; pixmode n
db63 : 696eeb                	db	"in",'k'+0x80				; ink n
db66 : 70617065f2            	db	"pape",'r'+0x80				; paper n
db6b : 636972636ce5          	db	"circl",'e'+0x80			; circle x,y,r
                             ;	db	"fil",'l'+0x80				; fill x,y,w,h,v
db71 : 68696d65ed            	db	"hime",'m'+0x80				; himem addr
db76 : 6d6f6e69746ff2        	db	"monito",'r'+0x80			; monitor
db7d : 737072636861f2        	db	"sprcha",'r'+0x80			; sprchar sp,ch
db84 : 737072706ff3          	db	"sprpo",'s'+0x80			; sprpos sp,x,y
db8a : 7370727570e4          	db	"sprup",'d'+0x80			; sprupd
db90 : 737072696e69f4        	db	"sprini",'t'+0x80			; sprinit
db97 : 7370726d756c74e9      	db	"sprmult",'i'+0x80			; sprmulti x[],y[]
db9f : 62736176e5            	db	"bsav",'e'+0x80				; bsave addr,len,"fname"
dba4 : 626c6f61e4            	db	"bloa",'d'+0x80				; bload addr,"fname"
dba9 : 74736176e5            	db	"tsav",'e'+0x80				; tsave "fname"
AS65 Assembler for R6502 [1.42].                                     Page  157
-------------------------------- bank\bank0.s --------------------------------

dbae : 746c6f61e4            	db	"tloa",'d'+0x80				; tload "fname"
                             ; Functions
dbb3 : 7065656ba8            	db	"peek",'('+0x80				; peek(x)
dbb8 : 6465656ba8            	db	"deek",'('+0x80				; peek(x)
dbbd : 737469636ba8          	db	"stick",'('+0x80			; stick(x)
dbc3 : 676574a8              	db	"get",'('+0x80				; get(x)
dbc7 : 636872a8              	db	"chr",'('+0x80				; chr(x)
dbcb : 6c656674a8            	db	"left",'('+0x80				; left(x$,y)
dbd0 : 7269676874a8          	db	"right",'('+0x80			; right(x$,y)
dbd6 : 6d6964a8              	db	"mid",'('+0x80				; mid(x$,y)
dbda : 6c656ea8              	db	"len",'('+0x80				; len(x$)
dbde : 6d656da8              	db	"mem",'('+0x80				; mem(x)
dbe2 : 7363726ea8            	db	"scrn",'('+0x80				; scrn(x,y)
dbe7 : 726e64a8              	db	"rnd",'('+0x80				; rnd(x)
dbeb : 656c6170736564a8      	db	"elapsed",'('+0x80			; elapsed(var)
dbf3 : 63616c6ca8            	db	"call",'('+0x80				; call(addr,A,X,Y)
dbf8 : 686578a8              	db	"hex",'('+0x80				; hex(x)
dbfc : 617363a8              	db	"asc",'('+0x80				; asc(x$)
dc00 : 76616ca8              	db	"val",'('+0x80				; val(x$)
dc04 : 706978656ca8          	db	"pixel",'('+0x80			; pixel(x,y)
dc0a : 737072686974a8        	db	"sprhit",'('+0x80			; sprhit(sp)
dc11 : 73676ea8              	db	"sgn",'('+0x80				; sgn(x)
dc15 : 61646472a8            	db	"addr",'('+0x80				; addr(var)
                             ; Numeric operators, in priority
dc1a : aa                    	db	'*'+0x80					; Multiply
dc1b : af                    	db 	'/'+0x80					; Divide
dc1c : dc                    	db 	'\\'+0x80					; Modulus
dc1d : 3cbc                  	db	'<','<'+0x80				; Shift left
dc1f : 3ebe                  	db	'>','>'+0x80				; Shift right
dc21 : ab                    	db 	'+'+0x80					; Add
dc22 : ad                    	db	'-'+0x80					; Subtract
                             ; Bool and conditional operators, in priority
dc23 : a6                    	db '&'+0x80						; AND
dc24 : fc                    	db '|'+0x80						; OR
dc25 : de                    	db '^'+0x80						; EOR
dc26 : 3cbd                  	db "<",'='+0x80					; Less than or equal
dc28 : 3ebd                  	db ">",'='+0x80					; Greater than or equal
dc2a : 3cbe                  	db "<",'>'+0x80					; Not equal
dc2c : bc                    	db '<'+0x80						; Less than
dc2d : be                    	db '>'+0x80						; Greater than
dc2e : 3dbd                  	db "=",'='+0x80					; Equality (always last)
                             
dc30 : 00                    	db  0
                             
                             
                             	
                             	
                             	include "dflat/tkjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
AS65 Assembler for R6502 [1.42].                                     Page  158
-------------------------------- bank\bank0.s --------------------------------

                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
dc31 :                       df_tk_tokenjmp
dc31 : 7add                  	dw	df_tk_assign
dc33 : 31de                  	dw	df_tk_callproc
dc35 : 83dd                  	dw	df_tk_comment
dc37 : cadd                  	dw	df_tk_println
dc39 : c4dd                  	dw	df_tk_printat
dc3b : cadd                  	dw	df_tk_print
dc3d : 15de                  	dw	df_tk_def
dc3f : 6ade                  	dw	df_tk_enddef
dc41 : 6cde                  	dw	df_tk_return
dc43 : 6ade                  	dw	df_tk_abort
dc45 : 06de                  	dw	df_tk_local
dc47 : f7dd                  	dw	df_tk_dim
dc49 : 6ade                  	dw	df_tk_repeat
dc4b : 6fde                  	dw	df_tk_until
dc4d : 1ade                  	dw	df_tk_for
dc4f : 6ade                  	dw	df_tk_next
dc51 : 6fde                  	dw	df_tk_while
dc53 : 6ade                  	dw	df_tk_wend
dc55 : 6fde                  	dw	df_tk_if
dc57 : 6ade                  	dw	df_tk_else
dc59 : 6ade                  	dw	df_tk_endif
dc5b : 6fde                  	dw	df_tk_elseif
dc5d : d1dd                  	dw	df_tk_data
dc5f : 7ef8                  	dw	df_tk_asm_parse_command
dc61 : 6ade                  	dw	df_tk_run
dc63 : b3dd                  	dw	df_tk_list
dc65 : dfdd                  	dw	df_tk_input
dc67 : 6ade                  	dw	df_tk_text
dc69 : 7fde                  	dw	df_tk_plot
dc6b : 6fde                  	dw	df_tk_cursor
dc6d : 6ade                  	dw	df_tk_cls
dc6f : 75de                  	dw	df_tk_poke
dc71 : 75de                  	dw	df_tk_doke
dc73 : 7fde                  	dw	df_tk_sound
dc75 : 87de                  	dw	df_tk_music
dc77 : 87de                  	dw	df_tk_play
dc79 : 6fde                  	dw	df_tk_save
dc7b : 6fde                  	dw	df_tk_load
dc7d : e8dd                  	dw	df_tk_read
dc7f : 6ade                  	dw	df_tk_new
dc81 : 7fde                  	dw	df_tk_renum
dc83 : 6fde                  	dw	df_tk_wait
dc85 : 33de                  	dw	df_tk_reset
dc87 : 6ade                  	dw	df_tk_hires
dc89 : 75de                  	dw	df_tk_point
dc8b : 87de                  	dw	df_tk_line
dc8d : 75de                  	dw	df_tk_lineto
AS65 Assembler for R6502 [1.42].                                     Page  159
-------------------------------- bank\bank0.s --------------------------------

dc8f : 6fde                  	dw	df_tk_pixmode
dc91 : 6fde                  	dw	df_tk_ink
dc93 : 6fde                  	dw	df_tk_paper
dc95 : 7fde                  	dw	df_tk_circle
                             ;	dw	df_tk_fill
dc97 : 6fde                  	dw	df_tk_himem
dc99 : 6ade                  	dw	df_tk_monitor
dc9b : 75de                  	dw	df_tk_sprchar
dc9d : 7fde                  	dw	df_tk_sprpos
dc9f : 6ade                  	dw	df_tk_sprupd
dca1 : 6ade                  	dw	df_tk_sprinit
dca3 : 75de                  	dw	df_tk_sprmulti
dca5 : 7fde                  	dw	df_tk_bsave
dca7 : 75de                  	dw	df_tk_bload
dca9 : 6fde                  	dw	df_tk_tsave
dcab : 6fde                  	dw	df_tk_tload
                             	
dcad : 3dde                  	dw	df_tk_peek
dcaf : 3dde                  	dw	df_tk_deek
dcb1 : 42de                  	dw	df_tk_stick
dcb3 : 3dde                  	dw	df_tk_get
dcb5 : 3dde                  	dw	df_tk_chr
dcb7 : 50de                  	dw	df_tk_left
dcb9 : 50de                  	dw	df_tk_right
dcbb : 56de                  	dw	df_tk_mid
dcbd : 3dde                  	dw	df_tk_len
dcbf : 3dde                  	dw	df_tk_mem
dcc1 : 50de                  	dw	df_tk_scrn
dcc3 : 3dde                  	dw	df_tk_rnd
dcc5 : 47de                  	dw	df_tk_elapsed
dcc7 : 5cde                  	dw	df_tk_call
dcc9 : 3dde                  	dw	df_tk_hex
dccb : 3dde                  	dw	df_tk_asc
dccd : 3dde                  	dw	df_tk_val
dccf : 50de                  	dw	df_tk_pixel
dcd1 : 3dde                  	dw	df_tk_sprhit
dcd3 : 3dde                  	dw	df_tk_sgn
dcd5 : 47de                  	dw	df_tk_addr
                             	
dcd7 : 6ade                  	dw	df_tk_mult
dcd9 : 6ade                  	dw	df_tk_div
dcdb : 6ade                  	dw	df_tk_mod
dcdd : 6ade                  	dw	df_tk_asl
dcdf : 6ade                  	dw	df_tk_lsr
dce1 : 6ade                  	dw	df_tk_add
dce3 : 6ade                  	dw	df_tk_sub
                             	
dce5 : 6ade                  	dw	df_tk_and
dce7 : 6ade                  	dw	df_tk_or
dce9 : 6ade                  	dw	df_tk_eor
dceb : 6ade                  	dw	df_tk_lte
dced : 6ade                  	dw	df_tk_gte
dcef : 6ade                  	dw	df_tk_ne
dcf1 : 6ade                  	dw	df_tk_lt
dcf3 : 6ade                  	dw	df_tk_gt
dcf5 : 6ade                  	dw	df_tk_eq
                             
                             
                             	
                             	
                             	
                             	
AS65 Assembler for R6502 [1.42].                                     Page  160
-------------------------------- bank\bank0.s --------------------------------

                             	
                             	include "dflat/tktyptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser type table (is it a keyword, function
                             ; In token order of df_tokensyms
dcf7 :                       df_tk_tokentype
dcf7 : 01                    	db	DFTK_KW
dcf8 : 01                    	db	DFTK_KW
dcf9 : 01                    	db	DFTK_KW
dcfa : 01                    	db	DFTK_KW
dcfb : 01                    	db	DFTK_KW
dcfc : 01                    	db	DFTK_KW
dcfd : 01                    	db	DFTK_KW
dcfe : 01                    	db	DFTK_KW
dcff : 01                    	db	DFTK_KW
dd00 : 01                    	db	DFTK_KW
dd01 : 01                    	db	DFTK_KW
dd02 : 01                    	db	DFTK_KW
dd03 : 01                    	db	DFTK_KW
dd04 : 01                    	db	DFTK_KW
dd05 : 01                    	db	DFTK_KW
dd06 : 01                    	db	DFTK_KW
dd07 : 01                    	db	DFTK_KW
dd08 : 01                    	db	DFTK_KW
dd09 : 01                    	db	DFTK_KW
dd0a : 01                    	db	DFTK_KW
dd0b : 01                    	db	DFTK_KW
dd0c : 01                    	db	DFTK_KW
dd0d : 01                    	db	DFTK_KW
dd0e : 01                    	db	DFTK_KW
dd0f : 01                    	db	DFTK_KW
dd10 : 01                    	db	DFTK_KW
dd11 : 01                    	db	DFTK_KW
dd12 : 01                    	db	DFTK_KW
dd13 : 01                    	db	DFTK_KW
dd14 : 01                    	db	DFTK_KW
dd15 : 01                    	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page  161
-------------------------------- bank\bank0.s --------------------------------

dd16 : 01                    	db	DFTK_KW
dd17 : 01                    	db	DFTK_KW
dd18 : 01                    	db	DFTK_KW
dd19 : 01                    	db	DFTK_KW
dd1a : 01                    	db	DFTK_KW
dd1b : 01                    	db	DFTK_KW
dd1c : 01                    	db	DFTK_KW
dd1d : 01                    	db	DFTK_KW
dd1e : 01                    	db	DFTK_KW
dd1f : 01                    	db	DFTK_KW
dd20 : 01                    	db	DFTK_KW
dd21 : 01                    	db	DFTK_KW
dd22 : 01                    	db	DFTK_KW
dd23 : 01                    	db	DFTK_KW
dd24 : 01                    	db	DFTK_KW
dd25 : 01                    	db	DFTK_KW
dd26 : 01                    	db	DFTK_KW
dd27 : 01                    	db	DFTK_KW
dd28 : 01                    	db	DFTK_KW
dd29 : 01                    	db	DFTK_KW
                             ;	db	DFTK_KW
dd2a : 01                    	db	DFTK_KW
dd2b : 01                    	db	DFTK_KW
dd2c : 01                    	db	DFTK_KW
dd2d : 01                    	db	DFTK_KW
dd2e : 01                    	db	DFTK_KW
dd2f : 01                    	db	DFTK_KW
dd30 : 01                    	db	DFTK_KW
dd31 : 01                    	db	DFTK_KW
dd32 : 01                    	db	DFTK_KW
dd33 : 01                    	db	DFTK_KW
dd34 : 01                    	db	DFTK_KW
                             
dd35 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd36 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd37 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd38 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd39 : 42                    	db 	DFTK_FN | DFTK_STR
dd3a : 42                    	db 	DFTK_FN | DFTK_STR
dd3b : 42                    	db 	DFTK_FN | DFTK_STR
dd3c : 42                    	db 	DFTK_FN | DFTK_STR
dd3d : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd3e : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd3f : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd40 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd41 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd42 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd43 : 42                    	db 	DFTK_FN | DFTK_STR
dd44 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd45 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd46 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd47 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd48 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
dd49 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                             	;* Operators add the order of precedence (0=high
dd4a : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd4b : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd4c : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
dd4d : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
dd4e : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
dd4f : 3e                    	db 	DFTK_OP | DFTK_STROP | DFTK_INT | DFTK_BYT +
dd50 : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
AS65 Assembler for R6502 [1.42].                                     Page  162
-------------------------------- bank\bank0.s --------------------------------

                             
dd51 : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd52 : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd53 : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
dd54 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd55 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd56 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd57 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd58 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
dd59 : 3f                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                             
                             
                             	
                             	
                             	
                             	
                             
                             	include "dflat/toksubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKSUBS.S
                             ;*  Module that implements the tokenisation of ke
                             ;*  When a line is being parsed, the index of the
                             ;*  found in the symbol table is used to call a r
                             ;*  here.  The job of a routine here is then to f
                             ;*  parse the raw input e.g. a command that takes
                             ;*  parameters, need to do what it needs to ident
                             ;*  Despite the number of keywords in dflat, this
                             ;*  anywhere near the size of rtsubs.s (the runti
                             ;*  equivalent of this) because there is so much 
                             ;*  synactically.
                             ;*  The tokenised output is put in to its own buf
                             ;*  if the whole input was tokenised successfully
                             ;*  dflat will either try and execute (if in imme
                             ;*  mode), or save it to program memory in line n
                             ;*  order.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
dd5a :                       mod_sz_toksubs_s
                             
                             ;* General routine to tokenise a mandatory variab
dd5a :                       df_tk_variable
dd5a : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
dd5d : 20a6d6           [ 6] 	jsr df_tk_peek_buf
dd60 : 20efd6           [ 6] 	jsr df_tk_isalpha
dd63 : 9013             [ 3] 	bcc df_tk_error
dd65 : a900             [ 2] 	lda #0
dd67 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse assignment preamble
AS65 Assembler for R6502 [1.42].                                     Page  163
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
dd68 :                       df_tk_preassign
                             	; Put assignment token
                             	; assume its a numeric int for now
dd68 : a980             [ 2] 	lda #0x80
dd6a : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	
                             	; first find or create a variable
dd6d : 205add           [ 6] 	jsr df_tk_variable
dd70 : 20e2d7           [ 6] 	jsr df_tk_var
                             	; next char should be '='
dd73 : a93d             [ 2] 	lda #'='
dd75 : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             
dd78 :                       df_tk_error
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric assignment
                             ;****************************************
dd7a :                       df_tk_assign
dd7a : 2068dd           [ 6] 	jsr df_tk_preassign
                             	; tokenise an expression (int or byte)
dd7d : 2029d9           [ 6] 	jsr df_tk_expression
dd80 : b0f6             [ 3] 	bcs df_tk_error
dd82 : 60               [ 6] 	rts
                             
dd83 :                       df_tk_comment
                             	; copy all subsequent chars to token
dd83 : 20acd6           [ 6] 	jsr df_tk_get_buf
dd86 : f006             [ 3] 	beq df_tk_comment_done
dd88 : 20b7d6           [ 6] 	jsr df_tk_put_tok
dd8b : 4c83dd           [ 3] 	jmp df_tk_comment
dd8e :                       df_tk_comment_done
dd8e : 18               [ 2] 	clc
dd8f : 60               [ 6] 	rts
                             
                             ; Utility to get procedure name with _
dd90 :                       df_tk_listp_procname
                             	; try and find the first proc
dd90 : a95f             [ 2] 	lda #'_'
dd92 : 202cd7           [ 6] 	jsr df_tk_expect_tok
dd95 : b01a             [ 3] 	bcs df_tk_listp_procname_err
                             	; now get first alpha then all alphanum
dd97 : 20a6d6           [ 6] 	jsr df_tk_peek_buf
dd9a : 20efd6           [ 6] 	jsr df_tk_isalpha
dd9d : 9012             [ 3] 	bcc df_tk_listp_procname_err
dd9f :                       df_tk_listp_procname_ch
dd9f : 20a6d6           [ 6] 	jsr df_tk_peek_buf
dda2 : 20fcd6           [ 6] 	jsr df_tk_isalphanum
dda5 : 9009             [ 3] 	bcc df_tk_listp_procname_ok
dda7 : 20acd6           [ 6] 	jsr df_tk_get_buf
ddaa : 20b7d6           [ 6] 	jsr df_tk_put_tok
ddad : 4c9fdd           [ 3] 	jmp df_tk_listp_procname_ch
ddb0 :                       df_tk_listp_procname_ok
ddb0 : 60               [ 6] 	rts		; C=0
ddb1 :                       df_tk_listp_procname_err
ddb1 : 38               [ 2] 	sec
ddb2 : 60               [ 6] 	rts
                             
                             ; list		: list whole program
AS65 Assembler for R6502 [1.42].                                     Page  164
-------------------------------- bank\bank0.s --------------------------------

                             ; list n	: list line n to end
                             ; list *	: list all procedures
                             ; list _proc: list _proc lines
ddb3 :                       df_tk_list
ddb3 : 2090dd           [ 6] 	jsr df_tk_listp_procname
ddb6 : 900b             [ 3] 	bcc df_tk_list_done
                             	; if not found try '*' or normal list
ddb8 :                       df_tk_list_procs
                             	; first try for list symbol
ddb8 : a92a             [ 2] 	lda #'*'
ddba : 202cd7           [ 6] 	jsr df_tk_expect_tok
ddbd : 9004             [ 3] 	bcc df_tk_list_done
                             	; else normal line number or nothing
ddbf :                       df_tk_list_line
                             	; tokenise an expression, nothing is ok
ddbf : 2029d9           [ 6] 	jsr df_tk_expression
ddc2 : 18               [ 2] 	clc
ddc3 :                       df_tk_list_done
ddc3 : 60               [ 6] 	rts
                             
                             ; printat,print,println can have 0,1 or many expr
ddc4 :                       df_tk_printat
                             	; Must get 2 parms for x,y
ddc4 : 2075de           [ 6] 	jsr df_tk_2parms
                             	; try getting more parms
ddc7 : 4cd6dd           [ 3] 	jmp df_tk_expr_more
ddca :                       df_tk_println
ddca :                       df_tk_print
                             	; tokenise an expression ok if null
ddca : 2029d9           [ 6] 	jsr df_tk_expression
ddcd : 9007             [ 3] 	bcc df_tk_expr_more
ddcf :                       df_tk_print_done
ddcf :                       df_tk_data_done
ddcf : 18               [ 2] 	clc
ddd0 : 60               [ 6] 	rts
                             
                             ; these must have 1 or more expressions
ddd1 :                       df_tk_data
ddd1 :                       df_tk_asm_db
ddd1 :                       df_tk_asm_dw
ddd1 :                       df_tk_next_expr
                             	; tokenise an expression
ddd1 : 2029d9           [ 6] 	jsr df_tk_expression
ddd4 : b065             [ 4] 	bcs df_tk_error2
                             ; this loop keeps processing comma seprated exore
ddd6 :                       df_tk_expr_more
                             	; is there more to come?
ddd6 : a92c             [ 2] 	lda #','
ddd8 : 202cd7           [ 6] 	jsr df_tk_expect_tok
dddb : b0f2             [ 3] 	bcs df_tk_data_done
dddd : 90f2             [ 3] 	bcc df_tk_next_expr
                             
dddf :                       df_tk_input
dddf : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
dde2 : 205add           [ 6] 	jsr df_tk_variable
dde5 : 4ce2d7           [ 3] 	jmp df_tk_var
                             	
dde8 :                       df_tk_read
                             	; tokenise a variable
dde8 : 205add           [ 6] 	jsr df_tk_variable
ddeb : 20e2d7           [ 6] 	jsr df_tk_var
AS65 Assembler for R6502 [1.42].                                     Page  165
-------------------------------- bank\bank0.s --------------------------------

                             	; if not at the end then keep going
ddee : a92c             [ 2] 	lda #','
ddf0 : 202cd7           [ 6] 	jsr df_tk_expect_tok
ddf3 : 90f3             [ 3] 	bcc df_tk_read
ddf5 : 18               [ 2] 	clc
ddf6 : 60               [ 6] 	rts
                             
ddf7 :                       df_tk_dim
                             	; tokenise a variable
ddf7 : 205add           [ 6] 	jsr df_tk_variable
ddfa : 202ad8           [ 6] 	jsr df_tk_arrvar
                             	; if not at the end then keep going
ddfd : a92c             [ 2] 	lda #','
ddff : 202cd7           [ 6] 	jsr df_tk_expect_tok
de02 : 90f3             [ 4] 	bcc df_tk_dim
de04 : 18               [ 2] 	clc
de05 : 60               [ 6] 	rts
                             
de06 :                       df_tk_local
                             	; tokenise a variable
de06 : 205add           [ 6] 	jsr df_tk_variable
de09 : 2014d8           [ 6] 	jsr df_tk_localvar
                             	; if not at the end then keep going
de0c : a92c             [ 2] 	lda #','
de0e : 202cd7           [ 6] 	jsr df_tk_expect_tok
de11 : 90f3             [ 3] 	bcc df_tk_local
de13 : 18               [ 2] 	clc
de14 : 60               [ 6] 	rts
                             
                             ; A = 0 : Def
                             ; A = 1 : Call
de15 :                       df_tk_def
de15 : a900             [ 2] 	lda #0
de17 : 4c35d8           [ 3] 	jmp df_tk_proc
                             
                             ; syntax : for a=1,10,1
de1a :                       df_tk_for
de1a : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise the for variable
de1d : a901             [ 2] 	lda #DFVVT_INT
de1f : 20e2d7           [ 6] 	jsr df_tk_var
                             
                             	; always expect '='
                             	; then starting value
de22 : a93d             [ 2] 	lda #'='
de24 : 2035d9           [ 6] 	jsr df_tk_tok_expression
                             	
                             	; always expect ',' separator
                             	; then ending value
de27 : a92c             [ 2] 	lda #','
de29 : 2035d9           [ 6] 	jsr df_tk_tok_expression
                             
                             	; always expect ',' separator
                             	; then step value
de2c : a92c             [ 2] 	lda #','
de2e : 4c35d9           [ 3] 	jmp df_tk_tok_expression
                             
                             	
                             ; call to proc should not occur by itself
de31 :                       df_tk_callproc
de31 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page  166
-------------------------------- bank\bank0.s --------------------------------

de32 : 60               [ 6] 	rts
                             
                             ; timer reset expects an int variable only
de33 :                       df_tk_reset
de33 : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
de36 : a901             [ 2] 	lda #DFVVT_INT
de38 : 4ce2d7           [ 3] 	jmp df_tk_var
                             
de3b :                       df_tk_error2
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ; These functions expect 1 parmeter
de3d :                       df_tk_len
de3d :                       df_tk_chr
de3d :                       df_tk_get
de3d :                       df_tk_deek
de3d :                       df_tk_vpeek
de3d :                       df_tk_peek
de3d :                       df_tk_mem
de3d :                       df_tk_rnd
de3d :                       df_tk_hex
de3d :                       df_tk_asc
de3d :                       df_tk_val
de3d :                       df_tk_sprhit
de3d :                       df_tk_sgn
de3d : 2029d9           [ 6] 	jsr df_tk_expression
de40 : b0f9             [ 3] 	bcs df_tk_error2
de42 :                       df_tk_closebrkt
de42 :                       df_tk_stick				; This function needs no parms
de42 : a929             [ 2] 	lda #')'
de44 : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ; These function expect a variable only
de47 :                       df_tk_addr
de47 :                       df_tk_elapsed
de47 : 205add           [ 6] 	jsr df_tk_variable
de4a : 20e2d7           [ 6] 	jsr df_tk_var
                             	; must have close braket
de4d : 4c42de           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 2 parameters
de50 :                       df_tk_left
de50 :                       df_tk_right
de50 :                       df_tk_scrn
de50 :                       df_tk_pixel
de50 : 2075de           [ 6] 	jsr df_tk_2parms
de53 : 4c42de           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 3 parameters
de56 :                       df_tk_mid
de56 : 207fde           [ 6] 	jsr df_tk_3parms
de59 : 4c42de           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 4 parameters
de5c :                       df_tk_call
de5c : 2075de           [ 6] 	jsr df_tk_2parms
de5f : a92c             [ 2] 	lda #','
de61 : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
de64 : 2075de           [ 6] 	jsr df_tk_2parms
AS65 Assembler for R6502 [1.42].                                     Page  167
-------------------------------- bank\bank0.s --------------------------------

de67 : 4c42de           [ 3] 	jmp df_tk_closebrkt
                             
                             ;all these commands require no parameters
de6a :                       df_tk_else
de6a :                       df_tk_endif
de6a :                       df_tk_enddef
de6a :                       df_tk_abort
de6a :                       df_tk_repeat
de6a :                       df_tk_next
de6a :                       df_tk_wend
de6a :                       df_tk_run
de6a :                       df_tk_dir
de6a :                       df_tk_cls
de6a :                       df_tk_new
de6a :                       df_tk_mult
de6a :                       df_tk_div
de6a :                       df_tk_mod
de6a :                       df_tk_asl
de6a :                       df_tk_lsr
de6a :                       df_tk_add
de6a :                       df_tk_sub
de6a :                       df_tk_and
de6a :                       df_tk_or
de6a :                       df_tk_eor
de6a :                       df_tk_lte
de6a :                       df_tk_lt
de6a :                       df_tk_gte
de6a :                       df_tk_gt
de6a :                       df_tk_ne
de6a :                       df_tk_eq
de6a :                       df_tk_monitor
de6a :                       df_tk_sprupd
de6a :                       df_tk_sprinit
de6a :                       df_tk_text
de6a :                       df_tk_hires
de6a : 18               [ 2] 	clc
de6b : 60               [ 6] 	rts
                             
                             ; 0 or 1 parameter special!
de6c :                       df_tk_return
de6c : 4c29d9           [ 3] 	jmp df_tk_expression
                             
                             
                             ; These commands expect 1 parameter	
de6f :                       df_tk_while
de6f :                       df_tk_until
de6f :                       df_tk_if
de6f :                       df_tk_elseif
de6f :                       df_tk_wait
de6f :                       df_tk_cursor
de6f :                       df_tk_del
de6f :                       df_tk_chdir
de6f :                       df_tk_load
de6f :                       df_tk_save
de6f :                       df_tk_tload
de6f :                       df_tk_tsave
de6f :                       df_tk_pixmode
de6f :                       df_tk_ink
de6f :                       df_tk_paper
de6f :                       df_tk_himem
                             
de6f :                       df_tk_asm_org
AS65 Assembler for R6502 [1.42].                                     Page  168
-------------------------------- bank\bank0.s --------------------------------

de6f :                       df_tk_asm_opt
de6f :                       df_tk_asm_ds
                             
                             	; first parm
de6f : 2029d9           [ 6] 	jsr df_tk_expression
de72 : b0c7             [ 3] 	bcs df_tk_error2
de74 : 60               [ 6] 	rts
                             
                             ; These commands expect 2 numeric parameters
de75 :                       df_tk_poke
de75 :                       df_tk_doke
de75 :                       df_tk_point
de75 :                       df_tk_sprchar
de75 :                       df_tk_sprmulti
de75 :                       df_tk_bload
de75 :                       df_tk_lineto
de75 :                       df_tk_2parms
                             	; first parm
de75 : 2029d9           [ 6] 	jsr df_tk_expression
de78 : b0c1             [ 3] 	bcs df_tk_error2
                             	; tokenise second parm
de7a : a92c             [ 2] 	lda #','
de7c : 4c35d9           [ 3] 	jmp df_tk_tok_expression
                             
                             ; these commands expect 3 numeric parameters
de7f :                       df_tk_hchar
de7f :                       df_tk_plot
de7f :                       df_tk_circle
de7f :                       df_tk_sound
de7f :                       df_tk_colour
de7f :                       df_tk_spritepos
de7f :                       df_tk_renum
de7f :                       df_tk_sprpos
de7f :                       df_tk_bsave
de7f :                       df_tk_3parms
de7f : 2075de           [ 6] 	jsr df_tk_2parms
                             	; tokenise third parm
de82 : a92c             [ 2] 	lda #','
de84 : 4c35d9           [ 3] 	jmp df_tk_tok_expression
                             
                             ; these commands expect 4 numeric parameters
de87 :                       df_tk_play
de87 :                       df_tk_music
de87 :                       df_tk_line
de87 :                       df_tk_4parms
de87 : 2075de           [ 6] 	jsr df_tk_2parms
de8a : a92c             [ 2] 	lda #','
de8c : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
de8f : 4c75de           [ 3] 	jmp df_tk_2parms
                             
                             ;df_tk_fill
                             ;df_tk_5parms
                             ;	jsr df_tk_3parms
                             ;	lda #','
                             ;	jsr df_tk_expect_tok_err
                             ;	jmp df_tk_2parms
                             
de92 :                       mod_sz_toksubs_e
                             
                             
de92 :                       mod_sz_tokenise_e
                             
AS65 Assembler for R6502 [1.42].                                     Page  169
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             	include "dflat/progedit.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROGEDIT.S
                             ;*  dflat module to enable editing of a dflat pro
                             ;*  dflat bascially starts here - waiting for use
                             ;*  when a line is entered, if it is not preceede
                             ;*  line number it is tokenised and attempted to 
                             ;*  immediatly.  If it is preceeded by a line num
                             ;*  number is used to save the tokenised line in 
                             ;*  position in memory.
                             ;*  So this is just like a good old editing sessi
                             ;*  nearly any common flavour of 80s basic. Howev
                             ;*  tokenises everything except whitespace and st
                             ;*  constants - even when saving.  Unlike my trus
                             ;*  where I could type in any garbage and it woul
                             ;*  saved with the line number, dflat needs to be
                             ;*  tokenise the line.  So it's actually a bit mo
                             ;*  Atari 8 bit BASIC.
                             ;*
                             ;************************************************
                             
de92 :                       mod_sz_progedit_s
                             
                             ;****************************************
                             ;* df_pg_find_line
                             ;* Find a line number in X(L), A(H)
                             ;* Return X(L), A(H) of line, Y = Length
                             ;* C=1 Exact match not found, C=0 Exact Found
                             ;* If not exact match then next highest line addr
                             ;* Will be in X and A
                             ;****************************************
de92 :                       df_pg_find_line
de92 : 863d             [ 3] 	stx num_a
de94 : 853e             [ 3] 	sta num_a+1
de96 : a565             [ 3] 	lda df_prgstrt
de98 : 8549             [ 3] 	sta num_tmp
de9a : a566             [ 3] 	lda df_prgstrt+1
de9c : 854a             [ 3] 	sta num_tmp+1
de9e :                       df_pg_check_next_line
de9e : a549             [ 3] 	lda num_tmp
dea0 : c567             [ 3] 	cmp df_prgend
dea2 : d011             [ 3] 	bne df_pg_check_line
dea4 : a54a             [ 3] 	lda num_tmp+1
dea6 : c568             [ 3] 	cmp df_prgend+1
dea8 : d00b             [ 3] 	bne df_pg_check_line
deaa :                       df_pr_line_gt_target	
                             	; End of program or line > target
                             	; X,A = address of finish
                             	; Load Y with the length
deaa : a200             [ 2] 	ldx #0
deac : a149             [ 6] 	lda (num_tmp,x)
deae : a8               [ 2] 	tay
deaf : a649             [ 3] 	ldx num_tmp
AS65 Assembler for R6502 [1.42].                                     Page  170
-------------------------------- bank\bank0.s --------------------------------

deb1 : a54a             [ 3] 	lda num_tmp+1
deb3 : 38               [ 2] 	sec
deb4 : 60               [ 6] 	rts
deb5 :                       df_pg_check_line
deb5 : 38               [ 2] 	sec					; Do a trial subtract of
deb6 : a001             [ 2] 	ldy #DFTK_LINNUM	; target - line
deb8 : a53d             [ 3] 	lda num_a
deba : f149             [ 5] 	sbc (num_tmp),y
debc : 854b             [ 3] 	sta num_tmp+2		; Partial result of sbc
debe : c8               [ 2] 	iny
debf : a53e             [ 3] 	lda num_a+1
dec1 : f149             [ 5] 	sbc (num_tmp),y
dec3 : 054b             [ 3] 	ora num_tmp+2		; or with partial result for z ch
                             	; If C=0 then line > target (done)
dec5 : 90e3             [ 3] 	bcc df_pr_line_gt_target
                             	; If partial result Z=0 then got an exact match
dec7 : f00f             [ 3] 	beq df_pr_line_match
                             	; Else we go to next line
dec9 : a200             [ 2] 	ldx #0
decb : 18               [ 2] 	clc
decc : a549             [ 3] 	lda num_tmp
dece : 6149             [ 6] 	adc (num_tmp,x)
ded0 : 8549             [ 3] 	sta num_tmp
ded2 : 90ca             [ 3] 	bcc df_pg_check_next_line
ded4 : e64a             [ 5] 	inc num_tmp+1
ded6 : d0c6             [ 3] 	bne df_pg_check_next_line	; Always
ded8 :                       df_pr_line_match
ded8 : a200             [ 2] 	ldx #0
deda : a149             [ 6] 	lda (num_tmp,x)
dedc : a8               [ 2] 	tay
dedd : a649             [ 3] 	ldx num_tmp
dedf : a54a             [ 3] 	lda num_tmp+1
dee1 : 18               [ 2] 	clc
dee2 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_pg_insert_block
                             ;* Insert a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
dee3 :                       df_pg_insert_block
                             	; Inserting requires a block copy from
                             	; end of program space to the insert address
                             	
                             	; Save address as this is the lowest address
dee3 : 863d             [ 3] 	stx num_a
dee5 : 853e             [ 3] 	sta num_a+1
                             	; End of program space is the first byte to move
dee7 : a567             [ 3] 	lda df_prgend
dee9 : 8545             [ 3] 	sta num_x
deeb : a568             [ 3] 	lda df_prgend+1
deed : 8546             [ 3] 	sta num_x+1	
deef :                       df_pg_insert_byte
                             	; Move a byte from the current top
deef : a200             [ 2] 	ldx #0
def1 : a145             [ 6] 	lda (num_x,x)
                             	; To the new top (+Y)
def3 : 9145             [ 5] 	sta (num_x),y
                             	; Compare current address with lowest
def5 : a545             [ 3] 	lda num_x
def7 : c53d             [ 3] 	cmp num_a
AS65 Assembler for R6502 [1.42].                                     Page  171
-------------------------------- bank\bank0.s --------------------------------

def9 : d012             [ 4] 	bne df_pg_insert_next_byte
defb : a546             [ 3] 	lda num_x+1
defd : c53e             [ 3] 	cmp num_a+1
deff : d00c             [ 4] 	bne df_pg_insert_next_byte
                             	; Finished, update program end pointer
df01 : 18               [ 2] 	clc
df02 : 98               [ 2] 	tya
df03 : 6567             [ 3] 	adc df_prgend
df05 : 8567             [ 3] 	sta df_prgend
                             	_bcc 2
                             
df09 : e668             [ 5] 	inc df_prgend+1
df0b : 18               [ 2] 	clc
df0c : 60               [ 6] 	rts	; C=0
df0d :                       df_pg_insert_next_byte
                             	; Decrement current address (trashes A)
                             	_decZPWordA num_x
                             
df15 : 4cefde           [ 3] 	jmp df_pg_insert_byte
                             
                             ;****************************************
                             ;* df_pg_delete_block
                             ;* Delete a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
df18 :                       df_pg_delete_block
                             	; Deleting requires a block copy from
                             	; deletion address to end of program
                             	
                             	; Save address as this is the start address
df18 : 863d             [ 3] 	stx num_a
df1a : 853e             [ 3] 	sta num_a+1
df1c : a200             [ 2] 	ldx #0	; No indirect indexing
df1e :                       df_pg_delete_byte
                             	; Move a byte from current+Y
df1e : b13d             [ 5] 	lda (num_a),y
                             	; Down to current (x=0)
df20 : 813d             [ 6] 	sta (num_a,x)
                             	; Compare current address with lowest
df22 : a53d             [ 3] 	lda num_a
df24 : c567             [ 3] 	cmp df_prgend
df26 : d017             [ 3] 	bne df_pg_delete_next_byte
df28 : a53e             [ 3] 	lda num_a+1
df2a : c568             [ 3] 	cmp df_prgend+1
df2c : d011             [ 3] 	bne df_pg_delete_next_byte
                             	; Finished, update program end pointer
df2e : 843d             [ 3] 	sty num_a
df30 : 38               [ 2] 	sec
df31 : a567             [ 3] 	lda df_prgend
df33 : e53d             [ 3] 	sbc num_a
df35 : 8567             [ 3] 	sta df_prgend
df37 : a568             [ 3] 	lda df_prgend+1
df39 : e900             [ 2] 	sbc #0
df3b : 8568             [ 3] 	sta df_prgend+1
df3d : 18               [ 2] 	clc
df3e : 60               [ 6] 	rts
df3f :                       df_pg_delete_next_byte
                             	; Increment current address
                             	_incZPWord num_a
                             
df45 : 4c1edf           [ 3] 	jmp df_pg_delete_byte
AS65 Assembler for R6502 [1.42].                                     Page  172
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             ;****************************************
                             ;* Get a line of input
                             ;* Input: C=1 for echo, 0 for no echo
                             ;* Output: C=0 means linbuff is valid
                             ;****************************************
df48 :                       df_pg_inputline
                             	; C is set on input for echo or not
                             	; Read a line of input
df48 : 2069c4           [ 6] 	jsr io_read_line
                             	
                             	; If nothing entered then sec
df4b : 98               [ 2] 	tya
df4c : d002             [ 3] 	bne df_pg_inputline_ok
df4e : 38               [ 2] 	sec
df4f : 60               [ 6] 	rts
df50 :                       df_pg_inputline_ok
                             	; Copy input bytes to line buffer
                             	; for lexical analysis
df50 :                       df_pg_copyinputtolinbuff
df50 : b139             [ 5] 	lda (buf_lo),y
df52 : 990004           [ 5] 	sta df_linbuff,y
df55 : 88               [ 2] 	dey
df56 : 10f8             [ 3] 	bpl df_pg_copyinputtolinbuff
df58 : 18               [ 2] 	clc
df59 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_pg_dflat
                             ;* Start a dflat editing session
                             ;****************************************
df5a :                       df_pg_dflat
                             	; reset stack pointer
df5a : a2ff             [ 2] 	ldx #255
df5c : 9a               [ 2] 	txs
                             
                             	; error handler address
df5d : a99c             [ 2] 	lda #lo(df_trap_error)
df5f : 8560             [ 3] 	sta df_pc
df61 : a9f7             [ 2] 	lda #hi(df_trap_error)
df63 : 8561             [ 3] 	sta df_pc+1
                             	
                             	; make sure normal I/O is resumed
                             	;jsr io_init_default
df65 :                       df_pg_prompt
df65 : a2fc             [ 2] 	ldx #lo(df_pg_prompt_msg)
df67 : a9df             [ 2] 	lda #hi(df_pg_prompt_msg)
df69 : 20a2c4           [ 6] 	jsr io_print_line
df6c : a900             [ 2] 	lda #0
df6e : 855e             [ 3] 	sta df_immed
df70 :                       df_pg_getcommand
                             	; current line is the token buffer when editing
df70 : a980             [ 2] 	lda #lo(df_tokbuff)
df72 : 8586             [ 3] 	sta df_currlin
df74 : a904             [ 2] 	lda #hi(df_tokbuff)
df76 : 8587             [ 3] 	sta df_currlin+1
df78 : 38               [ 2] 	sec
df79 : 2048df           [ 6] 	jsr df_pg_inputline
df7c : b0e7             [ 3] 	bcs df_pg_prompt	; If no input then back to prom
df7e : 2099df           [ 6] 	jsr df_pg_tokenise
AS65 Assembler for R6502 [1.42].                                     Page  173
-------------------------------- bank\bank0.s --------------------------------

df81 : a55e             [ 3] 	lda df_immed
df83 : f0eb             [ 3] 	beq df_pg_getcommand
                             	; clear variables ready to run the statement
df85 : 2003e0           [ 6] 	jsr df_initrun
                             	; run from tokbuff
df88 : a280             [ 2] 	ldx #lo(df_tokbuff)
df8a : a904             [ 2] 	lda #hi(df_tokbuff)
                             	; always skip length and line number
df8c : a003             [ 2] 	ldy #3
df8e : 8488             [ 3] 	sty df_exeoff
                             	; init currlin
df90 : 2079e3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; start execution
df93 : 208ce3           [ 6] 	jsr df_rt_exec_stat
                             	; Go and get another line of input
df96 : 4c65df           [ 3] 	jmp df_pg_prompt
                             
                             	; tokenise the line
df99 :                       df_pg_tokenise
df99 : a900             [ 2] 	lda #0
df9b : 855d             [ 3] 	sta errno
df9d : 206dd9           [ 6] 	jsr df_lexer_line
                             	; check if line number == 0
dfa0 : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
dfa3 : d00f             [ 3] 	bne df_pg_line_number
dfa5 : ad8204           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
dfa8 : d00a             [ 3] 	bne df_pg_line_number
                             	; check if line empty
dfaa : ad8004           [ 4] 	lda df_tokbuff
dfad : f004             [ 3] 	beq df_pg_nothing
                             	
                             	; line number == 0 so in immediate mode from tok
                             	; don't zero out the line length as some routine
                             	; run the line in immediate mode
dfaf : a901             [ 2] 	lda #1
dfb1 : 855e             [ 3] 	sta df_immed
dfb3 :                       df_pg_nothing
dfb3 : 60               [ 6] 	rts
                             
                             	; put the numbered line in to the right bit of m
dfb4 :                       df_pg_line_number
                             	; Check if this line exists
dfb4 : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
dfb7 : aa               [ 2] 	tax
dfb8 : ad8204           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
dfbb : 2092de           [ 6] 	jsr df_pg_find_line
                             	; Save line address for later X then A
dfbe : 8538             [ 3] 	sta tmp_d
dfc0 : 8a               [ 2] 	txa
dfc1 : 48               [ 3] 	pha
dfc2 : a538             [ 3] 	lda tmp_d
dfc4 : 48               [ 3] 	pha
                             	; If line exists then it needs deleting
dfc5 : b003             [ 3] 	bcs df_pg_skip_del_line
                             
                             	; delete line from program
dfc7 : 2018df           [ 6] 	jsr df_pg_delete_block
dfca :                       df_pg_skip_del_line
                             	; If line length is zero
                             	; then nothing else to do (i.e. line was deleted
dfca : ad8004           [ 4] 	lda df_tokbuff+DFTK_LINLEN
                             	; save the tokenised line length
AS65 Assembler for R6502 [1.42].                                     Page  174
-------------------------------- bank\bank0.s --------------------------------

dfcd : 48               [ 3] 	pha
dfce : d004             [ 3] 	bne df_pg_insertline
                             	; Length was zero, so get temp stuff off stack
dfd0 : 68               [ 4] 	pla
dfd1 : 68               [ 4] 	pla
dfd2 : 68               [ 4] 	pla
dfd3 : 60               [ 6] 	rts
                             
                             	; insert a program line unless it is immediate
dfd4 :                       df_pg_insertline
                             	; Restore previously saved length
dfd4 : 68               [ 4] 	pla
dfd5 : a8               [ 2] 	tay
                             	; Restore previously saved address to reinsert t
dfd6 : 68               [ 4] 	pla
dfd7 : 8538             [ 3] 	sta tmp_d
dfd9 : 68               [ 4] 	pla
dfda : aa               [ 2] 	tax
dfdb : a538             [ 3] 	lda tmp_d
                             	; And save it all back to stack again A,X,Y
                             	_pushAXY
                             
                             	; We now have insert address and length
dfe6 : 20e3de           [ 6] 	jsr df_pg_insert_block
                             	; Restore length and sub 1 to get index in to th
dfe9 : 68               [ 4] 	pla
dfea : a8               [ 2] 	tay
dfeb : 88               [ 2] 	dey
                             	; Restore address to a pointer, X is pulled firs
dfec : 68               [ 4] 	pla
dfed : aa               [ 2] 	tax
dfee : 863d             [ 3] 	stx num_a
dff0 : 68               [ 4] 	pla
dff1 : 853e             [ 3] 	sta num_a+1
                             	; num_a is destination, tokbuff is source, Y is 
dff3 :                       df_pg_insertlinbyte
dff3 : b98004           [ 4] 	lda df_tokbuff,y
dff6 : 913d             [ 5] 	sta (num_a),y
dff8 : 88               [ 2] 	dey
dff9 : 10f8             [ 3] 	bpl df_pg_insertlinbyte
dffb : 60               [ 6] 	rts
                             	
dffc :                       df_pg_prompt_msg
dffc : 52656164790d00        	db "Ready",UTF_CR,0
                             
e003 :                       mod_sz_progedit_e
                             
                             	include "dflat/runtime.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RUNTIME.S
                             ;*  This module is the runtime coordinator.  When
                             ;*  wants to run a program, execution of statemen
                             ;*  required procedure starts and proceeds from t
                             ;*  according to normal program flow.
                             ;*  This module also contains critical routines f
AS65 Assembler for R6502 [1.42].                                     Page  175
-------------------------------- bank\bank0.s --------------------------------

                             ;*  evaluation of expressions (numeric and string
                             ;*  Whilst the code to implement a specific comma
                             ;*  rtsubs.s, this is the key module that control
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
e003 :                       mod_sz_runtime_s
                             
                             ;****************************************
                             ;* df_initrun
                             ;* Initialise program space for runtime
                             ;****************************************
e003 :                       df_initrun
                             	; Set the key mask to check every 16 instruction
e003 : a910             [ 2] 	lda #0x10
e005 : 855c             [ 3] 	sta df_checkmsk
e007 : 855b             [ 3] 	sta df_checkkey
                             
                             	; String and array heap initialisation
                             	; Grows up from end of prog space PLUS 1
                             	; Initially empty (dim will allocate)
                             	_cpyZPWord df_prgend,df_starstrt
                             
                             	_incZPWord df_starstrt
                             
                             	_cpyZPWord df_starstrt,df_starend
                             
                             
e01f : a2ff             [ 2] 	ldx #0xff
                             	; Reset runtime stack (grows down)
e021 : 8676             [ 3] 	stx df_rtstop
                             	; make X=0
e023 : e8               [ 2] 	inx
                             	; Reset parameter stack (grows up)
e024 : 8677             [ 3] 	stx df_parmtop
                             	; Reset data pointer high byte
e026 : 8695             [ 3] 	stx df_currdat+1
                             	; if nest counter zeroed
e028 : 8693             [ 3] 	stx df_ifnest
                             
                             	; clear proc addresses
e02a : 202ee0           [ 6] 	jsr df_rt_init_vvt
                             
                             ;	clc
e02d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Initialise vvt
                             ;****************************************
e02e :                       df_rt_init_vvt
                             	; starting at beginning of vvt
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
e036 : a200             [ 2] 	ldx #0
e038 :                       df_rt_init_vvt_slot
e038 : a5a1             [ 3] 	lda df_tmpptra
e03a : c56d             [ 3] 	cmp df_vvtstrt
e03c : d006             [ 3] 	bne df_rt_init_vvt_slot_undim
e03e : a5a2             [ 3] 	lda df_tmpptra+1
AS65 Assembler for R6502 [1.42].                                     Page  176
-------------------------------- bank\bank0.s --------------------------------

e040 : c56e             [ 3] 	cmp df_vvtstrt+1
e042 : f02c             [ 3] 	beq df_rt_init_done
e044 :                       df_rt_init_vvt_slot_undim
                             	; Only zero out proc and array pointers
                             	; Scalar variables are not initialised
e044 : a000             [ 2] 	ldy #0
e046 : b1a1             [ 5] 	lda (df_tmpptra),y
e048 : 29c0             [ 2] 	and #DFVVT_PROC|DFVVT_ARRY
e04a : f016             [ 3] 	beq df_rt_init_vvt_skip
                             	; skip over the first byte which is variable typ
e04c : c8               [ 2] 	iny
                             	; zero out first 3 bytes for proc and arrays
e04d : a900             [ 2] 	lda #0
e04f : 91a1             [ 5] 	sta (df_tmpptra),y
e051 : c8               [ 2] 	iny
e052 : 91a1             [ 5] 	sta (df_tmpptra),y
e054 : c8               [ 2] 	iny
e055 : 91a1             [ 5] 	sta (df_tmpptra),y
e057 : c8               [ 2] 	iny
                             	; before doing dim2 check if proc
                             	; as we don't want to erase the parm count
e058 : a1a1             [ 6] 	lda (df_tmpptra,x)
e05a : 2940             [ 2] 	and #DFVVT_PROC
e05c : d004             [ 3] 	bne df_rt_init_vvt_skip
                             	; if not proc then zero dim2
e05e : a900             [ 2] 	lda #0
e060 : 91a1             [ 5] 	sta (df_tmpptra),y
e062 :                       df_rt_init_vvt_skip
                             	; increment pointer to next slot
                             	_adcZPByte df_tmpptra,#8
                             
e06d : 4c38e0           [ 3] 	jmp df_rt_init_vvt_slot 	; Don't rely on bcc
e070 :                       df_rt_init_done
e070 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* pop  X,A result from operator stack
                             ;****************************************
e071 :                       df_rt_getnval
                             	; evaluate the expression
e071 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; get X,A off operator stack
e074 : 4c81f6           [ 3] 	jmp df_ost_popInt
                             
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* Push result to operator stack
                             ;****************************************
e077 :                       df_rt_neval
                             	; push terminator on cpu stack
                             	; so we know where we are
e077 : a900             [ 2] 	lda #0
e079 : 48               [ 3] 	pha
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword token push on to operator stack
e07a :                       df_rt_neval_optk
e07a : a488             [ 3] 	ldy df_exeoff
                             	; check end of line
AS65 Assembler for R6502 [1.42].                                     Page  177
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;	cpy df_eolidx
                             ;	beq df_rt_neval_process
e07c : c47f             [ 3] 	cpy df_nxtstidx
e07e : f03a             [ 3] 	beq df_rt_neval_process
e080 : b186             [ 5] 	lda (df_currlin),y		; Get the byte which could b
e082 : 3024             [ 3] 	bmi df_rt_neval_tk		; N=1 means it's a keyword t
e084 : c920             [ 2] 	cmp #DFTK_ESCVAL		; <=32 means it's an escape to
e086 : 9019             [ 3] 	bcc df_rt_neval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ']'
e088 : c92c             [ 2] 	cmp #','
e08a : f02e             [ 3] 	beq df_rt_neval_process
e08c : c95d             [ 2] 	cmp #']'
e08e : f02a             [ 3] 	beq df_rt_neval_process
                             	; check for brackets
                             	; if close bracket then process
e090 : c929             [ 2] 	cmp #')'
e092 : f026             [ 3] 	beq df_rt_neval_process
                             	; Nothing of interest matched or it's open brack
                             	; so move to next byte either way
e094 : e688             [ 5] 	inc df_exeoff				; Next byte 
                             	; if bracket then evaluate expression recursivel
e096 : c928             [ 2] 	cmp #'('
e098 : d0e0             [ 3] 	bne df_rt_neval_optk
                             	; call evaluation function recursively
e09a : 2077e0           [ 6] 	jsr df_rt_neval
                             	; move to next byte
e09d : e688             [ 5] 	inc df_exeoff
e09f : d0d9             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
e0a1 :                       df_rt_neval_esc
e0a1 : 20fce0           [ 6] 	jsr df_rt_eval_esc
                             	; move to next byte
e0a4 : e688             [ 5] 	inc df_exeoff
e0a6 : d0d2             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
                             	; if a token then push on operator stack
e0a8 :                       df_rt_neval_tk
e0a8 : 297f             [ 2] 	and #0x7f
                             	; check if op (look up type using X as index)
                             	; X contains the current operator index
                             
e0aa : aa               [ 2] 	tax
e0ab : bdf7dc           [ 4] 	lda df_tk_tokentype,x
                             	; A contains token type
e0ae : 48               [ 3] 	pha
e0af : 2908             [ 2] 	and #DFTK_OP
e0b1 : d01c             [ 3] 	bne df_rt_neval_tk_opp
                             	; check if fn
e0b3 : 68               [ 4] 	pla
e0b4 : 2902             [ 2] 	and #DFTK_FN
e0b6 : d00c             [ 3] 	bne df_rt_neval_tk_fn
                             
                             	; If got here then something wrong
                             	SWBRK DFERR_OK
                             
                             
e0ba :                       df_rt_neval_process
                             	; pop operator off stack and execute
                             	; keep popping until reached the terminator
e0ba : 68               [ 4] 	pla
e0bb : f006             [ 3] 	beq df_rt_neval_done
                             	; run the token code
AS65 Assembler for R6502 [1.42].                                     Page  178
-------------------------------- bank\bank0.s --------------------------------

e0bd : 20f2e3           [ 6] 	jsr df_rt_run_token
                             	; top two bytes on ost stack is the result
e0c0 : 4cbae0           [ 3] 	jmp df_rt_neval_process
e0c3 :                       df_rt_neval_done
e0c3 : 60               [ 6] 	rts
                             
e0c4 :                       df_rt_neval_tk_fn
e0c4 : 18               [ 2] 	clc
e0c5 : 8a               [ 2] 	txa
                             	; run a fn token - returns a value on stack
e0c6 : e688             [ 5] 	inc df_exeoff
e0c8 : 20f2e3           [ 6] 	jsr df_rt_run_token
                             	; move to next byte
e0cb :                       df_rt_neval_nextbyte
e0cb : e688             [ 5] 	inc df_exeoff
e0cd : d0ab             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
                             
e0cf :                       df_rt_neval_tk_opp
e0cf : 68               [ 4] 	pla				; Get A off stack which is the type
e0d0 :                       df_rt_neval_tk_op
                             	; X=Op, A=Type
                             	; if this op < current top of op stack
                             	; then do the op as it is higher priority so sho
                             	; not be pushed
                             	; what is top of the op stack?
                             	; save current op token value
                             	; C=0 means process the op now, else don't
                             	; save current operator index
e0d0 : 86a1             [ 3] 	stx df_tmpptra				; Index in to token table not 
                             	; mask off to keep priority
e0d2 : 2907             [ 2] 	and #DFTK_OPMSK
e0d4 : 85a3             [ 3] 	sta df_tmpptrb
                             	; peek top of op stack - pull and push X
e0d6 : 68               [ 4] 	pla
e0d7 : 48               [ 3] 	pha
e0d8 : aa               [ 2] 	tax
                             	; if 0 then nothing so push op
e0d9 : f01c             [ 3] 	beq df_rt_neval_pushOp
                             	; use it to index in to type table
e0db : bdf7dc           [ 4] 	lda df_tk_tokentype,x
                             	; mask off to keep priority
e0de : 2907             [ 2] 	and #DFTK_OPMSK
                             	; compare with the saved token type which includ
e0e0 : c5a3             [ 3] 	cmp df_tmpptrb
                             	; if top of stack >= current then C=1
                             	; else C=0
                             	; what is the state of C?
                             	; if 1 then just pushOp
e0e2 : f002             [ 3] 	beq df_rt_neval_donow
e0e4 : b011             [ 3] 	bcs df_rt_neval_pushOp
e0e6 :                       df_rt_neval_donow
                             	; was C=0 so process now before pushing the new 
                             	; get operator off cpu stack
e0e6 : 68               [ 4] 	pla
e0e7 : a8               [ 2] 	tay		; Save whilst need to push other things
                             	; save the current op on cpu stack
e0e8 : a5a1             [ 3] 	lda df_tmpptra
e0ea : 48               [ 3] 	pha
e0eb : aa               [ 2] 	tax		; X = current op
e0ec : 98               [ 2] 	tya		; Get A back from Y (new op)
                             	; now run the token in A that came off the stack
e0ed : 20f2e3           [ 6] 	jsr df_rt_run_token
AS65 Assembler for R6502 [1.42].                                     Page  179
-------------------------------- bank\bank0.s --------------------------------

                             	; get current op off cpu stack in to X
e0f0 : 68               [ 4] 	pla
e0f1 : aa               [ 2] 	tax
                             	; get the token type in to A
e0f2 : bdf7dc           [ 4] 	lda df_tk_tokentype,x
                             	; now go back around again to check whether to p
e0f5 : d0d9             [ 3] 	bne df_rt_neval_tk_op		; ALWAYS as type never ze
e0f7 :                       df_rt_neval_pushOp
                             	; push the operator
e0f7 : a5a1             [ 3] 	lda df_tmpptra
e0f9 : 48               [ 3] 	pha
                             	; move to next byte
e0fa : d0cf             [ 3] 	bne df_rt_neval_nextbyte	; ALWAYS as token index
                             
                             
                             
                             
                             ; jump to escape evaluation routine
e0fc :                       df_rt_eval_esc
e0fc : 0a               [ 2] 	asl a
e0fd : aa               [ 2] 	tax
e0fe : bd0be1           [ 4] 	lda df_rt_eval_esc_tab,x
e101 : 85a1             [ 3] 	sta df_tmpptra
e103 : bd0ce1           [ 4] 	lda df_rt_eval_esc_tab+1,x
e106 : 85a2             [ 3] 	sta df_tmpptra+1
e108 : 6ca100           [ 6] 	jmp (df_tmpptra)
                             
e10b :                       df_rt_eval_esc_tab
e10b : c8e1                  	dw df_rt_eval_chr
e10d : d4e1                  	dw df_rt_eval_reserved
e10f : d4e1                  	dw df_rt_eval_reserved
e111 : d4e1                  	dw df_rt_eval_reserved
e113 : d4e1                  	dw df_rt_eval_reserved
e115 : d4e1                  	dw df_rt_eval_reserved	; no such thing as bytdec
e117 : c8e1                  	dw df_rt_eval_bythex
e119 : c8e1                  	dw df_rt_eval_bytbin
e11b : d4e1                  	dw df_rt_eval_reserved
e11d : c8e1                  	dw df_rt_eval_intdec
e11f : c8e1                  	dw df_rt_eval_inthex
e121 : c8e1                  	dw df_rt_eval_intbin
e123 : d4e1                  	dw df_rt_eval_reserved
e125 : d4e1                  	dw df_rt_eval_reserved
e127 : d4e1                  	dw df_rt_eval_reserved
e129 : d4e1                  	dw df_rt_eval_reserved
e12b : d6e1                  	dw df_rt_eval_strlit
e12d : 1be2                  	dw df_rt_eval_var
e12f : 0ee3                  	dw df_rt_eval_proc
                             
                             
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination is string accumulator
                             ;****************************************
e131 :                       df_rt_seval
e131 : a67a             [ 3] 	ldx df_sevalptr
e133 : a57b             [ 3] 	lda df_sevalptr+1
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination buffer / space
                             ;****************************************
e135 :                       df_rt_sval
                             	; keep X,A on the stack - will be modified
AS65 Assembler for R6502 [1.42].                                     Page  180
-------------------------------- bank\bank0.s --------------------------------

e135 : 8538             [ 3] 	sta tmp_d
e137 : 48               [ 3] 	pha
e138 : 8a               [ 2] 	txa
e139 : 48               [ 3] 	pha
e13a : a538             [ 3] 	lda tmp_d
                             	; push original destination
e13c : 205cf6           [ 6] 	jsr df_ost_pushStr
                             	; Push the destination to the 6502 stack
                             	; hi byte first then lo
                             	; push string idx so we know our starting positi
                             	; in the string buffer
                             	; this limits all evaluations to 255 bytes
                             ;	lda df_stridx
                             ;	jsr df_st_pushOp
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword operator token push on to operator 
                             	; if keyword function token run it
                             
e13f :                       df_rt_seval_optk
e13f : a488             [ 3] 	ldy df_exeoff
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_seval_done
e141 : c47f             [ 3] 	cpy df_nxtstidx
e143 : f069             [ 3] 	beq df_rt_seval_done
                             
e145 : b186             [ 5] 	lda (df_currlin),y
e147 : 301c             [ 3] 	bmi df_rt_seval_tk
                             
e149 : c920             [ 2] 	cmp #DFTK_ESCVAL
e14b : 900a             [ 3] 	bcc df_rt_seval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ')'
e14d : c92c             [ 2] 	cmp #','
e14f : f05d             [ 3] 	beq df_rt_seval_done
e151 : c929             [ 2] 	cmp #')'
e153 : f059             [ 3] 	beq df_rt_seval_done
e155 : d04a             [ 3] 	bne df_rt_seval_nextbyte
e157 :                       df_rt_seval_esc
                             	; the only escape char is STRLIT, VAR or PROC
e157 : c910             [ 2] 	cmp #DFTK_STRLIT
e159 : f04b             [ 3] 	beq	df_rt_seval_esc_strlit
e15b : c911             [ 2] 	cmp #DFTK_VAR
e15d : f028             [ 3] 	beq	df_rt_seval_esc_var
e15f : c912             [ 2] 	cmp #DFTK_PROC
e161 : f049             [ 3] 	beq	df_rt_seval_esc_proc
                             
                             	; error if got here
                             	SWBRK DFERR_SYNTAX
                             
                             
                             	; if a token then push on operator stack
e165 :                       df_rt_seval_tk
e165 : 8488             [ 3] 	sty df_exeoff
e167 : 297f             [ 2] 	and #0x7f
                             	; check if op
e169 : aa               [ 2] 	tax
e16a : bdf7dc           [ 4] 	lda df_tk_tokentype,x
e16d : 2904             [ 2] 	and #DFTK_STROP
e16f : d009             [ 3] 	bne df_rt_seval_tk_op
AS65 Assembler for R6502 [1.42].                                     Page  181
-------------------------------- bank\bank0.s --------------------------------

                             	; check if fn
e171 : bdf7dc           [ 4] 	lda df_tk_tokentype,x
e174 : 2902             [ 2] 	and #DFTK_FN
e176 : d006             [ 3] 	bne df_rt_seval_tk_fn
                             
                             	; token type mismatch if got here
                             	SWBRK DFERR_TYPEMISM
                             
                             
e17a :                       df_rt_seval_tk_op
                             	; the only op is $+
                             	; so just ignore!
e17a : 8a               [ 2] 	txa
e17b : 4ca1e1           [ 3] 	jmp df_rt_seval_nextbyte
                             
e17e :                       df_rt_seval_tk_fn
e17e : 8a               [ 2] 	txa
e17f : e688             [ 5] 	inc df_exeoff
e181 : 20f2e3           [ 6] 	jsr df_rt_run_token
e184 : 4c8be1           [ 3] 	jmp df_rt_seval_copy
                             
e187 :                       df_rt_seval_esc_var
                             	; go process the variable as a normal RVAL
e187 : 18               [ 2] 	clc
e188 : 201be2           [ 6] 	jsr df_rt_eval_var
                             	; copy source off rt stack to destination
e18b :                       df_rt_seval_copy
                             	; pull destination pointer
e18b : 68               [ 4] 	pla
e18c : 85a1             [ 3] 	sta df_tmpptra
e18e : 68               [ 4] 	pla
e18f : 85a2             [ 3] 	sta df_tmpptra+1
                             	; pop source string pointer off stack
e191 : 2085f6           [ 6] 	jsr df_ost_popStr
e194 : 86a3             [ 3] 	stx df_tmpptrb
e196 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; go and copy the string
e198 : 20b2e1           [ 6] 	jsr df_rt_copyStr
                             	; now save the destination
e19b : a5a2             [ 3] 	lda df_tmpptra+1
e19d : 48               [ 3] 	pha
e19e : a5a1             [ 3] 	lda df_tmpptra
e1a0 : 48               [ 3] 	pha
                             
                             ;	jmp df_rt_seval_nextbyte
e1a1 :                       df_rt_seval_nextbyte
e1a1 : e688             [ 5] 	inc df_exeoff
e1a3 : 4c3fe1           [ 3] 	jmp df_rt_seval_optk
                             
e1a6 :                       df_rt_seval_esc_strlit
                             	; evaluate string literal
e1a6 : 20d6e1           [ 6] 	jsr df_rt_eval_strlit
e1a9 : 4c8be1           [ 3] 	jmp df_rt_seval_copy
                             
e1ac :                       df_rt_seval_esc_proc
                             	; not yet suported *******
                             	SWBRK DFERR_OK
                             
                             
                             	; keep going until non-ws char found or end of l
e1ae :                       df_rt_seval_done
                             	;
AS65 Assembler for R6502 [1.42].                                     Page  182
-------------------------------- bank\bank0.s --------------------------------

e1ae : 68               [ 4] 	pla
e1af : 68               [ 4] 	pla
                             
e1b0 : 18               [ 2] 	clc
e1b1 : 60               [ 6] 	rts
                             
                             
                             ; Copy string from ptrb to ptra
e1b2 :                       df_rt_copyStr
e1b2 : a000             [ 2] 	ldy #0
e1b4 :                       df_rt_copyStr_ch
e1b4 : b1a3             [ 5] 	lda (df_tmpptrb),y
e1b6 : 91a1             [ 5] 	sta (df_tmpptra),y
e1b8 : f003             [ 3] 	beq df_rt_copyStr_done
e1ba : c8               [ 2] 	iny
e1bb : d0f7             [ 3] 	bne df_rt_copyStr_ch	; Always relying in Y never
e1bd :                       df_rt_copyStr_done
e1bd : 98               [ 2] 	tya
e1be : 18               [ 2] 	clc
e1bf : 65a1             [ 3] 	adc df_tmpptra
e1c1 : 85a1             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
e1c5 : e6a2             [ 5] 	inc df_tmpptra+1
e1c7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate and push numeric value
                             ;****************************************
e1c8 :                       df_rt_eval_intdec
e1c8 :                       df_rt_eval_bytdec
e1c8 :                       df_rt_eval_inthex
e1c8 :                       df_rt_eval_bythex
e1c8 :                       df_rt_eval_intbin
e1c8 :                       df_rt_eval_bytbin
e1c8 :                       df_rt_eval_chr
                             	; numeric constant
e1c8 : c8               [ 2] 	iny
e1c9 : b186             [ 5] 	lda (df_currlin),y
e1cb : aa               [ 2] 	tax
e1cc : c8               [ 2] 	iny
e1cd : b186             [ 5] 	lda (df_currlin),y
                             	; save offset before calling any routine
e1cf : 8488             [ 3] 	sty df_exeoff
                             	; push number on to stack
e1d1 : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
e1d4 :                       df_rt_eval_reserved
                             	; should not get here
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* Evaluate and push string constant
                             ;****************************************
e1d6 :                       df_rt_eval_strlit
e1d6 : 8488             [ 3] 	sty df_exeoff
                             	; calculate the effective address in to AX
                             	; y + currlin
e1d8 : 98               [ 2] 	tya
                             	; set carry to add one extra
e1d9 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page  183
-------------------------------- bank\bank0.s --------------------------------

e1da : 6586             [ 3] 	adc df_currlin
e1dc : aa               [ 2] 	tax
e1dd : a587             [ 3] 	lda df_currlin+1
e1df : 6900             [ 2] 	adc #0
                             
                             	; push string on to stack
e1e1 : 205cf6           [ 6] 	jsr df_ost_pushStr
                             	; now proceed until end of string found
e1e4 : a488             [ 3] 	ldy df_exeoff
e1e6 :                       df_rt_eval_strlit_ch
e1e6 : b186             [ 5] 	lda (df_currlin),y
e1e8 : f003             [ 3] 	beq df_rt_eval_strlit_done
e1ea : c8               [ 2] 	iny
e1eb : d0f9             [ 3] 	bne df_rt_eval_strlit_ch
e1ed :                       df_rt_eval_strlit_done	; Always relying on Y neve
e1ed : 8488             [ 3] 	sty df_exeoff
e1ef : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return array parameter
                             ;* A has parm
                             ;****************************************
e1f0 :                       df_rt_arry_parm
                             	; move past open bracket or comma
e1f0 : e688             [ 5] 	inc df_exeoff
                             	; evaluate expression inside bracket
e1f2 : 2071e0           [ 6] 	jsr df_rt_getnval
e1f5 : 8a               [ 2] 	txa
                             ;	clc
e1f6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return double array parameter
                             ;* X = dim1, Y = dim2
                             ;****************************************
e1f7 :                       df_rt_arry_parm2
                             	; go get array parm 1
e1f7 : 20f0e1           [ 6] 	jsr df_rt_arry_parm
e1fa : 48               [ 3] 	pha
e1fb : a200             [ 2] 	ldx #0
e1fd : a488             [ 3] 	ldy df_exeoff
e1ff :                       df_rt_arry_parm2_term
e1ff : b186             [ 5] 	lda (df_currlin),y
e201 : c95d             [ 2] 	cmp #']'
e203 : f011             [ 3] 	beq df_rt_arry_parm2_skiparry2
e205 : c92c             [ 2] 	cmp #','
e207 : f006             [ 3] 	beq df_rt_arry_parm2_arry2
e209 : 8488             [ 3] 	sty df_exeoff
e20b : c8               [ 2] 	iny
e20c : 4cffe1           [ 3] 	jmp df_rt_arry_parm2_term
e20f :                       df_rt_arry_parm2_arry2
                             	; get second dimension and put in Y
e20f : 20f0e1           [ 6] 	jsr df_rt_arry_parm
e212 : a8               [ 2] 	tay
e213 : 68               [ 4] 	pla
e214 : aa               [ 2] 	tax
                             ;	clc
e215 : 60               [ 6] 	rts
e216 :                       df_rt_arry_parm2_skiparry2
e216 : a000             [ 2] 	ldy #0
e218 : 68               [ 4] 	pla
e219 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page  184
-------------------------------- bank\bank0.s --------------------------------

                             ;	clc
e21a : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Evaluate and push variable
                             ;* The actual value is pushed if numeric
                             ;* The pointer is pushed if string
                             ;* Carry Set = LVAR else normal RVAR
                             ;* LVAR : Y = line index, A=vvt type, tmpptra = v
                             ;****************************************
e21b :                       df_rt_eval_var
                             	; save carry bit
e21b : 08               [ 3] 	php
                             	; if lvar mode then already passed escape token
e21c : b010             [ 3] 	bcs df_rt_eval_lvskip
                             	; move past var escape token
e21e : c8               [ 2] 	iny
                             	; get var vvt address
e21f : b186             [ 5] 	lda (df_currlin),y
e221 : 85a1             [ 3] 	sta df_tmpptra
e223 : c8               [ 2] 	iny
e224 : 8488             [ 3] 	sty df_exeoff
e226 : b186             [ 5] 	lda (df_currlin),y
e228 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; push vvt type first as this is the last thing 
e22a : a200             [ 2] 	ldx #0
e22c : a1a1             [ 6] 	lda (df_tmpptra,x)
e22e :                       df_rt_eval_lvskip
e22e : 48               [ 3] 	pha
                             	; Test A
e22f : aa               [ 2] 	tax
                             	; simple variable
e230 : 100e             [ 3] 	bpl df_rt_eval_var_notarry
                             	; even if an array if no dimensions then return 
                             	; if at end of statement or line then simple cop
                             ;	cpy df_eolidx
                             ;	beq df_rt_eval_var_simple
e232 : c47f             [ 3] 	cpy df_nxtstidx
e234 : f027             [ 3] 	beq df_rt_eval_var_simple
                             	; if next ch is not [ then simple copy
e236 : c8               [ 2] 	iny
e237 : b186             [ 5] 	lda (df_currlin),y
e239 : 88               [ 2] 	dey
e23a : c95b             [ 2] 	cmp #'['
e23c : d01f             [ 3] 	bne df_rt_eval_var_simple
                             	; go do array handling
e23e : f02b             [ 3] 	beq df_rt_eval_var_do_arry
e240 :                       df_rt_eval_var_notarry
                             	; pull the type, not needed here
e240 : 68               [ 4] 	pla
                             	; pull C and check if lvar wanted rather than rv
e241 : 28               [ 4] 	plp
e242 : b00c             [ 3] 	bcs df_rt_eval_lvar
                             	; just push the vvt lo,hi value
e244 : a001             [ 2] 	ldy #DFVVT_LO
e246 : b1a1             [ 5] 	lda (df_tmpptra),y
e248 : aa               [ 2] 	tax
e249 : a002             [ 2] 	ldy #DFVVT_HI
e24b : b1a1             [ 5] 	lda (df_tmpptra),y
                             
e24d : 4c51f6           [ 3] 	jmp df_ost_pushInt
AS65 Assembler for R6502 [1.42].                                     Page  185
-------------------------------- bank\bank0.s --------------------------------

                             
e250 :                       df_rt_eval_lvar
                             	; it's not an array, push the address of DFVVT_L
                             	; add DFVVT_LO offset to slot address in X,A
e250 : 18               [ 2] 	clc
e251 : a901             [ 2] 	lda #DFVVT_LO
e253 : 65a1             [ 3] 	adc df_tmpptra
e255 : aa               [ 2] 	tax
e256 : a5a2             [ 3] 	lda df_tmpptra+1
e258 : 6900             [ 2] 	adc #0
                             
                             	; push pointer to lo,hi
e25a : 4c60f6           [ 3] 	jmp df_ost_pushPtr
                             
e25d :                       df_rt_eval_var_simple
                             	; clean up stack
e25d : 68               [ 4] 	pla
e25e : 68               [ 4] 	pla
                             	; simply get lo,hi and push ptr on stack
e25f : a001             [ 2] 	ldy #DFVVT_LO
e261 : b1a1             [ 5] 	lda (df_tmpptra),y
e263 : aa               [ 2] 	tax
e264 : a002             [ 2] 	ldy #DFVVT_HI
e266 : b1a1             [ 5] 	lda (df_tmpptra),y
e268 : 4c60f6           [ 3] 	jmp df_ost_pushPtr
                             
e26b :                       df_rt_eval_var_do_arry
                             	; move past var index
e26b : e688             [ 5] 	inc df_exeoff
                             	; zero out x,y as they have dimension info
e26d : a200             [ 2] 	ldx #0
e26f : a000             [ 2] 	ldy #0
                             
                             	; ** Array handling routine **
                             	; A on stack = type
                             	; save vvt address
e271 : a5a2             [ 3] 	lda df_tmpptra+1
e273 : 48               [ 3] 	pha
e274 : a5a1             [ 3] 	lda df_tmpptra
e276 : 48               [ 3] 	pha
                             
                             	; get array parms in X,Y
e277 : 20f7e1           [ 6] 	jsr df_rt_arry_parm2
                             	; restore vvt address
e27a : 68               [ 4] 	pla
e27b : 85a1             [ 3] 	sta df_tmpptra
e27d : 68               [ 4] 	pla
e27e : 85a2             [ 3] 	sta df_tmpptra+1
                             	; save dimension indices for later
e280 : 86a3             [ 3] 	stx df_tmpptrb
e282 : 84a4             [ 3] 	sty df_tmpptrb+1
                             	; if y is zero then need to decide some stuff
e284 : c000             [ 2] 	cpy #0
e286 : d00e             [ 3] 	bne df_rt_eval_var_dim2adj
                             	; if dim2 > 0 then swap x,y
e288 : a004             [ 2] 	ldy #DFVVT_DIM2
e28a : b1a1             [ 5] 	lda (df_tmpptra),y
e28c : f008             [ 3] 	beq df_rt_eval_var_dim2adj
                             	; swap x,y
e28e : a6a3             [ 3] 	ldx df_tmpptrb
e290 : a4a4             [ 3] 	ldy df_tmpptrb+1
e292 : 86a4             [ 3] 	stx df_tmpptrb+1
AS65 Assembler for R6502 [1.42].                                     Page  186
-------------------------------- bank\bank0.s --------------------------------

e294 : 84a3             [ 3] 	sty df_tmpptrb
                             
e296 :                       df_rt_eval_var_dim2adj
e296 : a6a3             [ 3] 	ldx df_tmpptrb
e298 : a4a4             [ 3] 	ldy df_tmpptrb+1
                             	; don't let y=0
e29a : d001             [ 3] 	bne df_rt_eval_var_dim2adjy
e29c : c8               [ 2] 	iny
e29d :                       df_rt_eval_var_dim2adjy
                             	; don't let x=0
e29d : e000             [ 2] 	cpx #0
e29f : d001             [ 3] 	bne df_rt_eval_var_dim2adjx
e2a1 : e8               [ 2] 	inx
e2a2 :                       df_rt_eval_var_dim2adjx
                             	;calculate offset
                             	;(y-1)*dim1 + (x-1)
e2a2 : ca               [ 2] 	dex
e2a3 : a900             [ 2] 	lda #0
e2a5 : 853e             [ 3] 	sta num_a+1
e2a7 : 88               [ 2] 	dey
                             	; (y-1)
e2a8 : 843d             [ 3] 	sty num_a
                             	; if y is 0 then no need to multiply
e2aa : f00d             [ 3] 	beq df_rt_eval_var_nomult
                             	; (dim1)
e2ac : a003             [ 2] 	ldy #DFVVT_DIM1
e2ae : a900             [ 2] 	lda #0
e2b0 : 8542             [ 3] 	sta num_b+1
e2b2 : b1a1             [ 5] 	lda (df_tmpptra),y
e2b4 : 8541             [ 3] 	sta num_b
                             	; (y-1)*dim1 num_a has result
e2b6 : 2064d4           [ 6] 	jsr int_fast_mult
e2b9 :                       df_rt_eval_var_nomult
                             	; move x to a
e2b9 : 8a               [ 2] 	txa
                             	; add x to num_a
e2ba : 18               [ 2] 	clc
e2bb : 653d             [ 3] 	adc num_a
e2bd : 853d             [ 3] 	sta num_a
                             	_bcc 2
                             
e2c1 : e63e             [ 5] 	inc num_a+1
                             	; now have element offset in num_a
                             	; dimensions in x and y
e2c3 : a6a3             [ 3] 	ldx df_tmpptrb
e2c5 : a4a4             [ 3] 	ldy df_tmpptrb+1
                             	; get type of variable originally found
e2c7 : 68               [ 4] 	pla
e2c8 : 48               [ 3] 	pha
e2c9 : 2901             [ 2] 	and #DFVVT_INT
e2cb : f004             [ 3] 	beq df_rt_eval_var_push
                             	; if it is int then multiply offset by 2
e2cd : 063d             [ 5] 	asl num_a
e2cf : 263e             [ 5] 	rol num_a+1
e2d1 :                       df_rt_eval_var_push
                             	; add pointer in lo,hi to num_a
e2d1 : 18               [ 2] 	clc
e2d2 : a001             [ 2] 	ldy #DFVVT_LO
e2d4 : b1a1             [ 5] 	lda (df_tmpptra),y
e2d6 : 653d             [ 3] 	adc num_a
e2d8 : 853d             [ 3] 	sta num_a
e2da : a002             [ 2] 	ldy #DFVVT_HI
AS65 Assembler for R6502 [1.42].                                     Page  187
-------------------------------- bank\bank0.s --------------------------------

e2dc : b1a1             [ 5] 	lda (df_tmpptra),y
e2de : d002             [ 3] 	bne df_rt_array_exists
                             	; if vvt address hi is zero then array not dimen
                             	SWBRK DFERR_DIM
                             
e2e2 :                       df_rt_array_exists
e2e2 : 653e             [ 3] 	adc num_a+1
e2e4 : 853e             [ 3] 	sta num_a+1
                             	; get the type
e2e6 : 68               [ 4] 	pla
                             	; if not int or byte then push string
e2e7 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
e2e9 : f01b             [ 4] 	beq df_rt_eval_var_str
                             	; get LVAR preference
e2eb : 28               [ 4] 	plp
e2ec : b019             [ 4] 	bcs df_rt_eval_ptr
                             	; need to load lo and hi for int
                             	; but only lo for byt
e2ee : 2901             [ 2] 	and #DFVVT_INT
e2f0 : f00b             [ 3] 	beq df_rt_eval_byt
                             	; push the contents pointed to by num_a
e2f2 : a000             [ 2] 	ldy #0
e2f4 : b13d             [ 5] 	lda (num_a),y
e2f6 : aa               [ 2] 	tax
e2f7 : c8               [ 2] 	iny
e2f8 : b13d             [ 5] 	lda (num_a),y
e2fa : 4c51f6           [ 3] 	jmp df_ost_pushInt
e2fd :                       df_rt_eval_byt
e2fd : a000             [ 2] 	ldy #0
e2ff : b13d             [ 5] 	lda (num_a),y
e301 : aa               [ 2] 	tax
e302 : 98               [ 2] 	tya			; Make A=0
e303 : 4c51f6           [ 3] 	jmp df_ost_pushInt
e306 :                       df_rt_eval_var_str
e306 : 28               [ 4] 	plp
e307 :                       df_rt_eval_ptr
                             ;	clc
                             	; put num_a not contents
e307 : a63d             [ 3] 	ldx num_a
e309 : a53e             [ 3] 	lda num_a+1
e30b : 4c60f6           [ 3] 	jmp df_ost_pushPtr
                             
e30e :                       df_rt_eval_proc
e30e : a577             [ 3] 	lda df_parmtop				; Save current position of par
e310 : 48               [ 3] 	pha
e311 : 20a7f4           [ 6] 	jsr df_rt_proc				; Go and call the user functio
e314 : 68               [ 4] 	pla							; Get back the original parameter stac
e315 : c577             [ 3] 	cmp df_parmtop				; if it is the same, then no r
e317 : f002             [ 3] 	beq df_rt_eval_proc_err
e319 : 18               [ 2] 	clc
e31a : 60               [ 6] 	rts
e31b :                       df_rt_eval_proc_err
                             	; if no return value then report an errror
                             	SWBRK DFERR_RETURN
                             
                             
                             
                             
                             ;****************************************
                             ;* get two ints off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  188
-------------------------------- bank\bank0.s --------------------------------

e31d :                       df_rt_get2Ints
                             	; the first int popped is actually the second pa
e31d : 2081f6           [ 6] 	jsr df_ost_popInt
e320 : 86a3             [ 3] 	stx df_tmpptrb
e322 : 85a4             [ 3] 	sta df_tmpptrb+1
                             
e324 : 2081f6           [ 6] 	jsr df_ost_popInt
e327 : 86a1             [ 3] 	stx df_tmpptra
e329 : 85a2             [ 3] 	sta df_tmpptra+1
e32b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* get two strings off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
e32c :                       df_rt_get2Strs
                             	; the first int popped is actually the second pa
e32c : 2085f6           [ 6] 	jsr df_ost_popStr
e32f : 86a3             [ 3] 	stx df_tmpptrb
e331 : 85a4             [ 3] 	sta df_tmpptrb+1
                             
e333 : 2085f6           [ 6] 	jsr df_ost_popStr
e336 : 86a1             [ 3] 	stx df_tmpptra
e338 : 85a2             [ 3] 	sta df_tmpptra+1
e33a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 2 ints runtime parsing
                             ;****************************************
e33b :                       df_rt_parm_2ints
                             	; evaluate 1st parm
e33b : 2077e0           [ 6] 	jsr df_rt_neval
                             	; jump over comma
e33e : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e340 : 2077e0           [ 6] 	jsr df_rt_neval
                             	
e343 : 4c1de3           [ 3] 	jmp df_rt_get2Ints
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 3 ints runtime parsing
                             ;****************************************
e346 :                       df_rt_parm_3ints
                             	; evaluate 1st parm
e346 : 2077e0           [ 6] 	jsr df_rt_neval
e349 : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e34b : 2077e0           [ 6] 	jsr df_rt_neval
e34e : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e350 : 2077e0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 3rd parm
AS65 Assembler for R6502 [1.42].                                     Page  189
-------------------------------- bank\bank0.s --------------------------------

e353 :                       df_rt_parm_pop3
e353 : 2081f6           [ 6] 	jsr df_ost_popInt
e356 : 86a5             [ 3] 	stx df_tmpptrc
e358 : 85a6             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd and 1st
e35a : 4c1de3           [ 3] 	jmp df_rt_get2Ints
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 4 ints runtime parsing
                             ;****************************************
e35d :                       df_rt_parm_4ints
                             	; evaluate 1st parm
e35d : 2077e0           [ 6] 	jsr df_rt_neval
e360 : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e362 : 2077e0           [ 6] 	jsr df_rt_neval
e365 : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e367 : 2077e0           [ 6] 	jsr df_rt_neval
e36a : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
e36c : 2077e0           [ 6] 	jsr df_rt_neval
                             
                             	; pop 4th parm
e36f : 2081f6           [ 6] 	jsr df_ost_popInt
e372 : 86a7             [ 3] 	stx df_tmpptrd
e374 : 85a8             [ 3] 	sta df_tmpptrd+1
                             
                             	; pop 3,2,1 parms
e376 : 4c53e3           [ 3] 	jmp df_rt_parm_pop3
                             
                             	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
                             ;	sta df_tmpptrc+1
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 5 ints runtime parsing
                             ;****************************************
                             ;df_rt_parm_5ints
                             ;	; evaluate 1st parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 2nd parm
                             ;	jsr df_rt_neval
AS65 Assembler for R6502 [1.42].                                     Page  190
-------------------------------- bank\bank0.s --------------------------------

                             ;	inc df_exeoff
                             ;	; evaluate the 3rd parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 4th parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 5th parm
                             ;	jsr df_rt_neval
                             ;
                             ;	; pop 5th parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptre
                             ;	sta df_tmpptre+1
                             ;	; pop 4th parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrd
                             ;	sta df_tmpptrd+1
                             ;	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
                             ;	sta df_tmpptrc+1
                             ;	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             ;	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;
                             ;	rts
                             
                             ;****************************************
                             ;* initialise statement to be executed
                             ;* X,A = line pointer, Y=statement offset
                             ;****************************************
e379 :                       df_rt_init_stat_ptr
                             	; save current line
e379 : 8686             [ 3] 	stx df_currlin
e37b : 8587             [ 3] 	sta df_currlin+1
e37d : 8480             [ 3] 	sty df_curstidx
e37f : 8488             [ 3] 	sty df_exeoff
e381 : b186             [ 5] 	lda (df_currlin),y
e383 : 857f             [ 3] 	sta df_nxtstidx
e385 : a200             [ 2] 	ldx #0
e387 : a186             [ 6] 	lda (df_currlin,x)
e389 : 857e             [ 3] 	sta df_eolidx
                             ;	ldy df_curstidx
                             ;	lda (df_currlin),y
                             ;	sta df_nxtstidx
e38b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Execute from a statement pointed to
                             ;* by currlin and exeoff
                             ;****************************************
e38c :                       df_rt_exec_stat
e38c : a686             [ 3] 	ldx df_currlin
e38e : a587             [ 3] 	lda df_currlin+1
e390 : a488             [ 3] 	ldy df_exeoff
e392 :                       df_rt_exec_init_ptr
AS65 Assembler for R6502 [1.42].                                     Page  191
-------------------------------- bank\bank0.s --------------------------------

e392 : 2079e3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; assume normal flow of control if next line hi 
                             	; this means no line can execute below page 1, n
e395 : a900             [ 2] 	lda #0
e397 : 858a             [ 3] 	sta df_nextlin+1
                             
                             	; find first token in statement
e399 :                       df_rt_exec_find_tok
e399 : c8               [ 2] 	iny
e39a : b186             [ 5] 	lda (df_currlin),y
e39c : 10fb             [ 3] 	bpl df_rt_exec_find_tok
e39e :                       df_rt_exec_found_tok
                             	; skip past token to next byte in readiness
e39e : c8               [ 2] 	iny
e39f : 8488             [ 3] 	sty df_exeoff
                             	; Run that statement - if end of return will pul
                             	; and effectively do an rts from this routine.
e3a1 : 20f2e3           [ 6] 	jsr df_rt_run_token
                             
                             	; check for break, asynch get
e3a4 : c65b             [ 5] 	dec df_checkkey
e3a6 : d00a             [ 3] 	bne df_rt_exec_no_key
e3a8 : a55c             [ 3] 	lda df_checkmsk
e3aa : 855b             [ 3] 	sta df_checkkey
e3ac : 18               [ 2] 	clc
e3ad : 2051c4           [ 6] 	jsr io_get_ch
e3b0 : 9029             [ 3] 	bcc df_rt_exec_check_key
e3b2 :                       df_rt_exec_no_key
                             	; check if normal flow of control
e3b2 : a58a             [ 3] 	lda df_nextlin+1
e3b4 : d033             [ 3] 	bne df_rt_exec_jump
                             	; try and execute another statement until end of
e3b6 : a47f             [ 3] 	ldy df_nxtstidx
e3b8 : c47e             [ 3] 	cpy df_eolidx
e3ba : 8488             [ 3] 	sty df_exeoff
e3bc : d0ce             [ 3] 	bne df_rt_exec_stat
                             	
                             	; reached end of line, move to next
e3be : a200             [ 2] 	ldx #0
e3c0 : 18               [ 2] 	clc
e3c1 : a186             [ 6] 	lda (df_currlin,x)
e3c3 : 6586             [ 3] 	adc df_currlin
e3c5 : 8586             [ 3] 	sta df_currlin
                             	_bcc 2
                             
e3c9 : e687             [ 5] 	inc df_currlin+1
                             
                             	; start from first statement in new line
e3cb : a003             [ 2] 	ldy #3
e3cd : 8488             [ 3] 	sty df_exeoff
                             
                             	; check if this line has any content (length >0)
e3cf : a186             [ 6] 	lda (df_currlin,x)
e3d1 : 857e             [ 3] 	sta df_eolidx
                             	; no more lines (len = 0), program done
e3d3 : d0b7             [ 3] 	bne df_rt_exec_stat
                             	; else done
                             	; normally wouldn't get here except immediate mo
                             	; if line number <> 0 then error
e3d5 : a55e             [ 3] 	lda df_immed
e3d7 : f00e             [ 3] 	beq df_rt_unexpected_end
e3d9 :                       df_rt_exec_end
AS65 Assembler for R6502 [1.42].                                     Page  192
-------------------------------- bank\bank0.s --------------------------------

e3d9 : 18               [ 2] 	clc
e3da : 60               [ 6] 	rts
e3db :                       df_rt_exec_check_key
e3db : c91a             [ 2] 	cmp #UTF_BRK					; CTRK-Z?
e3dd : f006             [ 3] 	beq df_rt_exec_ctrl_z
e3df : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
e3e1 : d0cf             [ 3] 	bne df_rt_exec_no_key			; None relevant keys, go
e3e3 :                       df_rt_exec_ctrl_c
                             	SWBRK DFERR_BREAK
                             
e3e5 :                       df_rt_exec_ctrl_z
                             	; Force a break with zero error number
                             	; this will drop in to the monitor
                             	SWBRK 0
                             
                             
e3e7 :                       df_rt_unexpected_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
                             	; if hi byte of nextline is not zero then
                             	; current line = next line
e3e9 :                       df_rt_exec_jump
                             	; initialise statement pointer from nextlin,toks
e3e9 : a689             [ 3] 	ldx df_nextlin
e3eb : a58a             [ 3] 	lda df_nextlin+1
e3ed : a47f             [ 3] 	ldy df_nxtstidx
e3ef : 4c92e3           [ 3] 	jmp df_rt_exec_init_ptr
                             
                             
                             ;****************************************
                             ;* Run statement in A
                             ;****************************************
e3f2 :                       df_rt_run_token
                             	; mask off MSB
                             ;	and #0x7f
                             	; multiply by 2
e3f2 : 0a               [ 2] 	asl a
e3f3 : aa               [ 2] 	tax
e3f4 : bddde4           [ 4] 	lda df_rt_tokenjmp,x
e3f7 : 85a1             [ 3] 	sta df_tmpptra
e3f9 : bddee4           [ 4] 	lda df_rt_tokenjmp+1,x
e3fc : 85a2             [ 3] 	sta df_tmpptra+1
                             	; execution code finishes with rts
e3fe : 6ca100           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* X,A : Line Address, Y = Index
                             ;* C=0 Found next statement
                             ;* C=1 No statement found
                             ;****************************************
e401 :                       df_rt_nextstat
                             	; save pointer
e401 : 8690             [ 3] 	stx df_lineptr
e403 : 8591             [ 3] 	sta df_lineptr+1
                             	; if end of program then err
e405 : a200             [ 2] 	ldx #0
e407 : a190             [ 6] 	lda (df_lineptr,x)
e409 : f022             [ 3] 	beq df_rt_nextstat_err
                             	; if next statement idx == line length
                             ;	lda (df_lineptr),y
AS65 Assembler for R6502 [1.42].                                     Page  193
-------------------------------- bank\bank0.s --------------------------------

                             ;	beq df_rt_nextstat_ln
e40b : b190             [ 5] 	lda (df_lineptr),y
e40d : c190             [ 6] 	cmp (df_lineptr,x)
e40f : f007             [ 3] 	beq df_rt_nextstat_ln
                             	; then go to next line
                             	; else make this Y
e411 : a8               [ 2] 	tay
                             	; X = line low
e412 : a690             [ 3] 	ldx df_lineptr
                             	; A = line high
e414 : a591             [ 3] 	lda df_lineptr+1
e416 : 18               [ 2] 	clc
e417 : 60               [ 6] 	rts
e418 :                       df_rt_nextstat_ln
                             	; for next line, add line length to ptr
e418 : 18               [ 2] 	clc
                             ;	lda (df_lineptr,x)
e419 : 6590             [ 3] 	adc df_lineptr
e41b : 8590             [ 3] 	sta df_lineptr
                             	_bcc 2
                             
e41f : e691             [ 5] 	inc df_lineptr+1
                             	; if end of program set C as error
e421 : a190             [ 6] 	lda (df_lineptr,x)
e423 : f008             [ 3] 	beq df_rt_nextstat_err
e425 : a690             [ 3] 	ldx df_lineptr
e427 : a591             [ 3] 	lda df_lineptr+1
                             	; always skip line number and length for start o
e429 : a003             [ 2] 	ldy #3
e42b : 18               [ 2] 	clc
e42c : 60               [ 6] 	rts
e42d :                       df_rt_nextstat_err
e42d : a000             [ 2] 	ldy #0
e42f : 38               [ 2] 	sec
e430 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push current line and statement to runtime sta
                             ;****************************************
e431 :                       df_rt_push_stat
e431 : a580             [ 3] 	lda df_curstidx
e433 : 2008f6           [ 6] 	jsr df_rst_pushByte
e436 : a587             [ 3] 	lda df_currlin+1
e438 : a686             [ 3] 	ldx df_currlin
e43a : 4c20f6           [ 3] 	jmp df_rst_pushWord
                             ;	clc
                             ;	rts
                             
                             ;****************************************
                             ;* Pop line and statement from runtime stack
                             ;* And transfer control to next statement
                             ;****************************************
e43d :                       df_rt_pop_stat
e43d : 202ef6           [ 6] 	jsr df_rst_popWord
e440 : 8689             [ 3] 	stx	df_nextlin
e442 : 858a             [ 3] 	sta df_nextlin+1
e444 : 2011f6           [ 6] 	jsr df_rst_popByte
e447 : a8               [ 2] 	tay
e448 : a689             [ 3] 	ldx df_nextlin
e44a : a58a             [ 3] 	lda df_nextlin+1
e44c : 2001e4           [ 6] 	jsr df_rt_nextstat
e44f : 8689             [ 3] 	stx df_nextlin
AS65 Assembler for R6502 [1.42].                                     Page  194
-------------------------------- bank\bank0.s --------------------------------

e451 : 858a             [ 3] 	sta df_nextlin+1
e453 : 847f             [ 3] 	sty df_nxtstidx
                             ;	clc
e455 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find proc definition in procptr
                             ;* Only call if proc not found before
                             ;****************************************
e456 :                       df_rt_findproc
                             	; start at program beginning
                             	_cpyZPWord df_prgstrt,df_lineptr
                             
e45e : a003             [ 2] 	ldy #3
e460 : 8492             [ 3] 	sty df_lineidx
e462 : a200             [ 2] 	ldx #0
e464 : a190             [ 6] 	lda (df_lineptr,x)
e466 : f034             [ 3] 	beq df_rt_findproc_err
e468 :                       df_rt_findproc_cmd
e468 : c8               [ 2] 	iny
e469 : b190             [ 5] 	lda (df_lineptr),y
e46b : 10fb             [ 3] 	bpl df_rt_findproc_cmd
e46d : c986             [ 2] 	cmp #DFRT_DEF
e46f : d017             [ 3] 	bne df_rt_findproc_nextstat
                             	; skip def token
e471 : c8               [ 2] 	iny
                             	; skip proc escape token
e472 : c8               [ 2] 	iny
                             	; now check the proc address against procptr
e473 : b190             [ 5] 	lda (df_lineptr),y
e475 : c58e             [ 3] 	cmp df_procptr
e477 : d00f             [ 3] 	bne df_rt_findproc_nextstat
e479 : c8               [ 2] 	iny
e47a : b190             [ 5] 	lda (df_lineptr),y
e47c : c58f             [ 3] 	cmp df_procptr+1
e47e : d008             [ 3] 	bne df_rt_findproc_nextstat
                             
                             	; found it, return AXY with line details
e480 : a690             [ 3] 	ldx df_lineptr
e482 : a591             [ 3] 	lda df_lineptr+1
e484 : a492             [ 3] 	ldy df_lineidx
e486 : 18               [ 2] 	clc
e487 : 60               [ 6] 	rts
e488 :                       df_rt_findproc_nextstat
                             	; restore AXY line details and find next stateme
e488 : a690             [ 3] 	ldx df_lineptr
e48a : a591             [ 3] 	lda df_lineptr+1
e48c : a492             [ 3] 	ldy df_lineidx
e48e : 2001e4           [ 6] 	jsr df_rt_nextstat
e491 : b009             [ 3] 	bcs df_rt_findproc_err
e493 : 8690             [ 3] 	stx df_lineptr
e495 : 8591             [ 3] 	sta df_lineptr+1
e497 : 8492             [ 3] 	sty df_lineidx
e499 : 4c68e4           [ 3] 	jmp df_rt_findproc_cmd
                             	; error
e49c :                       df_rt_findproc_err
                             	SWBRK DFERR_NOPROC
                             
                             
                             ;****************************************
                             ;* Find an escape value
                             ;* Does not check for end of line or statement
AS65 Assembler for R6502 [1.42].                                     Page  195
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
e49e :                       df_rt_findescval
e49e : a488             [ 3] 	ldy df_exeoff
e4a0 : 88               [ 2] 	dey
e4a1 :                       df_rt_findescval_loop
e4a1 : c8               [ 2] 	iny
e4a2 : b186             [ 5] 	lda (df_currlin),y
e4a4 : c920             [ 2] 	cmp #DFTK_ESCVAL
e4a6 : b0f9             [ 3] 	bcs df_rt_findescval_loop
e4a8 : 8488             [ 3] 	sty df_exeoff
e4aa : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Skip white space
                             ;* Does not check for end of line or statement
                             ;* A contains non-ws char, df_exeoff updated
                             ;****************************************
e4ab :                       df_rt_skip_ws
e4ab : a488             [ 3] 	ldy df_exeoff
e4ad : 88               [ 2] 	dey
e4ae :                       df_rt_skip_ws_loop
e4ae : c8               [ 2] 	iny
e4af : b186             [ 5] 	lda (df_currlin),y
e4b1 : c920             [ 2] 	cmp #' '
e4b3 : f0f9             [ 3] 	beq df_rt_skip_ws_loop
e4b5 : 8488             [ 3] 	sty df_exeoff
e4b7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Get an lvar
                             ;* Assumes next token will be escape DFTK_VAR
                             ;* tmpptra contains vvt slot address
                             ;* X,A is the lvar pointer
                             ;****************************************
e4b8 :                       df_rt_getlvar
e4b8 : 209ee4           [ 6] 	jsr df_rt_findescval
                             	; move past the escape value
e4bb : c8               [ 2] 	iny
                             
                             	; get variable address
e4bc : b186             [ 5] 	lda (df_currlin),y
e4be : 85a1             [ 3] 	sta df_tmpptra
e4c0 : c8               [ 2] 	iny
e4c1 : b186             [ 5] 	lda (df_currlin),y
e4c3 : 85a2             [ 3] 	sta df_tmpptra+1
                             
e4c5 : 8488             [ 3] 	sty df_exeoff
                             	; get the type
e4c7 : a000             [ 2] 	ldy #0
e4c9 : b1a1             [ 5] 	lda (df_tmpptra),y
                             	; set carry flag to return pointer (lvar)
e4cb : 38               [ 2] 	sec
e4cc : a488             [ 3] 	ldy df_exeoff
e4ce : 201be2           [ 6] 	jsr df_rt_eval_var
e4d1 : 4c89f6           [ 3] 	jmp df_ost_popPtr
                             ;	rts
                             
                             ;****************************************
                             ;* Pop stat from rt stack and continue
                             ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HE
                             ;****************************************
e4d4 :                       df_rt_pop_stat_go
AS65 Assembler for R6502 [1.42].                                     Page  196
-------------------------------- bank\bank0.s --------------------------------

e4d4 : 203de4           [ 6] 	jsr df_rt_pop_stat
                             	; restore stack pointer so we don't lose this en
e4d7 : 68               [ 4] 	pla
e4d8 : a8               [ 2] 	tay
e4d9 : 8476             [ 3] 	sty df_rtstop
e4db : 18               [ 2] 	clc
e4dc : 60               [ 6] 	rts
                             
                             	include "dflat/rtjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime token an
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
e4dd :                       df_rt_tokenjmp
e4dd : c7ec                  	dw	df_rt_assign
e4df : a7f4                  	dw	df_rt_proc
e4e1 : d8ec                  	dw	df_rt_comment
e4e3 : 7fec                  	dw	df_rt_println
e4e5 : 3cec                  	dw	df_rt_printat
e4e7 : 46ec                  	dw	df_rt_print
e4e9 : 47f5                  	dw	df_rt_def			; 0x86
e4eb : caf5                  	dw	df_rt_enddef		; 0x87
e4ed : c7f5                  	dw	df_rt_return		; 0x88
e4ef : 69f4                  	dw	df_rt_abort			; 0x89
e4f1 : 98ea                  	dw	df_rt_local
e4f3 : c4ea                  	dw	df_rt_dim
e4f5 : 66e9                  	dw	df_rt_repeat		; 0x8c
e4f7 : 6ee9                  	dw	df_rt_until
e4f9 : cde8                  	dw	df_rt_for			; 0x8e
e4fb : 0be9                  	dw	df_rt_next			; 0x8f
e4fd : a6e7                  	dw	df_rt_while			; 0x90
e4ff : 09e8                  	dw	df_rt_wend			; 0x81
e501 : 8ce8                  	dw	df_rt_if			; 0x92
e503 : 7ae8                  	dw	df_rt_else			; 0x93
e505 : 75e8                  	dw	df_rt_endif			; 0x94
e507 : 7ae8                  	dw	df_rt_elseif		; 0x95
e509 : d8ec                  	dw	df_rt_data			; 0x96
e50b : 71f9                  	dw	df_rt_asm_assemble	; 0x97 df_rt_asm_assemble
AS65 Assembler for R6502 [1.42].                                     Page  197
-------------------------------- bank\bank0.s --------------------------------

e50d : d9ec                  	dw	df_rt_run
e50f : ceed                  	dw	df_rt_list
e511 : 5cea                  	dw	df_rt_input
e513 : cfeb                  	dw	df_rt_text
e515 : 4ceb                  	dw	df_rt_plot
e517 : bdeb                  	dw	df_rt_cursor
e519 : 49eb                  	dw	df_rt_cls
e51b : 36f0                  	dw	df_rt_poke
e51d : 27f0                  	dw	df_rt_doke
e51f : 69f0                  	dw	df_rt_sound
e521 : 7cf0                  	dw	df_rt_music
e523 : 91f0                  	dw	df_rt_play
e525 : 89f1                  	dw	df_rt_save
e527 : dbf1                  	dw	df_rt_load
e529 : 44ea                  	dw	df_rt_read
e52b : a3e7                  	dw	df_rt_new
e52d : eaec                  	dw	df_rt_renum
e52f : 26ec                  	dw	df_rt_wait
e531 : 41f2                  	dw	df_rt_reset
e533 : d2eb                  	dw	df_rt_hires
e535 : ebeb                  	dw	df_rt_point
e537 : 15ec                  	dw	df_rt_line
e539 : 07ec                  	dw	df_rt_lineto
e53b : d5eb                  	dw	df_rt_pixmode
e53d : dbeb                  	dw	df_rt_ink
e53f : e1eb                  	dw	df_rt_paper
e541 : f5eb                  	dw	df_rt_circle
                             ;	dw	df_rt_fill
e543 : c3eb                  	dw	df_rt_himem
e545 : a0e7                  	dw	df_rt_monitor
e547 : 6bf4                  	dw	df_rt_sprchar
e549 : 75f4                  	dw	df_rt_sprpos
e54b : 81f4                  	dw	df_rt_sprupd
e54d : 8af4                  	dw	df_rt_sprinit
e54f : 8df4                  	dw	df_rt_sprmulti
e551 : 68f1                  	dw	df_rt_bsave
e553 : 35f1                  	dw	df_rt_bload
e555 : e0f0                  	dw	df_rt_tsave
e557 : faf0                  	dw	df_rt_tload
                             
e559 : 58f2                  	dw	df_rt_peek
e55b : 56f2                  	dw	df_rt_deek
e55d : e1f2                  	dw	df_rt_stick
e55f : e7f2                  	dw	df_rt_get
e561 : a7f3                  	dw	df_rt_chr
e563 : ecf3                  	dw	df_rt_left
e565 : fdf3                  	dw	df_rt_right
e567 : 18f4                  	dw	df_rt_mid
e569 : 36f4                  	dw	df_rt_len
e56b : 93f2                  	dw	df_rt_mem
e56d : fbf2                  	dw	df_rt_scrn
e56f : 71f2                  	dw	df_rt_rnd
e571 : 15f3                  	dw	df_rt_elapsed
e573 : 30f3                  	dw	df_rt_call
e575 : bbf3                  	dw	df_rt_hex
e577 : 42f4                  	dw	df_rt_asc
e579 : 53f4                  	dw	df_rt_val
e57b : 08f3                  	dw	df_rt_pixel
e57d : 93f4                  	dw	df_rt_sprhit
e57f : 42f3                  	dw	df_rt_sgn
e581 : 5ff3                  	dw	df_rt_addr
                             	
AS65 Assembler for R6502 [1.42].                                     Page  198
-------------------------------- bank\bank0.s --------------------------------

e583 : f6e5                  	dw	df_rt_mult
e585 : 17e6                  	dw	df_rt_div
e587 : 38e6                  	dw	df_rt_mod
e589 : 59e6                  	dw	df_rt_asl
e58b : 6ce6                  	dw	df_rt_lsr
e58d : d0e5                  	dw	df_rt_add
e58f : e3e5                  	dw	df_rt_sub
                             	
e591 : 7fe6                  	dw	df_rt_and
e593 : 8ee6                  	dw	df_rt_or
e595 : 9de6                  	dw	df_rt_eor
e597 : 36e7                  	dw	df_rt_comlte
e599 : 3fe7                  	dw	df_rt_comgte
e59b : 48e7                  	dw	df_rt_comne
e59d : 1be7                  	dw	df_rt_comlt
e59f : 24e7                  	dw	df_rt_comgt
e5a1 : 2de7                  	dw	df_rt_comeq
                             
                             
                             ; escape sequence handlers
                             ; to do the reverse of tokenising during the list
                             ; command which is also used to save to disk.
e5a3 :                       df_rt_escjmp
e5a3 : a1ee                  	dw df_rt_lst_chr
e5a5 : a0ee                  	dw df_rt_lst_reserved
e5a7 : a0ee                  	dw df_rt_lst_reserved
e5a9 : a0ee                  	dw df_rt_lst_reserved
e5ab : a0ee                  	dw df_rt_lst_reserved	
e5ad : a0ee                  	dw df_rt_lst_reserved	; no such thing as bytdec
e5af : beee                  	dw df_rt_lst_bythex
e5b1 : e3ee                  	dw df_rt_lst_bytbin
e5b3 : a0ee                  	dw df_rt_lst_reserved	
e5b5 : 07ef                  	dw df_rt_lst_intdec
e5b7 : d1ee                  	dw df_rt_lst_inthex
e5b9 : ebee                  	dw df_rt_lst_intbin
e5bb : a0ee                  	dw df_rt_lst_reserved
e5bd : a0ee                  	dw df_rt_lst_reserved
e5bf : a0ee                  	dw df_rt_lst_reserved
e5c1 : a0ee                  	dw df_rt_lst_reserved	
e5c3 : 64ef                  	dw df_rt_lst_strlit
e5c5 : 12ef                  	dw df_rt_lst_var
e5c7 : 12ef                  	dw df_rt_lst_proc
                             
                             	include "dflat/rtsubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTSUBS.S
                             ;*  Module that implements the runtime execution 
                             ;*  keywords and functions.
                             ;*  So this is where most of the action is for ru
                             ;*  a line is being executed, the dflat runtime c
                             ;*  jumps through the runtime table to routines h
                             ;*  Every dflat statement begins with a token (ig
                             ;*  whitespace), even the implicit assignment and
                             ;*  invocation.
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  199
-------------------------------- bank\bank0.s --------------------------------

                             ;************************************************
                             
                             	; ROM code
                             	code
                             
e5c9 :                       mod_sz_rtsubs_s
                             
                             	include "dflat/numop.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  NUMOP.S
                             ;*	Dflat number AND string operators.
                             ;*  Uses the operator stack to get parameters, le
                             ;*  result on the operator stack.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; common pushint code
e5c9 :                       df_rt_putintres
e5c9 : a6a1             [ 3] 	ldx df_tmpptra
e5cb : a5a2             [ 3] 	lda df_tmpptra+1
e5cd : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; add two numbers
e5d0 :                       df_rt_add
e5d0 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e5e0 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             	
                             ; subtract
e5e3 :                       df_rt_sub
e5e3 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	_subZPWord df_tmpptra,df_tmpptrb
                             
e5f3 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; multiply
e5f6 :                       df_rt_mult
e5f6 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e609 : 208dd4           [ 6] 	jsr int_mult
                             	_cpyZPWord num_a,df_tmpptra
                             
e614 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; divide
e617 :                       df_rt_div
e617 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
AS65 Assembler for R6502 [1.42].                                     Page  200
-------------------------------- bank\bank0.s --------------------------------

                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e62a : 20b8d4           [ 6] 	jsr int_div
                             	_cpyZPWord num_a,df_tmpptra
                             
e635 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; mod
e638 :                       df_rt_mod
e638 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e64b : 20b8d4           [ 6] 	jsr int_div
                             	_cpyZPWord num_x,df_tmpptra
                             
e656 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; shift left
e659 :                       df_rt_asl
e659 : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e65c : a6a3             [ 3] 	ldx df_tmpptrb
e65e : e8               [ 2] 	inx
e65f :                       df_rt_aslbit
e65f : ca               [ 2] 	dex
e660 : f007             [ 3] 	beq df_rt_asldone
e662 : 06a1             [ 5] 	asl df_tmpptra
e664 : 26a2             [ 5] 	rol df_tmpptra+1
e666 : 4c5fe6           [ 3] 	jmp df_rt_aslbit
e669 :                       df_rt_asldone
e669 : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; shift right
e66c :                       df_rt_lsr
e66c : 201de3           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e66f : a6a3             [ 3] 	ldx df_tmpptrb
e671 : e8               [ 2] 	inx
e672 :                       df_rt_lsrbit
e672 : ca               [ 2] 	dex
e673 : f007             [ 3] 	beq df_rt_lsrdone
e675 : 46a2             [ 5] 	lsr df_tmpptra+1
e677 : 66a1             [ 5] 	ror df_tmpptra
e679 : 4c72e6           [ 3] 	jmp df_rt_lsrbit
e67c :                       df_rt_lsrdone
e67c : 4cc9e5           [ 3] 	jmp df_rt_putintres
                             
                             ; logical and
e67f :                       df_rt_and
e67f : 201de3           [ 6] 	jsr df_rt_get2Ints
e682 : a5a1             [ 3] 	lda df_tmpptra
e684 : 25a3             [ 3] 	and df_tmpptrb
e686 : aa               [ 2] 	tax
e687 : a5a2             [ 3] 	lda df_tmpptra+1
e689 : 25a4             [ 3] 	and df_tmpptrb+1
e68b : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             	
                             ; logical or
e68e :                       df_rt_or
AS65 Assembler for R6502 [1.42].                                     Page  201
-------------------------------- bank\bank0.s --------------------------------

e68e : 201de3           [ 6] 	jsr df_rt_get2Ints
e691 : a5a1             [ 3] 	lda df_tmpptra
e693 : 05a3             [ 3] 	ora df_tmpptrb
e695 : aa               [ 2] 	tax
e696 : a5a2             [ 3] 	lda df_tmpptra+1
e698 : 05a4             [ 3] 	ora df_tmpptrb+1
e69a : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; logical eor
e69d :                       df_rt_eor
e69d : 201de3           [ 6] 	jsr df_rt_get2Ints
e6a0 : a5a1             [ 3] 	lda df_tmpptra
e6a2 : 45a3             [ 3] 	eor df_tmpptrb
e6a4 : aa               [ 2] 	tax
e6a5 : a5a2             [ 3] 	lda df_tmpptra+1
e6a7 : 45a4             [ 3] 	eor df_tmpptrb+1
e6a9 : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; a==b common function
e6ac :                       df_rt_aequb
e6ac : a5a1             [ 3] 	lda df_tmpptra
e6ae : c5a3             [ 3] 	cmp df_tmpptrb
e6b0 : d004             [ 3] 	bne df_rt_aequbFin
e6b2 : a5a2             [ 3] 	lda df_tmpptra+1
e6b4 : c5a4             [ 3] 	cmp df_tmpptrb+1
e6b6 :                       df_rt_aequbFin
e6b6 : 60               [ 6] 	rts
                             
                             ; a-b common function
e6b7 :                       df_rt_asubb
e6b7 : 38               [ 2] 	sec
e6b8 : a5a1             [ 3] 	lda df_tmpptra
e6ba : e5a3             [ 3] 	sbc df_tmpptrb
e6bc : a5a2             [ 3] 	lda df_tmpptra+1
e6be : e5a4             [ 3] 	sbc df_tmpptrb+1
e6c0 : 5002             [ 3] 	bvc df_rt_asubbFin
e6c2 : 4980             [ 2] 	eor #0x80
e6c4 :                       df_rt_asubbFin
e6c4 : 60               [ 6] 	rts
                             
                             ; b-a common function
e6c5 :                       df_rt_bsuba
e6c5 : 38               [ 2] 	sec
e6c6 : a5a3             [ 3] 	lda df_tmpptrb
e6c8 : e5a1             [ 3] 	sbc df_tmpptra
e6ca : a5a4             [ 3] 	lda df_tmpptrb+1
e6cc : e5a2             [ 3] 	sbc df_tmpptra+1
e6ce : 5002             [ 3] 	bvc df_rt_bsubaFin
e6d0 : 4980             [ 2] 	eor #0x80
e6d2 :                       df_rt_bsubaFin
e6d2 : 60               [ 6] 	rts
                             
                             ; common routine push true
e6d3 :                       df_rt_true
e6d3 : a2ff             [ 2] 	ldx #0xff
e6d5 : 8a               [ 2] 	txa
e6d6 : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; common routine push false
e6d9 :                       df_rt_false
e6d9 : a200             [ 2] 	ldx #0x00
e6db : 8a               [ 2] 	txa
AS65 Assembler for R6502 [1.42].                                     Page  202
-------------------------------- bank\bank0.s --------------------------------

e6dc : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; a < b == (a-b) < 0
e6df :                       df_rt_lt
e6df : 201de3           [ 6] 	jsr df_rt_get2Ints
e6e2 : 20b7e6           [ 6] 	jsr df_rt_asubb
e6e5 : 30ec             [ 3] 	bmi df_rt_true
e6e7 : 10f0             [ 3] 	bpl df_rt_false
                             
                             ; a <=b == !(b-a > 0)
e6e9 :                       df_rt_lte
e6e9 : 201de3           [ 6] 	jsr df_rt_get2Ints
e6ec :                       df_rt_lte_calc
e6ec : 20c5e6           [ 6] 	jsr df_rt_bsuba
e6ef : 30e8             [ 3] 	bmi df_rt_false
e6f1 : 10e0             [ 3] 	bpl df_rt_true
                             
                             ; a > b == (b-a) < 0
e6f3 :                       df_rt_gt
e6f3 : 201de3           [ 6] 	jsr df_rt_get2Ints
e6f6 : 20c5e6           [ 6] 	jsr df_rt_bsuba
e6f9 : 30d8             [ 3] 	bmi df_rt_true
e6fb : 10dc             [ 3] 	bpl df_rt_false
                             
                             ; a >= b == (a-b >=0)
e6fd :                       df_rt_gte
e6fd : 201de3           [ 6] 	jsr df_rt_get2Ints
e700 :                       df_rt_gte_calc
e700 : 20b7e6           [ 6] 	jsr df_rt_asubb
e703 : 10ce             [ 4] 	bpl df_rt_true
e705 : 30d2             [ 4] 	bmi df_rt_false
                             
                             ; a == b
e707 :                       df_rt_eq
e707 : 201de3           [ 6] 	jsr df_rt_get2Ints
e70a : 20ace6           [ 6] 	jsr df_rt_aequb
e70d : d0ca             [ 4] 	bne df_rt_false
e70f : f0c2             [ 4] 	beq df_rt_true
                             
                             ; a <> b
e711 :                       df_rt_ne
e711 : 201de3           [ 6] 	jsr df_rt_get2Ints
e714 : 20ace6           [ 6] 	jsr df_rt_aequb
e717 : f0c0             [ 4] 	beq df_rt_false
e719 : d0b8             [ 4] 	bne df_rt_true
                             
                             ; Common usage of boolean operators for num and s
                             
e71b :                       df_rt_comlt
                             	; First find the data type on the stack
e71b : 207bf6           [ 6] 	jsr df_ost_peekType
e71e : 2980             [ 2] 	and #DFST_STR
e720 : d04a             [ 3] 	bne df_rt_slt
                             	; If not string then assume number
e722 : f0bb             [ 4] 	beq df_rt_lt
                             
e724 :                       df_rt_comgt
                             	; First find the data type on the stack
e724 : 207bf6           [ 6] 	jsr df_ost_peekType
e727 : 2980             [ 2] 	and #DFST_STR
e729 : d048             [ 3] 	bne df_rt_sgt
                             	; If not string then assume number
AS65 Assembler for R6502 [1.42].                                     Page  203
-------------------------------- bank\bank0.s --------------------------------

e72b : f0c6             [ 4] 	beq df_rt_gt
                             
e72d :                       df_rt_comeq
                             	; First find the data type on the stack
e72d : 207bf6           [ 6] 	jsr df_ost_peekType
e730 : 2980             [ 2] 	and #DFST_STR
e732 : d048             [ 3] 	bne df_rt_seq
                             	; If not string then assume number
e734 : f0d1             [ 3] 	beq df_rt_eq
                             
e736 :                       df_rt_comlte
                             	; First find the data type on the stack
e736 : 207bf6           [ 6] 	jsr df_ost_peekType
e739 : 2980             [ 2] 	and #DFST_STR
e73b : d014             [ 3] 	bne df_rt_slte
                             	; If not string then assume number
e73d : f0aa             [ 4] 	beq df_rt_lte
                             	
e73f :                       df_rt_comgte
                             	; First find the data type on the stack
e73f : 207bf6           [ 6] 	jsr df_ost_peekType
e742 : 2980             [ 2] 	and #DFST_STR
e744 : d018             [ 3] 	bne df_rt_sgte
                             	; If not string then assume number
e746 : f0b5             [ 4] 	beq df_rt_gte
                             
e748 :                       df_rt_comne
                             	; First find the data type on the stack
e748 : 207bf6           [ 6] 	jsr df_ost_peekType
e74b : 2980             [ 2] 	and #DFST_STR
e74d : d016             [ 3] 	bne df_rt_sne
                             	; If not string then assume number
e74f : f0c0             [ 3] 	beq df_rt_ne
                             
                             
                             ;********** STRING OPS **********
                             
                             ; string less than or equal
e751 :                       df_rt_slte
e751 : 2083e7           [ 6] 	jsr df_rt_str_comp
e754 : 3005             [ 3] 	bmi df_rt_str_comp_true
e756 : f003             [ 3] 	beq df_rt_str_comp_true
e758 :                       df_rt_str_comp_false
e758 : 4cd9e6           [ 3] 	jmp df_rt_false
e75b :                       df_rt_str_comp_true
e75b : 4cd3e6           [ 3] 	jmp df_rt_true	
                             
                             ; string greater then or equal	
e75e :                       df_rt_sgte
e75e : 2083e7           [ 6] 	jsr df_rt_str_comp
e761 : 10f8             [ 3] 	bpl df_rt_str_comp_true
e763 : 30f3             [ 3] 	bmi df_rt_str_comp_false
                             
                             ; string not equal
e765 :                       df_rt_sne
e765 : 2083e7           [ 6] 	jsr df_rt_str_comp
e768 : d0f1             [ 3] 	bne df_rt_str_comp_true
e76a : f0ec             [ 3] 	beq df_rt_str_comp_false
                             
                             ; string less than
e76c :                       df_rt_slt
e76c : 2083e7           [ 6] 	jsr df_rt_str_comp
AS65 Assembler for R6502 [1.42].                                     Page  204
-------------------------------- bank\bank0.s --------------------------------

e76f : 30ea             [ 3] 	bmi df_rt_str_comp_true
e771 : 10e5             [ 3] 	bpl df_rt_str_comp_false
                             
                             ; string greater than
e773 :                       df_rt_sgt
e773 : 2083e7           [ 6] 	jsr df_rt_str_comp
e776 : 30e0             [ 3] 	bmi df_rt_str_comp_false
e778 : f0de             [ 3] 	beq df_rt_str_comp_false
e77a : d0df             [ 3] 	bne df_rt_str_comp_true
                             
                             ; string equal
e77c :                       df_rt_seq
e77c : 2083e7           [ 6] 	jsr df_rt_str_comp
e77f : f0da             [ 3] 	beq df_rt_str_comp_true
e781 : d0d5             [ 3] 	bne df_rt_str_comp_false
                             
                             ; common string comparator
                             ; N=1 means <
                             ; Z=0 means >
                             ; Z=1 means ==
e783 :                       df_rt_str_comp
e783 : 202ce3           [ 6] 	jsr df_rt_get2Strs
e786 : a000             [ 2] 	ldy #0
e788 :                       df_rt_str_comp_byte
e788 : b1a1             [ 5] 	lda (df_tmpptra),y
e78a : aa               [ 2] 	tax							; Save op1 char in X
e78b : d1a3             [ 5] 	cmp (df_tmpptrb),y
                             	; if c=0 then <
e78d : 9008             [ 3] 	bcc df_rt_str_comp_lt
                             	; if c=1 and nz then >
e78f : d009             [ 3] 	bne df_rt_str_comp_gt
                             	; if here then both strings still the same
e791 : 8a               [ 2] 	txa							; What was op1 char
                             	; if char is zero then end
e792 : f009             [ 3] 	beq df_rt_str_comp_eq
                             	; else do next char
e794 : c8               [ 2] 	iny
e795 : d0f1             [ 3] 	bne df_rt_str_comp_byte ; Always - relying on Y 
e797 :                       df_rt_str_comp_lt
e797 : a9ff             [ 2] 	lda #0xff
e799 : 60               [ 6] 	rts
e79a :                       df_rt_str_comp_gt
e79a : a901             [ 2] 	lda #0x01
e79c : 60               [ 6] 	rts
e79d :                       df_rt_str_comp_eq
e79d : a900             [ 2] 	lda #0x00
e79f : 60               [ 6] 	rts
                             
                             
                             
                             
e7a0 :                       df_rt_monitor
e7a0 : 4c08d3           [ 3] 	jmp command_line
                             
e7a3 :                       df_rt_new
e7a3 : 4cb2f6           [ 3] 	jmp df_clear
                             
e7a6 :                       df_rt_while
                             	; push statement address
e7a6 : 2031e4           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_WHILE token
e7a9 : a990             [ 2] 	lda #DFRT_WHILE
AS65 Assembler for R6502 [1.42].                                     Page  205
-------------------------------- bank\bank0.s --------------------------------

e7ab : 2008f6           [ 6] 	jsr df_rst_pushByte
                             
                             	; get value in A,X
e7ae : 2071e0           [ 6] 	jsr df_rt_getnval
                             
                             	; if value<>0 then continue
e7b1 : e000             [ 2] 	cpx #0
e7b3 : f001             [ 3] 	beq df_rt_while_done
e7b5 : 60               [ 6] 	rts
e7b6 :                       df_rt_while_done
                             	; pop while data off stack as not needed
e7b6 : 202ef6           [ 6] 	jsr df_rst_popWord
e7b9 : 202ef6           [ 6] 	jsr df_rst_popWord
                             	; while evaluated false so find wend
                             	; but check for any nested while/wends
                             	; nest = 1 to start
e7bc : a593             [ 3] 	lda df_ifnest
e7be : 48               [ 3] 	pha
e7bf : a901             [ 2] 	lda #1
e7c1 : 8593             [ 3] 	sta df_ifnest
                             	; find the matching else/elseif/endif
                             	; start from current statement
                             	_cpyZPWord df_currlin,df_nextlin
                             
e7cb :                       df_rt_findwend
e7cb : a689             [ 3] 	ldx df_nextlin
e7cd : a58a             [ 3] 	lda df_nextlin+1
e7cf : a480             [ 3] 	ldy df_curstidx
e7d1 : 2001e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e7d4 : b031             [ 4] 	bcs df_rt_wend_end
e7d6 : 8689             [ 3] 	stx df_nextlin
e7d8 : 858a             [ 3] 	sta df_nextlin+1
e7da : 8480             [ 3] 	sty df_curstidx
                             	; find the command token
e7dc :                       df_rt_while_cmd
e7dc : c8               [ 2] 	iny
e7dd : b189             [ 5] 	lda (df_nextlin),y
e7df : 10fb             [ 3] 	bpl df_rt_while_cmd
                             	; check for wend
e7e1 : c991             [ 2] 	cmp #DFRT_WEND
e7e3 : d019             [ 3] 	bne df_rt_check_while
                             	; decrement nest
e7e5 : c693             [ 5] 	dec df_ifnest
                             	; if not zero then go find more commands
e7e7 : d0e2             [ 3] 	bne df_rt_findwend
                             	; else found it, restore if nest
                             	; and skip the wend statement
e7e9 : 68               [ 4] 	pla
e7ea : 8593             [ 3] 	sta df_ifnest
e7ec : a689             [ 3] 	ldx df_nextlin
e7ee : a58a             [ 3] 	lda df_nextlin+1
e7f0 : a480             [ 3] 	ldy df_curstidx
e7f2 : 2001e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e7f5 : b010             [ 4] 	bcs df_rt_wend_end
                             	; need to update nxtstidx to transfer control
e7f7 : 8689             [ 3] 	stx df_nextlin
e7f9 : 858a             [ 3] 	sta df_nextlin+1
e7fb : 847f             [ 3] 	sty df_nxtstidx
e7fd : 60               [ 6] 	rts
e7fe :                       df_rt_check_while
AS65 Assembler for R6502 [1.42].                                     Page  206
-------------------------------- bank\bank0.s --------------------------------

                             	; check for while
e7fe : c990             [ 2] 	cmp #DFRT_WHILE
e800 : d0c9             [ 4] 	bne df_rt_findwend
                             	; if while found then increment nest
e802 : e693             [ 5] 	inc df_ifnest
e804 : 4ccbe7           [ 3] 	jmp df_rt_findwend
e807 :                       df_rt_wend_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
e809 :                       df_rt_wend
e809 : 2011f6           [ 6] 	jsr df_rst_popByte
e80c : c990             [ 2] 	cmp #DFRT_WHILE
e80e : d00d             [ 3] 	bne df_rt_wend_err
                             	; pop the stat and continue
e810 : 202ef6           [ 6] 	jsr df_rst_popWord
e813 : 8689             [ 3] 	stx	df_nextlin
e815 : 858a             [ 3] 	sta df_nextlin+1
e817 : 2011f6           [ 6] 	jsr df_rst_popByte
e81a : 857f             [ 3] 	sta df_nxtstidx
e81c : 60               [ 6] 	rts
e81d :                       df_rt_wend_err
                             	SWBRK DFERR_WEND
                             
                             
                             ;move to next statement during if/else matching
                             ;end of program is an error
e81f :                       df_rt_if_stat
e81f : a689             [ 3] 	ldx df_nextlin
e821 : a58a             [ 3] 	lda df_nextlin+1
e823 : a480             [ 3] 	ldy df_curstidx
e825 : 2001e4           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e828 : b009             [ 3] 	bcs df_rt_if_stat_err
e82a : 8689             [ 3] 	stx df_nextlin
e82c : 858a             [ 3] 	sta df_nextlin+1
e82e : 8480             [ 3] 	sty df_curstidx
e830 : 847f             [ 3] 	sty df_nxtstidx
e832 : 60               [ 6] 	rts
                             ; program ended with no match
e833 :                       df_rt_if_stat_err
                             	SWBRK DFERR_UNCLOSEDIF
                             
                             
                             ; find matching else/elseif/endif
                             ; C = 0 match else/elseif/endif
                             ; C = 1 match endif only
                             ; endif is always matched
                             ; ** MAKE SURE NEXTLIN IS POPULATED! **
e835 :                       df_rt_if_match
                             	; save the current if nest level
e835 : a593             [ 3] 	lda df_ifnest
e837 : 48               [ 3] 	pha
                             	; local if nest level is zero to start with
e838 : a900             [ 2] 	lda #0
e83a : 8593             [ 3] 	sta df_ifnest
                             	; save match pref
e83c : 08               [ 3] 	php
                             	; find the matching else/elseif/endif
                             	; start from df_nextlin, df_curstidx
e83d :                       df_rt_findelseendif
e83d : 201fe8           [ 6] 	jsr df_rt_if_stat
AS65 Assembler for R6502 [1.42].                                     Page  207
-------------------------------- bank\bank0.s --------------------------------

                             	; find command
e840 :                       df_rt_ifcmd
e840 : c8               [ 2] 	iny
e841 : b189             [ 5] 	lda (df_nextlin),y
e843 : 10fb             [ 3] 	bpl df_rt_ifcmd
                             	; check for endif
e845 : c994             [ 2] 	cmp #DFRT_ENDIF
e847 : f015             [ 3] 	beq df_rt_ifelse
                             
e849 : 28               [ 4] 	plp
e84a : 08               [ 3] 	php
                             
e84b : b008             [ 3] 	bcs df_rt_ifskipelseif
e84d : c993             [ 2] 	cmp #DFRT_ELSE
e84f : f00d             [ 3] 	beq df_rt_ifelse
e851 : c995             [ 2] 	cmp #DFRT_ELSEIF
e853 : f009             [ 3] 	beq df_rt_ifelse
e855 :                       df_rt_ifskipelseif
                             	; another if token found - increment lcoal if ne
e855 : c992             [ 2] 	cmp #DFRT_IF
e857 : d002             [ 3] 	bne df_rt_skipnestif
e859 : e693             [ 5] 	inc df_ifnest
e85b :                       df_rt_skipnestif
                             	; no tokens of interest found, so next statement
e85b : 4c3de8           [ 3] 	jmp df_rt_findelseendif
                             
                             	; found else/elseif/endif
                             	; but check if this is nested
e85e :                       df_rt_ifelse
                             	; nest counter zero then found matching else/els
e85e : a693             [ 3] 	ldx df_ifnest
e860 : f009             [ 3] 	beq df_rt_if_found
                             	; endif token found so decrement local nest
e862 : c994             [ 2] 	cmp #DFRT_ENDIF
e864 : d002             [ 3] 	bne df_rt_skipnestendif
e866 : c693             [ 5] 	dec df_ifnest
e868 :                       df_rt_skipnestendif
                             	; continue to search for else/endif
e868 : 4c3de8           [ 3] 	jmp df_rt_findelseendif
                             	; ok got a match
e86b :                       df_rt_if_found
                             	; remove pref
e86b : 28               [ 4] 	plp
                             	; restore global if nest
e86c : 8538             [ 3] 	sta tmp_d			; Using as a temp place!
e86e : 68               [ 4] 	pla					; Get nest from stack
e86f : aa               [ 2] 	tax					; And put in X
e870 : a538             [ 3] 	lda tmp_d			; Get a back from temp!
e872 : 8693             [ 3] 	stx df_ifnest		; Now restore the nest counter
                             
                             	;A contains the token found, Y is index in to df
                             ;	clc
e874 : 60               [ 6] 	rts
                             
e875 :                       df_rt_endif
                             	; decrement if next level
e875 : c693             [ 5] 	dec df_ifnest
e877 : 3011             [ 3] 	bmi df_rt_noif_err
e879 :                       df_rt_if_done
e879 : 60               [ 6] 	rts
                             
                             	; else and ifelse encountered in a normal sequen
AS65 Assembler for R6502 [1.42].                                     Page  208
-------------------------------- bank\bank0.s --------------------------------

                             	; only happens when the clause has been executed
                             	; so we only now need to find the endif
e87a :                       df_rt_elseif
e87a :                       df_rt_else
                             	; not in if mode then error
e87a : a593             [ 3] 	lda df_ifnest
e87c : f00c             [ 3] 	beq df_rt_noif_err
                             	; find endif only
                             	; starting from current line and curstidx
                             	_cpyZPWord df_currlin,df_nextlin
                             
e886 : 38               [ 2] 	sec
e887 : 4c35e8           [ 3] 	jmp df_rt_if_match
                             
                             ; endif/else/elseif encountered outside of an if
e88a :                       df_rt_noif_err
                             	SWBRK DFERR_NOIF
                             
                             
                             	; when if is encountered, the job of this routin
                             	; to determine which clause to execute, then tra
                             	; program control to that point.  in normal prog
                             	; sequence else/elseif statements will signify t
                             	; of an if construct.
e88c :                       df_rt_if
                             	; increment global if nest counter
e88c : e693             [ 5] 	inc df_ifnest
e88e :                       df_rt_ifeval
                             	; get value
e88e : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; if X,A<>0 if is successful then continue norma
e891 : a8               [ 2] 	tay
e892 : d0e5             [ 3] 	bne df_rt_if_done
e894 : 8a               [ 2] 	txa
e895 : d0e2             [ 3] 	bne df_rt_if_done
                             	; got here then if clause evaluated to false
                             	; match with else/elseif/endif
                             	; df_nextlin is used to find the clause to execu
                             	_cpyZPWord df_currlin,df_nextlin
                             
e89f : 18               [ 2] 	clc
e8a0 : 2035e8           [ 6] 	jsr df_rt_if_match
                             	; A contains the token found, Y is index of this
                             
e8a3 : c993             [ 2] 	cmp #DFRT_ELSE
                             	; else: df_nextlin and df_nxtstidx points to the
e8a5 : f023             [ 3] 	beq df_rt_do_else
                             
e8a7 : c994             [ 2] 	cmp #DFRT_ENDIF
                             	; else: df_nextlin and df_nxtstidx points to the
e8a9 : f0ce             [ 3] 	beq df_rt_if_done
                             
                             	; elif detected - increment past the token and e
                             	; make this the current line and token index
                             	_cpyZPWord df_nextlin,df_currlin
                             
                             	; move past the token and save position
e8b3 : c8               [ 2] 	iny
e8b4 : 98               [ 2] 	tya
e8b5 : 48               [ 3] 	pha
                             	; initialise statement pointer
e8b6 : a480             [ 3] 	ldy df_curstidx
AS65 Assembler for R6502 [1.42].                                     Page  209
-------------------------------- bank\bank0.s --------------------------------

e8b8 : a686             [ 3] 	ldx df_currlin
e8ba : a587             [ 3] 	lda df_currlin+1
e8bc : 2079e3           [ 6] 	jsr df_rt_init_stat_ptr
                             	; restore Y (one byte past the token) and save i
e8bf : 68               [ 4] 	pla
e8c0 : a8               [ 2] 	tay
e8c1 : 8488             [ 3] 	sty df_exeoff
                             	; don't force a jump as we've initalised all var
e8c3 : a900             [ 2] 	lda #0
e8c5 : 858a             [ 3] 	sta df_nextlin+1
                             	; now everyting is set up to evaluate the elif c
e8c7 : 4c8ee8           [ 3] 	jmp df_rt_ifeval
                             
e8ca :                       df_rt_do_else
                             	; we need to point to the next statement not thi
e8ca : 4c1fe8           [ 3] 	jmp df_rt_if_stat
                             
e8cd :                       df_rt_for
                             	; push statement address to rt stack
e8cd : 2031e4           [ 6] 	jsr df_rt_push_stat
                             	; get lvar
e8d0 : 20b8e4           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer, A is fine to trample
e8d3 : 48               [ 3] 	pha
e8d4 : 8a               [ 2] 	txa
e8d5 : 48               [ 3] 	pha
                             
                             	; find starting value
                             	; evaluate the starting value
                             	; can't use df_rt_getnval as need to use A,X fir
e8d6 : e688             [ 5] 	inc df_exeoff
e8d8 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; get ready to update the counter using pointer
e8db : 68               [ 4] 	pla
e8dc : aa               [ 2] 	tax
e8dd : 86a1             [ 3] 	stx df_tmpptra
e8df : 68               [ 4] 	pla
e8e0 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; But remember lvar pointer for later A is ok to
e8e2 : 48               [ 3] 	pha
e8e3 : 8a               [ 2] 	txa
e8e4 : 48               [ 3] 	pha
                             
                             	; get the starting value from op stack
e8e5 : 2081f6           [ 6] 	jsr df_ost_popInt
                             	; save it to counter slot
e8e8 : a001             [ 2] 	ldy #1
e8ea : 91a1             [ 5] 	sta (df_tmpptra),y
e8ec : 8a               [ 2] 	txa
e8ed : 88               [ 2] 	dey
e8ee : 91a1             [ 5] 	sta (df_tmpptra),y
                             
                             	; find end value
                             	; evaluate the end value
e8f0 : e688             [ 5] 	inc df_exeoff
e8f2 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; and put on rt stack
e8f5 : 2020f6           [ 6] 	jsr df_rst_pushWord
                             
                             	; find step value
                             	; evaluate the end value
e8f8 : e688             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  210
-------------------------------- bank\bank0.s --------------------------------

e8fa : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; and push on rt stack
e8fd : 2020f6           [ 6] 	jsr df_rst_pushWord
                             	; save the counter lvar pointer
e900 : 68               [ 4] 	pla
e901 : aa               [ 2] 	tax
e902 : 68               [ 4] 	pla
e903 : 2020f6           [ 6] 	jsr df_rst_pushWord
                             	; all done - counter set to start
                             	; stack contains counter slot, step val, end val
                             	; now push for token
e906 : a98e             [ 2] 	lda #DFRT_FOR
e908 : 4c08f6           [ 3] 	jmp df_rst_pushByte
                             
e90b :                       df_rt_next
                             	; remember stack position
e90b : a476             [ 3] 	ldy df_rtstop
e90d : 98               [ 2] 	tya
e90e : 48               [ 3] 	pha
e90f : 2011f6           [ 6] 	jsr df_rst_popByte
e912 : c98e             [ 2] 	cmp #DFRT_FOR
e914 : d04e             [ 3] 	bne df_rt_next_err
                             	; get the slot address
e916 : 202ef6           [ 6] 	jsr df_rst_popWord
                             	; save address to ptrd, contents to ptra
e919 : 86a7             [ 3] 	stx df_tmpptrd
e91b : 85a8             [ 3] 	sta df_tmpptrd+1
e91d : a000             [ 2] 	ldy #0
e91f : b1a7             [ 5] 	lda (df_tmpptrd),y
e921 : 85a1             [ 3] 	sta df_tmpptra
e923 : c8               [ 2] 	iny
e924 : b1a7             [ 5] 	lda (df_tmpptrd),y
e926 : 85a2             [ 3] 	sta df_tmpptra+1
                             
                             	; get step value, save in ptrb
e928 : 202ef6           [ 6] 	jsr df_rst_popWord
e92b : 86a3             [ 3] 	stx df_tmpptrb
e92d : 85a4             [ 3] 	sta df_tmpptrb+1
e92f : 48               [ 3] 	pha					; Push A to check for -ve step
                             
                             	; add step to counter and save back to counter
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e93d : a5a1             [ 3] 	lda df_tmpptra
e93f : a000             [ 2] 	ldy #0
e941 : 91a7             [ 5] 	sta (df_tmpptrd),y
e943 : a5a2             [ 3] 	lda df_tmpptra+1
e945 : c8               [ 2] 	iny
e946 : 91a7             [ 5] 	sta (df_tmpptrd),y
                             
                             	; get end value, save in ptrb
e948 : 202ef6           [ 6] 	jsr df_rst_popWord
e94b : 86a3             [ 3] 	stx df_tmpptrb
e94d : 85a4             [ 3] 	sta df_tmpptrb+1
e94f : 68               [ 4] 	pla					; check if if +ve or -ve step
e950 : 1006             [ 3] 	bpl df_rt_check_pos
                             	; call gte operation but no need to get ints
                             	; as already in ptra and ptrb
e952 : 2000e7           [ 6] 	jsr df_rt_gte_calc
e955 : 4c5be9           [ 3] 	jmp df_rt_next_check
e958 :                       df_rt_check_pos
                             	; call lte operation but no need to get ints
AS65 Assembler for R6502 [1.42].                                     Page  211
-------------------------------- bank\bank0.s --------------------------------

                             	; as already in ptra and ptrb
e958 : 20ece6           [ 6] 	jsr df_rt_lte_calc
e95b :                       df_rt_next_check
                             	; check if true or false
e95b : 2081f6           [ 6] 	jsr df_ost_popInt
e95e : 8a               [ 2] 	txa
                             	; if false then next is done
e95f : f020             [ 3] 	beq df_rt_untilnext_done
                             	; else we continue
e961 : 4cd4e4           [ 3] 	jmp df_rt_pop_stat_go
                             
e964 :                       df_rt_next_err
                             	SWBRK DFERR_NEXTFOR
                             
                             
                             
e966 :                       df_rt_repeat
                             	; push statement address
e966 : 2031e4           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_REPEAT token
e969 : a98c             [ 2] 	lda #DFRT_REPEAT
e96b : 4c08f6           [ 3] 	jmp df_rst_pushByte
                             
e96e :                       df_rt_until
                             	; remember stack position
e96e : a576             [ 3] 	lda df_rtstop
e970 : 48               [ 3] 	pha
e971 : 2011f6           [ 6] 	jsr df_rst_popByte
e974 : c98c             [ 2] 	cmp #DFRT_REPEAT
e976 : d011             [ 3] 	bne df_rt_until_err
                             	; evaluate expression in to A,X
e978 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 then continue
e97b : 8a               [ 2] 	txa
e97c : d003             [ 3] 	bne df_rt_untilnext_done
                             
                             	; pop the stat and continue
e97e : 4cd4e4           [ 3] 	jmp df_rt_pop_stat_go
                             
e981 :                       df_rt_untilnext_done
e981 : 68               [ 4] 	pla
e982 : a8               [ 2] 	tay
                             	; pop 2 items off stack (line address, index)
                             	; and continue
e983 : 202ef6           [ 6] 	jsr df_rst_popWord
e986 : 4c11f6           [ 3] 	jmp df_rst_popByte
                             
e989 :                       df_rt_until_err
                             	SWBRK DFERR_UNTIL
                             
                             
e98b :                       df_rt_sadd
e98b : 60               [ 6] 	rts
                             
e98c :                       df_rt_print_num
e98c : 2081f6           [ 6] 	jsr df_ost_popInt
e98f : 18               [ 2] 	clc
e990 : 4cfdc3           [ 3] 	jmp print_a_to_d
                             
e993 :                       df_rt_print_str
e993 : 2085f6           [ 6] 	jsr df_ost_popStr
e996 : 86a1             [ 3] 	stx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  212
-------------------------------- bank\bank0.s --------------------------------

e998 : 85a2             [ 3] 	sta df_tmpptra+1
e99a : a000             [ 2] 	ldy #0
e99c :                       df_rt_print_str_ch
e99c : b1a1             [ 5] 	lda (df_tmpptra),y
e99e : f006             [ 3] 	beq df_rt_print_str_done
e9a0 : 2054c4           [ 6] 	jsr io_put_ch
e9a3 : c8               [ 2] 	iny
e9a4 : d0f6             [ 3] 	bne df_rt_print_str_ch		; Rely on y not wrapping
e9a6 :                       df_rt_print_str_done
e9a6 : 60               [ 6] 	rts
                             
                             ; * Find the position of the next data item to re
e9a7 :                       df_rt_nextdatum
e9a7 : a200             [ 2] 	ldx #0
                             	; load data line offset
e9a9 : a496             [ 3] 	ldy df_datoff
                             	; if data pointer unitialised (because high byte
e9ab : a595             [ 3] 	lda df_currdat+1
e9ad : d02e             [ 3] 	bne df_rt_skipinitdataptr
                             	; then start at program beginning
                             	_cpyZPWord df_prgstrt,df_currdat
                             
e9b7 :                       df_rt_datlinstart
                             	; if end of program then error
e9b7 : a194             [ 6] 	lda (df_currdat,x)
e9b9 : f032             [ 3] 	beq df_rt_datumerr
                             	; index in to first line byte
e9bb : a003             [ 2] 	ldy #3
e9bd : 8496             [ 3] 	sty df_datoff
                             	; find first 'data' statement
e9bf :                       df_rt_datastatement
e9bf : c8               [ 2] 	iny
e9c0 : 98               [ 2] 	tya
                             	; end of line reached?
e9c1 : c194             [ 6] 	cmp (df_currdat,x)
                             	; if not find data token
e9c3 : d00e             [ 3] 	bne df_rt_getdatatk
e9c5 :                       df_rt_datnextlin
                             	; if so then go to next line
e9c5 : 18               [ 2] 	clc
e9c6 : a594             [ 3] 	lda df_currdat
e9c8 : 6194             [ 6] 	adc (df_currdat,x)
e9ca : 8594             [ 3] 	sta df_currdat
                             	_bcc 2
                             
e9ce : e695             [ 5] 	inc df_currdat+1
e9d0 : 4cb7e9           [ 3] 	jmp df_rt_datlinstart
e9d3 :                       df_rt_getdatatk
e9d3 : b194             [ 5] 	lda (df_currdat),y
e9d5 : 10e8             [ 3] 	bpl df_rt_datastatement
                             	; found data statement?
e9d7 : c996             [ 2] 	cmp #DFRT_DATA
                             	; if not then go to next line
e9d9 : d0ea             [ 3] 	bne df_rt_datnextlin
e9db : 8496             [ 3] 	sty df_datoff
e9dd :                       df_rt_skipinitdataptr
e9dd : 98               [ 2] 	tya
                             	; end of line reached?
e9de : c194             [ 6] 	cmp (df_currdat,x)
                             	; if so go to next line
e9e0 : f0e3             [ 3] 	beq df_rt_datnextlin
                             	; else see if escape value
AS65 Assembler for R6502 [1.42].                                     Page  213
-------------------------------- bank\bank0.s --------------------------------

e9e2 : b194             [ 5] 	lda (df_currdat),y
e9e4 : c920             [ 2] 	cmp #DFTK_ESCVAL
e9e6 : c8               [ 2] 	iny
e9e7 : b0f4             [ 3] 	bcs df_rt_skipinitdataptr
                             	; ok found an escape value
                             	; save position and return
e9e9 : 88               [ 2] 	dey
e9ea : 8496             [ 3] 	sty df_datoff
e9ec : 60               [ 6] 	rts
e9ed :                       df_rt_datumerr
                             	SWBRK DFERR_NODATA
                             
                             
                             ; read a datum
e9ef :                       df_rt_readdatum
                             	; update data pointer to next data item
e9ef : 20a7e9           [ 6] 	jsr df_rt_nextdatum
                             	; now get lvar X,A from current statement
e9f2 : 20b8e4           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
e9f5 : 86a3             [ 3] 	stx df_tmpptrb
e9f7 : 85a4             [ 3] 	sta df_tmpptrb+1
                             
                             	; first save save current prgoram line and offse
e9f9 : a586             [ 3] 	lda df_currlin
e9fb : 48               [ 3] 	pha
e9fc : a587             [ 3] 	lda df_currlin+1
e9fe : 48               [ 3] 	pha
e9ff : a588             [ 3] 	lda df_exeoff
ea01 : 48               [ 3] 	pha
ea02 : a57e             [ 3] 	lda df_eolidx
ea04 : 48               [ 3] 	pha
ea05 : a57f             [ 3] 	lda df_nxtstidx
ea07 : 48               [ 3] 	pha
ea08 : a580             [ 3] 	lda df_curstidx
ea0a : 48               [ 3] 	pha
                             
                             	; use data pointer as current position for evalu
                             	_cpyZPWord df_currdat,df_currlin
                             
ea13 : a596             [ 3] 	lda df_datoff
ea15 : 8588             [ 3] 	sta df_exeoff
ea17 : a200             [ 2] 	ldx #0
ea19 : a194             [ 6] 	lda (df_currdat,x)
ea1b : 857e             [ 3] 	sta df_eolidx
ea1d : 857f             [ 3] 	sta df_nxtstidx
ea1f : a903             [ 2] 	lda #3
ea21 : 8580             [ 3] 	sta df_curstidx
                             
                             	; get type from vvt ptr in tmpa
ea23 : a1a1             [ 6] 	lda (df_tmpptra,x)
ea25 : a8               [ 2] 	tay
                             	; get lvar point from tmpb
ea26 : a6a3             [ 3] 	ldx df_tmpptrb
ea28 : a5a4             [ 3] 	lda df_tmpptrb+1
                             
                             	; X,A and Y set up, now evaluate and perform ass
ea2a : 20caec           [ 6] 	jsr df_rt_doassign
                             
                             	; update data offset as data has been consumed
ea2d : a588             [ 3] 	lda df_exeoff
ea2f : 8596             [ 3] 	sta df_datoff
AS65 Assembler for R6502 [1.42].                                     Page  214
-------------------------------- bank\bank0.s --------------------------------

                             	; restore line settings
ea31 : 68               [ 4] 	pla
ea32 : 8580             [ 3] 	sta df_curstidx
ea34 : 68               [ 4] 	pla
ea35 : 857f             [ 3] 	sta df_nxtstidx
ea37 : 68               [ 4] 	pla
ea38 : 857e             [ 3] 	sta df_eolidx
ea3a : 68               [ 4] 	pla
ea3b : 8588             [ 3] 	sta df_exeoff
ea3d : 68               [ 4] 	pla
ea3e : 8587             [ 3] 	sta df_currlin+1
ea40 : 68               [ 4] 	pla
ea41 : 8586             [ 3] 	sta df_currlin
ea43 : 60               [ 6] 	rts
                             
                             
ea44 :                       df_rt_read
                             	; find variable to read in to from current posit
ea44 : a488             [ 3] 	ldy df_exeoff
ea46 :                       df_rt_read_find_var
ea46 : c8               [ 2] 	iny
                             	; if end of line or statement then done
                             ;	cpy df_eolidx
                             ;	beq df_rt_read_done
ea47 : c47f             [ 3] 	cpy df_nxtstidx
ea49 : f00e             [ 3] 	beq df_rt_read_done
                             	; if not found escape then next byte
ea4b : b186             [ 5] 	lda (df_currlin),y
ea4d : c920             [ 2] 	cmp #DFTK_ESCVAL
ea4f : b0f5             [ 3] 	bcs df_rt_read_find_var
                             	; ok found escape, save position
ea51 : 8488             [ 3] 	sty df_exeoff
                             	; go and read in the value
ea53 : 20efe9           [ 6] 	jsr df_rt_readdatum
                             	; try find another variable
ea56 : 4c44ea           [ 3] 	jmp df_rt_read
                             
ea59 :                       df_rt_read_done
                             	; save position
ea59 : 8488             [ 3] 	sty df_exeoff
ea5b : 60               [ 6] 	rts
                             
ea5c :                       df_rt_input
                             	; df_tmpptra has the vvt address, X,A is the lva
ea5c : 20b8e4           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
ea5f : 86a3             [ 3] 	stx df_tmpptrb
ea61 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; go read a line of input
                             	; buf_lo ptr has the input, Y is size
ea63 : 38               [ 2] 	sec
ea64 : 2069c4           [ 6] 	jsr io_read_line
                             	; check the type
ea67 : a200             [ 2] 	ldx #0
ea69 : a1a1             [ 6] 	lda (df_tmpptra,x)
ea6b : 2904             [ 2] 	and #DFVVT_STR
ea6d : d008             [ 3] 	bne df_rt_input_str
ea6f : a1a1             [ 6] 	lda (df_tmpptra,x)
ea71 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
ea73 : d00a             [ 3] 	bne df_rt_input_num
                             	; if not int or byte then error
ea75 : f01f             [ 3] 	beq df_rt_input_err
AS65 Assembler for R6502 [1.42].                                     Page  215
-------------------------------- bank\bank0.s --------------------------------

ea77 :                       df_rt_input_str
ea77 : b139             [ 5] 	lda (buf_lo),y
ea79 : 91a3             [ 5] 	sta (df_tmpptrb),y
ea7b : 88               [ 2] 	dey
ea7c : 10f9             [ 3] 	bpl df_rt_input_str
ea7e : 60               [ 6] 	rts
                             
ea7f :                       df_rt_input_num
                             	; X,A = address, linbuff must be on page boundar
ea7f : a53a             [ 3] 	lda buf_lo+1
ea81 : a639             [ 3] 	ldx buf_lo
ea83 : a000             [ 2] 	ldy #0				; any numeric format
ea85 : 20e1c1           [ 6] 	jsr con_n_to_a
ea88 : b00c             [ 3] 	bcs df_rt_input_err
ea8a : a000             [ 2] 	ldy #0
ea8c : a53d             [ 3] 	lda num_a
ea8e : 91a3             [ 5] 	sta (df_tmpptrb),y
ea90 : c8               [ 2] 	iny
ea91 : a53e             [ 3] 	lda num_a+1
ea93 : 91a3             [ 5] 	sta (df_tmpptrb),y
ea95 : 60               [ 6] 	rts
ea96 :                       df_rt_input_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
ea98 :                       df_rt_local
                             	; get current local count off rt stack
ea98 : 2011f6           [ 6] 	jsr df_rst_popByte
                             	; save on pc stack for incrmenting
ea9b : 48               [ 3] 	pha
ea9c : a488             [ 3] 	ldy df_exeoff
ea9e : 88               [ 2] 	dey
ea9f :                       df_rt_local_findesc
ea9f : c8               [ 2] 	iny
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_local_done
eaa0 : c47f             [ 3] 	cpy df_nxtstidx
eaa2 : f01c             [ 3] 	beq df_rt_local_done
                             	; find a var
eaa4 : b186             [ 5] 	lda (df_currlin),y
eaa6 : c911             [ 2] 	cmp #DFTK_VAR
eaa8 : d0f5             [ 3] 	bne df_rt_local_findesc
                             	; jump over escape value
eaaa : c8               [ 2] 	iny
                             	; get var slot in A,X
eaab : b186             [ 5] 	lda (df_currlin),y
eaad : aa               [ 2] 	tax
eaae : c8               [ 2] 	iny
eaaf : b186             [ 5] 	lda (df_currlin),y
eab1 : 8488             [ 3] 	sty df_exeoff
                             	; localise this variable
eab3 : 20f4f5           [ 6] 	jsr df_rt_proc_local
                             	; increment local counter
eab6 : 68               [ 4] 	pla
eab7 : 18               [ 2] 	clc
eab8 : 6901             [ 2] 	adc #1
eaba : 48               [ 3] 	pha
eabb : a488             [ 3] 	ldy df_exeoff
eabd : 4c9fea           [ 3] 	jmp df_rt_local_findesc
eac0 :                       df_rt_local_done
                             	; get the local counter
AS65 Assembler for R6502 [1.42].                                     Page  216
-------------------------------- bank\bank0.s --------------------------------

                             	; put on to rt stack
eac0 : 68               [ 4] 	pla
eac1 : 4c08f6           [ 3] 	jmp df_rst_pushByte
                             
                             
eac4 :                       df_rt_dim
eac4 : a488             [ 3] 	ldy df_exeoff
eac6 : 88               [ 2] 	dey
eac7 :                       df_rt_dim_findesc
                             	; check end of line
eac7 : c8               [ 2] 	iny
                             ;	cpy df_eolidx
                             ;	beq df_rt_dim_done
eac8 : c47f             [ 3] 	cpy df_nxtstidx
eaca : f07a             [ 4] 	beq df_rt_dim_done
                             	; find a var
eacc : b186             [ 5] 	lda (df_currlin),y
eace : c911             [ 2] 	cmp #DFTK_VAR
ead0 : d0f5             [ 3] 	bne df_rt_dim_findesc
                             	; jump over escape value
ead2 : c8               [ 2] 	iny
                             	; get var address
ead3 : b186             [ 5] 	lda (df_currlin),y
ead5 : 85a1             [ 3] 	sta df_tmpptra
ead7 : c8               [ 2] 	iny
ead8 : b186             [ 5] 	lda (df_currlin),y
eada : 85a2             [ 3] 	sta df_tmpptra+1
                             	; move to open bracket
eadc : c8               [ 2] 	iny
eadd : 8488             [ 3] 	sty df_exeoff
                             	; check if already dim'd
eadf : a003             [ 2] 	ldy #DFVVT_DIM1
eae1 : b1a1             [ 5] 	lda (df_tmpptra),y
eae3 : d062             [ 4] 	bne df_rt_dim_err
                             	; Save slot address found earlier
eae5 : a5a1             [ 3] 	lda df_tmpptra
eae7 : 48               [ 3] 	pha
eae8 : a5a2             [ 3] 	lda df_tmpptra+1
eaea : 48               [ 3] 	pha
eaeb : 20f7e1           [ 6] 	jsr df_rt_arry_parm2
                             	; Restore slot address
eaee : 68               [ 4] 	pla
eaef : 85a2             [ 3] 	sta df_tmpptra+1
eaf1 : 68               [ 4] 	pla
eaf2 : 85a1             [ 3] 	sta df_tmpptra
                             ;	bcs df_rt_dim_err
                             	; save x,y to dim1,2
eaf4 : 98               [ 2] 	tya
eaf5 : 48               [ 3] 	pha
eaf6 : 8a               [ 2] 	txa
eaf7 : 48               [ 3] 	pha
eaf8 : a003             [ 2] 	ldy #DFVVT_DIM1
eafa : 68               [ 4] 	pla
eafb : 91a1             [ 5] 	sta (df_tmpptra),y
eafd : c8               [ 2] 	iny
eafe : 68               [ 4] 	pla
eaff : 91a1             [ 5] 	sta (df_tmpptra),y
eb01 :                       df_rt_dim_alloc
                             	; ok we have up to 2 dimensions
                             	; mult dim 1 and 2 if dim 2 <> 0
eb01 : a003             [ 2] 	ldy #DFVVT_DIM1
eb03 : b1a1             [ 5] 	lda (df_tmpptra),y
AS65 Assembler for R6502 [1.42].                                     Page  217
-------------------------------- bank\bank0.s --------------------------------

eb05 : 853d             [ 3] 	sta num_a
eb07 : a900             [ 2] 	lda #0
eb09 : 853e             [ 3] 	sta num_a+1
eb0b : c8               [ 2] 	iny
eb0c : b1a1             [ 5] 	lda (df_tmpptra),y
eb0e : d002             [ 3] 	bne df_rt_dim2_nz
eb10 : a901             [ 2] 	lda #1
eb12 :                       df_rt_dim2_nz
eb12 : 8541             [ 3] 	sta num_b
eb14 : a900             [ 2] 	lda #0
eb16 : 8542             [ 3] 	sta num_b+1
eb18 : 2064d4           [ 6] 	jsr int_fast_mult
                             	; check the type if int then mult2
eb1b : a200             [ 2] 	ldx #0
eb1d : a1a1             [ 6] 	lda (df_tmpptra,x)
eb1f : 2901             [ 2] 	and #DFVVT_INT
eb21 : f004             [ 3] 	beq df_rt_dim2_mul2
eb23 : 063d             [ 5] 	asl num_a
eb25 : 263e             [ 5] 	rol num_a+1
eb27 :                       df_rt_dim2_mul2
                             	; finally, we have a size of array
eb27 : a63d             [ 3] 	ldx num_a
eb29 : a53e             [ 3] 	lda num_a+1
                             
                             	; get a block of that size from heap
eb2b : 208df6           [ 6] 	jsr df_st_malloc
                             	; save pointer to block in var
eb2e : a002             [ 2] 	ldy #DFVVT_HI
eb30 : 91a1             [ 5] 	sta (df_tmpptra),y
eb32 : 8a               [ 2] 	txa
eb33 : 88               [ 2] 	dey
eb34 : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; finally, update the type to indicate array
eb36 : a200             [ 2] 	ldx #0
eb38 : a1a1             [ 6] 	lda (df_tmpptra,x)
eb3a : 0980             [ 2] 	ora #DFVVT_ARRY
eb3c : 81a1             [ 6] 	sta (df_tmpptra,x)
                             	; don't increment byte again - go check for more
eb3e : 4cc4ea           [ 3] 	jmp df_rt_dim
eb41 :                       df_rt_dim_next_byte
eb41 : e688             [ 5] 	inc df_exeoff
eb43 : 4cc4ea           [ 3] 	jmp df_rt_dim
eb46 :                       df_rt_dim_done
eb46 : 60               [ 6] 	rts
eb47 :                       df_rt_dim_err
                             	SWBRK DFERR_DIM
                             
                             
                             
eb49 :                       df_rt_cls
eb49 : 4c97cd           [ 3] 	jmp gr_cls
                             
                             
eb4c :                       df_rt_plot
                             	; evaluate the expression
eb4c : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
eb4f : 8a               [ 2] 	txa
eb50 : 48               [ 3] 	pha
                             	; jump over comma
eb51 : e688             [ 5] 	inc df_exeoff
                             	; evaluate the expression
AS65 Assembler for R6502 [1.42].                                     Page  218
-------------------------------- bank\bank0.s --------------------------------

eb53 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
eb56 : 8a               [ 2] 	txa
eb57 : 48               [ 3] 	pha
                             	; jump over comma
eb58 : e688             [ 5] 	inc df_exeoff
                             	; evaluate the expression
eb5a : 2077e0           [ 6] 	jsr df_rt_neval
                             	; check the type on the stack
eb5d : 207bf6           [ 6] 	jsr df_ost_peekType
                             	; if >=0x80 then a pointer / string
eb60 : aa               [ 2] 	tax
eb61 : 301b             [ 3] 	bmi df_rt_plotstr
                             	; else it is int
eb63 : 2081f6           [ 6] 	jsr df_ost_popInt
                             	; save  low byte of pop result in a temp
eb66 : 86a1             [ 3] 	stx df_tmpptra
eb68 : a511             [ 3] 	lda gr_scrngeom+gr_mode			; Check screen mode
eb6a : d009             [ 3] 	bne df_rt_plot_h_int
                             	; get X and Y coord in that order
                             	; but Y coord goes in X register!!!
eb6c : 68               [ 4] 	pla
eb6d : aa               [ 2] 	tax
eb6e : 68               [ 4] 	pla
eb6f : a8               [ 2] 	tay
eb70 : a5a1             [ 3] 	lda df_tmpptra	; Get pop result in to A
eb72 : 4cebcd           [ 3] 	jmp gr_plot
eb75 :                       df_rt_plot_h_int
eb75 : 68               [ 4] 	pla
eb76 : a8               [ 2] 	tay
eb77 : 68               [ 4] 	pla
eb78 : aa               [ 2] 	tax
eb79 : a5a1             [ 3] 	lda df_tmpptra	; Get pop result in to A
eb7b : 4caacf           [ 3] 	jmp gr_hchar
                             
                             
eb7e :                       df_rt_plotstr
                             	; pop string pointer
eb7e : 2089f6           [ 6] 	jsr df_ost_popPtr
                             	; save pointer to tmpa
eb81 : 86a1             [ 3] 	stx df_tmpptra
eb83 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; get y and x in that order
                             	; but X register is Y coord!!
eb85 : 68               [ 4] 	pla
eb86 : 85a5             [ 3] 	sta df_tmpptrc			; Y coord in C
eb88 : 68               [ 4] 	pla
eb89 : 85a3             [ 3] 	sta df_tmpptrb			; X coord in B
                             	; set cursror position
eb8b : a000             [ 2] 	ldy #0
eb8d : 84a9             [ 3] 	sty df_tmpptre
eb8f :                       df_rt_plotstrch
eb8f : a4a9             [ 3] 	ldy df_tmpptre
eb91 : b1a1             [ 5] 	lda (df_tmpptra),y
eb93 : 85a7             [ 3] 	sta df_tmpptrd			; char in D
eb95 : f025             [ 3] 	beq df_rt_plotstrdone
eb97 : e6a9             [ 5] 	inc df_tmpptre
eb99 : a511             [ 3] 	lda gr_scrngeom+gr_mode; Check screen mode
eb9b : d00d             [ 3] 	bne df_rt_plot_h_str
eb9d : a5a7             [ 3] 	lda df_tmpptrd			; Get char to plot
eb9f : a6a5             [ 3] 	ldx df_tmpptrc			; Get Y coord
eba1 : a4a3             [ 3] 	ldy df_tmpptrb			; Get X coord
AS65 Assembler for R6502 [1.42].                                     Page  219
-------------------------------- bank\bank0.s --------------------------------

eba3 : 20ebcd           [ 6] 	jsr gr_plot
eba6 : e6a3             [ 5] 	inc df_tmpptrb			; Increment X coord
eba8 : d0e5             [ 3] 	bne df_rt_plotstrch		; Always - assume x is neve
ebaa :                       df_rt_plot_h_str
ebaa : a5a7             [ 3] 	lda df_tmpptrd			; Get char to plot
ebac : a6a3             [ 3] 	ldx df_tmpptrb			; Get X coord
ebae : a4a5             [ 3] 	ldy df_tmpptrc			; Get Y coord
ebb0 : 20aacf           [ 6] 	jsr gr_hchar
ebb3 : 18               [ 2] 	clc
ebb4 : a5a3             [ 3] 	lda df_tmpptrb
ebb6 : 6520             [ 3] 	adc gr_scrngeom+gr_pitch
ebb8 : 85a3             [ 3] 	sta df_tmpptrb
ebba : d0d3             [ 3] 	bne df_rt_plotstrch		; Always - assume adding pi
ebbc :                       df_rt_plotstrdone
ebbc : 60               [ 6] 	rts
                             
ebbd :                       df_rt_cursor
                             	; evaluate the expression
ebbd : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; write low byte of vdp_curoff
                             	; by writing a zero then cursor on else not
ebc0 : 860d             [ 3] 	stx vdp_curoff
ebc2 : 60               [ 6] 	rts
                             
ebc3 :                       df_rt_himem
                             	; evaluate the expression
ebc3 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; write X,A to df_memtop
ebc6 : 8e1106           [ 4] 	stx df_memtop
ebc9 : 8d1206           [ 4] 	sta df_memtop+1
                             	; now clear everything down
ebcc : 4cb2f6           [ 3] 	jmp df_clear
                             
ebcf :                       df_rt_text
ebcf : 4c01cd           [ 3] 	jmp gr_init_screen_txt
                             
ebd2 :                       df_rt_hires
ebd2 : 4c1acd           [ 3] 	jmp gr_init_hires
                             
ebd5 :                       df_rt_pixmode
                             	; evaluate the expression X = mode
ebd5 : 2071e0           [ 6] 	jsr df_rt_getnval
ebd8 : 861f             [ 3] 	stx gr_scrngeom+gr_pixmode
ebda : 60               [ 6] 	rts
                             
ebdb :                       df_rt_ink
                             	; evaluate the expression X = col
ebdb : 2071e0           [ 6] 	jsr df_rt_getnval
ebde : 8623             [ 3] 	stx gr_scrngeom+gr_ink
ebe0 : 60               [ 6] 	rts
                             
ebe1 :                       df_rt_paper
                             	; evaluate the expression X = col
ebe1 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; Add 16 to get paper colour
ebe4 : 8a               [ 2] 	txa
ebe5 : 18               [ 2] 	clc
ebe6 : 6910             [ 2] 	adc #16
ebe8 : 8524             [ 3] 	sta gr_scrngeom+gr_paper
ebea : 60               [ 6] 	rts
                             
ebeb :                       df_rt_point
AS65 Assembler for R6502 [1.42].                                     Page  220
-------------------------------- bank\bank0.s --------------------------------

ebeb : 203be3           [ 6] 	jsr df_rt_parm_2ints
ebee : a6a1             [ 3] 	ldx df_tmpptra
ebf0 : a4a3             [ 3] 	ldy df_tmpptrb
ebf2 : 4c6ad0           [ 3] 	jmp gr_point
                             
ebf5 :                       df_rt_circle
ebf5 : 2046e3           [ 6] 	jsr df_rt_parm_3ints
ebf8 : a5a1             [ 3] 	lda df_tmpptra				; load x0
ebfa : 853d             [ 3] 	sta num_a
ebfc : a5a3             [ 3] 	lda	df_tmpptrb				; load y0
ebfe : 853e             [ 3] 	sta num_a+1
ec00 : a5a5             [ 3] 	lda df_tmpptrc				; load r
ec02 : 853f             [ 3] 	sta num_a+2
ec04 : 4c9bd0           [ 3] 	jmp gr_circle
                             
ec07 :                       df_rt_lineto
ec07 : 203be3           [ 6] 	jsr df_rt_parm_2ints
ec0a : a6a1             [ 3] 	ldx df_tmpptra				; load x1
ec0c : a4a3             [ 3] 	ldy df_tmpptrb				; load y1
ec0e :                       df_rt_doline
ec0e : 863f             [ 3] 	stx num_a+2
ec10 : 8440             [ 3] 	sty num_a+3
ec12 : 4c51d1           [ 3] 	jmp gr_line
ec15 :                       df_rt_line
ec15 : 205de3           [ 6] 	jsr df_rt_parm_4ints
ec18 : a6a1             [ 3] 	ldx df_tmpptra				; load x0
ec1a : a4a3             [ 3] 	ldy	df_tmpptrb				; load y0
ec1c : 205fd0           [ 6] 	jsr gr_set_hires_cur		; Start from x,y
ec1f : a6a5             [ 3] 	ldx df_tmpptrc				; load x1
ec21 : a4a7             [ 3] 	ldy df_tmpptrd				; load y1
ec23 : 4c0eec           [ 3] 	jmp df_rt_doline
                             
ec26 :                       df_rt_wait
                             	; evaluate the expression
ec26 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; put high byte in to Y (X,Y)=16 bits
ec29 : a8               [ 2] 	tay
                             ;	bne df_rt_wait_counter
                             	; If A=X=0 then don't try to wait
                             ;	txa
                             ;	beq df_rt_wait_done
ec2a :                       df_rt_wait_counter
                             	; get vdp low byte timer val in A
ec2a : a508             [ 3] 	lda vdp_cnt
ec2c :                       df_rt_wait_tick
                             	; check if a tick has occurred (i.e. val <> A)
ec2c : c508             [ 3] 	cmp vdp_cnt
ec2e : f0fc             [ 3] 	beq df_rt_wait_tick
                             	; countdown tick
ec30 : 8a               [ 2] 	txa
ec31 : d001             [ 3] 	bne df_rt_wait_skiphi
ec33 : 88               [ 2] 	dey
ec34 :                       df_rt_wait_skiphi	
ec34 : ca               [ 2] 	dex
ec35 : 8a               [ 2] 	txa
ec36 : d0f2             [ 3] 	bne df_rt_wait_counter
ec38 : 98               [ 2] 	tya
ec39 : d0ef             [ 3] 	bne df_rt_wait_counter
ec3b :                       df_rt_wait_done
ec3b : 60               [ 6] 	rts
                             
ec3c :                       df_rt_printat
AS65 Assembler for R6502 [1.42].                                     Page  221
-------------------------------- bank\bank0.s --------------------------------

                             	; Get x,y
ec3c : 203be3           [ 6] 	jsr df_rt_parm_2ints
ec3f : a6a1             [ 3] 	ldx df_tmpptra
ec41 : a4a3             [ 3] 	ldy df_tmpptrb
                             	; Set the cursror here
ec43 : 2004ce           [ 6] 	jsr gr_set_cur
                             	; and continue to normal print command
ec46 :                       df_rt_print
ec46 : a488             [ 3] 	ldy df_exeoff
ec48 : 88               [ 2] 	dey
ec49 :                       df_rt_print_ws
ec49 : c8               [ 2] 	iny
                             
                             	; evaluate an expression
                             ;	cpy df_eolidx
                             ;	beq df_rt_print_done
ec4a : c47f             [ 3] 	cpy df_nxtstidx
ec4c : f02e             [ 3] 	beq df_rt_print_done
ec4e : b186             [ 5] 	lda (df_currlin),y
ec50 : c93a             [ 2] 	cmp #':'
ec52 : f028             [ 3] 	beq df_rt_print_done
ec54 : c920             [ 2] 	cmp #' '
ec56 : f0f1             [ 3] 	beq df_rt_print_ws
ec58 : c92c             [ 2] 	cmp #','
ec5a : f0ed             [ 3] 	beq df_rt_print_ws
                             	; save index
ec5c : 8488             [ 3] 	sty df_exeoff
                             
                             	; if starts with string literal then process sev
ec5e : c910             [ 2] 	cmp #DFTK_STRLIT
ec60 : f014             [ 3] 	beq df_rt_print_string
                             	; else evaluate a numeric
ec62 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; check what is on the argument stack
ec65 : 207bf6           [ 6] 	jsr df_ost_peekType
ec68 : 3006             [ 3] 	bmi df_rt_print_gotstr
ec6a : 208ce9           [ 6] 	jsr df_rt_print_num
ec6d : 4c46ec           [ 3] 	jmp df_rt_print
ec70 :                       df_rt_print_gotstr
ec70 : 2093e9           [ 6] 	jsr df_rt_print_str
ec73 : 4c46ec           [ 3] 	jmp df_rt_print
ec76 :                       df_rt_print_string
ec76 : 2031e1           [ 6] 	jsr df_rt_seval
ec79 : 4c70ec           [ 3] 	jmp df_rt_print_gotstr
ec7c :                       df_rt_print_done
ec7c : 8488             [ 3] 	sty df_exeoff
ec7e : 60               [ 6] 	rts
                             
ec7f :                       df_rt_println
ec7f : 2046ec           [ 6] 	jsr df_rt_print
ec82 : a90d             [ 2] 	lda #UTF_CR
ec84 : 4c54c4           [ 3] 	jmp io_put_ch
                             
                             
                             ; assign to a number variable
                             ; X,A must have lvar
ec87 :                       df_rt_nassign
                             	; push var address, A ok to trample
ec87 : 48               [ 3] 	pha
ec88 : 8a               [ 2] 	txa
ec89 : 48               [ 3] 	pha
                             
AS65 Assembler for R6502 [1.42].                                     Page  222
-------------------------------- bank\bank0.s --------------------------------

                             	; now go evaluate expression in to A,X
ec8a : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; restore variable address to write to to df_tmp
                             	; but don't lose current A
ec8d : a8               [ 2] 	tay					; Save A in Y
ec8e : 68               [ 4] 	pla
ec8f : 85a1             [ 3] 	sta df_tmpptra
ec91 : 68               [ 4] 	pla
ec92 : 85a2             [ 3] 	sta df_tmpptra+1
ec94 : 98               [ 2] 	tya					; Get A back from Y
                             
                             	; save X,A int in contents section
ec95 : a001             [ 2] 	ldy #1
ec97 : 91a1             [ 5] 	sta (df_tmpptra),y
ec99 : 8a               [ 2] 	txa
ec9a : 88               [ 2] 	dey
ec9b : 91a1             [ 5] 	sta (df_tmpptra),y
                             
ec9d : 60               [ 6] 	rts
                             
                             ; assign to a string variable
                             ; X,A must have lvar
ec9e :                       df_rt_sassign
                             	; now go evaluate expression
                             	; with the destination being already in X,A
ec9e : 2035e1           [ 6] 	jsr df_rt_sval
                             
                             	; get string pointer from top of runtime stack
eca1 : 4c85f6           [ 3] 	jmp df_ost_popStr
                             
                             
                             ; generate lvar from a var token ready for assign
eca4 :                       df_rt_generate_lvar
                             	; move past escape val
eca4 : a488             [ 3] 	ldy df_exeoff
eca6 : c8               [ 2] 	iny
                             	; pointing to variable index
eca7 : b186             [ 5] 	lda (df_currlin),y
eca9 : 85a1             [ 3] 	sta df_tmpptra
ecab : c8               [ 2] 	iny
ecac : b186             [ 5] 	lda (df_currlin),y
ecae : 8488             [ 3] 	sty df_exeoff
ecb0 : 85a2             [ 3] 	sta df_tmpptra+1
                             
                             	; get the type and save
ecb2 : a200             [ 2] 	ldx #0
ecb4 : a1a1             [ 6] 	lda (df_tmpptra,x)
ecb6 : 48               [ 3] 	pha
                             
                             	; set carry flag to return pointer (lvar)
ecb7 : 38               [ 2] 	sec
ecb8 : 201be2           [ 6] 	jsr df_rt_eval_var
ecbb : 2089f6           [ 6] 	jsr df_ost_popPtr
                             
                             	; pull the type previously saved into Y
ecbe : 8538             [ 3] 	sta tmp_d		; Save A
ecc0 : 68               [ 4] 	pla
ecc1 : a8               [ 2] 	tay
ecc2 : a538             [ 3] 	lda tmp_d
                             	; move past the lvar variable index
ecc4 : e688             [ 5] 	inc df_exeoff
ecc6 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  223
-------------------------------- bank\bank0.s --------------------------------

                             
                             ; general assignment execution
                             ; generate lvar first
ecc7 :                       df_rt_assign
ecc7 : 20a4ec           [ 6] 	jsr df_rt_generate_lvar
                             ; X,A,Y contain lvar pointer and type
ecca :                       df_rt_doassign
                             	; save A and put type Y in to A to check for str
ecca : 48               [ 3] 	pha
eccb : 98               [ 2] 	tya
eccc : 2904             [ 2] 	and #DFVVT_STR
                             	; if a string then string expression
ecce : d004             [ 3] 	bne df_rt_assign_str
                             	;  jump to numeric expression evaluator
                             	; remember to restore A
ecd0 : 68               [ 4] 	pla
ecd1 : 4c87ec           [ 3] 	jmp df_rt_nassign
ecd4 :                       df_rt_assign_str
                             	; else jump to string expression evaluator
                             	; remember to restore A
ecd4 : 68               [ 4] 	pla
ecd5 : 4c9eec           [ 3] 	jmp df_rt_sassign
                             
                             ; comment or data token is ignored by runtime
ecd8 :                       df_rt_comment
ecd8 :                       df_rt_data
ecd8 : 60               [ 6] 	rts
                             
                             
                             ; run token - future expansion
ecd9 :                       df_rt_run
ecd9 : 60               [ 6] 	rts
                             
                             ; end of line / statement indicator
                             ; CS = End, CC = not end
ecda :                       df_rt_eos
ecda : a488             [ 3] 	ldy df_exeoff
                             ;	cpy df_eolidx
                             ;	beq df_rt_eos_true
ecdc : c47f             [ 3] 	cpy df_nxtstidx
ecde : f008             [ 3] 	beq df_rt_eos_true
ece0 : b186             [ 5] 	lda (df_currlin),y
ece2 : c93a             [ 2] 	cmp #':'
ece4 : f002             [ 3] 	beq df_rt_eos_true
ece6 : 18               [ 2] 	clc
ece7 : 60               [ 6] 	rts
ece8 :                       df_rt_eos_true
ece8 : 38               [ 2] 	sec
ece9 : 60               [ 6] 	rts
                             
                             ; renum startLine,newStart,increment
                             ; renumbers from the first matching line to end o
ecea :                       df_rt_renum
ecea : e688             [ 5] 	inc df_exeoff
ecec : 2046e3           [ 6] 	jsr df_rt_parm_3ints
                             	; starting line number
ecef : a6a1             [ 3] 	ldx df_tmpptra
ecf1 : a5a2             [ 3] 	lda df_tmpptra+1
ecf3 : 2092de           [ 6] 	jsr df_pg_find_line
ecf6 : 9002             [ 3] 	bcc df_rt_renum_ok
                             	SWBRK DFERR_NOLINE
                             
AS65 Assembler for R6502 [1.42].                                     Page  224
-------------------------------- bank\bank0.s --------------------------------

ecfa :                       df_rt_renum_ok
                             	; save starting position pointer in ptrd
ecfa : 86a7             [ 3] 	stx df_tmpptrd
ecfc : 85a8             [ 3] 	sta df_tmpptrd+1
ecfe :                       df_rt_renum_do
                             	; if not end of program
ecfe : a000             [ 2] 	ldy #0
ed00 : b1a7             [ 5] 	lda (df_tmpptrd),y
                             	; then renumber this line
ed02 : d001             [ 3] 	bne df_rt_renum_update
                             	; else done
ed04 : 60               [ 6] 	rts
ed05 :                       df_rt_renum_update
                             	; so set this line number to new line number
ed05 : a001             [ 2] 	ldy #DFTK_LINNUM
ed07 : a5a3             [ 3] 	lda df_tmpptrb
ed09 : 91a7             [ 5] 	sta (df_tmpptrd),y
ed0b : c8               [ 2] 	iny
ed0c : a5a4             [ 3] 	lda df_tmpptrb+1
ed0e : 91a7             [ 5] 	sta (df_tmpptrd),y
                             	; add increment to new line
                             	_addZPWord df_tmpptrb,df_tmpptrc
                             
ed1d :                       df_rt_renum_next
                             	; point ptrd to the next line
ed1d : 18               [ 2] 	clc
ed1e : a5a7             [ 3] 	lda df_tmpptrd
ed20 : a200             [ 2] 	ldx #0
ed22 : 61a7             [ 6] 	adc (df_tmpptrd,x)
ed24 : 85a7             [ 3] 	sta df_tmpptrd
                             	_bcc 2
                             
ed28 : e6a8             [ 5] 	inc df_tmpptrd+1
ed2a : 4cfeec           [ 3] 	jmp df_rt_renum_do
                             
                             
                             ; * List all procs in VNT
ed2d :                       df_rt_listprocnames
                             	; start at the beginning of the vnt table
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	; start at varcnt
ed35 : a571             [ 3] 	lda df_varcnt
ed37 : 85a3             [ 3] 	sta df_tmpptrb
ed39 :                       df_rt_listcheckvnt
                             	; If reached 0 then not found
ed39 : a5a3             [ 3] 	lda df_tmpptrb
ed3b : f03a             [ 3] 	beq df_rt_listpn_done
ed3d : a000             [ 2] 	ldy #0
ed3f : b1a1             [ 5] 	lda (df_tmpptra),y
ed41 : c95f             [ 2] 	cmp #'_'
ed43 : d01b             [ 3] 	bne df_rt_listnextvnt
ed45 :                       df_rt_listprocch
ed45 : b1a1             [ 5] 	lda (df_tmpptra),y
ed47 : 2054c4           [ 6] 	jsr io_put_ch
ed4a : aa               [ 2] 	tax
ed4b : f003             [ 3] 	beq df_rt_listproccr
ed4d : c8               [ 2] 	iny
ed4e : d0f5             [ 3] 	bne df_rt_listprocch		; Always
ed50 :                       df_rt_listproccr
ed50 : a90d             [ 2] 	lda #UTF_CR
ed52 : 2054c4           [ 6] 	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page  225
-------------------------------- bank\bank0.s --------------------------------

ed55 : 18               [ 2] 	clc
ed56 :                       df_rt_listprocpause
ed56 : 2051c4           [ 6] 	jsr io_get_ch
ed59 : c920             [ 2] 	cmp #' '
ed5b : d003             [ 3] 	bne df_rt_listnextvnt
ed5d :                       df_rt_listwait
ed5d : 38               [ 2] 	sec
ed5e : b0f6             [ 3] 	bcs df_rt_listprocpause
ed60 :                       df_rt_listnextvnt
ed60 : b1a1             [ 5] 	lda (df_tmpptra),y
ed62 : f003             [ 3] 	beq df_rt_listgotnext
ed64 : c8               [ 2] 	iny
ed65 : d0f9             [ 3] 	bne df_rt_listnextvnt		; Always
ed67 :                       df_rt_listgotnext
                             	; dec vnt #
ed67 : c6a3             [ 5] 	dec df_tmpptrb
                             	; skip past zero terminator
ed69 : c8               [ 2] 	iny
                             	; add this to vnt pointer
ed6a : 18               [ 2] 	clc
ed6b : 98               [ 2] 	tya
ed6c : 65a1             [ 3] 	adc df_tmpptra
ed6e : 85a1             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
ed72 : e6a2             [ 5] 	inc df_tmpptra+1
ed74 : 4c39ed           [ 3] 	jmp df_rt_listcheckvnt
ed77 :                       df_rt_listpn_done
ed77 : 60               [ 6] 	rts
                             
ed78 :                       df_rt_listproc
                             	; A already contains '_'
ed78 : 8d0004           [ 4] 	sta df_linbuff
ed7b : a200             [ 2] 	ldx #0
ed7d : a488             [ 3] 	ldy df_exeoff
ed7f :                       df_rt_listp_copy
ed7f : c8               [ 2] 	iny
ed80 : e8               [ 2] 	inx
ed81 : b186             [ 5] 	lda (df_currlin),y
ed83 : 9d0004           [ 5] 	sta df_linbuff,x
ed86 : 20fcd6           [ 6] 	jsr df_tk_isalphanum
ed89 : b0f4             [ 3] 	bcs df_rt_listp_copy
                             	; zero the line index
ed8b : a200             [ 2] 	ldx #0
ed8d : 867c             [ 3] 	stx df_linoff
                             	; save runtime pos
ed8f : 8488             [ 3] 	sty df_exeoff
                             	; Now try and find in VNT
ed91 : 201bd5           [ 6] 	jsr df_var_find
ed94 : b036             [ 3] 	bcs df_rt_listp_notfound
                             	; Ok we have got a match in X,A find the proc
ed96 : 868e             [ 3] 	stx df_procptr
ed98 : 858f             [ 3] 	sta df_procptr+1
ed9a : 2056e4           [ 6] 	jsr df_rt_findproc
                             	; Save the line pointer
ed9d : 86a1             [ 3] 	stx df_tmpptra
ed9f : 85a2             [ 3] 	sta df_tmpptra+1
                             	; save statement index in to line
                             ;	sty df_lineidx
                             ;	; Check if '-' option used
                             ;	ldy df_exeoff
                             ;	lda (df_currlin),y
AS65 Assembler for R6502 [1.42].                                     Page  226
-------------------------------- bank\bank0.s --------------------------------

                             ;	cmp #'-'
                             ;	; if so, list to end of program
                             ;	beq df_rt_listprgend
                             	; Now try and find the end of this procedure
                             	; enddef or another def
                             	; A,X=Line ptr, Y=line idx
                             ;	ldx df_tmpptra
                             ;	lda df_tmpptra+1
                             ;	ldy df_lineidx
eda1 :                       df_rt_listp_findend
                             	; Go to next stat
eda1 : 2001e4           [ 6] 	jsr df_rt_nextstat
eda4 : b057             [ 3] 	bcs df_rt_listprgend
                             	; save y (a,x in lineptr), A is ok to trample
eda6 : 98               [ 2] 	tya
eda7 : 48               [ 3] 	pha
                             	; find the command
eda8 :                       df_rt_listp_findcmd
eda8 : c8               [ 2] 	iny
eda9 : b190             [ 5] 	lda (df_lineptr),y
edab : 10fb             [ 3] 	bpl df_rt_listp_findcmd
                             	; restore y to stat beginning
edad : 8538             [ 3] 	sta tmp_d
edaf : 68               [ 4] 	pla
edb0 : a8               [ 2] 	tay
edb1 : a538             [ 3] 	lda tmp_d
                             	; check A - looking for enddef or def
edb3 : c987             [ 2] 	cmp #DFRT_ENDDEF
edb5 : f00b             [ 3] 	beq df_rt_listp_done
edb7 : c986             [ 2] 	cmp #DFRT_DEF
edb9 : f007             [ 3] 	beq df_rt_listp_done
                             	; if neither then next stat from current
edbb : a690             [ 3] 	ldx df_lineptr
edbd : a591             [ 3] 	lda df_lineptr+1
edbf : 4ca1ed           [ 3] 	jmp df_rt_listp_findend
edc2 :                       df_rt_listp_done
                             	; Push end line on to stack
edc2 : a591             [ 3] 	lda df_lineptr+1
edc4 : 48               [ 3] 	pha
edc5 : 8a               [ 2] 	txa
edc6 : 48               [ 3] 	pha
edc7 : a591             [ 3] 	lda df_lineptr+1
edc9 : 4c03ee           [ 3] 	jmp df_rt_list_line
edcc :                       df_rt_listp_notfound
                             	; Fatal error if proc not found
                             	SWBRK DFERR_NOPROC
                             
                             
                             ; list token
edce :                       df_rt_list
edce : a900             [ 2] 	lda #0
edd0 : 85a9             [ 3] 	sta df_tmpptre		; Zero means in normal list mode
                             	; find non-ws
edd2 : 20abe4           [ 6] 	jsr df_rt_skip_ws
                             	; if end of statement then no line specifiers
edd5 : 20daec           [ 6] 	jsr df_rt_eos
                             	; so list whole program
edd8 : b01b             [ 3] 	bcs df_rt_listprg
                             
                             	;if '_' then use procnames
edda : c95f             [ 2] 	cmp #'_'
eddc : d003             [ 3] 	bne df_rt_list_all
AS65 Assembler for R6502 [1.42].                                     Page  227
-------------------------------- bank\bank0.s --------------------------------

edde : 4c78ed           [ 3] 	jmp df_rt_listproc
ede1 :                       df_rt_list_all
                             	;if '*' then display all procnames
ede1 : c92a             [ 2] 	cmp #'*'
ede3 : d003             [ 3] 	bne df_rt_list_linno
ede5 : 4c2ded           [ 3] 	jmp df_rt_listprocnames
ede8 :                       df_rt_list_linno
                             	; else get 1st parameter
ede8 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
edeb : 2092de           [ 6] 	jsr df_pg_find_line
                             	; save start in ptra
edee : 86a1             [ 3] 	stx df_tmpptra
edf0 : 85a2             [ 3] 	sta df_tmpptra+1
edf2 : 4cfded           [ 3] 	jmp df_rt_listprgend
                             	; NO ability to choose and ending line number!
                             
                             ; Common listing routine used by LIST and SAVE
                             ; tmpe = 0 means in LIST mode else SAVE mode
                             ; can stop the listing in LIST mode with CTRL-C
edf5 :                       df_rt_listprg
                             	; program start and end as for pointer value
                             	_cpyZPWord df_prgstrt, df_tmpptra
                             
edfd :                       df_rt_listprgend
edfd : a568             [ 3] 	lda df_prgend+1
edff : 48               [ 3] 	pha
ee00 : a567             [ 3] 	lda df_prgend
ee02 : 48               [ 3] 	pha
ee03 :                       df_rt_list_line
                             	; if line length = 0 then end of program
ee03 : a000             [ 2] 	ldy #0
ee05 : b1a1             [ 5] 	lda (df_tmpptra),y
ee07 : f038             [ 3] 	beq df_rt_list_line_fin
                             	; if in list mode and CTRL-C then also stop
ee09 : a5a9             [ 3] 	lda df_tmpptre
ee0b : d010             [ 3] 	bne df_rt_list_line_cont
                             	; check for break, asynch get
ee0d : 18               [ 2] 	clc
ee0e :                       df_rt_list_synckey
ee0e : a5a9             [ 3] 	lda df_tmpptre					; Ignore keys on save mode
ee10 : d00b             [ 3] 	bne df_rt_list_line_cont
ee12 :                       df_rt_list_pause
ee12 : 2051c4           [ 6] 	jsr io_get_ch
ee15 : c920             [ 2] 	cmp #' '						; Space = PAUSE
ee17 : f0f9             [ 3] 	beq df_rt_list_pause			; C=1 for synchronouse ke
ee19 : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
ee1b : f024             [ 3] 	beq df_rt_list_line_fin
ee1d :                       df_rt_list_line_cont
ee1d : a000             [ 2] 	ldy #0
ee1f : 847c             [ 3] 	sty df_linoff
ee21 : 2044ee           [ 6] 	jsr df_rt_list_all_line
ee24 :                       df_rt_list_next_line
                             	; new line
ee24 : 207bc1           [ 6] 	jsr utilPrintCRLF
                             	; increment pointer to next line
ee27 : 18               [ 2] 	clc
ee28 : a5a1             [ 3] 	lda df_tmpptra
ee2a : a000             [ 2] 	ldy #0
ee2c : 71a1             [ 5] 	adc (df_tmpptra),y
ee2e : 85a1             [ 3] 	sta df_tmpptra
                             	_bcc 2
AS65 Assembler for R6502 [1.42].                                     Page  228
-------------------------------- bank\bank0.s --------------------------------

                             
ee32 : e6a2             [ 5] 	inc df_tmpptra+1
                             	; if pointer > end then listing is done
ee34 : 38               [ 2] 	sec
ee35 : 68               [ 4] 	pla
ee36 : aa               [ 2] 	tax
ee37 : e5a1             [ 3] 	sbc df_tmpptra
ee39 : 68               [ 4] 	pla
ee3a : 48               [ 3] 	pha
ee3b : e5a2             [ 3] 	sbc df_tmpptra+1
ee3d : 8a               [ 2] 	txa
ee3e : 48               [ 3] 	pha
ee3f : b0c2             [ 3] 	bcs df_rt_list_line
ee41 :                       df_rt_list_line_fin
                             	; if got here then reached tmpb
ee41 : 68               [ 4] 	pla
ee42 : 68               [ 4] 	pla
ee43 :                       df_rt_list_line_only_fin
ee43 : 60               [ 6] 	rts
                             
                             ;Using df_tmpptra as line pointer
                             ;Print decode an entire line
ee44 :                       df_rt_list_all_line				; Start here to include nu
ee44 : 207eef           [ 6] 	jsr df_rt_list_linnum
ee47 :                       df_rt_list_line_only			; Start here for just the 
ee47 : a003             [ 2] 	ldy #3
ee49 : b1a1             [ 5] 	lda (df_tmpptra),y
ee4b : 8592             [ 3] 	sta df_lineidx
ee4d : c8               [ 2] 	iny
ee4e : 847c             [ 3] 	sty df_linoff
ee50 :                       df_rt_list_decode
ee50 : a47c             [ 3] 	ldy df_linoff
ee52 : b1a1             [ 5] 	lda (df_tmpptra),y
ee54 : 3010             [ 3] 	bmi df_rt_list_token
ee56 : c920             [ 2] 	cmp #DFTK_ESCVAL
ee58 : 9006             [ 3] 	bcc df_rt_list_escval
                             	; normal char just print it
ee5a : 2054c4           [ 6] 	jsr io_put_ch
ee5d : 4c69ee           [ 3] 	jmp df_rt_list_nexttok
ee60 :                       df_rt_list_escval
                             	; A and Y need to be valid on entry
ee60 : 2082ee           [ 6] 	jsr df_rt_list_decode_esc
ee63 : 4c69ee           [ 3] 	jmp df_rt_list_nexttok
ee66 :                       df_rt_list_token
ee66 : 208fef           [ 6] 	jsr df_rt_list_decode_token
ee69 :                       df_rt_list_nexttok
                             	; advance the line offset
ee69 : e67c             [ 5] 	inc df_linoff
ee6b : a57c             [ 3] 	lda df_linoff
                             	; check if at end of line
ee6d : a200             [ 2] 	ldx #0
ee6f : c1a1             [ 6] 	cmp (df_tmpptra,x)
ee71 : f0d0             [ 3] 	beq df_rt_list_line_only_fin
                             	; check if at end of statement
ee73 : c592             [ 3] 	cmp df_lineidx
ee75 : d0d9             [ 3] 	bne df_rt_list_decode
ee77 : a8               [ 2] 	tay
                             	; save the next statement offset
ee78 : b1a1             [ 5] 	lda (df_tmpptra),y
ee7a : 8592             [ 3] 	sta df_lineidx
ee7c : c8               [ 2] 	iny
ee7d : 847c             [ 3] 	sty df_linoff
AS65 Assembler for R6502 [1.42].                                     Page  229
-------------------------------- bank\bank0.s --------------------------------

ee7f : 4c50ee           [ 3] 	jmp df_rt_list_decode
                             
                             
                             ; decode escape sequences
                             ; Input: A contains the esc val and Y is char lin
ee82 :                       df_rt_list_decode_esc
                             	; jump over esc byte
ee82 : c8               [ 2] 	iny
ee83 : 847c             [ 3] 	sty df_linoff
ee85 : 48               [ 3] 	pha
                             	; get the next two bytes in case needed
ee86 : b1a1             [ 5] 	lda (df_tmpptra),y
ee88 : 85a3             [ 3] 	sta df_tmpptrb
ee8a : c8               [ 2] 	iny
ee8b : b1a1             [ 5] 	lda (df_tmpptra),y
ee8d : 85a4             [ 3] 	sta df_tmpptrb+1
ee8f : 88               [ 2] 	dey				; Y is on byte after esc byte
ee90 : 68               [ 4] 	pla
                             	; x2 to get jmp offset
ee91 : 0a               [ 2] 	asl a
ee92 : aa               [ 2] 	tax
ee93 : bda3e5           [ 4] 	lda df_rt_escjmp,x
ee96 : 85a5             [ 3] 	sta df_tmpptrc
ee98 : bda4e5           [ 4] 	lda df_rt_escjmp+1,x
ee9b : 85a6             [ 3] 	sta df_tmpptrc+1
                             	; now jump to decoder
ee9d : 6ca500           [ 6] 	jmp (df_tmpptrc)
                             
                             ; reserved
eea0 :                       df_rt_lst_reserved
eea0 : 60               [ 6] 	rts
                             
                             ; decode a byte char
eea1 :                       df_rt_lst_chr
eea1 : a927             [ 2] 	lda #0x27			; Single quote
eea3 : 2054c4           [ 6] 	jsr io_put_ch
eea6 : a5a3             [ 3] 	lda df_tmpptrb
eea8 : 2054c4           [ 6] 	jsr io_put_ch
eeab : a927             [ 2] 	lda #0x27			; Single quote
eead : 2054c4           [ 6] 	jsr io_put_ch
eeb0 : c8               [ 2] 	iny
eeb1 : 847c             [ 3] 	sty df_linoff
eeb3 : 60               [ 6] 	rts
                             
                             ; Output 0x for hex chars
eeb4 :                       df_rt_lst_hex_pre
eeb4 : a930             [ 2] 	lda #'0'
eeb6 : 2054c4           [ 6] 	jsr io_put_ch
eeb9 : a978             [ 2] 	lda #'x'
eebb : 4c54c4           [ 3] 	jmp io_put_ch
                             
                             
                             ; Decode a byte hex
eebe :                       df_rt_lst_bythex
eebe : 20b4ee           [ 6] 	jsr df_rt_lst_hex_pre
eec1 :                       df_rt_lst_lo_hex
eec1 : a5a3             [ 3] 	lda df_tmpptrb
eec3 : 2098c1           [ 6] 	jsr str_a_to_x
eec6 : 2054c4           [ 6] 	jsr io_put_ch
eec9 : 8a               [ 2] 	txa
eeca : 2054c4           [ 6] 	jsr io_put_ch
eecd :                       df_rt_lst_const_done
AS65 Assembler for R6502 [1.42].                                     Page  230
-------------------------------- bank\bank0.s --------------------------------

eecd : c8               [ 2] 	iny
eece : 847c             [ 3] 	sty df_linoff
eed0 : 60               [ 6] 	rts
                             
                             ; Decode an int hex
eed1 :                       df_rt_lst_inthex
eed1 : 20b4ee           [ 6] 	jsr df_rt_lst_hex_pre
eed4 : a5a4             [ 3] 	lda df_tmpptrb+1
eed6 : 2098c1           [ 6] 	jsr str_a_to_x
eed9 : 2054c4           [ 6] 	jsr io_put_ch
eedc : 8a               [ 2] 	txa
eedd : 2054c4           [ 6] 	jsr io_put_ch
eee0 : 4cc1ee           [ 3] 	jmp df_rt_lst_lo_hex
                             
                             ; Decode a byte binary
eee3 :                       df_rt_lst_bytbin
eee3 : a5a3             [ 3] 	lda df_tmpptrb
eee5 : 85a4             [ 3] 	sta df_tmpptrb+1
eee7 : a208             [ 2] 	ldx #8
eee9 : d002             [ 3] 	bne df_rt_lst_bin
                             
                             ; Decode a int binary
eeeb :                       df_rt_lst_intbin
eeeb : a210             [ 2] 	ldx #16
                             	; FALL THROUGH
                             ; Main 01 decoding of binary
eeed :                       df_rt_lst_bin
eeed : a930             [ 2] 	lda #'0'
eeef : 2054c4           [ 6] 	jsr io_put_ch
eef2 : a962             [ 2] 	lda #'b'
eef4 : 2054c4           [ 6] 	jsr io_put_ch
eef7 :                       df_rt_lst_bit
eef7 : a930             [ 2] 	lda #'0'
eef9 : 06a3             [ 5] 	asl df_tmpptrb
eefb : 26a4             [ 5] 	rol df_tmpptrb+1
eefd : 6900             [ 2] 	adc #0				; If C=1 then '0' becomes '1'
eeff :                       df_rt_lst_bit_skip0
eeff : 2054c4           [ 6] 	jsr io_put_ch
ef02 : ca               [ 2] 	dex
ef03 : d0f2             [ 4] 	bne df_rt_lst_bit
ef05 : f0c6             [ 4] 	beq df_rt_lst_const_done
                             
                             ; Decode a decimal integer
ef07 :                       df_rt_lst_intdec
ef07 : a6a3             [ 3] 	ldx df_tmpptrb
ef09 : a5a4             [ 3] 	lda df_tmpptrb+1
ef0b : c8               [ 2] 	iny
ef0c : 847c             [ 3] 	sty df_linoff
ef0e : 18               [ 2] 	clc
ef0f : 4cfdc3           [ 3] 	jmp print_a_to_d
                             
                             
                             ; decode a variable or procedure
                             ; Slot address to decode in ptrb
ef12 :                       df_rt_lst_var
ef12 :                       df_rt_lst_proc
                             	; jump over the address bytes
ef12 : c8               [ 2] 	iny
ef13 : 847c             [ 3] 	sty df_linoff
                             
                             	; ptrc starts at VNT start
                             	_cpyZPWord df_vntstrt,df_tmpptrc
AS65 Assembler for R6502 [1.42].                                     Page  231
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             	; ptrd starts at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptrd
                             
ef25 : a000             [ 2] 	ldy #0
ef27 :                       df_rt_list_findvvt
                             	; Check have we reached target addr in vvt?
ef27 : a5a7             [ 3] 	lda df_tmpptrd
ef29 : c5a3             [ 3] 	cmp df_tmpptrb
ef2b : d006             [ 3] 	bne df_rt_list_vvtend
ef2d : a5a8             [ 3] 	lda df_tmpptrd+1
ef2f : c5a4             [ 3] 	cmp df_tmpptrb+1
ef31 : f021             [ 3] 	beq df_rt_list_gotvvt
ef33 :                       df_rt_list_vvtend
ef33 : b1a5             [ 5] 	lda (df_tmpptrc),y
ef35 : f009             [ 3] 	beq df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
ef3d : 4c33ef           [ 3] 	jmp df_rt_list_vvtend
ef40 :                       df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
                             	; move target slot address towards top of mem
ef46 : 18               [ 2] 	clc
ef47 : a5a7             [ 3] 	lda df_tmpptrd
ef49 : 6908             [ 2] 	adc #DFVVT_SZ
ef4b : 85a7             [ 3] 	sta df_tmpptrd
                             	_bcc 2
                             
ef4f : e6a8             [ 5] 	inc df_tmpptrd+1
                             	; go back and check again
ef51 : 4c27ef           [ 3] 	jmp df_rt_list_findvvt
ef54 :                       df_rt_list_gotvvt
ef54 : b1a5             [ 5] 	lda (df_tmpptrc),y
ef56 : f025             [ 3] 	beq df_rt_list_donvvt
ef58 : 2054c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrc
                             
ef61 : 4c54ef           [ 3] 	jmp df_rt_list_gotvvt
                             
ef64 :                       df_rt_lst_strlit
ef64 : a922             [ 2] 	lda #0x22
ef66 : 2054c4           [ 6] 	jsr io_put_ch
ef69 : a47c             [ 3] 	ldy df_linoff
ef6b :                       df_rt_lst_strlitch
ef6b : b1a1             [ 5] 	lda (df_tmpptra),y
ef6d : f007             [ 3] 	beq df_rt_lst_strlitdon
ef6f : 2054c4           [ 6] 	jsr io_put_ch
ef72 : c8               [ 2] 	iny
ef73 : 4c6bef           [ 3] 	jmp df_rt_lst_strlitch
ef76 :                       df_rt_lst_strlitdon
ef76 : a922             [ 2] 	lda #0x22
ef78 : 2054c4           [ 6] 	jsr io_put_ch
ef7b : 847c             [ 3] 	sty df_linoff
ef7d :                       df_rt_list_donvvt
ef7d : 60               [ 6] 	rts
                             
ef7e :                       df_rt_list_linnum
ef7e : a001             [ 2] 	ldy #1
ef80 : b1a1             [ 5] 	lda (df_tmpptra),y
ef82 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page  232
-------------------------------- bank\bank0.s --------------------------------

ef83 : c8               [ 2] 	iny
ef84 : b1a1             [ 5] 	lda (df_tmpptra),y
ef86 : 18               [ 2] 	clc
ef87 : 20fdc3           [ 6] 	jsr print_a_to_d
ef8a : a920             [ 2] 	lda #0x20			; Always add a space after line num
ef8c : 4c54c4           [ 3] 	jmp io_put_ch
                             
                             ; decode a token value with MSB set
ef8f :                       df_rt_list_decode_token
                             	; if not assembler then normal listing
ef8f : c997             [ 2] 	cmp #DFRT_ASM
ef91 : d003             [ 3] 	bne df_rt_list_decode_token_normal
ef93 : 4ccdef           [ 3] 	jmp df_rt_asm_decode_token
ef96 :                       df_rt_list_decode_token_normal
ef96 : 297f             [ 2] 	and #0x7f
                             	; token 0 and 1 don't get decoded they are impli
ef98 : c902             [ 2] 	cmp #2
ef9a : b001             [ 3] 	bcs df_rt_list_do_decode_tkn
ef9c : 60               [ 6] 	rts
ef9d :                       df_rt_list_do_decode_tkn
ef9d : aa               [ 2] 	tax
ef9e : a997             [ 2] 	lda #lo(df_tokensyms)
efa0 : 85a3             [ 3] 	sta df_tmpptrb
efa2 : a9da             [ 2] 	lda #hi(df_tokensyms)
efa4 : 85a4             [ 3] 	sta df_tmpptrb+1
efa6 :                       df_rt_list_find_sym
efa6 : 8a               [ 2] 	txa
efa7 : f012             [ 3] 	beq df_rt_list_got_sym
efa9 : a000             [ 2] 	ldy #0
efab :                       df_rt_list_next_ch
efab : b1a3             [ 5] 	lda (df_tmpptrb),y
efad : 48               [ 3] 	pha
                             	_incZPWord df_tmpptrb
                             
efb4 : 68               [ 4] 	pla
efb5 : 10f4             [ 3] 	bpl df_rt_list_next_ch
efb7 :                       df_rt_list_got_last_sym
                             	; ok got to the last ch
                             	; advance to next sym
efb7 : ca               [ 2] 	dex
efb8 : 4ca6ef           [ 3] 	jmp df_rt_list_find_sym
efbb :                       df_rt_list_got_sym
efbb : a1a3             [ 6] 	lda (df_tmpptrb,x)		; Relies on X=0 from branch
efbd : 08               [ 3] 	php
efbe : 297f             [ 2] 	and #0x7f
efc0 : 2054c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
efc9 : 28               [ 4] 	plp
efca : 10ef             [ 3] 	bpl df_rt_list_got_sym
efcc : 60               [ 6] 	rts
                             
                             ;** Decode assembler token in A **
efcd :                       df_rt_asm_decode_token
efcd : a92e             [ 2] 	lda #'.'			;Always put out the . symbol
efcf : 2054c4           [ 6] 	jsr io_put_ch
efd2 : a47c             [ 3] 	ldy df_linoff		;Print out any whitespace
efd4 :                       df_rt_asm_decode_token_ws
efd4 : c8               [ 2] 	iny					;Point to char after the asm token
efd5 : 847c             [ 3] 	sty df_linoff
efd7 : b1a1             [ 5] 	lda (df_tmpptra),y	;What is the char?
efd9 : 2017d7           [ 6] 	jsr df_tk_isws		;If not then found the keyword
AS65 Assembler for R6502 [1.42].                                     Page  233
-------------------------------- bank\bank0.s --------------------------------

efdc : 9006             [ 3] 	bcc df_rt_asm_decode_token_found
efde : 2054c4           [ 6] 	jsr io_put_ch		;Print the space
efe1 : 4cd4ef           [ 3] 	jmp df_rt_asm_decode_token_ws
efe4 :                       df_rt_asm_decode_token_found
efe4 : c911             [ 2] 	cmp #DFTK_VAR		; If is a label variable?
efe6 : d003             [ 3] 	bne df_rt_asm_decode_token_keyword
                             	; if so then process as normal escape handling
efe8 : 4c82ee           [ 3] 	jmp df_rt_list_decode_esc
efeb :                       df_rt_asm_decode_token_keyword
efeb : 297f             [ 2] 	and #0x7f			; Mask off MSB
efed : aa               [ 2] 	tax					;Put it in to X as the counter
                             	; Point to asm symbol table
efee : a995             [ 2] 	lda #lo(df_asm_tokensyms)
eff0 : 85a3             [ 3] 	sta df_tmpptrb
eff2 : a9fc             [ 2] 	lda #hi(df_asm_tokensyms)
eff4 : 85a4             [ 3] 	sta df_tmpptrb+1
eff6 :                       df_rt_list_find_asm_sym
eff6 : 8a               [ 2] 	txa
eff7 : f01b             [ 4] 	beq df_rt_list_got_asm_sym
eff9 : a000             [ 2] 	ldy #0
effb :                       df_rt_list_next_asm_ch
                             	_incZPWord df_tmpptrb
                             
f001 : b1a3             [ 5] 	lda (df_tmpptrb),y
f003 : c920             [ 2] 	cmp #' '			; Skip all chars >=' '
f005 : b0f4             [ 4] 	bcs df_rt_list_next_asm_ch
f007 : 38               [ 2] 	sec					; Skip offset and mode bytes
f008 : 65a3             [ 3] 	adc df_tmpptrb
f00a : 85a3             [ 3] 	sta df_tmpptrb
                             	_bcc 2
                             
f00e : e6a4             [ 5] 	inc df_tmpptrb+1
f010 : ca               [ 2] 	dex					; One less symbol to skip over
f011 : 4cf6ef           [ 3] 	jmp df_rt_list_find_asm_sym
f014 :                       df_rt_list_got_asm_sym
f014 : a1a3             [ 6] 	lda (df_tmpptrb,x)	; Relies on X=0 from branch
f016 : c920             [ 2] 	cmp #' '
f018 : 900c             [ 3] 	bcc df_rt_asm_decode_token_done
f01a : 2054c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
f023 : 4c14f0           [ 3] 	jmp df_rt_list_got_asm_sym
f026 :                       df_rt_asm_decode_token_done
f026 : 60               [ 6] 	rts
                             
                             
f027 :                       df_rt_doke
f027 : 203be3           [ 6] 	jsr df_rt_parm_2ints
f02a : a5a3             [ 3] 	lda df_tmpptrb
f02c : a000             [ 2] 	ldy #0
f02e : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; get high byte to doke
f030 : a5a4             [ 3] 	lda df_tmpptrb+1
f032 : c8               [ 2] 	iny
                             	; poke hi byte
f033 : 91a1             [ 5] 	sta (df_tmpptra),y
f035 : 60               [ 6] 	rts
                             
f036 :                       df_rt_poke
f036 : 203be3           [ 6] 	jsr df_rt_parm_2ints
f039 : a5a3             [ 3] 	lda df_tmpptrb
f03b : a000             [ 2] 	ldy #0
AS65 Assembler for R6502 [1.42].                                     Page  234
-------------------------------- bank\bank0.s --------------------------------

f03d : 91a1             [ 5] 	sta (df_tmpptra),y
f03f : 60               [ 6] 	rts
                             
f040 :                       df_rt_snd_common
                             	; 3 inputs
                             	; tmpa = channel (1,2,3), tmpb = period, tmpc = 
f040 : a5a1             [ 3] 	lda df_tmpptra
                             	; tone channel addressing is 0 to 2
f042 : 38               [ 2] 	sec
f043 : e901             [ 2] 	sbc #1
f045 : 2903             [ 2] 	and #3
                             	; ok doing a tone channel, get reg index for per
f047 : 0a               [ 2] 	asl a
f048 : aa               [ 2] 	tax
                             	; get low byte of period
f049 : a5a3             [ 3] 	lda df_tmpptrb
f04b : 206ec0           [ 6] 	jsr snd_set
                             	; increment reg number to high byte
f04e : e8               [ 2] 	inx
                             	; get high byte of period
f04f : a5a4             [ 3] 	lda df_tmpptrb+1
f051 : 290f             [ 2] 	and #0x0f
                             	; set period
f053 : 206ec0           [ 6] 	jsr snd_set
                             	; get volume register index (8 = channel 1)
f056 : 18               [ 2] 	clc
f057 : a5a1             [ 3] 	lda df_tmpptra
f059 : 2903             [ 2] 	and #3
f05b : 6907             [ 2] 	adc #7
f05d : aa               [ 2] 	tax
                             	; get volume
f05e : a5a5             [ 3] 	lda df_tmpptrc
f060 : 290f             [ 2] 	and #0x0f
f062 : d002             [ 3] 	bne df_rt_sound_env_skip
                             	; envelope mode
f064 : 0910             [ 2] 	ora #0x10
f066 :                       df_rt_sound_env_skip
f066 : 4c6ec0           [ 3] 	jmp snd_set
                             
                             ; sound chan,period,volume
f069 :                       df_rt_sound
f069 : 2046e3           [ 6] 	jsr df_rt_parm_3ints
f06c :                       df_rt_dosound
                             	; check which channel (0 = noise)
f06c : a5a1             [ 3] 	lda df_tmpptra
f06e : f003             [ 3] 	beq df_rt_sound_noise
f070 : 4c40f0           [ 3] 	jmp df_rt_snd_common
f073 :                       df_rt_sound_noise
                             	; ok update the noise channel, volume is irrelev
f073 : a206             [ 2] 	ldx #6
f075 : a5a3             [ 3] 	lda df_tmpptrb
f077 : 291f             [ 2] 	and #0x1f
f079 : 4c6ec0           [ 3] 	jmp snd_set
                             
                             ; music chan,octave,note,volume
f07c :                       df_rt_music
f07c : 205de3           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 2 = octave, need to x 12word = 24
                             	; get period A,X (hi/lo)
                             	; pass in octave # in X and note # in Y
f07f : a6a3             [ 3] 	ldx df_tmpptrb
f081 : a4a5             [ 3] 	ldy df_tmpptrc
AS65 Assembler for R6502 [1.42].                                     Page  235
-------------------------------- bank\bank0.s --------------------------------

f083 : 2017d4           [ 6] 	jsr snd_get_note
                             	; store note period in b
f086 : 86a3             [ 3] 	stx df_tmpptrb
f088 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; put vol in tmpc
f08a : a5a7             [ 3] 	lda df_tmpptrd
f08c : 85a5             [ 3] 	sta df_tmpptrc
                             	; tmpa,b,c contain chan,per,vol
f08e : 4c6cf0           [ 3] 	jmp df_rt_dosound
                             
                             
                             ; play tonemask,noisemask,envelope,period
f091 :                       df_rt_play
f091 : 205de3           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 1 = tone enable
f094 : a5a1             [ 3] 	lda df_tmpptra
f096 : 2907             [ 2] 	and #7
f098 : 85a1             [ 3] 	sta df_tmpptra
                             	; parm 2 = noise enable
f09a : a5a3             [ 3] 	lda df_tmpptrb
f09c : 2907             [ 2] 	and #7
f09e : 0a               [ 2] 	asl a
f09f : 0a               [ 2] 	asl a
f0a0 : 0a               [ 2] 	asl a
f0a1 : 05a1             [ 3] 	ora df_tmpptra
                             	; we now have bits set for channels to enable
                             	; but need to invert for the 8910
                             	; top 2 bits are 0 and 1 as these are port b (in
f0a3 : 497f             [ 2] 	eor #0x7f
                             	; reg 7 is control register
f0a5 : a207             [ 2] 	ldx #7
f0a7 : 206ec0           [ 6] 	jsr snd_set
                             	; parm 3 = envelope mode
f0aa : a5a5             [ 3] 	lda df_tmpptrc
f0ac : 290f             [ 2] 	and #0xf
                             	; 13 is envelope shape register
f0ae : a20d             [ 2] 	ldx #13
f0b0 : 206ec0           [ 6] 	jsr snd_set
                             	; parm 4 = envelope period
                             	; 11 is envelope period register
f0b3 : a20b             [ 2] 	ldx #11
                             	; get low
f0b5 : a5a7             [ 3] 	lda df_tmpptrd
f0b7 : 206ec0           [ 6] 	jsr snd_set
                             	; get high
f0ba : e8               [ 2] 	inx
f0bb : a5a8             [ 3] 	lda df_tmpptrd+1
f0bd : 4c6ec0           [ 3] 	jmp snd_set
                             
                             ;df_rt_fill
                             ;	jsr df_rt_parm_5ints
                             ;	rts
                             	
                             ;* common filename procesing routine
                             ;*
f0c0 :                       df_rt_init_filename
                             	; evaluate string
f0c0 : 2077e0           [ 6] 	jsr df_rt_neval
f0c3 : 2085f6           [ 6] 	jsr df_ost_popStr
                             
                             	; save string address
f0c6 : 86a5             [ 3] 	stx df_tmpptrc
AS65 Assembler for R6502 [1.42].                                     Page  236
-------------------------------- bank\bank0.s --------------------------------

f0c8 : 85a6             [ 3] 	sta df_tmpptrc+1
                             
                             	; copy string to fhandle
f0ca : a000             [ 2] 	ldy #0
f0cc :                       df_rt_copy_fn
f0cc : b1a5             [ 5] 	lda (df_tmpptrc),y
f0ce :                       df_rt_fname_case
f0ce : 990004           [ 5] 	sta df_linbuff,y				; Put filename in line buffe
f0d1 : c8               [ 2] 	iny
f0d2 : aa               [ 2] 	tax
f0d3 : d0f7             [ 3] 	bne df_rt_copy_fn
f0d5 : 60               [ 6] 	rts
                             
                             ;* common file parsing routine
f0d6 :                       df_rt_parse_file
                             	; now process filename
f0d6 : 20c0f0           [ 6] 	jsr df_rt_init_filename
f0d9 : a900             [ 2] 	lda #0						; Initialise tape system
f0db : 4c2bc4           [ 3] 	jmp io_active_device
f0de :                       df_rt_file_errc
                             	SWBRK DFERR_FNAME
                             
                             
                             ; save "file" as text
f0e0 :                       df_rt_tsave
f0e0 : 20d6f0           [ 6] 	jsr df_rt_parse_file
f0e3 : 205ac4           [ 6] 	jsr io_open_write
f0e6 : b0f6             [ 3] 	bcs df_rt_file_errc
                             	; ok now have redirected output to device
                             	; go and list the program in save mode
f0e8 : a901             [ 2] 	lda #1
f0ea : 85a9             [ 3] 	sta df_tmpptre
f0ec : 20f5ed           [ 6] 	jsr df_rt_listprg
                             	; final CR to end the save
f0ef : a90d             [ 2] 	lda #UTF_CR
f0f1 : 2054c4           [ 6] 	jsr io_put_ch
f0f4 :                       df_rt_file_cleanup
                             	; close the file
f0f4 : 205dc4           [ 6] 	jsr io_close
                             	; restore to default device io
f0f7 : 4c28c4           [ 3] 	jmp io_set_default
                             
                             
                             ; load "file" from text
f0fa :                       df_rt_tload
f0fa : 20d6f0           [ 6] 	jsr df_rt_parse_file
f0fd : 2057c4           [ 6] 	jsr io_open_read
f100 : b0dc             [ 4] 	bcs df_rt_file_errc
                             	; no echo - very important
                             	; else might try and write to a device
                             	; only open for reading (i.e. SD CARD)
f102 :                       df_rt_loadline
f102 : 18               [ 2] 	clc					; NO ECHO!
f103 : 2048df           [ 6] 	jsr df_pg_inputline
                             	; if C clear then tokenise line
f106 : 9015             [ 3] 	bcc df_rt_ldtokenise
                             	; else done
                             	; clear dflat runtime else will try to execute
                             	; the last tokenised line!
f108 : a200             [ 2] 	ldx #0
f10a : 8e8004           [ 4] 	stx df_tokbuff			; Offset to next line
f10d : 8e8104           [ 4] 	stx df_tokbuff+1		; Clear line low
AS65 Assembler for R6502 [1.42].                                     Page  237
-------------------------------- bank\bank0.s --------------------------------

f110 : 8e8204           [ 4] 	stx df_tokbuff+2		; Clear line high
f113 : 867f             [ 3] 	stx df_nxtstidx			; Clear next statement
f115 : 867e             [ 3] 	stx df_eolidx			; Clear end of line too
f117 : e8               [ 2] 	inx						; Set immediate mode
f118 : 865e             [ 3] 	stx df_immed
f11a : 4cf4f0           [ 3] 	jmp df_rt_file_cleanup	; Ok now can close and do
f11d :                       df_rt_ldtokenise
f11d : 2099df           [ 6] 	jsr df_pg_tokenise		; Tokenise loaded string
f120 : 4c02f1           [ 3] 	jmp df_rt_loadline		; Continue with next until b
                             
                             
                             ; Utility to open in binary mode save
f123 :                       df_rt_openforbinsave
f123 : 20d6f0           [ 6] 	jsr df_rt_parse_file
f126 : 2066c4           [ 6] 	jsr io_open_ext2		; Ext2 is binary file save
f129 : b0b3             [ 4] 	bcs df_rt_file_errc
f12b : 60               [ 6] 	rts
                             
                             ; Utility to open in binary mode load
f12c :                       df_rt_openforbinload
                             	; Get filename and open file for binary read
f12c : 20d6f0           [ 6] 	jsr df_rt_parse_file
f12f : 2063c4           [ 6] 	jsr io_open_ext1		; Ext1 is binary file read
f132 : b0aa             [ 4] 	bcs df_rt_file_errc
f134 : 60               [ 6] 	rts
                             
                             ; bload addr,"file"
f135 :                       df_rt_bload
                             	; Get address but keep on stack
f135 : e688             [ 5] 	inc df_exeoff
f137 : 2077e0           [ 6] 	jsr df_rt_neval
                             
                             	; Get filename and open file for binary read
f13a : e688             [ 5] 	inc df_exeoff
f13c : 202cf1           [ 6] 	jsr df_rt_openforbinload
                             
                             	; Get address from stack in to ptra
f13f : 2081f6           [ 6] 	jsr df_ost_popInt
f142 : 86a1             [ 3] 	stx df_tmpptra
f144 : 85a2             [ 3] 	sta df_tmpptra+1
                             
                             	; Get file address to X,Y
f146 : 2051c4           [ 6] 	jsr io_get_ch
f149 : aa               [ 2] 	tax
f14a : 2051c4           [ 6] 	jsr io_get_ch
f14d : a8               [ 2] 	tay
                             
                             	; Check if user address is zero
f14e : a5a1             [ 3] 	lda df_tmpptra
f150 : 05a2             [ 3] 	ora df_tmpptra+1
f152 : d004             [ 3] 	bne df_rt_bload_addr
                             	; If it is zero then use address from file
f154 : 86a1             [ 3] 	stx df_tmpptra
f156 : 84a2             [ 3] 	sty df_tmpptra+1
f158 :                       df_rt_bload_addr
                             	; Get file length
f158 : 2051c4           [ 6] 	jsr io_get_ch
f15b : 85a3             [ 3] 	sta df_tmpptrb
f15d : 2051c4           [ 6] 	jsr io_get_ch
f160 : 85a4             [ 3] 	sta df_tmpptrb+1
                             
                             	; Go and load the bytes
AS65 Assembler for R6502 [1.42].                                     Page  238
-------------------------------- bank\bank0.s --------------------------------

f162 : 2004f2           [ 6] 	jsr df_rt_loadbin
                             	; Close the file
f165 : 4cf4f0           [ 3] 	jmp df_rt_file_cleanup
                             
                             ; Save a binary file
                             ; addr,length,fname
f168 :                       df_rt_bsave
                             	; Get source address and length but leave on sta
                             	; evaluate 1st parm
f168 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; jump over comma
f16b : e688             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
f16d : 2077e0           [ 6] 	jsr df_rt_neval
                             
                             	; Process file and open for binary save
f170 : e688             [ 5] 	inc df_exeoff
f172 : 2023f1           [ 6] 	jsr df_rt_openforbinsave
                             
                             	; Get length in to ptrb
f175 : 2081f6           [ 6] 	jsr df_ost_popInt
f178 : 86a3             [ 3] 	stx df_tmpptrb
f17a : 85a4             [ 3] 	sta df_tmpptrb+1
                             
                             	; Get address in to ptra
f17c : 2081f6           [ 6] 	jsr df_ost_popInt
f17f : 86a1             [ 3] 	stx df_tmpptra
f181 : 85a2             [ 3] 	sta df_tmpptra+1
                             
                             	; now save bytes
f183 : 2016f2           [ 6] 	jsr df_rt_savebin
                             	; Close the file
f186 : 4cf4f0           [ 3] 	jmp df_rt_file_cleanup
                             
                             
                             ; save dflat tokenised program as binary
f189 :                       df_rt_save
                             	; Process file and open for binary save
f189 : 2023f1           [ 6] 	jsr df_rt_openforbinsave
                             
                             	; first save zero page stuff
                             	; ok this saves a bit more than needed
                             	; but it's no biggie and doesn't
                             	; clobber temp space
f18c : a95b             [ 2] 	lda #lo(dflat_zp_save_s)
f18e : 85a1             [ 3] 	sta df_tmpptra
f190 : a900             [ 2] 	lda #hi(dflat_zp_save_s)
f192 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; save length
f194 : 38               [ 2] 	sec
f195 : a9a1             [ 2] 	lda #lo(dflat_zp_save_e)
f197 : e95b             [ 2] 	sbc #lo(dflat_zp_save_s)
f199 : 85a3             [ 3] 	sta df_tmpptrb
f19b : a900             [ 2] 	lda #hi(dflat_zp_save_e)
f19d : e900             [ 2] 	sbc #hi(dflat_zp_save_s)
f19f : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f1a1 : 2016f2           [ 6] 	jsr df_rt_savebin
                             
                             	; now save the dflat program
f1a4 : a565             [ 3] 	lda df_prgstrt
f1a6 : 85a1             [ 3] 	sta df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  239
-------------------------------- bank\bank0.s --------------------------------

f1a8 : a566             [ 3] 	lda df_prgstrt+1
f1aa : 85a2             [ 3] 	sta df_tmpptra+1
                             	; save length
f1ac : 38               [ 2] 	sec
f1ad : a567             [ 3] 	lda df_prgend
f1af : e565             [ 3] 	sbc df_prgstrt
f1b1 : 85a3             [ 3] 	sta df_tmpptrb
f1b3 : a568             [ 3] 	lda df_prgend+1
f1b5 : e566             [ 3] 	sbc df_prgstrt+1
f1b7 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f1b9 : 2016f2           [ 6] 	jsr df_rt_savebin
                             
                             	; now save the variables VVT and VNT
f1bc : a569             [ 3] 	lda df_vntstrt
f1be : 85a1             [ 3] 	sta df_tmpptra
f1c0 : a56a             [ 3] 	lda df_vntstrt+1
f1c2 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; save length
f1c4 : 38               [ 2] 	sec
f1c5 : a56d             [ 3] 	lda df_vvtstrt
f1c7 : e569             [ 3] 	sbc df_vntstrt
f1c9 : 85a3             [ 3] 	sta df_tmpptrb
f1cb : a56e             [ 3] 	lda df_vvtstrt+1
f1cd : e56a             [ 3] 	sbc df_vntstrt+1
f1cf : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; now save bytes
f1d1 : 2016f2           [ 6] 	jsr df_rt_savebin
                             
                             	; close the file
f1d4 : 205dc4           [ 6] 	jsr io_close
f1d7 : 18               [ 2] 	clc
                             	; Close the file
f1d8 : 4cf4f0           [ 3] 	jmp df_rt_file_cleanup
                             
                             
                             ; load dflat tokenised program as binary
f1db :                       df_rt_load
f1db : 202cf1           [ 6] 	jsr df_rt_openforbinload
                             
                             	; Get zero page header
f1de : 20f7f1           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f1e1 : 2004f2           [ 6] 	jsr df_rt_loadbin
                             
                             	; Get program header
f1e4 : 20f7f1           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f1e7 : 2004f2           [ 6] 	jsr df_rt_loadbin
                             
                             	; Get variables header
f1ea : 20f7f1           [ 6] 	jsr df_rt_getbin_parms
                             	; and get bytes
f1ed : 2004f2           [ 6] 	jsr df_rt_loadbin
                             
                             	; close the file
f1f0 : 205dc4           [ 6] 	jsr io_close
f1f3 : 18               [ 2] 	clc
                             	; Close the file
f1f4 : 4cf4f0           [ 3] 	jmp df_rt_file_cleanup
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  240
-------------------------------- bank\bank0.s --------------------------------

                             ; Utility to get 4 parms from binary header
f1f7 :                       df_rt_getbin_parms
f1f7 : a200             [ 2] 	ldx #0
f1f9 :                       df_rt_getbin_parms_loop
f1f9 : 2051c4           [ 6] 	jsr io_get_ch
f1fc : 95a1             [ 4] 	sta df_tmpptra,x
f1fe : e8               [ 2] 	inx
f1ff : e004             [ 2] 	cpx #4
f201 : d0f6             [ 4] 	bne df_rt_getbin_parms_loop
f203 : 60               [ 6] 	rts
                             
                             ; Utility to load a bin file in address ptra
                             ; Length in ptr b
f204 :                       df_rt_loadbin
                             	; Now load all bytes
f204 : a000             [ 2] 	ldy #0
f206 :                       df_rt_loadbin_byte
                             	; Get a byte from tape
f206 : 2051c4           [ 6] 	jsr io_get_ch
                             	; Save it to destination
f209 : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; Increment destination
f20b : c8               [ 2] 	iny
f20c : d002             [ 3] 	bne df_rt_loadbin_inc
f20e : e6a2             [ 5] 	inc df_tmpptra+1
f210 :                       df_rt_loadbin_inc
                             	; Decrement length remaining
f210 : 2034f2           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f213 : d0f1             [ 3] 	bne df_rt_loadbin_byte
                             	; Yes the close the file
f215 : 60               [ 6] 	rts
                             
                             ; Utility to save a bin file from address ptra
                             ; Length in ptr b
f216 :                       df_rt_savebin
                             	; Save dest and length to tape
f216 : a200             [ 2] 	ldx #0
f218 :                       df_rt_bsave_parms
f218 : b5a1             [ 4] 	lda df_tmpptra,x
f21a : 2054c4           [ 6] 	jsr io_put_ch
f21d : e8               [ 2] 	inx
f21e : e004             [ 2] 	cpx #4
f220 : d0f6             [ 3] 	bne df_rt_bsave_parms
                             
                             	; Now save all bytes
f222 : a000             [ 2] 	ldy #0
f224 :                       df_rt_savebin_byte
                             	; Get byte from memory
f224 : b1a1             [ 5] 	lda (df_tmpptra),y
                             	; Put byte to tape
f226 : 2054c4           [ 6] 	jsr io_put_ch
                             	; Increment destination
f229 : c8               [ 2] 	iny
f22a : d002             [ 3] 	bne df_rt_savebin_inc
f22c : e6a2             [ 5] 	inc df_tmpptra+1
f22e :                       df_rt_savebin_inc
                             	; Decrement length remaining
f22e : 2034f2           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f231 : d0f1             [ 3] 	bne df_rt_savebin_byte
f233 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  241
-------------------------------- bank\bank0.s --------------------------------

                             
                             ; Decrement length in ptrb
f234 :                       df_rt_dec_binlen
                             	; Decrement length remaining
f234 : a5a3             [ 3] 	lda df_tmpptrb
f236 : d002             [ 3] 	bne df_rt_binlen_skip
f238 : c6a4             [ 5] 	dec df_tmpptrb+1
f23a :                       df_rt_binlen_skip
f23a : c6a3             [ 5] 	dec df_tmpptrb
                             	; Reached zero?
f23c : a5a3             [ 3] 	lda df_tmpptrb
f23e : 05a4             [ 3] 	ora df_tmpptrb+1
f240 : 60               [ 6] 	rts
                             
                             
                             ; reset var
f241 :                       df_rt_reset
                             	; now get lvar X,A from current statement
f241 : 20b8e4           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
f244 : 86a3             [ 3] 	stx df_tmpptrb
f246 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; load the vdp count as the reset value of timer
                             	; turn off interrupts while reading vdp lo,hi
f248 : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
                             	; clear interrupts to access 3 byte vdp counter 
f24a : 78               [ 2] 	sei
f24b : a508             [ 3] 	lda vdp_cnt
f24d : 91a3             [ 5] 	sta (df_tmpptrb),y
f24f : a509             [ 3] 	lda vdp_cnt+1
f251 : c8               [ 2] 	iny
f252 : 91a3             [ 5] 	sta (df_tmpptrb),y
                             	; restore interrupts asap
f254 : 58               [ 2] 	cli
f255 : 60               [ 6] 	rts
                             
                             ;***** FUNCTIONS *****
                             
f256 :                       df_rt_deek
f256 : 38               [ 2] 	sec
f257 : 24                    	db 0x24	; BIT skip the clc
f258 :                       df_rt_peek
f258 : 18               [ 2] 	clc
f259 :                       df_rt_readbyte
f259 : 08               [ 3] 	php
                             ;	inc df_exeoff
f25a : 2071e0           [ 6] 	jsr df_rt_getnval
f25d : 86a1             [ 3] 	stx df_tmpptra
f25f : 85a2             [ 3] 	sta df_tmpptra+1
f261 : a000             [ 2] 	ldy #0
f263 : b1a1             [ 5] 	lda (df_tmpptra),y
f265 : aa               [ 2] 	tax
f266 : a900             [ 2] 	lda #0
f268 : 28               [ 4] 	plp
f269 : 9003             [ 3] 	bcc df_rt_readbyte_skip
f26b : c8               [ 2] 	iny
f26c : b1a1             [ 5] 	lda (df_tmpptra),y
f26e :                       df_rt_readbyte_skip
f26e : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; Random number generator
                             ; rnd(0) = get next number
AS65 Assembler for R6502 [1.42].                                     Page  242
-------------------------------- bank\bank0.s --------------------------------

                             ; rnd(>0) = set seed
f271 :                       df_rt_rnd
                             ;	inc df_exeoff
f271 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; if input is 0 then generate next random number
f274 : e000             [ 2] 	cpx #0
f276 : d014             [ 3] 	bne df_rt_rnd_set
f278 : c900             [ 2] 	cmp #0
f27a : d010             [ 3] 	bne df_rt_rnd_set
                             	; generate next number
f27c : a598             [ 3] 	lda df_rnd+1
f27e : 4a               [ 2] 	lsr a
f27f : 2697             [ 5] 	rol df_rnd
f281 : 9002             [ 3] 	bcc df_rt_rnd_noeor
f283 : 49b4             [ 2] 	eor #0xb4
f285 :                       df_rt_rnd_noeor
f285 : 8598             [ 3] 	sta df_rnd+1
f287 : 4597             [ 3] 	eor df_rnd
f289 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             	; else set the seed to that number and done
f28c :                       df_rt_rnd_set
f28c : 8697             [ 3] 	stx df_rnd
f28e : 8598             [ 3] 	sta df_rnd+1
f290 : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             
                             ;* Return memory footprint as follows:
                             ;* 0	Return free memory (start of vvt - end of he
                             ;* 1	Return program size (end of prg - start of p
                             ;* 2	Return size of vars (end of vnt - start of v
f293 :                       df_rt_mem
                             ;	inc df_exeoff
f293 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
f296 : e001             [ 2] 	cpx #1
f298 : f017             [ 3] 	beq df_rt_mem_prg
f29a : e002             [ 2] 	cpx #2
f29c : f026             [ 3] 	beq df_rt_mem_var
                             	; default is free memory
f29e :                       df_rt_mem_free
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_starend,df_tmpptrb
                             
f2ae : 4cd4f2           [ 3] 	jmp df_rt_mem_calc
f2b1 :                       df_rt_mem_prg
                             	_cpyZPWord df_prgend,df_tmpptra
                             
                             	_cpyZPWord df_prgstrt,df_tmpptrb
                             
f2c1 : 4cd4f2           [ 3] 	jmp df_rt_mem_calc
f2c4 :                       df_rt_mem_var
                             	_cpyZPWord df_vvtstrt,df_tmpptra
                             
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
f2d4 :                       df_rt_mem_calc
                             	; tmpa-tmpb result in X,A
f2d4 : 38               [ 2] 	sec
f2d5 : a5a1             [ 3] 	lda df_tmpptra
f2d7 : e5a3             [ 3] 	sbc df_tmpptrb
f2d9 : aa               [ 2] 	tax
AS65 Assembler for R6502 [1.42].                                     Page  243
-------------------------------- bank\bank0.s --------------------------------

f2da : a5a2             [ 3] 	lda df_tmpptra+1
f2dc : e5a4             [ 3] 	sbc df_tmpptrb+1
f2de : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ;* a=stick()
                             ;* returns bit condition of joystick positions
                             ;* no actual joystick support so this is
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
f2e1 :                       df_rt_stick
                             ;	inc df_exeoff
f2e1 : 2078c7           [ 6] 	jsr kb_stick				; Get pos in to A
f2e4 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             ; k=get(sync) sync>=1 means sync
f2e7 :                       df_rt_get
                             ;	inc df_exeoff
f2e7 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used, check for sync or async
                             	; c=0 if x<1 else x>=1 makes c=1
f2ea : e001             [ 2] 	cpx #1
f2ec :                       df_rt_get_sync
f2ec : 08               [ 3] 	php
f2ed : 2051c4           [ 6] 	jsr io_get_ch				; Return in A, C=0 is good
f2f0 : 9005             [ 3] 	bcc df_rt_get_pushp			; Push A (and do plp)
f2f2 : 28               [ 4] 	plp
f2f3 : b0f7             [ 3] 	bcs df_rt_get_sync			; If sync then check again
f2f5 : 9001             [ 3] 	bcc df_rt_get_push			; Else push zero (no plp)
f2f7 :                       df_rt_get_pushp
f2f7 : 28               [ 4] 	plp
f2f8 :                       df_rt_get_push
f2f8 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             ; s = scrn(x,y)
f2fb :                       df_rt_scrn
                             ;	inc df_exeoff
f2fb : 203be3           [ 6] 	jsr df_rt_parm_2ints
f2fe : a4a1             [ 3] 	ldy df_tmpptra			; Y is the x coord!
f300 : a6a3             [ 3] 	ldx df_tmpptrb			; X is the y coord!
f302 : 20fecd           [ 6] 	jsr gr_get
f305 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             ; p = pixel(x,y)
f308 :                       df_rt_pixel
                             ;	inc df_exeoff
f308 : 203be3           [ 6] 	jsr df_rt_parm_2ints
f30b : a6a1             [ 3] 	ldx df_tmpptra
f30d : a4a3             [ 3] 	ldy df_tmpptrb
f30f : 2064d0           [ 6] 	jsr gr_pixel
f312 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             
                             ; e=elapsed(var)
f315 :                       df_rt_elapsed
                             	; now get lvar X,A from current statement
f315 : 20b8e4           [ 6] 	jsr df_rt_getlvar
f318 : e688             [ 5] 	inc df_exeoff
                             	; save lvar in tmpb, vvt ptr in tmpa
f31a : 86a3             [ 3] 	stx df_tmpptrb
f31c : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; subtract vdp counter from value
                             	; turn off interrupts while reading vdp lo,hi
AS65 Assembler for R6502 [1.42].                                     Page  244
-------------------------------- bank\bank0.s --------------------------------

f31e : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
f320 : 38               [ 2] 	sec
                             	; disable interrupts to access vdp counter
f321 : 78               [ 2] 	sei
f322 : a508             [ 3] 	lda vdp_cnt
f324 : f1a3             [ 5] 	sbc (df_tmpptrb),y
f326 : aa               [ 2] 	tax
f327 : a509             [ 3] 	lda vdp_cnt+1
                             	; restore interrupts asap
f329 : 58               [ 2] 	cli
f32a : c8               [ 2] 	iny
f32b : f1a3             [ 5] 	sbc (df_tmpptrb),y
f32d : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
f330 :                       df_rt_call
                             ;	inc df_exeoff
f330 : 205de3           [ 6] 	jsr df_rt_parm_4ints
f333 : a5a3             [ 3] 	lda df_tmpptrb				; load A
f335 : a6a5             [ 3] 	ldx	df_tmpptrc				; load X
f337 : a4a7             [ 3] 	ldy df_tmpptrd				; load Y
f339 : 203ff3           [ 6] 	jsr df_rt_calljsr
f33c :                       df_rt_push_int1
f33c : 4c51f6           [ 3] 	jmp df_ost_pushInt			; A,X pair is return value
f33f :                       df_rt_calljsr
f33f : 6ca100           [ 6] 	jmp (df_tmpptra)			; tmpptra is address, return 
                             
f342 :                       df_rt_sgn
                             ;	inc df_exeoff
f342 : 2071e0           [ 6] 	jsr df_rt_getnval
f345 : 86a1             [ 3] 	stx df_tmpptra
f347 : 05a1             [ 3] 	ora df_tmpptra
f349 : f00f             [ 3] 	beq df_rt_sgn_z
f34b : 2980             [ 2] 	and #0x80
f34d : d006             [ 3] 	bne df_rt_sgn_n
f34f : a201             [ 2] 	ldx #1
f351 : a900             [ 2] 	lda #0
f353 : f0e7             [ 3] 	beq df_rt_push_int1			; Always
f355 :                       df_rt_sgn_n
f355 : a2ff             [ 2] 	ldx #0xff
f357 : 8a               [ 2] 	txa
f358 : d0e2             [ 3] 	bne df_rt_push_int1			; Always
f35a :                       df_rt_sgn_z
f35a : a200             [ 2] 	ldx #0
f35c : 8a               [ 2] 	txa
f35d : f0dd             [ 3] 	beq df_rt_push_int1			; Always
                             
                             ; addr(X)
f35f :                       df_rt_addr
                             	; get lvar X,A from current statement
f35f : 20b8e4           [ 6] 	jsr df_rt_getlvar
f362 : e688             [ 5] 	inc df_exeoff
f364 : 4c51f6           [ 3] 	jmp df_ost_pushInt
                             
                             ; string length calculator
                             ; X,A = source
                             ; A = length not including zero
f367 :                       df_rt_strlen_common
f367 : 86a1             [ 3] 	stx df_tmpptra
f369 : 85a2             [ 3] 	sta df_tmpptra+1
f36b : a0ff             [ 2] 	ldy #0xff
f36d :                       df_rt_strlen_count
f36d : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  245
-------------------------------- bank\bank0.s --------------------------------

f36e : b1a1             [ 5] 	lda (df_tmpptra),y
f370 : d0fb             [ 3] 	bne df_rt_strlen_count
f372 : 98               [ 2] 	tya
f373 : 60               [ 6] 	rts
                             
                             
                             ; common routine to extract a string
                             ; tmpa = source string
                             ; tmpb = dest string
                             ; tmpc = start pos
                             ; tmpd = endpos
f374 :                       df_rt_str_extract
                             	; source string
f374 : 2085f6           [ 6] 	jsr df_ost_popStr
f377 : 86a1             [ 3] 	stx df_tmpptra
f379 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; destination is string accumulator
f37b : a57a             [ 3] 	lda df_sevalptr
f37d : 85a3             [ 3] 	sta df_tmpptrb
f37f : a57b             [ 3] 	lda df_sevalptr+1
f381 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; start pos
f383 : a4a5             [ 3] 	ldy df_tmpptrc
f385 : a200             [ 2] 	ldx #0
f387 :                       df_rt_str_cpy_ch
f387 : c4a7             [ 3] 	cpy df_tmpptrd
f389 : f011             [ 3] 	beq df_str_src_end
f38b : b1a1             [ 5] 	lda (df_tmpptra),y
f38d : f00d             [ 3] 	beq df_str_src_end
f38f : 81a3             [ 6] 	sta (df_tmpptrb,x)
                             	_incZPWord df_tmpptrb
                             
f397 : c8               [ 2] 	iny
f398 : d0ed             [ 3] 	bne df_rt_str_cpy_ch
                             	SWBRK DFERR_STRLONG
                             
f39c :                       df_str_src_end
f39c : a900             [ 2] 	lda #0
f39e : 81a3             [ 6] 	sta (df_tmpptrb,x)
f3a0 : a67a             [ 3] 	ldx df_sevalptr
f3a2 : a57b             [ 3] 	lda df_sevalptr+1
f3a4 : 4c5cf6           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = chr(x)
f3a7 :                       df_rt_chr
                             ;	inc df_exeoff
                             	; get char in X
f3a7 : 2071e0           [ 6] 	jsr df_rt_getnval
f3aa : a000             [ 2] 	ldy #0
                             	; transfer lo byte to A
f3ac : 8a               [ 2] 	txa
f3ad : 917a             [ 5] 	sta (df_sevalptr),y
f3af : c8               [ 2] 	iny
                             	; zero terminator
f3b0 : a900             [ 2] 	lda #0
f3b2 : 917a             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f3b4 : a67a             [ 3] 	ldx df_sevalptr
f3b6 : a57b             [ 3] 	lda df_sevalptr+1
f3b8 : 4c5cf6           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = hex(x)
AS65 Assembler for R6502 [1.42].                                     Page  246
-------------------------------- bank\bank0.s --------------------------------

f3bb :                       df_rt_hex
                             ;	inc df_exeoff
                             	; create hex digits
f3bb : 2071e0           [ 6] 	jsr df_rt_getnval
f3be : 85a1             [ 3] 	sta df_tmpptra	; Save the high byte
f3c0 : 8a               [ 2] 	txa				; Convert low byte first
f3c1 : 2098c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
f3c4 : 85a3             [ 3] 	sta df_tmpptrb
f3c6 : 8a               [ 2] 	txa				; Push low digit of low byte from X
f3c7 : 48               [ 3] 	pha
f3c8 : a5a3             [ 3] 	lda df_tmpptrb	; Get A back from temp
f3ca : 48               [ 3] 	pha				; Push high digit of low byte
f3cb : a5a1             [ 3] 	lda df_tmpptra	; Get the high byte
f3cd : 2098c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
                             	; create string
f3d0 : a000             [ 2] 	ldy #0			; Index in to string temp area
                             	; hi/hi
f3d2 : 917a             [ 5] 	sta (df_sevalptr),y
f3d4 : c8               [ 2] 	iny
                             	; hi/lo
f3d5 : 8a               [ 2] 	txa
f3d6 : 917a             [ 5] 	sta (df_sevalptr),y
f3d8 : c8               [ 2] 	iny
                             	; lo/hi
f3d9 : 68               [ 4] 	pla
f3da : 917a             [ 5] 	sta (df_sevalptr),y
f3dc : c8               [ 2] 	iny
                             	; lo/lo
f3dd : 68               [ 4] 	pla
f3de : 917a             [ 5] 	sta (df_sevalptr),y
f3e0 : c8               [ 2] 	iny
                             	; zero terminator
f3e1 : a900             [ 2] 	lda #0
f3e3 : 917a             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f3e5 : a67a             [ 3] 	ldx df_sevalptr
f3e7 : a57b             [ 3] 	lda df_sevalptr+1
f3e9 : 4c5cf6           [ 3] 	jmp df_ost_pushStr
                             
                             ; $l = left($s, x)
f3ec :                       df_rt_left
                             ;	inc df_exeoff
                             
                             	; first get the string to act on
                             	; point to string accumulator
f3ec : 2031e1           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars
f3ef : e688             [ 5] 	inc df_exeoff
f3f1 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract
f3f4 : 86a7             [ 3] 	stx df_tmpptrd
                             	; start position
f3f6 : a000             [ 2] 	ldy #0
f3f8 : 84a5             [ 3] 	sty df_tmpptrc
f3fa : 4c74f3           [ 3] 	jmp df_rt_str_extract
                             
                             ; $r = right($s, x)
f3fd :                       df_rt_right
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f3fd : 2031e1           [ 6] 	jsr df_rt_seval
AS65 Assembler for R6502 [1.42].                                     Page  247
-------------------------------- bank\bank0.s --------------------------------

                             	; now get the num of chars from the right
f400 : e688             [ 5] 	inc df_exeoff
f402 : 2071e0           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract from the right
f405 : 86a5             [ 3] 	stx df_tmpptrc
                             	; end pos = len
f407 : a67a             [ 3] 	ldx df_sevalptr
f409 : a57b             [ 3] 	lda df_sevalptr+1
f40b : 2067f3           [ 6] 	jsr df_rt_strlen_common
f40e : 85a7             [ 3] 	sta df_tmpptrd
                             	; subtract num chars to extract to get start pos
f410 : 38               [ 2] 	sec
f411 : e5a5             [ 3] 	sbc df_tmpptrc
f413 : 85a5             [ 3] 	sta df_tmpptrc
f415 : 4c74f3           [ 3] 	jmp df_rt_str_extract
                             
                             ; $m = mid($s, x, y)
f418 :                       df_rt_mid
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f418 : 2031e1           [ 6] 	jsr df_rt_seval
                             	; now get start of string segment
f41b : e688             [ 5] 	inc df_exeoff
f41d : 2077e0           [ 6] 	jsr df_rt_neval
                             	; number of chars to extract
f420 : e688             [ 5] 	inc df_exeoff
f422 : 2071e0           [ 6] 	jsr df_rt_getnval
f425 : 86a7             [ 3] 	stx df_tmpptrd
                             	; start position
f427 : 2081f6           [ 6] 	jsr df_ost_popInt
f42a : ca               [ 2] 	dex					; zero offset rather than 1
f42b : 86a5             [ 3] 	stx df_tmpptrc
                             	; update end pos by adding start pos
f42d : 8a               [ 2] 	txa
f42e : 18               [ 2] 	clc
f42f : 65a7             [ 3] 	adc df_tmpptrd
f431 : 85a7             [ 3] 	sta df_tmpptrd
f433 : 4c74f3           [ 3] 	jmp df_rt_str_extract
                             
                             ; %l = len($s)
f436 :                       df_rt_len
                             ;	inc df_exeoff
                             	; evaluate the string in the string accumulator
f436 : 2031e1           [ 6] 	jsr df_rt_seval
f439 : 2085f6           [ 6] 	jsr df_ost_popStr
                             	; now calculate the length of this string
f43c : 2067f3           [ 6] 	jsr df_rt_strlen_common
f43f : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = asc($s)
f442 :                       df_rt_asc
                             ;	inc df_exeoff
                             	; Evaluate string in the string accumulator
f442 : 2031e1           [ 6] 	jsr df_rt_seval
f445 : 2085f6           [ 6] 	jsr df_ost_popStr
                             	; Store point in ZP
f448 : 86a1             [ 3] 	stx df_tmpptra
f44a : 85a2             [ 3] 	sta df_tmpptra+1
                             	; Find the character at beginning
f44c : a200             [ 2] 	ldx #0
f44e : a1a1             [ 6] 	lda (df_tmpptra,x)
AS65 Assembler for R6502 [1.42].                                     Page  248
-------------------------------- bank\bank0.s --------------------------------

f450 : 4c55f6           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = val($s)
f453 :                       df_rt_val
                             ;	inc df_exeoff
                             	; evaluate the string
f453 : 2031e1           [ 6] 	jsr df_rt_seval
f456 : 2085f6           [ 6] 	jsr df_ost_popStr
f459 : a000             [ 2] 	ldy #0				; any numeric format
f45b : 20e1c1           [ 6] 	jsr con_n_to_a		; result in num_a
f45e : b007             [ 3] 	bcs df_rt_val_err
f460 : a63d             [ 3] 	ldx num_a
f462 : a53e             [ 3] 	lda num_a+1
                             	; Save as an int
f464 : 4c51f6           [ 3] 	jmp df_ost_pushInt
f467 :                       df_rt_val_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ; stop execution
f469 :                       df_rt_abort
                             	SWBRK DFERR_ABORT
                             
                             
f46b :                       df_rt_sprchar
f46b : 203be3           [ 6] 	jsr df_rt_parm_2ints
f46e : a5a1             [ 3] 	lda df_tmpptra
f470 : a6a3             [ 3] 	ldx df_tmpptrb
f472 : 4cd7d2           [ 3] 	jmp gr_spr_char
                             
f475 :                       df_rt_sprpos
f475 : 2046e3           [ 6] 	jsr df_rt_parm_3ints
f478 : a5a1             [ 3] 	lda df_tmpptra
f47a : a6a3             [ 3] 	ldx df_tmpptrb
f47c : a4a5             [ 3] 	ldy df_tmpptrc
f47e : 4ce7d2           [ 3] 	jmp gr_spr_pos
                             
f481 :                       df_rt_sprupd
f481 : 2072d2           [ 6] 	jsr gr_spr_erase
f484 : 2084d2           [ 6] 	jsr gr_spr_new
f487 : 4cb6d2           [ 3] 	jmp gr_spr_draw
                             
f48a :                       df_rt_sprinit
f48a : 4c64d2           [ 3] 	jmp gr_spr_init
                             
f48d :                       df_rt_sprmulti
f48d : 203be3           [ 6] 	jsr df_rt_parm_2ints
f490 : 4cf4d2           [ 3] 	jmp gr_spr_multi_pos
                             
f493 :                       df_rt_sprhit
                             ;	inc df_exeoff
f493 : 2071e0           [ 6] 	jsr df_rt_getnval
f496 : 8a               [ 2] 	txa
f497 : 20ddd2           [ 6] 	jsr gr_spr_hit
f49a : b003             [ 3] 	bcs df_rt_sprhit_inactive
                             	; Active sprite hit = background
f49c : 4c55f6           [ 3] 	jmp df_ost_pushIntA
f49f :                       df_rt_sprhit_inactive
                             	; Inactive sprite hit = -1
f49f : a2ff             [ 2] 	ldx #0xff
f4a1 : 8a               [ 2] 	txa
f4a2 : 4c51f6           [ 3] 	jmp df_ost_pushInt
AS65 Assembler for R6502 [1.42].                                     Page  249
-------------------------------- bank\bank0.s --------------------------------

                             
                             
f4a5 :                       mod_sz_rtsubs_e
                             
                             
                             	include "dflat/proc.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROC.S
                             ;*  dflat module to handle procedures:
                             ;*  - executing a procedure
                             ;*  - find a proc, pass local and non-local param
                             ;*  - return from a proc, unload locals
                             ;*  - save the definition of a proc in the VNT an
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f4a5 :                       mod_sz_proc_s
                             
f4a5 :                       df_rt_proc_parmerr
f4a5 :                       df_rt_deferr
                             	SWBRK DFERR_PROCPARM
                             
                             
                             
                             ; call procedure
f4a7 :                       df_rt_proc
                             	; move past escape token
f4a7 : a488             [ 3] 	ldy df_exeoff
f4a9 : c8               [ 2] 	iny
                             	; Get VVT address X,A and procptr
f4aa : b186             [ 5] 	lda (df_currlin),y
f4ac : aa               [ 2] 	tax
f4ad : c8               [ 2] 	iny
f4ae : b186             [ 5] 	lda (df_currlin),y
f4b0 : c8               [ 2] 	iny
f4b1 : 8488             [ 3] 	sty df_exeoff
f4b3 : 868e             [ 3] 	stx df_procptr
f4b5 : 858f             [ 3] 	sta df_procptr+1
                             	
                             	; is index 0 (held in dim1)
                             	; then need to find the procedure
f4b7 : a003             [ 2] 	ldy #DFVVT_DIM1
f4b9 : b18e             [ 5] 	lda (df_procptr),y
f4bb : d014             [ 3] 	bne df_rt_proc_addr
                             	; find proc
f4bd : 2056e4           [ 6] 	jsr df_rt_findproc
                             	; save y (line index)
f4c0 : 8438             [ 3] 	sty tmp_d
                             	; now go and update the proc vvt address
f4c2 : a002             [ 2] 	ldy #DFVVT_HI
f4c4 : 918e             [ 5] 	sta (df_procptr),y
f4c6 : a001             [ 2] 	ldy #DFVVT_LO
AS65 Assembler for R6502 [1.42].                                     Page  250
-------------------------------- bank\bank0.s --------------------------------

f4c8 : 8a               [ 2] 	txa
f4c9 : 918e             [ 5] 	sta (df_procptr),y
f4cb : a003             [ 2] 	ldy #DFVVT_DIM1
                             	; get back line index in to A
f4cd : a538             [ 3] 	lda tmp_d
f4cf : 918e             [ 5] 	sta (df_procptr),y
f4d1 :                       df_rt_proc_addr
                             	; move past first open bracket
f4d1 : e688             [ 5] 	inc df_exeoff
                             	
                             	; get parm count
f4d3 : a004             [ 2] 	ldy #DFVVT_DIM2
f4d5 : b18e             [ 5] 	lda (df_procptr),y	
f4d7 : f018             [ 3] 	beq df_rt_proc_parm_none
                             	; push the right number of parms on
f4d9 : 48               [ 3] 	pha
                             
f4da : c688             [ 5] 	dec df_exeoff		; Pre-adjust
f4dc :                       df_rt_proc_push_parm
                             	; move past comma or opening bracket
f4dc : e688             [ 5] 	inc df_exeoff
                             	; if at end then error!
f4de : a488             [ 3] 	ldy df_exeoff
f4e0 : b186             [ 5] 	lda (df_currlin),y
f4e2 : c929             [ 2] 	cmp #')'
f4e4 : f0bf             [ 3] 	beq df_rt_proc_parmerr
                             	; else try and evaluate
f4e6 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; get parm count off stack
f4e9 : 68               [ 4] 	pla
                             	; decrement
f4ea : 38               [ 2] 	sec
f4eb : e901             [ 2] 	sbc #1
                             	; and put back on stack
f4ed : 48               [ 3] 	pha
                             	; go back and do all required parms
f4ee : d0ec             [ 3] 	bne df_rt_proc_push_parm
                             	; remove parm counter from stack
f4f0 :                       df_rt_proc_parm_done
f4f0 : 68               [ 4] 	pla
f4f1 :                       df_rt_proc_parm_none
                             	; should be at close bracket
f4f1 : a488             [ 3] 	ldy df_exeoff
f4f3 : b186             [ 5] 	lda (df_currlin),y
f4f5 : c929             [ 2] 	cmp #')'
f4f7 : d0ac             [ 3] 	bne df_rt_proc_parmerr
                             	; should be no more parms
                             	; ok, finally we have all parms on rt stack
                             	; now execute the procedure
                             	; get back the proc address
f4f9 : a68e             [ 3] 	ldx df_procptr
f4fb : a58f             [ 3] 	lda df_procptr+1
                             ;	bne df_rt_exec_proc		; ALWAYS as procptr+1 !=0
                             	
                             ; executing a procedure in VVT slot A,X
f4fd :                       df_rt_exec_proc
                             	; save slot address
f4fd : 86a1             [ 3] 	stx df_tmpptra
f4ff : 85a2             [ 3] 	sta df_tmpptra+1
                             	
                             	; need to save all important vars
f501 : a586             [ 3] 	lda df_currlin
AS65 Assembler for R6502 [1.42].                                     Page  251
-------------------------------- bank\bank0.s --------------------------------

f503 : 48               [ 3] 	pha
f504 : a587             [ 3] 	lda df_currlin+1
f506 : 48               [ 3] 	pha
f507 : a588             [ 3] 	lda df_exeoff
f509 : 48               [ 3] 	pha
f50a : a57f             [ 3] 	lda df_nxtstidx
f50c : 48               [ 3] 	pha
f50d : a580             [ 3] 	lda df_curstidx
f50f : 48               [ 3] 	pha
f510 : a57e             [ 3] 	lda df_eolidx
f512 : 48               [ 3] 	pha
f513 : a593             [ 3] 	lda df_ifnest
f515 : 48               [ 3] 	pha
                             
                             	; now initialise the data
f516 : a001             [ 2] 	ldy #DFVVT_LO
f518 : b1a1             [ 5] 	lda (df_tmpptra),y
f51a : 8586             [ 3] 	sta df_currlin
f51c : c8               [ 2] 	iny
f51d : b1a1             [ 5] 	lda (df_tmpptra),y
f51f : 8587             [ 3] 	sta df_currlin+1
f521 : c8               [ 2] 	iny
f522 : b1a1             [ 5] 	lda (df_tmpptra),y
f524 : 8588             [ 3] 	sta df_exeoff
f526 : 8580             [ 3] 	sta df_curstidx
f528 : a000             [ 2] 	ldy #0		; hmm XXXXX might need to be tay to get 
f52a : b186             [ 5] 	lda (df_currlin),y
f52c : 857f             [ 3] 	sta df_nxtstidx
                             	; now execute statements
f52e : 208ce3           [ 6] 	jsr df_rt_exec_stat
                             ;	bcs df_rt_exec_proc_err
                             	; now restore the position
f531 : 68               [ 4] 	pla
f532 : 8593             [ 3] 	sta df_ifnest
f534 : 68               [ 4] 	pla
f535 : 857e             [ 3] 	sta df_eolidx
f537 : 68               [ 4] 	pla
f538 : 8580             [ 3] 	sta df_curstidx
f53a : 68               [ 4] 	pla
f53b : 857f             [ 3] 	sta df_nxtstidx
f53d : 68               [ 4] 	pla
f53e : 8588             [ 3] 	sta df_exeoff
f540 : 68               [ 4] 	pla
f541 : 8587             [ 3] 	sta df_currlin+1
f543 : 68               [ 4] 	pla
f544 : 8586             [ 3] 	sta df_currlin
                             	; should be all restored, so return
f546 : 60               [ 6] 	rts
                             
                             
f547 :                       df_rt_def
                             	; line offset pointing at DFTK_PROC
                             	; skip over PROC address and open bracket
f547 : a688             [ 3] 	ldx df_exeoff
f549 : e8               [ 2] 	inx
f54a : e8               [ 2] 	inx
f54b : e8               [ 2] 	inx
f54c : 8688             [ 3] 	stx df_exeoff
                             	; parms on stack in reverse order to parm list
                             	; so get each parm and type and save to scratch
f54e : a201             [ 2] 	ldx #1									; index in to scratch
f550 : 868c             [ 3] 	stx df_procargs							; Proc args is the #args-1
AS65 Assembler for R6502 [1.42].                                     Page  252
-------------------------------- bank\bank0.s --------------------------------

f552 : a488             [ 3] 	ldy df_exeoff
f554 :                       df_rt_def_find_var
f554 : c8               [ 2] 	iny
f555 : b186             [ 5] 	lda (df_currlin),y
                             	; check if end of parm list
f557 : c929             [ 2] 	cmp #')'
f559 : f021             [ 3] 	beq df_rt_def_parm_done
                             	; else check if found a variable escape token (<
f55b : c911             [ 2] 	cmp #DFTK_VAR
f55d : f007             [ 3] 	beq df_rt_def_got_var
                             	; else check if non-local specifier
f55f : c926             [ 2] 	cmp #DFTK_VARPARM						; This is a regular ASCII
f561 : d0f1             [ 3] 	bne df_rt_def_find_var
f563 :                       df_rt_def_got_varparm
                             	; set high bit
f563 : 0980             [ 2] 	ora #0x80
                             	; advance over non-local specifier
f565 : c8               [ 2] 	iny
f566 :                       df_rt_def_got_var
f566 : 4980             [ 2] 	eor #0x80			; If was set by '&' qualifier then w
f568 : 9d1306           [ 5] 	sta scratch,x		; Save parm type (by value or ref
                             	; get address and save in scratch
f56b : c8               [ 2] 	iny
f56c : b186             [ 5] 	lda (df_currlin),y
f56e : 9d3306           [ 5] 	sta scratch+32,x	; Hope 32 params is enough! :-)
f571 : c8               [ 2] 	iny
f572 : b186             [ 5] 	lda (df_currlin),y
f574 : 9d5306           [ 5] 	sta scratch+64,x
f577 : e8               [ 2] 	inx
f578 : e68c             [ 5] 	inc df_procargs
f57a : d0d8             [ 3] 	bne df_rt_def_find_var  ; always - relies not ze
f57c :                       df_rt_def_parm_done
                             	; save index that we got to
f57c : 8488             [ 3] 	sty df_exeoff
                             	; save def param list position in temp
f57e : 868b             [ 3] 	stx df_procmode
                             	; all var indices on the operator stack
                             	; now load up variables with parameters
                             	; initially assume no locals
f580 : a900             [ 2] 	lda #0
f582 : 858d             [ 3] 	sta df_procloc
f584 :                       df_rt_def_load_var
f584 : c68c             [ 5] 	dec df_procargs
f586 : f038             [ 3] 	beq df_rt_def_load_var_done
                             	; get var address
f588 : c68b             [ 5] 	dec df_procmode
f58a : a68b             [ 3] 	ldx df_procmode
f58c : bd3306           [ 4] 	lda scratch+32,x
f58f : 85a1             [ 3] 	sta df_tmpptra
f591 : bd5306           [ 4] 	lda scratch+64,x
f594 : 85a2             [ 3] 	sta df_tmpptra+1
                             	
f596 : bd1306           [ 4] 	lda scratch,x
                             	; if MSB is clear then this is not a local varia
                             	; so just go an initialise with stacking
f599 : 1009             [ 3] 	bpl df_rt_def_initialise_parm
                             	; else call the local handling code to 
                             	; push the var address on to the runtime stack
f59b : a6a1             [ 3] 	ldx df_tmpptra
f59d : a5a2             [ 3] 	lda df_tmpptra+1
f59f : 20f4f5           [ 6] 	jsr df_rt_proc_local
                             	; increment number of locals
AS65 Assembler for R6502 [1.42].                                     Page  253
-------------------------------- bank\bank0.s --------------------------------

f5a2 : e68d             [ 5] 	inc df_procloc
f5a4 :                       df_rt_def_initialise_parm
                             	; load type
f5a4 : a000             [ 2] 	ldy #DFVVT_TYPE
f5a6 : b1a1             [ 5] 	lda (df_tmpptra),y
                             	; if array or string type then pop pointer from 
f5a8 : 2984             [ 2] 	and #DFVVT_STR|DFVVT_ARRY
f5aa : f006             [ 3] 	beq df_rt_def_load_var_int
f5ac : 2089f6           [ 6] 	jsr df_ost_popPtr
f5af : 4cb5f5           [ 3] 	jmp df_rt_def_load_var_int_skip
f5b2 :                       df_rt_def_load_var_int
                             	; must be int pop it from operator stack
f5b2 : 2081f6           [ 6] 	jsr df_ost_popInt
f5b5 :                       df_rt_def_load_var_int_skip
                             	; update the variable
f5b5 : a002             [ 2] 	ldy #DFVVT_HI
f5b7 : 91a1             [ 5] 	sta (df_tmpptra),y
f5b9 : 88               [ 2] 	dey
f5ba : 8a               [ 2] 	txa
f5bb : 91a1             [ 5] 	sta (df_tmpptra),y
                             	
f5bd : 4c84f5           [ 3] 	jmp df_rt_def_load_var
f5c0 :                       df_rt_def_load_var_done
                             	; save the number of local parameters found so t
                             	; be unloaded when the proc ends
f5c0 : a58d             [ 3] 	lda df_procloc
f5c2 : 2008f6           [ 6] 	jsr df_rst_pushByte
                             	; continue with next statement
f5c5 : 18               [ 2] 	clc
f5c6 : 60               [ 6] 	rts
                             
                             	
                             ; return a value
f5c7 :                       df_rt_return
                             	; evaluate the return and put on the parameter s
                             	; then process this like an end of procedure
f5c7 : 2077e0           [ 6] 	jsr df_rt_neval
                             ; end def for a proc
f5ca :                       df_rt_enddef
                             	; unload any locals
                             ;	jsr df_rt_proc_unlocal
                             	; nothing to do - main loop will terminate
                             ;	clc
                             ;	rts
                             ; enddef falls through to the unlocal code	
                             	
                             ; unload any local variables from runtime stack
                             ;df_rt_proc_unlocal
f5ca : 2011f6           [ 6] 	jsr df_rst_popByte
f5cd : aa               [ 2] 	tax
f5ce : f020             [ 3] 	beq df_rt_proc_unload_done
f5d0 :                       df_rt_proc_unloadvar
f5d0 : 8a               [ 2] 	txa
f5d1 : 48               [ 3] 	pha
                             	; var value is popped first then index
                             	; get a word and put in tmpb
f5d2 : 202ef6           [ 6] 	jsr df_rst_popWord
f5d5 : 86a3             [ 3] 	stx df_tmpptrb
f5d7 : 85a4             [ 3] 	sta df_tmpptrb+1
                             	; get the var address
f5d9 : 202ef6           [ 6] 	jsr df_rst_popWord
f5dc : 86a1             [ 3] 	stx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  254
-------------------------------- bank\bank0.s --------------------------------

f5de : 85a2             [ 3] 	sta df_tmpptra+1
                             	; store lo byte first
f5e0 : a001             [ 2] 	ldy #DFVVT_LO
f5e2 : a5a3             [ 3] 	lda df_tmpptrb
f5e4 : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; then hi
f5e6 : c8               [ 2] 	iny
f5e7 : a5a4             [ 3] 	lda df_tmpptrb+1
f5e9 : 91a1             [ 5] 	sta (df_tmpptra),y
                             	; restore counter
f5eb : 68               [ 4] 	pla
f5ec : aa               [ 2] 	tax
f5ed : ca               [ 2] 	dex
f5ee : d0e0             [ 3] 	bne df_rt_proc_unloadvar
f5f0 :                       df_rt_proc_unload_done
f5f0 : 68               [ 4] 	pla				; Pull old return address from stack
f5f1 : 68               [ 4] 	pla
f5f2 : 18               [ 2] 	clc
f5f3 : 60               [ 6] 	rts
                             	
                             ; push a local variable to the runtime stack
                             ; X,A = var slot
f5f4 :                       df_rt_proc_local
                             	; save address
f5f4 : 86a1             [ 3] 	stx df_tmpptra
f5f6 : 85a2             [ 3] 	sta df_tmpptra+1
                             	; push var slot on rt stack
f5f8 : 2020f6           [ 6] 	jsr df_rst_pushWord
f5fb :                       df_rt_proc_local_load	
                             	; load x,a with var value lo,hi
f5fb : a001             [ 2] 	ldy #DFVVT_LO
f5fd : b1a1             [ 5] 	lda (df_tmpptra),y
f5ff : aa               [ 2] 	tax
f600 : c8               [ 2] 	iny
f601 : b1a1             [ 5] 	lda (df_tmpptra),y
                             	; push word on to rt stack
f603 : 2020f6           [ 6] 	jsr df_rst_pushWord
f606 : 18               [ 2] 	clc
f607 : 60               [ 6] 	rts
                             		
f608 :                       mod_sz_proc_e
                             
                             
f608 :                       mod_sz_runtime_e
                             
                             
                             
                             	include "dflat/stack.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  STACK.S
                             ;*  This module implements the dflat software sta
                             ;*  needs a few stacks:
                             ;*  - 6502 stack for expression parsing and reent
                             ;*  - dflat runtime stack for things like for/nex
                             ;*  - dflat parameter stack for passing parameter
AS65 Assembler for R6502 [1.42].                                     Page  255
-------------------------------- bank\bank0.s --------------------------------

                             ;*  The two software stacks are implemented in th
                             ;*  with the operator stack growing up from 0 and
                             ;*  runtime stack growing down from 255.  Hopeful
                             ;*  don't meet as there are no checks for this at
                             ;*  purely because I want speed over friendliness
                             ;*  I may come to regret this!
                             ;*  I have also added the only runtime memory all
                             ;*  needed by dflat here.  Humourously I have cal
                             ;*  which is taken from the C language, but it's 
                             ;*  grab some memory after end the of dflat progr
                             ;*  arrays - which of course cannot have storage 
                             ;*  tokenisation time (e.g. because I dimension a
                             ;*  a size from a variable).
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Push a byte on to runtime stack
                             ;* A = byte
                             ;****************************************
f608 :                       df_rst_pushByte
f608 : a476             [ 3] 	ldy df_rtstop
f60a : 990005           [ 5] 	sta df_rtstck,y
f60d : 88               [ 2] 	dey
f60e : 8476             [ 3] 	sty df_rtstop
f610 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f611 :                       df_rst_popByte
f611 : a476             [ 3] 	ldy df_rtstop
f613 : c8               [ 2] 	iny
f614 : b90005           [ 4] 	lda df_rtstck,y
f617 : 8476             [ 3] 	sty df_rtstop
f619 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Peek a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f61a :                       df_rst_peekByte
f61a : a476             [ 3] 	ldy df_rtstop
                             	; Look at what is below top of stack
                             	; below means the next address up as
                             	; this stack grows downwards like 6502
f61c : b90105           [ 4] 	lda df_rtstck+1,y
f61f : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Push a word on to runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f620 :                       df_rst_pushWord
f620 : a476             [ 3] 	ldy df_rtstop
f622 : 990005           [ 5] 	sta df_rtstck,y
f625 : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page  256
-------------------------------- bank\bank0.s --------------------------------

f626 : 8a               [ 2] 	txa
f627 : 990005           [ 5] 	sta df_rtstck,y
f62a : 88               [ 2] 	dey
f62b : 8476             [ 3] 	sty df_rtstop
f62d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a word off runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f62e :                       df_rst_popWord
f62e : a476             [ 3] 	ldy df_rtstop
f630 : c8               [ 2] 	iny
f631 : be0005           [ 4] 	ldx df_rtstck,y
f634 : c8               [ 2] 	iny
f635 : b90005           [ 4] 	lda df_rtstck,y
f638 : 8476             [ 3] 	sty df_rtstop
f63a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push a parameter on to parm stack
                             ;* X,A - int
                             ;* Y - type
                             ;****************************************
f63b :                       df_ost_pushParmX
f63b : 8438             [ 3] 	sty tmp_d		; Save Type
f63d : a477             [ 3] 	ldy df_parmtop	; Get stack index
                             	; push high byte first (A)
f63f : 990005           [ 5] 	sta df_rtstck,y
f642 : c8               [ 2] 	iny
                             	; push low byte next (X)
f643 : 8a               [ 2] 	txa
f644 : 990005           [ 5] 	sta df_rtstck,y
f647 : c8               [ 2] 	iny
f648 : a538             [ 3] 	lda tmp_d		; get Type
f64a : 990005           [ 5] 	sta df_rtstck,y
f64d : c8               [ 2] 	iny
                             	; save new top of stack
f64e : 8477             [ 3] 	sty df_parmtop
f650 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push an int on to parm stack
                             ;* X,A - int
                             ;****************************************
f651 :                       df_ost_pushInt
f651 : a001             [ 2] 	ldy #DFST_INT
f653 : d0e6             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push A on to parm stack
                             ;* X,A - int
                             ;****************************************
f655 :                       df_ost_pushIntA
f655 : a001             [ 2] 	ldy #DFST_INT
f657 : aa               [ 2] 	tax
f658 : a900             [ 2] 	lda #0
f65a : f0df             [ 3] 	beq df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push a string pointer on to parm stack
                             ;* X,A - int
AS65 Assembler for R6502 [1.42].                                     Page  257
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
f65c :                       df_ost_pushStr
f65c : a080             [ 2] 	ldy #DFST_STR
f65e : d0db             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push a general pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f660 :                       df_ost_pushPtr
f660 : a0ff             [ 2] 	ldy #0xff
f662 : d0d7             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             	
                             ;****************************************
                             ;* Pop parameter from the stack
                             ;* X,A - int
                             ;* Y - type expected
                             ;****************************************
f664 :                       df_ost_popParmX
f664 : 98               [ 2] 	tya
f665 : a477             [ 3] 	ldy df_parmtop
                             	; pull type first
f667 : 88               [ 2] 	dey
f668 : 390005           [ 4] 	and df_rtstck,y
f66b : f00c             [ 3] 	beq df_st_typemismatcherr
                             	; pull low byte first
f66d : 88               [ 2] 	dey
f66e : be0005           [ 4] 	ldx df_rtstck,y
                             	; pull high byte next
f671 : 88               [ 2] 	dey
f672 : b90005           [ 4] 	lda df_rtstck,y
                             	; save new top of stack
f675 : 8477             [ 3] 	sty df_parmtop
f677 : 18               [ 2] 	clc
f678 : 60               [ 6] 	rts
f679 :                       df_st_typemismatcherr
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ;****************************************
                             ;* Return type on top of stack
                             ;* A - type
                             ;****************************************
f67b :                       df_ost_peekType
f67b : a477             [ 3] 	ldy df_parmtop
f67d : b9ff04           [ 4] 	lda df_rtstck-1,y
f680 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop an int off parm stack
                             ;* X,A - int
                             ;****************************************
f681 :                       df_ost_popInt
f681 : a001             [ 2] 	ldy #DFST_INT
f683 : d0df             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             
                             ;****************************************
                             ;* Pop a string pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f685 :                       df_ost_popStr
f685 : a080             [ 2] 	ldy #DFST_STR
AS65 Assembler for R6502 [1.42].                                     Page  258
-------------------------------- bank\bank0.s --------------------------------

f687 : d0db             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             	
                             ;****************************************
                             ;* Pop a general pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f689 :                       df_ost_popPtr
f689 : a0ff             [ 2] 	ldy #0xff
f68b : d0d7             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             	
                             	
                             ;****************************************
                             ;* Allocate space on the heap
                             ;* X, A = Number of bytes to allocate
                             ;* X, A return address of allocated space
                             ;****************************************
f68d :                       df_st_malloc
                             	; save A in Y
f68d : a8               [ 2] 	tay
                             	; save old starend
f68e : a575             [ 3] 	lda df_starend+1
f690 : 48               [ 3] 	pha
f691 : a574             [ 3] 	lda df_starend
f693 : 48               [ 3] 	pha
                             	; restore A from Y
f694 : 98               [ 2] 	tya
                             	; add X,A to starend
f695 : 48               [ 3] 	pha
f696 : 8a               [ 2] 	txa
f697 : 18               [ 2] 	clc
f698 : 6574             [ 3] 	adc df_starend
f69a : 8574             [ 3] 	sta df_starend
f69c : 68               [ 4] 	pla
f69d : 6575             [ 3] 	adc df_starend+1
f69f : 8575             [ 3] 	sta df_starend+1
                             	; return old starend as start of space
f6a1 : 68               [ 4] 	pla
f6a2 : aa               [ 2] 	tax
f6a3 : 68               [ 4] 	pla
f6a4 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* df_init
                             ;* Initialise dflat language settings
                             ;****************************************
f6a5 :                       df_init
                             	; Initialise top of memory to default
                             	; This can be overridden by himem command
f6a5 : a900             [ 2] 	lda #lo(DF_MEMTOP)
f6a7 : 8d1106           [ 4] 	sta df_memtop
f6aa : a998             [ 2] 	lda #hi(DF_MEMTOP)
f6ac : 8d1206           [ 4] 	sta df_memtop+1
                             
                             	; Init program space
f6af : 4cb2f6           [ 3] 	jmp df_clear
                             
                             	; Initialise assembler
                             ;	jsr asm_init
                             
                             ;	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  259
-------------------------------- bank\bank0.s --------------------------------

                             
                             ;****************************************
                             ;* df_clear
                             ;* Initialise program space
                             ;****************************************
f6b2 :                       df_clear
                             	; Start of program space
f6b2 : a913             [ 2] 	lda #lo(DF_PROGSTART)
f6b4 : 8565             [ 3] 	sta df_prgstrt
f6b6 : 8567             [ 3] 	sta df_prgend
f6b8 : a907             [ 2] 	lda #hi(DF_PROGSTART)
f6ba : 8566             [ 3] 	sta df_prgstrt+1
f6bc : 8568             [ 3] 	sta df_prgend+1
                             	; Terminal value in prog space
f6be : a900             [ 2] 	lda #0
f6c0 : a8               [ 2] 	tay
f6c1 : 9165             [ 5] 	sta (df_prgstrt),y
                             	; No variables - zero the count
f6c3 : 8571             [ 3] 	sta df_varcnt
                             
                             	; Variable value table
                             	; Grows down from mem top
f6c5 : ad1106           [ 4] 	lda df_memtop
f6c8 : 856d             [ 3] 	sta df_vvtstrt
f6ca : 856f             [ 3] 	sta df_vvtend
f6cc : ad1206           [ 4] 	lda df_memtop+1
f6cf : 856e             [ 3] 	sta df_vvtstrt+1
f6d1 : 8570             [ 3] 	sta df_vvtend+1
                             
                             	; Variable name table
                             	; Grows down from mem top
f6d3 : a56d             [ 3] 	lda df_vvtstrt
f6d5 : 8569             [ 3] 	sta df_vntstrt
f6d7 : 856b             [ 3] 	sta df_vntend
f6d9 : a56e             [ 3] 	lda df_vvtstrt+1
f6db : 856a             [ 3] 	sta df_vntstrt+1
f6dd : 856c             [ 3] 	sta df_vntend+1
                             
                             	; String accumulator
f6df : a913             [ 2] 	lda #lo(scratch)
f6e1 : 857a             [ 3] 	sta df_sevalptr
f6e3 : a906             [ 2] 	lda #hi(scratch)
f6e5 : 857b             [ 3] 	sta df_sevalptr+1
                             
f6e7 : 60               [ 6] 	rts
                             
f6e8 :                       mod_sz_dflat_e
                             
                             	include "dflat/error.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.S
                             ;*  Error handling module.
                             ;*  Whan an error is thrown using BRK, this modul
                             ;*  displaying the error plus any associated line
                             ;*  if it was running a program.  It then resets 
AS65 Assembler for R6502 [1.42].                                     Page  260
-------------------------------- bank\bank0.s --------------------------------

                             ;*  settings and takes the system back to program
                             ;*  mode.  The message uses the general IO handle
                             ;*  output must be set to the right place else fo
                             ;*	the error message will be written to tape!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             	include "dflat/error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ; Error message table, each msg null terminated
f6e8 :                       df_tk_errortab
f6e8 : 4f6b00                	db	"Ok", 0
f6eb : 53796e74617800        	db	"Syntax", 0
AS65 Assembler for R6502 [1.42].                                     Page  261
-------------------------------- bank\bank0.s --------------------------------

f6f2 : 5479706500            	db	"Type", 0
f6f7 : 52652d64696d00        	db	"Re-dim", 0
f6fe : 4e6f2072657065..      	db	"No repeat", 0
f708 : 4e6f206465666e00      	db	"No defn", 0
f710 : 5061726d00            	db	"Parm", 0
f715 : 456e64656400          	db	"Ended", 0
f71b : 4e6f20656e6469..      	db	"No endif", 0
f724 : 4e6f20696600          	db	"No if", 0
f72a : 4e6f20666f7200        	db	"No for", 0
f731 : 4e6f7420666f75..      	db	"Not found", 0
f73b : 546f6f206c6f6e..      	db	"Too long", 0
f744 : 427265616b00          	db	"Break", 0
f74a : 4e6f206461746100      	db	"No data", 0
f752 : 4e6f207768696c..      	db	"No while", 0
f75b : 4e6f206c696e6500      	db	"No line", 0
f763 : 4e6f2072657475..      	db	"No return ", 0
f76e : 41626f7274656400      	db	"Aborted", 0
f776 : 426f756e647300        	db	"Bounds", 0
f77d : 4e6f206f726700        	db	"No org", 0
f784 : 00                    	db	0
                             
f785 :                       df_tk_error_inline
f785 : 20696e206c696e..      	db	" in line ", 0
f78f :                       df_tk_error_atpos
f78f : 20706f732000          	db	" pos ", 0
f795 :                       df_tk_error_error
f795 : 206572726f7200        	db	" error", 0
                             
                             ;****************************************
                             ;* df_trap_error
                             ;* Show an error message
                             ;* errno is error number
                             ;* currlin = Line number
                             ;* exeoff = offset
                             ;* at the end jump to program editor
                             ;****************************************
f79c :                       df_trap_error
                             	; set IO back to normal
f79c : 2025c5           [ 6] 	jsr init_via0
f79f : 2028c4           [ 6] 	jsr io_set_default
f7a2 : 58               [ 2] 	cli
                             
f7a3 : a9e8             [ 2] 	lda #lo(df_tk_errortab)
f7a5 : 85a1             [ 3] 	sta df_tmpptra
f7a7 : a9f6             [ 2] 	lda #hi(df_tk_errortab)
f7a9 : 85a2             [ 3] 	sta df_tmpptra+1
f7ab : a65d             [ 3] 	ldx errno				; 0 or >=128 goes to monitor
f7ad : f002             [ 3] 	beq df_trap_go_monitor
f7af : 1003             [ 3] 	bpl df_trap_normal
f7b1 :                       df_trap_go_monitor
f7b1 : 4c2af8           [ 3] 	jmp df_trap_monitor
f7b4 :                       df_trap_normal
f7b4 : a000             [ 2] 	ldy #0
f7b6 :                       df_show_err_find
                             	; If on a zero, then error table exhausted
                             	; so drop in to the monitor
f7b6 : b1a1             [ 5] 	lda (df_tmpptra),y
f7b8 : f070             [ 4] 	beq df_trap_monitor
                             	; Skip over this error text including zero termi
f7ba :                       df_show_err_skip
                             	_incZPWord df_tmpptra
                             
AS65 Assembler for R6502 [1.42].                                     Page  262
-------------------------------- bank\bank0.s --------------------------------

f7c0 : b1a1             [ 5] 	lda (df_tmpptra),y
f7c2 : d0f6             [ 3] 	bne df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f7ca : ca               [ 2] 	dex
f7cb : d0e9             [ 3] 	bne df_show_err_find
                             	; Error message found
f7cd : a6a1             [ 3] 	ldx df_tmpptra
f7cf : a5a2             [ 3] 	lda df_tmpptra+1
f7d1 : 20a2c4           [ 6] 	jsr io_print_line
f7d4 : a295             [ 2] 	ldx #lo(df_tk_error_error)
f7d6 : a9f7             [ 2] 	lda #hi(df_tk_error_error)
f7d8 : 20a2c4           [ 6] 	jsr io_print_line
                             	; if line number <> 0 then print it
f7db : a001             [ 2] 	ldy #DFTK_LINNUM
f7dd : b186             [ 5] 	lda (df_currlin),y
f7df : aa               [ 2] 	tax
f7e0 : c8               [ 2] 	iny
f7e1 : b186             [ 5] 	lda (df_currlin),y
f7e3 : d004             [ 3] 	bne df_show_err_linnum
f7e5 : e000             [ 2] 	cpx #0x00
f7e7 : f019             [ 4] 	beq df_show_err_fin
f7e9 :                       df_show_err_linnum
                             	_println df_tk_error_inline
                             
f7fe : 18               [ 2] 	clc
f7ff : 20fdc3           [ 6] 	jsr print_a_to_d
f802 :                       df_show_err_fin
f802 : a488             [ 3] 	ldy df_exeoff
f804 : f01d             [ 3] 	beq df_show_err_done
                             	_println df_tk_error_atpos
                             
f81b : 98               [ 2] 	tya
f81c : aa               [ 2] 	tax
f81d : a900             [ 2] 	lda #0
f81f : 18               [ 2] 	clc
f820 : 20fdc3           [ 6] 	jsr print_a_to_d
f823 :                       df_show_err_done
f823 : 207bc1           [ 6] 	jsr utilPrintCRLF
f826 : 18               [ 2] 	clc
                             	; back to editor
f827 : 4c5adf           [ 3] 	jmp df_pg_dflat
                             
                             
                             ; For unknown errors, jump to monitor
f82a :                       df_trap_monitor
                             	; Print PC
                             	_println_low df_msg_pc
                             
f831 : a563             [ 3] 	lda df_brkpc+1
f833 : 2083c1           [ 6] 	jsr utilPrintA
f836 : a562             [ 3] 	lda df_brkpc
f838 : 2083c1           [ 6] 	jsr utilPrintA
f83b : 2073c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print A
                             	_println_low df_msg_acc
                             
f845 : a53d             [ 3] 	lda num_a
f847 : 2083c1           [ 6] 	jsr utilPrintA
f84a : 2073c1           [ 6] 	jsr utilPrintSPC
                             
AS65 Assembler for R6502 [1.42].                                     Page  263
-------------------------------- bank\bank0.s --------------------------------

                             	; Print X
                             	_println_low df_msg_xreg
                             
f854 : a53e             [ 3] 	lda num_a+1
f856 : 2083c1           [ 6] 	jsr utilPrintA
f859 : 2073c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print Y
                             	_println_low df_msg_yreg
                             
f863 : a53f             [ 3] 	lda num_a+2
f865 : 2083c1           [ 6] 	jsr utilPrintA
f868 : 207bc1           [ 6] 	jsr utilPrintCRLF
                             
f86b : 20a0e7           [ 6] 	jsr df_rt_monitor
                             	; back to editor
f86e : 4c5adf           [ 3] 	jmp df_pg_dflat
                             
f871 :                       df_msg_pc
f871 : 50433a00              	db "PC:\x0"
f875 :                       df_msg_acc
f875 : 413a00                	db "A:\x0"
f878 :                       df_msg_xreg
f878 : 583a00                	db "X:\x0"
f87b :                       df_msg_yreg
f87b : 593a00                	db "Y:\x0"
                             
                             	include	"dflat/asm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*  This is the main controller code file for the
                             ;*  This file includes all the required source fi
                             ;*	in addition to dflat.s
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
f87e :                       mod_sz_asm_s
                             
                             	;	dflat.s is already included, so just the addit
                             	include "dflat/asm.i"
                             ;* Addressing modes - 15 in total, 16 with direct
                             ;*  0   Nothing
                             ;*	1 	Absolute			XXX <word>
                             ;*	2 	Absolute,X			XXX <word>,x
                             ;*	3 	Absolute,Y			XXX <word>,y
                             ;*	4	Zeropage			XXX	<byte>
                             ;*	5	Zeropage,X			XXX	<byte>,x
                             ;*	6	Zeropage,Y			XXX	<byte>,y
                             ;*	7	Indirect			XXX	(<byte>)
                             ;*	8	Indirect,X			XXX	(<byte>,x)
                             ;*	9	Indirect,Y			XXX	(<byte>),y
                             ;*	A	Absolute indirect	XXX	(<word>)
AS65 Assembler for R6502 [1.42].                                     Page  264
-------------------------------- bank\bank0.s --------------------------------

                             ;*	B	Absolute indirect,x	XXX	(<word>,x)
                             ;*	C	Immediate			XXX #<byte>
                             ;*	D	Accumulator			XXX (same as implied)
                             ;*	E	Implied				XXX
                             ;*	F	Relative			XXX	<byte>
                             ;*	10	Assembler directive	XXX .......
                             
0000 =                       AM_NONE		= 0
0001 =                       AM_ABS	 	= 1
0002 =                       AM_ABSX		= 2
0003 =                       AM_ABSY		= 3
0004 =                       AM_ZP		= 4
0005 =                       AM_ZPX		= 5
0006 =                       AM_ZPY		= 6
0007 =                       AM_ZPIND	= 7
0008 =                       AM_ZPINDX	= 8
0009 =                       AM_ZPINDY	= 9
000a =                       AM_ABSIND	= 10
000b =                       AM_ABSINDX	= 11
000c =                       AM_IMM		= 12
000d =                       AM_ACC		= 13
000d =                       AM_IMP		= AM_ACC
000f =                       AM_REL		= 15
0010 =                       AM_DIR		= 16
                             
                             
                             
                             	include "dflat/tkasm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*	Module that implements tokenisation of the ass
                             ;* 	The assembler is an extension to dflat, almos
                             ;*	almost a language within a language, as it has
                             ;*	own symbol tables to allow adding new keywords
                             ;*	running out of space in the main symtol table 
                             ;*	for normal 6502 asembler syntax which is at od
                             ;*	regular dflat.
                             ;*	Hence, this module has to do its own additiona
                             ;*	to tokenise the assembly.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f87e :                       mod_sz_tkasm_s
                             
                             	; if didn't find regular keywords then try assen
f87e :                       df_tk_asm_parse_command
                             	; skip the white space after the dot
f87e : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; find the assembler symbol
f881 : 20acf8           [ 6] 	jsr df_tk_asm_matchtok
                             	; if not found then must be a label assignment
f884 : b021             [ 3] 	bcs df_tk_asm_parse_command_symbol
AS65 Assembler for R6502 [1.42].                                     Page  265
-------------------------------- bank\bank0.s --------------------------------

                             	; Get the assembler symbol and put the token
f886 : a583             [ 3] 	lda df_symoff
                             	; Set the MSB
f888 : 0980             [ 2] 	ora #0x80
f88a : 20b7d6           [ 6] 	jsr df_tk_put_tok
                             	; check the first addressing mode code
                             	; remember to jump over the offset byte
f88d : a001             [ 2] 	ldy #1
f88f : b181             [ 5] 	lda (df_symtab),y
                             	; Directive?
f891 : c910             [ 2] 	cmp #AM_DIR
f893 : d00c             [ 3] 	bne df_tk_asm_mnemonic
                             	; if directive then process it
f895 : a583             [ 3] 	lda df_symoff
f897 : 2003f9           [ 6] 	jsr df_tk_asm_exec_parser
f89a : b004             [ 3] 	bcs df_tk_asm_parse_command_err
                             	; [1] ignore white space but keep it
f89c : 2008d7           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
f89f : 18               [ 2] 	clc
f8a0 :                       df_tk_asm_parse_command_err
f8a0 : 60               [ 6] 	rts
f8a1 :                       df_tk_asm_mnemonic
                             	; for all nmemonics, work out the addressing mod
f8a1 : 2012f9           [ 6] 	jsr df_tk_asm_addr_mode
f8a4 : b0fa             [ 3] 	bcs df_tk_asm_parse_command_err
f8a6 : 60               [ 6] 	rts
f8a7 :                       df_tk_asm_parse_command_symbol
                             	; No mask
f8a7 : a900             [ 2] 	lda #0
f8a9 : 4ce2d7           [ 3] 	jmp df_tk_var
                             
                             
                             ;****************************************
                             ;* df_tk_asm_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
f8ac :                       df_tk_asm_matchtok
                             	; Start at token symbols beginning
f8ac : a995             [ 2] 	lda #lo(df_asm_tokensyms)
f8ae : 8581             [ 3] 	sta df_symtab
f8b0 : a9fc             [ 2] 	lda #hi(df_asm_tokensyms)
f8b2 : 8582             [ 3] 	sta df_symtab+1
f8b4 : a900             [ 2] 	lda #0
f8b6 : 8583             [ 3] 	sta df_symoff
f8b8 : a200             [ 2] 	ldx #0
f8ba :                       df_tk_asm_checknexttok
                             	; From the line buffer current pointer
                             	; Check for a token match
f8ba : a47c             [ 3] 	ldy df_linoff
f8bc :                       df_tk_asm_checktokch
                             	; Get symtable char
f8bc : a181             [ 6] 	lda (df_symtab,x)
                             	; if less than ascii ' ' then reached end of
                             	; this symbol and everything matched so found!
f8be : c920             [ 2] 	cmp #' '
f8c0 : 9033             [ 3] 	bcc df_tk_asm_symfound
                             	; Else compare with current line buffer char
AS65 Assembler for R6502 [1.42].                                     Page  266
-------------------------------- bank\bank0.s --------------------------------

f8c2 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
f8c5 : d00a             [ 3] 	bne df_tk_asm_symnomatch
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
f8cd : c8               [ 2] 	iny
f8ce : 4cbcf8           [ 3] 	jmp df_tk_asm_checktokch
f8d1 :                       df_tk_asm_symnomatch
                             	; Increment symbol counter to next symbol
f8d1 : e683             [ 5] 	inc df_symoff
f8d3 :                       df_tk_asm_symnextentry
f8d3 : a181             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is < ' '
f8d5 : c920             [ 2] 	cmp #' '
f8d7 : 9009             [ 3] 	bcc  df_tk_asm_foundsymend
                             	_incZPWord df_symtab
                             
f8df : 4cd3f8           [ 3] 	jmp df_tk_asm_symnextentry
f8e2 :                       df_tk_asm_foundsymend
                             	; Now at the offset to jump over addressing
                             	; mode and opcode values. Add offset to ptr
                             	; remember than C is clear and A has offset
                             	; set C so always jump over the offset
f8e2 : 38               [ 2] 	sec
f8e3 : 6581             [ 3] 	adc df_symtab
f8e5 : 8581             [ 3] 	sta df_symtab
f8e7 : a582             [ 3] 	lda df_symtab+1
f8e9 : 6900             [ 2] 	adc #0
f8eb : 8582             [ 3] 	sta df_symtab+1
                             	; If next char is not zero then
                             	; try and match with line buffer
f8ed : a181             [ 6] 	lda (df_symtab,x)
f8ef : d0c9             [ 3] 	bne df_tk_asm_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
f8f1 : 8583             [ 3] 	sta df_symoff		; Relies on A=0
                             	; Set C to indicate error (no match)
f8f3 : 38               [ 2] 	sec
f8f4 : 60               [ 6] 	rts
f8f5 :                       df_tk_asm_symfound
                             	; Full match with keyword in symtable but
                             	; check the next buffer char is not alphanum
                             	; as this could be part of a symbol
                             	; Point to next buffer char in any case
                             	; y already points to char after keyword
f8f5 : b90004           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
f8f8 : 20fcd6           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
f8fb : b0d4             [ 3] 	bcs df_tk_asm_symnomatch
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
f8fd : 847c             [ 3] 	sty df_linoff
f8ff : a583             [ 3] 	lda df_symoff
                             	; df_symtab points to the offset
f901 :                       df_tk_asm_addr_mode_ok
f901 : 18               [ 2] 	clc
f902 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  267
-------------------------------- bank\bank0.s --------------------------------

                             ;****************************************
                             ;* df_tk_asm_exec_parser
                             ;* Execute parse routine for this statement
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f903 :                       df_tk_asm_exec_parser
f903 : 0a               [ 2] 	asl a
f904 : aa               [ 2] 	tax
f905 : bdc1fe           [ 4] 	lda df_tk_asm_tokenjmp,x
f908 : 85a1             [ 3] 	sta df_tmpptra
f90a : bdc2fe           [ 4] 	lda df_tk_asm_tokenjmp+1,x
f90d : 85a2             [ 3] 	sta df_tmpptra+1
f90f : 6ca100           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* df_tk_asm_addr_mode
                             ;* Tokenise the addressing mode
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
f912 :                       df_tk_asm_addr_mode
f912 : 2008d7           [ 6] 	jsr df_tk_skip_ws		;Skip whitespace
f915 : c900             [ 2] 	cmp #0					;End of line?
f917 : f0e8             [ 3] 	beq df_tk_asm_addr_mode_ok
f919 : c93a             [ 2] 	cmp #':'				;End of statement?
f91b : f0e4             [ 3] 	beq df_tk_asm_addr_mode_ok
f91d : a923             [ 2] 	lda #'#'				; Check for immediate
f91f : 202cd7           [ 6] 	jsr df_tk_expect_tok
f922 : b003             [ 3] 	bcs df_tk_asm_addr_mode_1
f924 : 4c47f9           [ 3] 	jmp df_tk_imm		; Process immediate
f927 :                       df_tk_asm_addr_mode_1
f927 : a928             [ 2] 	lda #'('				; One of indirect modes?
f929 : 202cd7           [ 6] 	jsr df_tk_expect_tok
f92c : b003             [ 3] 	bcs df_tk_asm_addr_mode_2
f92e : 4c4af9           [ 3] 	jmp df_tk_indirect
f931 :                       df_tk_asm_addr_mode_2
                             	; here just a regular address
                             	; Just one expression expected
f931 : 2029d9           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f934 : a92c             [ 2] 	lda #','
f936 : 202cd7           [ 6] 	jsr df_tk_expect_tok
f939 : b0c6             [ 3] 	bcs df_tk_asm_addr_mode_ok
                             	; must be x or y
f93b : a978             [ 2] 	lda #'x'
f93d : 202cd7           [ 6] 	jsr df_tk_expect_tok
f940 : 90bf             [ 3] 	bcc df_tk_asm_addr_mode_ok
                             	; got to here, must be y
f942 : a979             [ 2] 	lda #'y'
f944 : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             	
                             	
                             ;* Tokenise immediate addressing mode	
f947 :                       df_tk_imm
                             	; Just one expression expected
f947 : 4c29d9           [ 3] 	jmp df_tk_expression
                             	
                             ;* Tokenise indirect
f94a :                       df_tk_indirect
                             	; Just one expression expected
AS65 Assembler for R6502 [1.42].                                     Page  268
-------------------------------- bank\bank0.s --------------------------------

f94a : 2029d9           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
f94d : a92c             [ 2] 	lda #','
f94f : 202cd7           [ 6] 	jsr df_tk_expect_tok
                             	; if not then might be indirect Y
f952 : b00a             [ 3] 	bcs df_tk_indirect_y
                             	; Else must have be indirect "x)"
f954 : a978             [ 2] 	lda #'x'
f956 : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
f959 : a929             [ 2] 	lda #')'
f95b : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             	
f95e :                       df_tk_indirect_y
                             	; Definitely has a close bracket
f95e : a929             [ 2] 	lda #')'
f960 : 2037d7           [ 6] 	jsr df_tk_expect_tok_err
                             	; Is there a comma after the expression
f963 : a92c             [ 2] 	lda #','
f965 : 202cd7           [ 6] 	jsr df_tk_expect_tok
f968 : b005             [ 3] 	bcs df_tk_indirect_done
                             	; if comma then must be indirect y
f96a : a979             [ 2] 	lda #'y'
f96c : 4c37d7           [ 3] 	jmp df_tk_expect_tok_err
                             
f96f :                       df_tk_indirect_done
f96f : 18               [ 2] 	clc
f970 : 60               [ 6] 	rts
                             	
                             
                             	
                             
                             
                             ;************************************************
                             ;*           TOKENISATION SUBROUTINES
                             ;************************************************
                             
                             
                             ;* HANDLE DIRECTIVES
                             
                             ;* All tokenisation is part of regular toksub rou
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  269
-------------------------------- bank\bank0.s --------------------------------

                             
                             
                             
                             
                             
                             
f971 :                       mod_sz_tkasm_e
                             
                             
                             	include "dflat/rtasm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTASM.S
                             ;*  Module that implements the runtime execution 
                             ;*  assembler.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f971 :                       mod_sz_rtasm_s
                             
f971 :                       df_rt_asm_assemble
                             	; check if >=0x80 (directive or mnemonic)
f971 : a488             [ 3] 	ldy df_exeoff
f973 : b186             [ 5] 	lda (df_currlin),y
f975 : 1009             [ 3] 	bpl df_rt_asm_do_label
f977 : 2084f9           [ 6] 	jsr df_rt_asm_command
f97a : 2079fb           [ 6] 	jsr df_rt_asm_printCR
f97d : 4c83f9           [ 3] 	jmp df_rt_asm_assemble_done
f980 :                       df_rt_asm_do_label
f980 : 20a8f9           [ 6] 	jsr df_rt_asm_label
f983 :                       df_rt_asm_assemble_done
                             	; any clean up here
f983 : 60               [ 6] 	rts
                             
                             ; Jump to mnemonic or 
                             ; directive with index in A ignoring MSB
f984 :                       df_rt_asm_command
f984 : 297f             [ 2] 	and #0x7f
f986 : 48               [ 3] 	pha
f987 : aa               [ 2] 	tax
                             	; Point to Xth symtable entry of addr modes and 
f988 : 2047fc           [ 6] 	jsr df_rt_asm_skip_to_sym
                             
                             	; Get first addressing mode (ignoring offset byt
f98b : a001             [ 2] 	ldy #1
f98d : b181             [ 5] 	lda (df_symtab),y
                             	; is it a directive?
f98f : c910             [ 2] 	cmp #AM_DIR
                             	; if directive
f991 : f003             [ 3] 	beq df_rt_asm_dir
                             	; Else must be a normal mnemonic
f993 : 4c6dfa           [ 3] 	jmp df_rt_asm_mnem
                             
AS65 Assembler for R6502 [1.42].                                     Page  270
-------------------------------- bank\bank0.s --------------------------------

                             ; Jump to the appropriate directive
f996 :                       df_rt_asm_dir
                             	; Get the index and *2
                             	; to get jump vector
f996 : 68               [ 4] 	pla
f997 : 0a               [ 2] 	asl a
f998 : aa               [ 2] 	tax
                             	; jump over directive code
f999 : e688             [ 5] 	inc df_exeoff
                             	; jump to directive handler
f99b : bdcbfe           [ 4] 	lda df_rt_asm_tokenjmp,x
f99e : 85a1             [ 3] 	sta df_tmpptra
f9a0 : bdccfe           [ 4] 	lda df_rt_asm_tokenjmp+1,x
f9a3 : 85a2             [ 3] 	sta df_tmpptra+1
f9a5 : 6ca100           [ 6] 	jmp (df_tmpptra)
                             
                             ; Process label
                             ; Set the label to the PC
f9a8 :                       df_rt_asm_label
                             	; Get the address of the variable in A,X
f9a8 : 20a4ec           [ 6] 	jsr df_rt_generate_lvar
f9ab : 869e             [ 3] 	stx df_asmoprnd
f9ad : 859f             [ 3] 	sta df_asmoprnd+1
                             	; Assign to value of PC
f9af : a000             [ 2] 	ldy #0
f9b1 : a599             [ 3] 	lda df_asmpc
f9b3 : 919e             [ 5] 	sta (df_asmoprnd),y
f9b5 : a59a             [ 3] 	lda df_asmpc+1
f9b7 : c8               [ 2] 	iny
f9b8 : 919e             [ 5] 	sta (df_asmoprnd),y
f9ba : 60               [ 6] 	rts	
                             
                             ;* Set the code origin
f9bb :                       df_rt_asm_org
                             	; Get the address from expression
f9bb : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to PC
f9be : a59e             [ 3] 	lda df_asmoprnd
f9c0 : 8599             [ 3] 	sta df_asmpc
f9c2 : a59f             [ 3] 	lda df_asmoprnd+1
f9c4 : 859a             [ 3] 	sta df_asmpc+1
f9c6 : a903             [ 2] 	lda #3
f9c8 : 85a0             [ 3] 	sta df_asmlen
f9ca : 4c3bfb           [ 3] 	jmp df_rt_asm_printPC
                             
                             ; Set the assembly option
                             ; Bit 0 set = Print code to console
                             ; But 1 set = Write code to memory
                             ; Be sure to run 2 non-write passes
                             ; before a write pass
                             ; First pass may result in ZP used a lot
                             ; Second pass resolves forward refs to ABS
                             ; Final write pass then stores the code
f9cd :                       df_rt_asm_opt
                             	; Get the value from expression
f9cd : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to OPT
f9d0 : a59e             [ 3] 	lda df_asmoprnd
f9d2 : 859b             [ 3] 	sta df_asmopt
f9d4 : 60               [ 6] 	rts
                             
                             ; dw and db handled here
AS65 Assembler for R6502 [1.42].                                     Page  271
-------------------------------- bank\bank0.s --------------------------------

                             ; keep going through comma separated
                             ; list and write bytes or words
                             ; string expansion also handled
f9d5 :                       df_rt_asm_db
f9d5 : a902             [ 2] 	lda #2
f9d7 : 2c                    	db	0x2c			; BIT abs to ignore next 2 bytes
f9d8 :                       df_rt_asm_dw
f9d8 : a903             [ 2] 	lda #3
f9da :                       df_rt_asm_db_start
f9da : 85a0             [ 3] 	sta df_asmlen
f9dc : 203bfb           [ 6] 	jsr df_rt_asm_printPC
f9df : 2056fb           [ 6] 	jsr df_rt_asm_printSPC
f9e2 :                       df_rt_asm_data
f9e2 : 2077e0           [ 6] 	jsr df_rt_neval		; Evaluate expression
f9e5 : 207bf6           [ 6] 	jsr df_ost_peekType	; What is the type
f9e8 : a8               [ 2] 	tay
f9e9 : 300d             [ 3] 	bmi df_rt_asm_string; If string
f9eb : 2081f6           [ 6] 	jsr df_ost_popInt	; else get number in A,X
f9ee : 869e             [ 3] 	stx df_asmoprnd		; store low value
f9f0 : 859f             [ 3] 	sta df_asmoprnd+1	; store high value
f9f2 : 2020fa           [ 6] 	jsr df_rt_asm_data_write
f9f5 : 4c15fa           [ 3] 	jmp df_rt_asm_data_next
f9f8 :                       df_rt_asm_string
f9f8 : 2089f6           [ 6] 	jsr df_ost_popPtr	; pop string pointer
f9fb : 86a1             [ 3] 	stx df_tmpptra		; save pointer to tmpa
f9fd : 85a2             [ 3] 	sta df_tmpptra+1
f9ff :                       df_rt_asm_string_ch
f9ff : a000             [ 2] 	ldy #0
fa01 : b1a1             [ 5] 	lda (df_tmpptra),y	; Get string char, 0=done
fa03 : f010             [ 3] 	beq df_rt_asm_data_next
fa05 : 859e             [ 3] 	sta df_asmoprnd		; Save as operand
fa07 : 849f             [ 3] 	sty df_asmoprnd+1	; High is always zero
fa09 : 2020fa           [ 6] 	jsr df_rt_asm_data_write
                             	_incZPWord df_tmpptra
                             
fa12 : 4cfff9           [ 3] 	jmp df_rt_asm_string_ch
fa15 :                       df_rt_asm_data_next
fa15 : 20daec           [ 6] 	jsr df_rt_eos		; End?
fa18 : b005             [ 3] 	bcs df_rt_asm_data_done
fa1a : e688             [ 5] 	inc df_exeoff		; Jump over ','
fa1c : 4ce2f9           [ 3] 	jmp df_rt_asm_data
fa1f :                       df_rt_asm_data_done
fa1f : 60               [ 6] 	rts	
                             
                             ; Write one db or dw value
                             ; Check for value too big for db
                             ; Advance PC by df_asmlen
fa20 :                       df_rt_asm_data_write
fa20 : 205ffb           [ 6] 	jsr df_rt_asm_printOPR
fa23 :                       df_rt_asm_data_write_skip1
fa23 : a902             [ 2] 	lda #2
fa25 : 259b             [ 3] 	and df_asmopt
fa27 : f017             [ 3] 	beq df_rt_asm_data_write_skip2
fa29 : a59e             [ 3] 	lda df_asmoprnd
fa2b : a000             [ 2] 	ldy #0
fa2d : 9199             [ 5] 	sta (df_asmpc),y
fa2f : c8               [ 2] 	iny
fa30 : a902             [ 2] 	lda #2
fa32 : c5a0             [ 3] 	cmp df_asmlen
fa34 : d006             [ 3] 	bne df_rt_asm_data_write_hi
fa36 : a59f             [ 3] 	lda df_asmoprnd+1
fa38 : d014             [ 3] 	bne df_rt_asm_data_write_err
AS65 Assembler for R6502 [1.42].                                     Page  272
-------------------------------- bank\bank0.s --------------------------------

fa3a : f004             [ 3] 	beq df_rt_asm_data_write_skip2
fa3c :                       df_rt_asm_data_write_hi
fa3c : a59f             [ 3] 	lda df_asmoprnd+1
fa3e : 9199             [ 5] 	sta (df_asmpc),y
fa40 :                       df_rt_asm_data_write_skip2
fa40 : a4a0             [ 3] 	ldy df_asmlen
fa42 : 88               [ 2] 	dey					; Add 1 less!
fa43 : 98               [ 2] 	tya
fa44 : 18               [ 2] 	clc
fa45 : 6599             [ 3] 	adc df_asmpc
fa47 : 8599             [ 3] 	sta df_asmpc
                             	_bcc 2
                             
fa4b : e69a             [ 5] 	inc df_asmpc+1
fa4d : 60               [ 6] 	rts
fa4e :                       df_rt_asm_data_write_err	
                             	SWBRK DFERR_QUANTITY
                             
                             	
                             	
fa50 :                       df_rt_asm_ds
fa50 : 203bfb           [ 6] 	jsr df_rt_asm_printPC
fa53 : 2056fb           [ 6] 	jsr df_rt_asm_printSPC
                             	; Get the address from expression
fa56 : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             	; ADD this in to PC
fa59 : 18               [ 2] 	clc
fa5a : a59e             [ 3] 	lda df_asmoprnd
fa5c : 6599             [ 3] 	adc df_asmpc
fa5e : 8599             [ 3] 	sta df_asmpc
fa60 : a59f             [ 3] 	lda df_asmoprnd+1
fa62 : 659a             [ 3] 	adc df_asmpc+1
fa64 : 859a             [ 3] 	sta df_asmpc+1
                             	; len=1 for printing
fa66 : a903             [ 2] 	lda #3
fa68 : 85a0             [ 3] 	sta df_asmlen
fa6a : 4c5ffb           [ 3] 	jmp df_rt_asm_printOPR
                             
                             
                             ; Process a normal assembler mnemonic
fa6d :                       df_rt_asm_mnem
fa6d : 68               [ 4] 	pla				; Throw away previous temp variable
                             	; jump over mnemonic code
fa6e : e688             [ 5] 	inc df_exeoff
                             	; work out the addressing mode and get operand
fa70 : 20a7fb           [ 6] 	jsr df_rt_asm_addrmode
                             
fa73 :                       df_rt_asm_mnem_try
fa73 : a59c             [ 3] 	lda df_asmadmd					; With the addressing mode
fa75 : 202ffc           [ 6] 	jsr df_rt_asm_find_addr_mode	; Find it for this 
fa78 : c900             [ 2] 	cmp #AM_NONE					; Exists?
fa7a : d014             [ 3] 	bne	df_rt_asm_mnem_chk			; If does then check it
fa7c :                       df_rt_asm_check_alt
fa7c : a69c             [ 3] 	ldx df_asmadmd					; Use ad mode as an index
fa7e : bd84fc           [ 4] 	lda df_asm_altaddrmode,x		; Else get alternate
fa81 : c900             [ 2] 	cmp #AM_NONE					; Is there an alternate?
fa83 : f02d             [ 3] 	beq df_rt_asm_mnem_err			; If no then error
fa85 : 202ffc           [ 6] 	jsr df_rt_asm_find_addr_mode	; Check does mode e
fa88 : c900             [ 2] 	cmp #AM_NONE					; this instruction
fa8a : f026             [ 3] 	beq df_rt_asm_mnem_err			; if no then error
fa8c : c59c             [ 3] 	cmp df_asmadmd					; Same as the original?
fa8e : f00e             [ 3] 	beq df_rt_asm_mnem_done			; if so then done
AS65 Assembler for R6502 [1.42].                                     Page  273
-------------------------------- bank\bank0.s --------------------------------

fa90 :                       df_rt_asm_mnem_chk
fa90 : 859c             [ 3] 	sta df_asmadmd					; This is the final mode
fa92 : aa               [ 2] 	tax								; Get the length
fa93 : bd73fc           [ 4] 	lda df_asm_length,x
fa96 : a69f             [ 3] 	ldx df_asmoprnd+1				; Is operand hi non-zero?
fa98 : f004             [ 3] 	beq df_rt_asm_mnem_done			; If zero then done
fa9a : c903             [ 2] 	cmp #3							; Else must be len 3?
fa9c : d0de             [ 3] 	bne df_rt_asm_check_alt			; Try an alternate
fa9e :                       df_rt_asm_mnem_done
fa9e : a69c             [ 3] 	ldx df_asmadmd					; Get the final mode index
faa0 : bd73fc           [ 4] 	lda df_asm_length,x				; Get the length
faa3 : 85a0             [ 3] 	sta df_asmlen
faa5 : a59c             [ 3] 	lda df_asmadmd					; Get the final mode
faa7 : 202ffc           [ 6] 	jsr df_rt_asm_find_addr_mode	; Get the Y index o
                             	; Ok now get the opcode
faaa : c8               [ 2] 	iny
faab : b181             [ 5] 	lda (df_symtab),y
faad : 859d             [ 3] 	sta df_asmopcde
                             	; Now have all information to assemble
faaf : 4cb4fa           [ 3] 	jmp df_rt_asm_encode
                             	
fab2 :                       df_rt_asm_mnem_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ; Take assembler data and encode it
                             ; depending on the current option
                             ; Option 0 = No write
                             ; Option 1 = No write, Print
                             ; Option 2 = Write
                             ; Option 3 = Write, Print
fab4 :                       df_rt_asm_encode
                             	; If relative then need to calculate offset
fab4 : a59c             [ 3] 	lda df_asmadmd
fab6 : c90f             [ 2] 	cmp #AM_REL
fab8 : d033             [ 3] 	bne df_rt_asm_encode_skiprel
                             	; If high byte is 0 then do nothing
faba : a59f             [ 3] 	lda df_asmoprnd+1
fabc : f02f             [ 3] 	beq df_rt_asm_encode_skiprel
                             	; else calculate distance from PC
                             	; first take 2 off operand
fabe : 38               [ 2] 	sec
fabf : a59e             [ 3] 	lda df_asmoprnd
fac1 : e902             [ 2] 	sbc #2
fac3 : 859e             [ 3] 	sta df_asmoprnd
fac5 : a59f             [ 3] 	lda df_asmoprnd+1
fac7 : e900             [ 2] 	sbc #0
fac9 : 859f             [ 3] 	sta df_asmoprnd+1
                             	; now calculate current operand-PC
facb : 38               [ 2] 	sec
facc : a59e             [ 3] 	lda df_asmoprnd
face : e599             [ 3] 	sbc df_asmpc
fad0 : 859e             [ 3] 	sta df_asmoprnd
fad2 : a59f             [ 3] 	lda df_asmoprnd+1
fad4 : e59a             [ 3] 	sbc df_asmpc+1
                             	; put 0 in high operand storage
                             	; but A contains result of subtraction
                             	; so check that for out of range
fad6 : a000             [ 2] 	ldy #0
fad8 : 849f             [ 3] 	sty df_asmoprnd+1
                             	; detect too far; high byte is either 0 or 255
                             	; else it's an error
AS65 Assembler for R6502 [1.42].                                     Page  274
-------------------------------- bank\bank0.s --------------------------------

fada : a8               [ 2] 	tay
fadb : f00a             [ 3] 	beq df_rt_asm_encode_relpos
fadd : c9ff             [ 2] 	cmp #0xff
fadf : d00a             [ 3] 	bne df_rt_asm_encode_relfar
                             	; if high is ff then low must be same -ve
fae1 : a59e             [ 3] 	lda df_asmoprnd
fae3 : 3008             [ 3] 	bmi df_rt_asm_encode_skiprel
                             	; else error
fae5 : 1004             [ 3] 	bpl df_rt_asm_encode_relfar
fae7 :                       df_rt_asm_encode_relpos
                             	; if high is 00 then low must be same +ve
fae7 : a59e             [ 3] 	lda df_asmoprnd
fae9 : 1002             [ 3] 	bpl df_rt_asm_encode_skiprel
                             	; else error
faeb :                       df_rt_asm_encode_relfar
                             	; set to non-zero value, dec because it is zero 
faeb : c69f             [ 5] 	dec df_asmoprnd+1
faed :                       df_rt_asm_encode_skiprel
                             	; Only write the code if bit 1=1
faed : a902             [ 2] 	lda #0x02
faef : 259b             [ 3] 	and df_asmopt
faf1 : f028             [ 4] 	beq df_rt_asm_encode_print
faf3 : a000             [ 2] 	ldy #0
faf5 : a59d             [ 3] 	lda df_asmopcde
faf7 : 9199             [ 5] 	sta (df_asmpc),y
faf9 : a5a0             [ 3] 	lda df_asmlen
fafb : c901             [ 2] 	cmp #1						; No operand
fafd : f01c             [ 4] 	beq df_rt_asm_encode_print
faff : c903             [ 2] 	cmp #3						; Word operand
fb01 : f00e             [ 3] 	beq df_rt_asm_encode_writeword
                             	; byte operand, high byte must be zero
fb03 : a59f             [ 3] 	lda df_asmoprnd+1
fb05 : f002             [ 3] 	beq df_rt_asm_encode_writebyte
                             	SWBRK DFERR_QUANTITY
                             
fb09 :                       df_rt_asm_encode_writebyte
fb09 : c8               [ 2] 	iny 
fb0a : a59e             [ 3] 	lda df_asmoprnd
fb0c : 9199             [ 5] 	sta (df_asmpc),y
fb0e : 4c1bfb           [ 3] 	jmp df_rt_asm_encode_print
fb11 :                       df_rt_asm_encode_writeword
fb11 : c8               [ 2] 	iny 
fb12 : a59e             [ 3] 	lda df_asmoprnd
fb14 : 9199             [ 5] 	sta (df_asmpc),y
fb16 : c8               [ 2] 	iny 
fb17 : a59f             [ 3] 	lda df_asmoprnd+1
fb19 : 9199             [ 5] 	sta (df_asmpc),y	
fb1b :                       df_rt_asm_encode_print
fb1b : 202bfb           [ 6] 	jsr df_rt_asm_print_mmen
                             	; advance pc
fb1e : 18               [ 2] 	clc
fb1f : a599             [ 3] 	lda df_asmpc
fb21 : 65a0             [ 3] 	adc df_asmlen
fb23 : 8599             [ 3] 	sta df_asmpc
                             	_bcc 2
                             
fb27 : e69a             [ 5] 	inc df_asmpc+1
fb29 : 18               [ 2] 	clc
fb2a : 60               [ 6] 	rts
                             
                             
                             ; Print the full 1,2,3 byte instruction
AS65 Assembler for R6502 [1.42].                                     Page  275
-------------------------------- bank\bank0.s --------------------------------

                             ; depends on df_asmopt
fb2b :                       df_rt_asm_print_mmen
fb2b : 203bfb           [ 6] 	jsr df_rt_asm_printPC
fb2e : 2056fb           [ 6] 	jsr df_rt_asm_printSPC
fb31 : 204bfb           [ 6] 	jsr df_rt_asm_printOPC
fb34 : 2056fb           [ 6] 	jsr df_rt_asm_printSPC
fb37 : 205ffb           [ 6] 	jsr df_rt_asm_printOPR
fb3a :                       df_rt_asm_print_rts			; Hopefully subs can get he
fb3a : 60               [ 6] 	rts
                             
fb3b :                       df_rt_asm_printPC
                             	; Check the option bit 0 (Print)
fb3b : a901             [ 2] 	lda #0x01
fb3d : 259b             [ 3] 	and df_asmopt
fb3f : f0f9             [ 3] 	beq df_rt_asm_print_rts
                             	; Print current PC
fb41 : a59a             [ 3] 	lda df_asmpc+1
fb43 : 2083c1           [ 6] 	jsr utilPrintA
fb46 : a599             [ 3] 	lda df_asmpc
fb48 : 4c83c1           [ 3] 	jmp utilPrintA
                             
fb4b :                       df_rt_asm_printOPC
                             	; Check the option bit 0 (Print)
fb4b : a901             [ 2] 	lda #0x01
fb4d : 259b             [ 3] 	and df_asmopt
fb4f : f0e9             [ 3] 	beq df_rt_asm_print_rts
fb51 : a59d             [ 3] 	lda df_asmopcde
fb53 : 4c83c1           [ 3] 	jmp utilPrintA
                             
fb56 :                       df_rt_asm_printSPC
                             	; Check the option bit 0 (Print)
fb56 : a901             [ 2] 	lda #0x01
fb58 : 259b             [ 3] 	and df_asmopt
fb5a : f0de             [ 3] 	beq df_rt_asm_print_rts
fb5c : 4c73c1           [ 3] 	jmp utilPrintSPC
                             	
fb5f :                       df_rt_asm_printOPR
                             	; Check the option bit 0 (Print)
fb5f : a901             [ 2] 	lda #0x01
fb61 : 259b             [ 3] 	and df_asmopt
fb63 : f0d5             [ 3] 	beq df_rt_asm_print_rts	
fb65 : a5a0             [ 3] 	lda df_asmlen				; check how may operand bytes
fb67 : c901             [ 2] 	cmp #1						; if only opcode, done
fb69 : f0cf             [ 3] 	beq df_rt_asm_print_rts	
fb6b : c902             [ 2] 	cmp #2
fb6d : f005             [ 3] 	beq df_rt_asm_printOPR_1	; if only 2 do low byte
fb6f : a59f             [ 3] 	lda df_asmoprnd+1
fb71 : 2083c1           [ 6] 	jsr utilPrintA
fb74 :                       df_rt_asm_printOPR_1
fb74 : a59e             [ 3] 	lda df_asmoprnd
fb76 : 4c83c1           [ 3] 	jmp utilPrintA
                             
fb79 :                       df_rt_asm_printCR
                             	; Check the option bit 0 (Print)
fb79 : a901             [ 2] 	lda #0x01
fb7b : 259b             [ 3] 	and df_asmopt
fb7d : f0bb             [ 3] 	beq df_rt_asm_print_rts
fb7f : 4c7bc1           [ 3] 	jmp utilPrintCRLF
                             
fb82 :                       df_rt_asm_printCH
fb82 : 8538             [ 3] 	sta tmp_d
                             	; Check the option bit 0 (Print)
AS65 Assembler for R6502 [1.42].                                     Page  276
-------------------------------- bank\bank0.s --------------------------------

fb84 : a901             [ 2] 	lda #0x01
fb86 : 259b             [ 3] 	and df_asmopt
fb88 : f0b0             [ 3] 	beq df_rt_asm_print_rts
fb8a : a538             [ 3] 	lda tmp_d
fb8c : 4c54c4           [ 3] 	jmp io_put_ch
                             
                             ; Print an entire line, but save df_exeoff
fb8f :                       df_rt_asm_printline
                             	; Check the option bit 0 (Print)
fb8f : a901             [ 2] 	lda #0x01
fb91 : 259b             [ 3] 	and df_asmopt
fb93 : f0a5             [ 3] 	beq df_rt_asm_print_rts
fb95 : a588             [ 3] 	lda df_exeoff
fb97 : 48               [ 3] 	pha
                             	; use df_tmpptra
                             	_cpyZPWord df_currlin, df_tmpptra
                             
fba0 : 2047ee           [ 6] 	jsr df_rt_list_line_only
fba3 : 68               [ 4] 	pla
fba4 : 8588             [ 3] 	sta df_exeoff
fba6 : 60               [ 6] 	rts
                             
                             
                             ; Calculate the addressing mode
                             ; Populate the operand as needed
                             ; A and df_asmadmd contain Addressing Mode
fba7 :                       df_rt_asm_addrmode	
                             	; Store nothing in address mode
fba7 : a900             [ 2] 	lda #AM_NONE
fba9 : 859c             [ 3] 	sta df_asmadmd
                             	; zero out the operand
fbab : a900             [ 2] 	lda #0
fbad : 859e             [ 3] 	sta df_asmoprnd
fbaf : 859f             [ 3] 	sta df_asmoprnd+1
fbb1 : 20daec           [ 6] 	jsr df_rt_eos			; End of statement?
fbb4 : b00d             [ 3] 	bcs df_rt_asm_AM_IMP
                             	; jump over whitespace
fbb6 : 20abe4           [ 6] 	jsr df_rt_skip_ws
                             	; Check what it is
fbb9 : c923             [ 2] 	cmp #'#'				; Immediate?
fbbb : f034             [ 3] 	beq df_rt_asm_AM_IMM
fbbd : c928             [ 2] 	cmp #'('				; Indirect something?
fbbf : f03a             [ 3] 	beq df_rt_asm_AM_INDIRECT
                             	; Must be ABS,ZP or REL
fbc1 : d005             [ 3] 	bne df_rt_asm_ABSREL
                             ; Process IMP/ACC
fbc3 :                       df_rt_asm_AM_IMP
fbc3 : a90d             [ 2] 	lda #AM_IMP
fbc5 : 859c             [ 3] 	sta df_asmadmd
fbc7 : 60               [ 6] 	rts
                             ; Process ABS or REL
fbc8 :                       df_rt_asm_ABSREL	
                             	; Evaluate operand
fbc8 : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             
fbcb : 20daec           [ 6] 	jsr df_rt_eos			; End of statement?
fbce : b00f             [ 3] 	bcs df_rt_asm_AM_ABS
fbd0 : c8               [ 2] 	iny						; Jump over ","
fbd1 : b186             [ 5] 	lda (df_currlin),y		; Load X or Y
fbd3 : c8               [ 2] 	iny						; Jump over index reg
fbd4 : 8588             [ 3] 	sta df_exeoff			; Save exe offset
fbd6 : c978             [ 2] 	cmp #'x'				; Indirect X?
AS65 Assembler for R6502 [1.42].                                     Page  277
-------------------------------- bank\bank0.s --------------------------------

fbd8 : f012             [ 3] 	beq df_rt_asm_AM_ABSX
                             ; Process ABSY
fbda :                       df_rt_asm_AM_ABSY
fbda : a906             [ 2] 	lda #AM_ZPY				; Go for smallest modes
fbdc : 859c             [ 3] 	sta df_asmadmd
fbde : 60               [ 6] 	rts
                             ; Process what looks like pure ABS, could be REL
fbdf :                       df_rt_asm_AM_ABS
fbdf : a001             [ 2] 	ldy #1					; Check first addressing mode
fbe1 : b181             [ 5] 	lda (df_symtab),y
fbe3 : c90f             [ 2] 	cmp #AM_REL
fbe5 : f002             [ 3] 	beq df_rt_asm_AM_REL
fbe7 : a904             [ 2] 	lda #AM_ZP				; Go for smallest modes
fbe9 :                       df_rt_asm_AM_REL
fbe9 : 859c             [ 3] 	sta df_asmadmd
fbeb : 60               [ 6] 	rts
                             ; Process ABSX
fbec :                       df_rt_asm_AM_ABSX
fbec : a905             [ 2] 	lda #AM_ZPX				; Go for smallest modes
fbee : 859c             [ 3] 	sta df_asmadmd
fbf0 : 60               [ 6] 	rts
                             ; Process Immediate
fbf1 :                       df_rt_asm_AM_IMM
                             	; skip over #
fbf1 : e688             [ 5] 	inc df_exeoff
                             	; Get operand
fbf3 : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             	; Mark as immediate
fbf6 : a90c             [ 2] 	lda #AM_IMM
fbf8 : 859c             [ 3] 	sta df_asmadmd
fbfa : 60               [ 6] 	rts
                             ; Process indirect
fbfb :                       df_rt_asm_AM_INDIRECT
                             	; skip over (
fbfb : e688             [ 5] 	inc df_exeoff
                             	; Calculate the operand
fbfd : 2024fc           [ 6] 	jsr df_rt_asm_get_operand
                             	; what is next char?
fc00 : a488             [ 3] 	ldy df_exeoff
fc02 : b186             [ 5] 	lda (df_currlin),y
fc04 : c929             [ 2] 	cmp #')'			; Could be IND or INDY
fc06 : f009             [ 3] 	beq df_rt_asm_AM_ZPINDORY
                             	; else must be INDX
                             	; skip 'x)'
fc08 : c8               [ 2] 	iny
fc09 : c8               [ 2] 	iny
fc0a : 8488             [ 3] 	sty df_exeoff
fc0c : a908             [ 2] 	lda #AM_ZPINDX
fc0e : 859c             [ 3] 	sta df_asmadmd
fc10 : 60               [ 6] 	rts
                             ; Pure indirect mode found
fc11 :                       df_rt_asm_AM_ZPINDORY
fc11 : a907             [ 2] 	lda #AM_ZPIND			; Assume ZPIND
fc13 : c8               [ 2] 	iny
fc14 : 8488             [ 3] 	sty df_exeoff
                             	; if at end of line/statement then pure indirect
fc16 : 20daec           [ 6] 	jsr df_rt_eos			; End of statement?
fc19 : b006             [ 3] 	bcs df_rt_asm_AM_ZPIND
                             	; else must be INDY
fc1b : a909             [ 2] 	lda #AM_ZPINDY
                             	; skip ',Y'
fc1d : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  278
-------------------------------- bank\bank0.s --------------------------------

fc1e : c8               [ 2] 	iny
fc1f : 8488             [ 3] 	sty df_exeoff
fc21 :                       df_rt_asm_AM_ZPIND
fc21 : 859c             [ 3] 	sta df_asmadmd
fc23 : 60               [ 6] 	rts
                             
                             ; Get and save the operand
                             ; df_asmoprnd contains the result
fc24 :                       df_rt_asm_get_operand
                             	; evaluate
fc24 : 2077e0           [ 6] 	jsr df_rt_neval
                             	; Get the parameter from stack
fc27 : 2081f6           [ 6] 	jsr df_ost_popInt
                             	; put in the operand
fc2a : 869e             [ 3] 	stx df_asmoprnd
fc2c : 859f             [ 3] 	sta df_asmoprnd+1
fc2e : 60               [ 6] 	rts
                             	
                             ; From current symtab entry, find addressing
                             ; mode in A.  AM_NONE=Not found, Y=index
fc2f :                       df_rt_asm_find_addr_mode
                             	; save A in tmp
fc2f : 8538             [ 3] 	sta tmp_d
                             	; Start first entry (1) - 2 = 0xff
fc31 : a0ff             [ 2] 	ldy #0xff
fc33 : a200             [ 2] 	ldx #0
fc35 :                       df_rt_asm_find_addr_mode_loop
                             	; next entry
fc35 : c8               [ 2] 	iny
fc36 : c8               [ 2] 	iny
                             	; if current index > num entries then error
fc37 : 98               [ 2] 	tya
fc38 : 38               [ 2] 	sec
fc39 : e181             [ 6] 	sbc (df_symtab,x)
fc3b : b007             [ 3] 	bcs df_rt_asm_find_addr_mode_err
                             	; is symtab addressing mode what we want?
fc3d : b181             [ 5] 	lda (df_symtab),y
fc3f : c538             [ 3] 	cmp tmp_d
fc41 : d0f2             [ 3] 	bne df_rt_asm_find_addr_mode_loop
                             	; done A=mode, y=index in to df_symtab
fc43 : 60               [ 6] 	rts
fc44 :                       df_rt_asm_find_addr_mode_err
fc44 : a900             [ 2] 	lda #AM_NONE
fc46 :                       df_rt_asm_skip_to_sym_done; Used by function belo
fc46 : 60               [ 6] 	rts
                             
                             
                             ; Skip X amount of symbols in table
                             ; A contains how many addr mode and op code bytes
                             ; df_symtab points to offset byte
fc47 :                       df_rt_asm_skip_to_sym
fc47 : e8               [ 2] 	inx				; so done when X=0
                             	; Start at token symbols beginning
fc48 : a995             [ 2] 	lda #lo(df_asm_tokensyms)
fc4a : 8581             [ 3] 	sta df_symtab
fc4c : a9fc             [ 2] 	lda #hi(df_asm_tokensyms)
fc4e : 8582             [ 3] 	sta df_symtab+1
fc50 : a900             [ 2] 	lda #0
fc52 : 8583             [ 3] 	sta df_symoff
fc54 : a8               [ 2] 	tay
fc55 :                       df_rt_asm_skip_to_sym_next
                             	; Get symtable char
AS65 Assembler for R6502 [1.42].                                     Page  279
-------------------------------- bank\bank0.s --------------------------------

fc55 : b181             [ 5] 	lda (df_symtab),y
                             	; if < ' ' then jumped over symbol chars
fc57 : c920             [ 2] 	cmp #' '
fc59 : 9009             [ 3] 	bcc df_rt_asm_skip_to_sym_end
                             	;else next smy tab char
                             	_incZPWord df_symtab
                             
fc61 : 4c55fc           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             	; Found end of symbol
fc64 :                       df_rt_asm_skip_to_sym_end
                             	;if done then return
fc64 : ca               [ 2] 	dex
fc65 : f0df             [ 3] 	beq df_rt_asm_skip_to_sym_done
                             	;jump over addr and op code by A bytes
fc67 : 38               [ 2] 	sec
fc68 : 6581             [ 3] 	adc df_symtab
fc6a : 8581             [ 3] 	sta df_symtab
                             	_bcc 2
                             
fc6e : e682             [ 5] 	inc df_symtab+1
fc70 : 4c55fc           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             
fc73 :                       mod_sz_rtasm_e
                             
                             
                             	include "dflat/asmsymtab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMSYMTAB.S
                             ;*	Mainly this contains the symbol table for asse
                             ;*	mnemonics but also meta data like what address
                             ;*	and the length of opcodes.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             	;* Length of each addressing mode
                             	;* ORDER significant!
fc73 :                       df_asm_length
fc73 : 00030303020202..      	db	0,3,3,3,2,2,2,2,2,2,3,3,2,1,1,2,0
                             
                             	; Always try for lowest addressing mode, but
                             	; this table maps to alternative
fc84 :                       df_asm_altaddrmode
fc84 : 00                    	db AM_NONE		;AM_NONE	= 0
fc85 : 00                    	db AM_NONE		;AM_ABS	 	= 1
fc86 : 00                    	db AM_NONE		;AM_ABSX	= 2
fc87 : 00                    	db AM_NONE		;AM_ABSY	= 3
fc88 : 01                    	db AM_ABS		;AM_ZP		= 4
fc89 : 02                    	db AM_ABSX		;AM_ZPX		= 5
fc8a : 03                    	db AM_ABSY		;AM_ZPY		= 6
fc8b : 0a                    	db AM_ABSIND	;AM_ZPIND	= 7
fc8c : 0b                    	db AM_ABSINDX	;AM_ZPINDX	= 8
fc8d : 09                    	db AM_ZPINDY	;AM_ZPINDY	= 9
AS65 Assembler for R6502 [1.42].                                     Page  280
-------------------------------- bank\bank0.s --------------------------------

fc8e : 00                    	db AM_NONE		;AM_ABSIND	= 10
fc8f : 00                    	db AM_NONE		;AM_ABSINDX	= 11
fc90 : 00                    	db AM_NONE		;AM_IMM		= 12
fc91 : 00                    	db AM_NONE		;AM_ACC		= 13
fc92 : 00                    	db AM_NONE		;AM_IMP		= AM_ACC
fc93 : 0f                    	db AM_REL		;AM_REL		= 15
fc94 : 00                    	db AM_NONE		;AM_DIR		= 16
                             
                             
                             	;*	Mnemonic/	How many addressing modes /
                             	;* 	Mode		Opcode for mode
fc95 :                       df_asm_tokensyms
                             	;* Start with directives
fc95 : 6f726702              	db	"org",		1*2
fc99 : 1000                  	db	AM_DIR,		0x00
fc9b : 6f707402              	db	"opt",		1*2
fc9f : 1000                  	db	AM_DIR,		0x00
fca1 : 646202                	db	"db",		1*2
fca4 : 1000                  	db	AM_DIR,		0x00
fca6 : 647702                	db	"dw",		1*2
fca9 : 1000                  	db	AM_DIR,		0x00
fcab : 647302                	db	"ds",		1*2
fcae : 1000                  	db	AM_DIR,		0x00	
                             
fcb0 : 61646310              	db	"adc",		8*2
fcb4 : 0c69                  	db	AM_IMM,		0x69
fcb6 : 0465                  	db	AM_ZP,		0x65
fcb8 : 0575                  	db	AM_ZPX,		0x75
fcba : 016d                  	db	AM_ABS,		0x6d
fcbc : 027d                  	db	AM_ABSX,	0x7d
fcbe : 0379                  	db	AM_ABSY,	0x79
fcc0 : 0861                  	db	AM_ZPINDX,	0x61
fcc2 : 0971                  	db	AM_ZPINDY,	0x71
                             	
fcc4 : 616e6410              	db	"and",		8*2
fcc8 : 0c29                  	db	AM_IMM,		0x29
fcca : 0425                  	db	AM_ZP,		0x25
fccc : 0535                  	db	AM_ZPX,		0x35
fcce : 012d                  	db	AM_ABS,		0x2d
fcd0 : 023d                  	db	AM_ABSX,	0x3d
fcd2 : 0339                  	db	AM_ABSY,	0x39
fcd4 : 0821                  	db	AM_ZPINDX,	0x21
fcd6 : 0931                  	db	AM_ZPINDY,	0x31
                             
fcd8 : 636d7010              	db	"cmp",		8*2
fcdc : 0cc9                  	db	AM_IMM,		0xc9
fcde : 04c5                  	db	AM_ZP,		0xc5
fce0 : 05d5                  	db	AM_ZPX,		0xd5
fce2 : 01cd                  	db	AM_ABS,		0xcd
fce4 : 02dd                  	db	AM_ABSX,	0xdd
fce6 : 03d9                  	db	AM_ABSY,	0xd9
fce8 : 08c1                  	db	AM_ZPINDX,	0xc1
fcea : 09d1                  	db	AM_ZPINDY,	0xd1
                             
fcec : 656f7210              	db	"eor",		8*2
fcf0 : 0c49                  	db	AM_IMM,		0x49
fcf2 : 0445                  	db	AM_ZP,		0x45
fcf4 : 0555                  	db	AM_ZPX,		0x55
fcf6 : 014d                  	db	AM_ABS,		0x4d
fcf8 : 025d                  	db	AM_ABSX,	0x5d
fcfa : 0359                  	db	AM_ABSY,	0x59
fcfc : 0841                  	db	AM_ZPINDX,	0x41
AS65 Assembler for R6502 [1.42].                                     Page  281
-------------------------------- bank\bank0.s --------------------------------

fcfe : 0951                  	db	AM_ZPINDY,	0x51
                             
fd00 : 6c646110              	db	"lda",		8*2
fd04 : 0ca9                  	db	AM_IMM,		0xa9
fd06 : 04a5                  	db	AM_ZP,		0xa5
fd08 : 05b5                  	db	AM_ZPX,		0xb5
fd0a : 01ad                  	db	AM_ABS,		0xad
fd0c : 02bd                  	db	AM_ABSX,	0xbd
fd0e : 03b9                  	db	AM_ABSY,	0xb9
fd10 : 08a1                  	db	AM_ZPINDX,	0xa1
fd12 : 09b1                  	db	AM_ZPINDY,	0xb1
                             
fd14 : 6f726110              	db	"ora",		8*2
fd18 : 0c09                  	db	AM_IMM,		0x09
fd1a : 0405                  	db	AM_ZP,		0x05
fd1c : 0515                  	db	AM_ZPX,		0x15
fd1e : 010d                  	db	AM_ABS,		0x0d
fd20 : 021d                  	db	AM_ABSX,	0x1d
fd22 : 0319                  	db	AM_ABSY,	0x19
fd24 : 0801                  	db	AM_ZPINDX,	0x01
fd26 : 0911                  	db	AM_ZPINDY,	0x11
                             
fd28 : 73626310              	db	"sbc",		8*2
fd2c : 0ce9                  	db	AM_IMM,		0xe9
fd2e : 04e5                  	db	AM_ZP,		0xe5
fd30 : 05f5                  	db	AM_ZPX,		0xf5
fd32 : 01ed                  	db	AM_ABS,		0xed
fd34 : 02fd                  	db	AM_ABSX,	0xfd
fd36 : 03f9                  	db	AM_ABSY,	0xf9
fd38 : 08e1                  	db	AM_ZPINDX,	0xe1
fd3a : 09f1                  	db	AM_ZPINDY,	0xf1
                             
fd3c : 73746110              	db	"sta",		8*2
fd40 : 0485                  	db	AM_ZP,		0x85
fd42 : 0595                  	db	AM_ZPX,		0x95
fd44 : 018d                  	db	AM_ABS,		0x8d
fd46 : 029d                  	db	AM_ABSX,	0x9d
fd48 : 0399                  	db	AM_ABSY,	0x99
fd4a : 0881                  	db	AM_ZPINDX,	0x81
fd4c : 0991                  	db	AM_ZPINDY,	0x91
fd4e : 0792                  	db	AM_ZPIND,	0x92
                             
fd50 : 61736c0a              	db	"asl",		5*2
fd54 : 0d0a                  	db	AM_IMP,		0x0a
fd56 : 0406                  	db	AM_ZP,		0x06
fd58 : 0516                  	db	AM_ZPX,		0x16
fd5a : 010e                  	db	AM_ABS,		0x0e
fd5c : 021e                  	db	AM_ABSX,	0x1e
fd5e : 64656308              	db	"dec",		4*2
fd62 : 04c6                  	db	AM_ZP,		0xc6
fd64 : 05d6                  	db	AM_ZPX,		0xd6
fd66 : 01ce                  	db	AM_ABS,		0xce
fd68 : 02de                  	db	AM_ABSX,	0xde
fd6a : 696e6308              	db	"inc",		4*2
fd6e : 04e6                  	db	AM_ZP,		0xe6
fd70 : 05f6                  	db	AM_ZPX,		0xf6
fd72 : 01ee                  	db	AM_ABS,		0xee
fd74 : 02fe                  	db	AM_ABSX,	0xfe
fd76 : 6c73720a              	db	"lsr",		5*2
fd7a : 0d4a                  	db	AM_IMP,		0x4a
fd7c : 0446                  	db	AM_ZP,		0x46
fd7e : 0556                  	db	AM_ZPX,		0x56
AS65 Assembler for R6502 [1.42].                                     Page  282
-------------------------------- bank\bank0.s --------------------------------

fd80 : 014e                  	db	AM_ABS,		0x4e
fd82 : 025e                  	db	AM_ABSX,	0x5e
fd84 : 726f6c0a              	db	"rol",		5*2
fd88 : 0d2a                  	db	AM_IMP,		0x2a
fd8a : 0426                  	db	AM_ZP,		0x26
fd8c : 0536                  	db	AM_ZPX,		0x36
fd8e : 012e                  	db	AM_ABS,		0x2e
fd90 : 023e                  	db	AM_ABSX,	0x3e
fd92 : 726f720a              	db	"ror",		5*2
fd96 : 0d6a                  	db	AM_IMP,		0x6a
fd98 : 0466                  	db	AM_ZP,		0x66
fd9a : 0576                  	db	AM_ZPX,		0x76
fd9c : 016e                  	db	AM_ABS,		0x6e
fd9e : 027e                  	db	AM_ABSX,	0x7e
                             
fda0 : 62697404              	db	"bit",		2*2
fda4 : 0424                  	db	AM_ZP,		0x24
fda6 : 012c                  	db	AM_ABS,		0x2c
                             	
fda8 : 62726b02              	db	"brk",		1*2
fdac : 0d00                  	db	AM_IMP,		0x00
                             	
fdae : 636c6302              	db	"clc",		1*2
fdb2 : 0d18                  	db	AM_IMP,		0x18
fdb4 : 636c6402              	db	"cld",		1*2
fdb8 : 0dd8                  	db	AM_IMP,		0xd8
fdba : 636c6902              	db	"cli",		1*2
fdbe : 0d58                  	db	AM_IMP,		0x58
fdc0 : 636c7602              	db	"clv",		1*2
fdc4 : 0db8                  	db	AM_IMP,		0xb8
fdc6 : 73656302              	db	"sec",		1*2
fdca : 0d38                  	db	AM_IMP,		0x38
fdcc : 73656402              	db	"sed",		1*2
fdd0 : 0df8                  	db	AM_IMP,		0xf8
fdd2 : 73656902              	db	"sei",		1*2
fdd6 : 0d78                  	db	AM_IMP,		0x78
                             	
fdd8 : 63707806              	db	"cpx",		3*2
fddc : 0ce0                  	db	AM_IMM,		0xe0
fdde : 04e4                  	db	AM_ZP,		0xe4
fde0 : 01ec                  	db	AM_ABS,		0xec
fde2 : 63707906              	db	"cpy",		3*2
fde6 : 0cc0                  	db	AM_IMM,		0xc0
fde8 : 04c4                  	db	AM_ZP,		0xc4
fdea : 01cc                  	db	AM_ABS,		0xcc
fdec : 64657802              	db	"dex",		1*2
fdf0 : 0dca                  	db	AM_IMP,		0xca
fdf2 : 64657902              	db	"dey",		1*2
fdf6 : 0d88                  	db	AM_IMP,		0x88
fdf8 : 696e7802              	db	"inx",		1*2
fdfc : 0de8                  	db	AM_IMP,		0xe8
fdfe : 696e7902              	db	"iny",		1*2
fe02 : 0dc8                  	db	AM_IMP,		0xc8
fe04 : 6c64780a              	db	"ldx",		5*2
fe08 : 0ca2                  	db	AM_IMM,		0xa2
fe0a : 04a6                  	db	AM_ZP,		0xa6
fe0c : 06b6                  	db	AM_ZPY,		0xb6
fe0e : 01ae                  	db	AM_ABS,		0xae
fe10 : 03be                  	db	AM_ABSY,	0xbe
fe12 : 6c64790a              	db	"ldy",		5*2
fe16 : 0ca0                  	db	AM_IMM,		0xa0
fe18 : 04a4                  	db	AM_ZP,		0xa4
AS65 Assembler for R6502 [1.42].                                     Page  283
-------------------------------- bank\bank0.s --------------------------------

fe1a : 05b4                  	db	AM_ZPX,		0xb4
fe1c : 01ac                  	db	AM_ABS,		0xac
fe1e : 02bc                  	db	AM_ABSX,	0xbc
fe20 : 73747806              	db	"stx",		3*2
fe24 : 0486                  	db	AM_ZP,		0x86
fe26 : 0696                  	db	AM_ZPY,		0x96
fe28 : 018e                  	db	AM_ABS,		0x8e
fe2a : 73747906              	db	"sty",		3*2
fe2e : 0484                  	db	AM_ZP,		0x84
fe30 : 0594                  	db	AM_ZPX,		0x94
fe32 : 018c                  	db	AM_ABS,		0x8c
                             
fe34 : 62636302              	db	"bcc",		1*2
fe38 : 0f90                  	db	AM_REL,		0x90
fe3a : 62637302              	db	"bcs",		1*2
fe3e : 0fb0                  	db	AM_REL,		0xb0
fe40 : 62657102              	db	"beq",		1*2
fe44 : 0ff0                  	db	AM_REL,		0xf0
fe46 : 626d6902              	db	"bmi",		1*2
fe4a : 0f30                  	db	AM_REL,		0x30
fe4c : 626e6502              	db	"bne",		1*2
fe50 : 0fd0                  	db	AM_REL,		0xd0
fe52 : 62706c02              	db	"bpl",		1*2
fe56 : 0f10                  	db	AM_REL,		0x10
fe58 : 62766302              	db	"bvc",		1*2
fe5c : 0f50                  	db	AM_REL,		0x50
fe5e : 62767302              	db	"bvs",		1*2
fe62 : 0f70                  	db	AM_REL,		0x70
fe64 : 6a6d7004              	db	"jmp",		2*2
fe68 : 014c                  	db	AM_ABS,		0x4c
fe6a : 0a6c                  	db	AM_ABSIND,	0x6c
fe6c : 6a737202              	db	"jsr",		1*2
fe70 : 0120                  	db	AM_ABS,		0x20
                             	
fe72 : 6e6f7002              	db	"nop",		1*2
fe76 : 0dea                  	db	AM_IMP,		0xea
fe78 : 70686102              	db	"pha",		1*2
fe7c : 0d48                  	db	AM_IMP,		0x48
fe7e : 70687002              	db	"php",		1*2
fe82 : 0d08                  	db	AM_IMP,		0x08
fe84 : 706c6102              	db	"pla",		1*2
fe88 : 0d68                  	db	AM_IMP,		0x68
fe8a : 706c7002              	db	"plp",		1*2
fe8e : 0d28                  	db	AM_IMP,		0x28
fe90 : 72746902              	db	"rti",		1*2
fe94 : 0d40                  	db	AM_IMP,		0x40
fe96 : 72747302              	db	"rts",		1*2
fe9a : 0d60                  	db	AM_IMP,		0x60
fe9c : 74617802              	db	"tax",		1*2
fea0 : 0daa                  	db	AM_IMP,		0xaa
fea2 : 74617902              	db	"tay",		1*2
fea6 : 0da8                  	db	AM_IMP,		0xa8
fea8 : 74737802              	db	"tsx",		1*2
feac : 0dba                  	db	AM_IMP,		0xba
feae : 74786102              	db	"txa",		1*2
feb2 : 0d8a                  	db	AM_IMP,		0x8a
feb4 : 74787302              	db	"txs",		1*2
feb8 : 0d9a                  	db	AM_IMP,		0x9a
feba : 74796102              	db	"tya",		1*2
febe : 0d98                  	db	AM_IMP,		0x98	
                             	
                             	;* Terminates with a zero
AS65 Assembler for R6502 [1.42].                                     Page  284
-------------------------------- bank\bank0.s --------------------------------

fec0 : 00                    	db	0
                             
                             	include	"dflat/asmjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMJUMPTAB.S
                             ;*  Runtime token jump table for assembler.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; Only directives needed as all opcodes are handl
                             ; through a single routine
fec1 :                       df_tk_asm_tokenjmp
fec1 : 6fde                  	dw	df_tk_asm_org
fec3 : 6fde                  	dw	df_tk_asm_opt
fec5 : d1dd                  	dw	df_tk_asm_db
fec7 : d1dd                  	dw	df_tk_asm_dw
fec9 : 6fde                  	dw	df_tk_asm_ds
                             
fecb :                       df_rt_asm_tokenjmp
fecb : bbf9                  	dw	df_rt_asm_org
fecd : cdf9                  	dw	df_rt_asm_opt
fecf : d5f9                  	dw	df_rt_asm_db
fed1 : d8f9                  	dw	df_rt_asm_dw
fed3 : 50fa                  	dw	df_rt_asm_ds
                             
                             
                             ;****************************************
                             ;* as_init
                             ;* Initialise assembler settings
                             ;****************************************
fed5 :                       asm_init
                             	; Zero the PC
fed5 : a900             [ 2] 	lda #0
fed7 : 8599             [ 3] 	sta df_asmpc
fed9 : 859a             [ 3] 	sta df_asmpc+1
                             	; Zero the option
fedb : 859b             [ 3] 	sta df_asmopt
fedd : 60               [ 6] 	rts
                             
fede :                       mod_sz_asm_e
                             
AS65 Assembler for R6502 [1.42].                                     Page  285
-------------------------------- bank\bank0.s --------------------------------

fede :                       mod_sz_language_e
                             	; End of Code
fede :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
